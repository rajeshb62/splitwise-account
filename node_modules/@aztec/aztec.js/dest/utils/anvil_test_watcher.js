import { createDebugLogger } from '@aztec/aztec.js';
import { RunningPromise } from '@aztec/foundation/running-promise';
import { RollupAbi } from '@aztec/l1-artifacts';
import { getAddress, getContract } from 'viem';
/**
 * Represents a watcher for a rollup contract.
 *
 * It started on a network like anvil where time traveling is allowed, and auto-mine is turned on
 * it will periodically check if the current slot have already been filled, e.g., there was an L2
 * block within the slot. And if so, it will time travel into the next slot.
 */
export class AnvilTestWatcher {
    constructor(cheatcodes, rollupAddress, publicClient) {
        this.cheatcodes = cheatcodes;
        this.logger = createDebugLogger(`aztec:utils:watcher`);
        this.rollup = getContract({
            address: getAddress(rollupAddress.toString()),
            abi: RollupAbi,
            client: publicClient,
        });
        this.logger.info(`Watcher created for rollup at ${rollupAddress}`);
    }
    async start() {
        if (this.filledRunningPromise) {
            throw new Error('Watcher already watching for filled slot');
        }
        // If auto mining is not supported (e.g., we are on a real network), then we
        // will simple do nothing. But if on an anvil or the like, this make sure that
        // the sandbox and tests don't break because time is frozen and we never get to
        // the next slot.
        const isAutoMining = await this.cheatcodes.isAutoMining();
        if (isAutoMining) {
            this.filledRunningPromise = new RunningPromise(() => this.mineIfSlotFilled(), 1000);
            this.filledRunningPromise.start();
            this.logger.info(`Watcher started`);
        }
        else {
            this.logger.info(`Watcher not started because not auto mining`);
        }
    }
    async stop() {
        await this.filledRunningPromise?.stop();
    }
    async mineIfSlotFilled() {
        try {
            const currentSlot = await this.rollup.read.getCurrentSlot();
            const pendingBlockNumber = BigInt(await this.rollup.read.getPendingBlockNumber());
            const [, , lastSlotNumber] = await this.rollup.read.blocks([pendingBlockNumber]);
            if (currentSlot === lastSlotNumber) {
                // We should jump to the next slot
                const timestamp = await this.rollup.read.getTimestampForSlot([currentSlot + 1n]);
                try {
                    await this.cheatcodes.warp(Number(timestamp));
                }
                catch (e) {
                    this.logger.error(`Failed to warp to timestamp ${timestamp}: ${e}`);
                }
                this.logger.info(`Slot ${currentSlot} was filled, jumped to next slot`);
            }
        }
        catch (err) {
            this.logger.error('mineIfSlotFilled failed');
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW52aWxfdGVzdF93YXRjaGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL2FudmlsX3Rlc3Rfd2F0Y2hlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQXdDLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFMUYsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUVoRCxPQUFPLEVBQXFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFHbEg7Ozs7OztHQU1HO0FBQ0gsTUFBTSxPQUFPLGdCQUFnQjtJQU8zQixZQUNVLFVBQXlCLEVBQ2pDLGFBQXlCLEVBQ3pCLFlBQXVEO1FBRi9DLGVBQVUsR0FBVixVQUFVLENBQWU7UUFIM0IsV0FBTSxHQUFnQixpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBT3JFLElBQUksQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDO1lBQ3hCLE9BQU8sRUFBRSxVQUFVLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQzdDLEdBQUcsRUFBRSxTQUFTO1lBQ2QsTUFBTSxFQUFFLFlBQVk7U0FDckIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUNBQWlDLGFBQWEsRUFBRSxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVELEtBQUssQ0FBQyxLQUFLO1FBQ1QsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztZQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7UUFDOUQsQ0FBQztRQUVELDRFQUE0RTtRQUM1RSw4RUFBOEU7UUFDOUUsK0VBQStFO1FBQy9FLGlCQUFpQjtRQUNqQixNQUFNLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFMUQsSUFBSSxZQUFZLEVBQUUsQ0FBQztZQUNqQixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxjQUFjLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDcEYsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2xDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDdEMsQ0FBQzthQUFNLENBQUM7WUFDTixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDO1FBQ2xFLENBQUM7SUFDSCxDQUFDO0lBRUQsS0FBSyxDQUFDLElBQUk7UUFDUixNQUFNLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUMxQyxDQUFDO0lBRUQsS0FBSyxDQUFDLGdCQUFnQjtRQUNwQixJQUFJLENBQUM7WUFDSCxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQzVELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxDQUFDLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxDQUFDO1lBQ2xGLE1BQU0sQ0FBQyxFQUFFLEFBQUQsRUFBRyxjQUFjLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztZQUVqRixJQUFJLFdBQVcsS0FBSyxjQUFjLEVBQUUsQ0FBQztnQkFDbkMsa0NBQWtDO2dCQUNsQyxNQUFNLFNBQVMsR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pGLElBQUksQ0FBQztvQkFDSCxNQUFNLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO2dCQUNoRCxDQUFDO2dCQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7b0JBQ1gsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsK0JBQStCLFNBQVMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUN0RSxDQUFDO2dCQUVELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsV0FBVyxrQ0FBa0MsQ0FBQyxDQUFDO1lBQzFFLENBQUM7UUFDSCxDQUFDO1FBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7UUFDL0MsQ0FBQztJQUNILENBQUM7Q0FDRiJ9
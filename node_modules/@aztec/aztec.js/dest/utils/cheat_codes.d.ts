import { type EpochProofClaim, type Note, type PXE } from '@aztec/circuit-types';
import { type AztecAddress, EthAddress, Fr } from '@aztec/circuits.js';
import { type L1ContractAddresses } from '@aztec/ethereum';
import { RollupAbi } from '@aztec/l1-artifacts';
import { type GetContractReturnType, type Hex, type WalletClient } from 'viem';
/**
 * A class that provides utility functions for interacting with the chain.
 */
export declare class CheatCodes {
    /** Cheat codes for L1.*/
    eth: EthCheatCodes;
    /** Cheat codes for Aztec L2. */
    aztec: AztecCheatCodes;
    /** Cheat codes for the Aztec Rollup contract on L1. */
    rollup: RollupCheatCodes;
    constructor(
    /** Cheat codes for L1.*/
    eth: EthCheatCodes, 
    /** Cheat codes for Aztec L2. */
    aztec: AztecCheatCodes, 
    /** Cheat codes for the Aztec Rollup contract on L1. */
    rollup: RollupCheatCodes);
    static create(rpcUrl: string, pxe: PXE): Promise<CheatCodes>;
    static createRollup(rpcUrl: string, addresses: Pick<L1ContractAddresses, 'rollupAddress'>): RollupCheatCodes;
}
/**
 * A class that provides utility functions for interacting with ethereum (L1).
 */
export declare class EthCheatCodes {
    /**
     * The RPC URL to use for interacting with the chain
     */
    rpcUrl: string;
    /**
     * The logger to use for the eth cheatcodes
     */
    logger: import("@aztec/foundation/log").Logger;
    constructor(
    /**
     * The RPC URL to use for interacting with the chain
     */
    rpcUrl: string, 
    /**
     * The logger to use for the eth cheatcodes
     */
    logger?: import("@aztec/foundation/log").Logger);
    rpcCall(method: string, params: any[]): Promise<any>;
    /**
     * Get the auto mine status of the underlying chain
     * @returns True if automine is on, false otherwise
     */
    isAutoMining(): Promise<boolean>;
    /**
     * Get the current blocknumber
     * @returns The current block number
     */
    blockNumber(): Promise<number>;
    /**
     * Get the current chainId
     * @returns The current chainId
     */
    chainId(): Promise<number>;
    /**
     * Get the current timestamp
     * @returns The current timestamp
     */
    timestamp(): Promise<number>;
    /**
     * Advance the chain by a number of blocks
     * @param numberOfBlocks - The number of blocks to mine
     * @returns The current chainId
     */
    mine(numberOfBlocks?: number): Promise<void>;
    /**
     * Set the balance of an account
     * @param account - The account to set the balance for
     * @param balance - The balance to set
     */
    setBalance(account: EthAddress, balance: bigint): Promise<void>;
    /**
     * Set the interval between blocks (block time)
     * @param interval - The interval to use between blocks
     */
    setBlockInterval(interval: number): Promise<void>;
    /**
     * Set the next block timestamp
     * @param timestamp - The timestamp to set the next block to
     */
    setNextBlockTimestamp(timestamp: number): Promise<void>;
    /**
     * Set the next block timestamp and mines the block
     * @param timestamp - The timestamp to set the next block to
     */
    warp(timestamp: number): Promise<void>;
    /**
     * Dumps the current chain state to a file.
     * @param fileName - The file name to dump state into
     */
    dumpChainState(fileName: string): Promise<void>;
    /**
     * Loads the chain state from a file.
     * @param fileName - The file name to load state from
     */
    loadChainState(fileName: string): Promise<void>;
    /**
     * Load the value at a storage slot of a contract address on eth
     * @param contract - The contract address
     * @param slot - The storage slot
     * @returns - The value at the storage slot
     */
    load(contract: EthAddress, slot: bigint): Promise<bigint>;
    /**
     * Set the value at a storage slot of a contract address on eth
     * @param contract - The contract address
     * @param slot - The storage slot
     * @param value - The value to set the storage slot to
     */
    store(contract: EthAddress, slot: bigint, value: bigint): Promise<void>;
    /**
     * Computes the slot value for a given map and key.
     * @param baseSlot - The base slot of the map (specified in Aztec.nr contract)
     * @param key - The key to lookup in the map
     * @returns The storage slot of the value in the map
     */
    keccak256(baseSlot: bigint, key: bigint): bigint;
    /**
     * Send transactions impersonating an externally owned account or contract.
     * @param who - The address to impersonate
     */
    startImpersonating(who: EthAddress | Hex): Promise<void>;
    /**
     * Stop impersonating an account that you are currently impersonating.
     * @param who - The address to stop impersonating
     */
    stopImpersonating(who: EthAddress | Hex): Promise<void>;
    /**
     * Set the bytecode for a contract
     * @param contract - The contract address
     * @param bytecode - The bytecode to set
     */
    etch(contract: EthAddress, bytecode: `0x${string}`): Promise<void>;
    /**
     * Get the bytecode for a contract
     * @param contract - The contract address
     * @returns The bytecode for the contract
     */
    getBytecode(contract: EthAddress): Promise<`0x${string}`>;
}
/** Cheat codes for the L1 rollup contract. */
export declare class RollupCheatCodes {
    private ethCheatCodes;
    private addresses;
    private client;
    private rollup;
    private logger;
    constructor(ethCheatCodes: EthCheatCodes, addresses: Pick<L1ContractAddresses, 'rollupAddress'>);
    /** Returns the current slot */
    getSlot(): Promise<bigint>;
    /** Returns the current epoch */
    getEpoch(): Promise<bigint>;
    /**
     * Returns the pending and proven chain tips
     * @returns The pending and proven chain tips
     */
    getTips(): Promise<{
        /** The pending chain tip */
        pending: bigint;
        /** The proven chain tip */
        proven: bigint;
    }>;
    /** Warps time in L1 until the next epoch */
    advanceToNextEpoch(): Promise<void>;
    /**
     * Warps time in L1 equivalent to however many slots.
     * @param howMany - The number of slots to advance.
     */
    advanceSlots(howMany: number): Promise<void>;
    /** Returns the current proof claim (if any) */
    getProofClaim(): Promise<EpochProofClaim | undefined>;
    /**
     * Marks the specified block (or latest if none) as proven
     * @param maybeBlockNumber - The block number to mark as proven (defaults to latest pending)
     */
    markAsProven(maybeBlockNumber?: number | bigint): Promise<void>;
    /**
     * Executes an action impersonated as the owner of the Rollup contract.
     * @param action - The action to execute
     */
    asOwner(action: (owner: Hex, rollup: GetContractReturnType<typeof RollupAbi, WalletClient>) => Promise<void>): Promise<void>;
}
/**
 * A class that provides utility functions for interacting with the aztec chain.
 */
export declare class AztecCheatCodes {
    /**
     * The PXE Service to use for interacting with the chain
     */
    pxe: PXE;
    /**
     * The eth cheat codes.
     */
    eth: EthCheatCodes;
    /**
     * The logger to use for the aztec cheatcodes
     */
    logger: import("@aztec/foundation/log").Logger;
    constructor(
    /**
     * The PXE Service to use for interacting with the chain
     */
    pxe: PXE, 
    /**
     * The eth cheat codes.
     */
    eth: EthCheatCodes, 
    /**
     * The logger to use for the aztec cheatcodes
     */
    logger?: import("@aztec/foundation/log").Logger);
    /**
     * Computes the slot value for a given map and key.
     * @param mapSlot - The slot of the map (specified in Aztec.nr contract)
     * @param key - The key to lookup in the map
     * @returns The storage slot of the value in the map
     */
    computeSlotInMap(mapSlot: Fr | bigint, key: Fr | bigint | AztecAddress): Fr;
    /**
     * Get the current blocknumber
     * @returns The current block number
     */
    blockNumber(): Promise<number>;
    /**
     * Get the current timestamp
     * @returns The current timestamp
     */
    timestamp(): Promise<number>;
    /**
     * Loads the value stored at the given slot in the public storage of the given contract.
     * @param who - The address of the contract
     * @param slot - The storage slot to lookup
     * @returns The value stored at the given slot
     */
    loadPublic(who: AztecAddress, slot: Fr | bigint): Promise<Fr>;
    /**
     * Loads the value stored at the given slot in the private storage of the given contract.
     * @param contract - The address of the contract
     * @param owner - The owner for whom the notes are encrypted
     * @param slot - The storage slot to lookup
     * @returns The notes stored at the given slot
     */
    loadPrivate(owner: AztecAddress, contract: AztecAddress, slot: Fr | bigint): Promise<Note[]>;
}
//# sourceMappingURL=cheat_codes.d.ts.map
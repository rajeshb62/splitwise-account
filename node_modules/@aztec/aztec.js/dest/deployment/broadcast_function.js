import { ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS, computeVerificationKeyHash, createPrivateFunctionMembershipProof, createUnconstrainedFunctionMembershipProof, getContractClassFromArtifact, } from '@aztec/circuits.js';
import { FunctionType, bufferAsFields } from '@aztec/foundation/abi';
import { padArrayEnd } from '@aztec/foundation/collection';
import { Fr } from '@aztec/foundation/fields';
import { getRegistererContract } from './protocol_contracts.js';
/**
 * Sets up a call to broadcast a private function's bytecode via the ClassRegisterer contract.
 * Note that this is not required for users to call the function, but is rather a convenience to make
 * this code publicly available so dapps or wallets do not need to redistribute it.
 * @param wallet - Wallet to send the transaction.
 * @param artifact - Contract artifact that contains the function to be broadcast.
 * @param selector - Selector of the function to be broadcast.
 * @returns A ContractFunctionInteraction object that can be used to send the transaction.
 */
export async function broadcastPrivateFunction(wallet, artifact, selector) {
    const contractClass = getContractClassFromArtifact(artifact);
    const privateFunctionArtifact = artifact.functions.find(fn => selector.equals(fn));
    if (!privateFunctionArtifact) {
        throw new Error(`Private function with selector ${selector.toString()} not found`);
    }
    const { artifactTreeSiblingPath, artifactTreeLeafIndex, artifactMetadataHash, functionMetadataHash, unconstrainedFunctionsArtifactTreeRoot, privateFunctionTreeSiblingPath, privateFunctionTreeLeafIndex, } = createPrivateFunctionMembershipProof(selector, artifact);
    const vkHash = computeVerificationKeyHash(privateFunctionArtifact.verificationKey);
    const bytecode = bufferAsFields(privateFunctionArtifact.bytecode, MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS);
    await wallet.addCapsule(bytecode);
    const registerer = getRegistererContract(wallet);
    return Promise.resolve(registerer.methods.broadcast_private_function(contractClass.id, artifactMetadataHash, unconstrainedFunctionsArtifactTreeRoot, privateFunctionTreeSiblingPath, privateFunctionTreeLeafIndex, padArrayEnd(artifactTreeSiblingPath, Fr.ZERO, ARTIFACT_FUNCTION_TREE_MAX_HEIGHT), artifactTreeLeafIndex, 
    // eslint-disable-next-line camelcase
    { selector, metadata_hash: functionMetadataHash, vk_hash: vkHash }));
}
/**
 * Sets up a call to broadcast an unconstrained function's bytecode via the ClassRegisterer contract.
 * Note that this is not required for users to call the function, but is rather a convenience to make
 * this code publicly available so dapps or wallets do not need to redistribute it.
 * @param wallet - Wallet to send the transaction.
 * @param artifact - Contract artifact that contains the function to be broadcast.
 * @param selector - Selector of the function to be broadcast.
 * @returns A ContractFunctionInteraction object that can be used to send the transaction.
 */
export async function broadcastUnconstrainedFunction(wallet, artifact, selector) {
    const contractClass = getContractClassFromArtifact(artifact);
    const functionArtifactIndex = artifact.functions.findIndex(fn => fn.functionType === FunctionType.UNCONSTRAINED && selector.equals(fn));
    if (functionArtifactIndex < 0) {
        throw new Error(`Unconstrained function with selector ${selector.toString()} not found`);
    }
    const functionArtifact = artifact.functions[functionArtifactIndex];
    const { artifactMetadataHash, artifactTreeLeafIndex, artifactTreeSiblingPath, functionMetadataHash, privateFunctionsArtifactTreeRoot, } = createUnconstrainedFunctionMembershipProof(selector, artifact);
    const bytecode = bufferAsFields(functionArtifact.bytecode, MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS);
    await wallet.addCapsule(bytecode);
    const registerer = getRegistererContract(wallet);
    return registerer.methods.broadcast_unconstrained_function(contractClass.id, artifactMetadataHash, privateFunctionsArtifactTreeRoot, padArrayEnd(artifactTreeSiblingPath, Fr.ZERO, ARTIFACT_FUNCTION_TREE_MAX_HEIGHT), artifactTreeLeafIndex, 
    // eslint-disable-next-line camelcase
    { selector, metadata_hash: functionMetadataHash });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvYWRjYXN0X2Z1bmN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RlcGxveW1lbnQvYnJvYWRjYXN0X2Z1bmN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxpQ0FBaUMsRUFDakMsdURBQXVELEVBQ3ZELDBCQUEwQixFQUMxQixvQ0FBb0MsRUFDcEMsMENBQTBDLEVBQzFDLDRCQUE0QixHQUM3QixNQUFNLG9CQUFvQixDQUFDO0FBQzVCLE9BQU8sRUFBZ0QsWUFBWSxFQUFFLGNBQWMsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ25ILE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFJOUMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFaEU7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLENBQUMsS0FBSyxVQUFVLHdCQUF3QixDQUM1QyxNQUFjLEVBQ2QsUUFBMEIsRUFDMUIsUUFBMEI7SUFFMUIsTUFBTSxhQUFhLEdBQUcsNEJBQTRCLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDN0QsTUFBTSx1QkFBdUIsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuRixJQUFJLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztRQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxRQUFRLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFRCxNQUFNLEVBQ0osdUJBQXVCLEVBQ3ZCLHFCQUFxQixFQUNyQixvQkFBb0IsRUFDcEIsb0JBQW9CLEVBQ3BCLHNDQUFzQyxFQUN0Qyw4QkFBOEIsRUFDOUIsNEJBQTRCLEdBQzdCLEdB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
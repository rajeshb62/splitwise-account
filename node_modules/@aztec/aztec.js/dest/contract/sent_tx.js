import { TxStatus, } from '@aztec/circuit-types';
import { retryUntil } from '@aztec/foundation/retry';
export const DefaultWaitOpts = {
    timeout: 60,
    provenTimeout: 600,
    interval: 1,
    waitForNotesSync: true,
    debug: false,
};
/**
 * The SentTx class represents a sent transaction through the PXE, providing methods to fetch
 * its hash, receipt, and mining status.
 */
export class SentTx {
    constructor(pxe, txHashPromise) {
        this.pxe = pxe;
        this.txHashPromise = txHashPromise;
    }
    /**
     * Retrieves the transaction hash of the SentTx instance.
     * The function internally awaits for the 'txHashPromise' to resolve, and then returns the resolved transaction hash.
     *
     * @returns A promise that resolves to the transaction hash of the SentTx instance.
     * TODO(#7717): Don't throw here.
     */
    getTxHash() {
        return this.txHashPromise;
    }
    /**
     * Retrieve the transaction receipt associated with the current SentTx instance.
     * The function fetches the transaction hash using 'getTxHash' and then queries
     * the PXE to get the corresponding transaction receipt.
     *
     * @returns A promise that resolves to a TxReceipt object representing the fetched transaction receipt.
     */
    async getReceipt() {
        const txHash = await this.getTxHash();
        return await this.pxe.getTxReceipt(txHash);
    }
    /**
     * Awaits for a tx to be mined and returns the receipt. Throws if tx is not mined.
     * @param opts - Options for configuring the waiting for the tx to be mined.
     * @returns The transaction receipt.
     */
    async wait(opts) {
        if (opts?.debug && opts.waitForNotesSync === false) {
            throw new Error('Cannot set debug to true if waitForNotesSync is false');
        }
        const receipt = await this.waitForReceipt(opts);
        if (receipt.status !== TxStatus.SUCCESS && !opts?.dontThrowOnRevert) {
            throw new Error(`Transaction ${await this.getTxHash()} was ${receipt.status}. Reason: ${receipt.error ?? 'unknown'}`);
        }
        if (opts?.proven && receipt.blockNumber !== undefined) {
            await this.waitForProven(receipt.blockNumber, opts);
        }
        if (opts?.debug) {
            const txHash = await this.getTxHash();
            const tx = (await this.pxe.getTxEffect(txHash));
            const visibleIncomingNotes = await this.pxe.getIncomingNotes({ txHash });
            const visibleOutgoingNotes = await this.pxe.getOutgoingNotes({ txHash });
            receipt.debugInfo = {
                noteHashes: tx.noteHashes,
                nullifiers: tx.nullifiers,
                publicDataWrites: tx.publicDataWrites,
                l2ToL1Msgs: tx.l2ToL1Msgs,
                visibleIncomingNotes,
                visibleOutgoingNotes,
            };
        }
        return receipt;
    }
    /**
     * Gets unencrypted logs emitted by this tx.
     * @remarks This function will wait for the tx to be mined if it hasn't been already.
     * @returns The requested logs.
     */
    async getUnencryptedLogs() {
        await this.wait();
        return this.pxe.getUnencryptedLogs({ txHash: await this.getTxHash() });
    }
    /**
     * Get notes of accounts registered in the provided PXE/Wallet created in this tx.
     * @remarks This function will wait for the tx to be mined if it hasn't been already.
     * @returns The requested notes.
     */
    async getVisibleNotes() {
        await this.wait();
        return this.pxe.getIncomingNotes({ txHash: await this.getTxHash() });
    }
    async waitForReceipt(opts) {
        const txHash = await this.getTxHash();
        return await retryUntil(async () => {
            const txReceipt = await this.pxe.getTxReceipt(txHash);
            // If receipt is not yet available, try again
            if (txReceipt.status === TxStatus.PENDING) {
                return undefined;
            }
            // If the tx was dropped, return it
            if (txReceipt.status === TxStatus.DROPPED) {
                return txReceipt;
            }
            // If we don't care about waiting for notes to be synced, return the receipt
            const waitForNotesSync = opts?.waitForNotesSync ?? DefaultWaitOpts.waitForNotesSync;
            if (!waitForNotesSync) {
                return txReceipt;
            }
            // Check if all sync blocks on the PXE Service are greater or equal than the block in which the tx was mined
            const { blocks, notes } = await this.pxe.getSyncStatus();
            const targetBlock = txReceipt.blockNumber;
            const areNotesSynced = blocks >= targetBlock && Object.values(notes).every(block => block >= targetBlock);
            return areNotesSynced ? txReceipt : undefined;
        }, 'isMined', opts?.timeout ?? DefaultWaitOpts.timeout, opts?.interval ?? DefaultWaitOpts.interval);
    }
    async waitForProven(minedBlock, opts) {
        return await retryUntil(async () => {
            const provenBlock = await this.pxe.getProvenBlockNumber();
            return provenBlock >= minedBlock ? provenBlock : undefined;
        }, 'isProven', opts?.provenTimeout ?? DefaultWaitOpts.provenTimeout, opts?.interval ?? DefaultWaitOpts.interval);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VudF90eC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb250cmFjdC9zZW50X3R4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFNTCxRQUFRLEdBQ1QsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUF3QnJELE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBYTtJQUN2QyxPQUFPLEVBQUUsRUFBRTtJQUNYLGFBQWEsRUFBRSxHQUFHO0lBQ2xCLFFBQVEsRUFBRSxDQUFDO0lBQ1gsZ0JBQWdCLEVBQUUsSUFBSTtJQUN0QixLQUFLLEVBQUUsS0FBSztDQUNiLENBQUM7QUFFRjs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sTUFBTTtJQUNqQixZQUFzQixHQUFRLEVBQVksYUFBOEI7UUFBbEQsUUFBRyxHQUFILEdBQUcsQ0FBSztRQUFZLGtCQUFhLEdBQWIsYUFBYSxDQUFpQjtJQUFHLENBQUM7SUFFNUU7Ozs7OztPQU1HO0lBQ0ksU0FBUztRQUNkLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksS0FBSyxDQUFDLFVBQVU7UUFDckIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDdEMsT0FBTyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFlO1FBQy9CLElBQUksSUFBSSxFQUFFLEtBQUssSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEtBQUssS0FBSyxFQUFFLENBQUM7WUFDbkQsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1FBQzNFLENBQUM7UUFDRCxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFj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
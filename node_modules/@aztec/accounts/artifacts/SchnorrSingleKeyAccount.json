{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"SchnorrSingleKeyAccount","functions":[{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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pH3S0sEtwt86ap+0pH3SkvZJS9onLWmftGR90pL1SUunasm+M2qftHSqluw7o/ZJS6dqyb4zap+0ZH3SkvVJS94nLaH7uh88ap+0hO7pfvCo3mfUPmnpXF3e+6P2SUvn6vLeH7VPWjpXl/f+qH3SUp8ub+nT5S19urylT5e39Onylj5d3tKny1v6dHlLny5v6dPlLX26vKVPl7f06fKWPl3e0qfLW/p0eUufLm/p0+Utfbq8pU+Xt/Tp8pY+Xd7Sp8tb+nR5S58ub+nT5S19urylT5e39Onylj5d3tKny1v6dHlLny5v6dPlLX26vKVPl7f06fKWPl3e0qfLW/p0eUufLm/p0+Utfbq8pU+Xt/Tp8pY+Xd7Sp8tb+nR5a58ub+3T5a19ury1T5e3Du8zapu0pH26vLVPl7f26fLWPl3e2qfLW/t0eWufLm/t0+Wtfbq8tU+Xt/bp8tY+Xd7ap8tb+3R5a58ub+3T5a19ury1T5e39uny1j5d3tqny1v7dHlrny5v7dPlrX26vLVPl7f26fLWPl3e2qfLW/t0eWufLm/t0+Wtfbq8tU+Xt/bp8tY+Xd7ap8tbT9XlvYZeZC/5OKr3GfXgtGQ+LqPau1vfHjVcLtolcvgvo/6Qn88tv8jy09/Jz3VD/nxu+eup5R/dd/1o+QKWnyHXW2f4vPvWeX2l59T19yZ7dIf1d45qfUb1PqOSU8KDRyUnik+Pupvog5w+HjwqOak8eFRyqnnsqElOQA8e9VRpaX/UU6Wl/VFPlZb2R/U+o54qLe2P2ictZZ+0lH3SUvZJS9UnLVWftFR90lL1SUtHd1h/56h90lL1SUvVJy1Vn7RUfdLS7JOWZp+0NPukpdknLR3dYf2do/ZJS7NPWpp90tLsk5Zmn7S0+qSl1SctrT5pafVJS0d3WH/nqH3S0uqTllaftLT6pKXVJi3ZaJOWbLRJSzbapCUbbdKSDe8zapu0ZKNNWrLRJi3ZaJOWbPRJS9InLUmftCR90pL0SUtHd1h/56h90pL0SUvSJy1Jn7QkfdKS9klL2ictaZ+0pH3S0tEd1t85ap+0pH3SkvZJS9onLWmftGR90pL1SUvWJy1Zn7R0dIf1d47aJy1Zn7RkfdKS9UlL1icteZ+05H3SkvdJS94nLR3dYf2do/ZJS+i+6weP2ictoXu0Hzxqn7SE7ud+8Kh90tK5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","brillig_names":["get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","view"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"H4sIAAAAAAAA/9VdB5gT1ffNJrv0pYjYwUUFFFGT7SuigCAgggURURS3ZAWpwqKigot0BOmIYsHee8XesKNib9gb9t5+ov97cZ77HB4BsufOf+583/ny8jJvcm6ZO+9MJjMZkX+WPpmRyMOZ/7QzCDHvNUrI8fVlOfoaOvqyHX1NHH3NHH3bEDr7+lo51tvZ0Zfj6Gvt6Gvj9dlLhvfa2XvNixfm5yeLcpOJvERpPLekrLggnl9QVlicKE4UFBdU5Bbn5SWL84uLSspKiuIlify8ZKKyoCSvMv7PslO0ZlvxWi255ZI8W8J4xuOSPFulzzPX38HcmhMyLa4cr7+8dttITbul1d/Ka5txO9P7HEJrwi7Rmn6zRH0+iNduSbQB+nNXXNwT9r7F283x+SED7IcY0A8RwZzdDVcDkpI826TPs8Df4dq3drP2IV5Meyer3ca3b7Wl9+0IuxP2cOxbMXBOtQRuq20UF5v2QvUZ7b+2wG21A/pvT6D/XLnd3srtPa327lZ7D19ud6D3exH2Juzj5XaWtU3/gq6fHYA+aWzxjHsHvIT3muu95nmv+d5rgfda6L0Wea/F3muJ97qv99ox+o8POnvfsx+970TYn3AA20LoQuhKOJDQjdCdcBChB6EnoRfhYEJvwiGEPoS+hEMJhxEOJxxB6Ec4ktCfcBRhAOFowkDCMYRjCYMIxxGOJwwmnEAoJZQRygkVhCShknAiYQhhKOEkwjDCcMIIwkjCKMJowsmEMYSxhCrCOMIphFMJpxHGE04nnOH55Mxo5L+T2lzPSXZfgaOv2NHX0dHHTq7n6+vk6Nvf0XeAo6+zo6+Lo6+ro+9AR183R193R99Bjr4ejr6ejr5ejr6DHX29HX2HOPr6OPr6OvoOdfQd5ug73NF3hKOvn6PvSEdff0ffUY6+AY6+ox19Ax19xzj6jnX0DXL0HefoO97RN9jRd4Kjr9TRV+boK3f0VTj6ko6+SkffiY6+IY6+oY6+kxx9wxx9wx19Ixx9Ix19oxx9ox19Jzv6xjj6xjr6qhx94xx9pzj6TnX0neboG+/oO93Rd4bX59XWf5cM77Wz9xqv3QI98OZ425lA25xIOItQTZhEOJswmTCFMJUwjTCdMIMwkzCLcA5hNmEO4VzCXMI8wnzCAsJCwiLCYsISwnmEpYTzCRcQlhEu9A5Cti8nOPw70dF3lqOv2tE3ydF3tqNvsqNviqNvqqNvmqNvuqNvhqNvpqNvlqPvHEffbEffHEffuY6+uY6+eY6++Y6+BY6+hY6+RY6+xY6+JY6+8xx9Sx195zv6LnD0LXP0Xej12YuZZHf2XuO1W/6zz9ZWjEwAbCtZyUs8MRHIK54pIzL9saiNzRyLsyD++yeu1bXfVq7nv8QkYCwSYY5F/r88E2fXzua4ZXNicm22lfsf/yWmAGORG85YxH08E1PTtLmwcgObE9PS21axw3+J6cBY5IUtFsVOnokZW25z0UZsTszc0m0VbdR/iVnAWOSHJxa5KXgmztkSm4tS2pyYvfnbKt+E/xJzgLEoCEMsijbJM3Hu5tkc3wybE3M3Z1vxzfJfYh4wFoX/v7Eo2Eyeifmbsjl/s21OLEi5rfzKLfBfYiEwFkX/X7Eo2iKeiUUbt7l4C21OLN7Itkoqt9h/iSXAWBQHH4t4GjwT57lsjqdlc2LphttKpOm/xPnAWJQEGYuKtHkmLvivzXm1sDmxzNpWbmWt/Je4EBiLfQOKRbx2SwJ4fiAB1LcJW5/VNhYdlcQCqIMSwHl8ogAYi/2UxAI430sA5yuJYmAsOimJBfC4lgDW5URHYCz2F4oF+mIg4P6bAOZfQsp/UZ//ahtn5BzjoijK5rx4lmdrRmTDBf1bKY73PxdumeXiqCBh3jh6u5cAk0HK7kuiNQ4GbXd9ssUiG/4oL2HDhbBkq4g76GK2nYjHbV8s995cavZI86voci8J7T5eyf9LKbrqI6qW+XVzOTDpLwUHV2IHX+4oHLW1e3lUx9FuGTDWl8FsLswP8mh3WVTmaHd5VJDw5QJHuytCfrRju69QfrRbBku2knIHXZGj3ZXem6v8R7srHUe7qwI42iGqljnaXQlM+quEgouu+kibr8ZVz0Qkgj8SX+IVjSg4B5HS4BrwbAFdtDjG1wjMksJut8kdtN3XKpkdInP8OuE6Ea/dkuCYXCdQJ64B+vB6BfvL9QL7yw3gGbqZq9xgcZXyBTqfrgPm041Cfr0xuqFyQ9emC4B+uAnmh/xkkMr1JnD8zHJzVJDwzQLK9ZaQK1e2+5ZojYNB2w1UuV4AS7ayXAddEeV6q/fmNr9yvdWhXG8LQLkiqpZRrrcCk/42oeCiqz7S5ttDPiO90SsaMbAPbwT6EFl47wh5PDhf7hCY3QLtdh68EPlyi8BMFpk7d4ZcGbEP7xTw4R1AH94F9qFZ0McAZP26O+Q1h2Nyt0DNuUdI+d0jqKiNL9D7EDKfVgj5dUUAihp5pfu9MD8U5QapqO8Fx88s90UFCd8noKjvD7miZrvvj9Y4GLTdQBX1+bBkK0466Ioo6ge8Nw/6FfUDDkX9YACKGlG1jKJ+AJj0DwoFF131kTY/FPLZ1AqvaKAV9QqgD5GF9+GQx4Pz5WGB2S3QbhFFbfIQPZNF5s4jIVfU7MNHBHz4MNCHj4J9aBb0MQBZvx4Lec3hmDwmUHMeF1J+jwsqauML9D6EzKeVQn5dGYCiXgr0wxMwPyQTQSrqJ8DxM8uTUUHCTwoo6qdCrqjZ7qeiNQ4GbTdQRb0UlmyJSgddEUX9tPfmGb+iftqhqJ8JQFEjqpZR1E8Dk/4ZoeCiqz7S5mdDPpta6RUNtKJeCfQhsvA+F/J4cL48JzC7BdotoqhNHqJnssjcWRVyRc0+XCXgw+eAPnwe7EOzoI8ByPr1QshrDsfkBYGa86KQ8ntRUFEbX6D3IWQ+rRby6+oAFPV5QD+8BPNDXqCK+iVw/MzyclSQ8MsCivqVkCtqtvuVaI2DQdsNVFGfB0u28sAU9avem9f8ivpVh6J+LQBFjahaRlG/Ckz614SCi676SJtfD/lsarVXNNCKejXQh8jC+0bI48H58obA7BZot4iiNnmInskic+fNkCtq9uGbAj58A+jDt8A+NAv6GICsX2+HvOZwTN4WqDnvCCm/dwQVtfEFeh9C5tMaIb+uCUBRI+81/y7MD6WB3u/yXXD8zPJeVJDwewKK+v2QK2q2+/1ojYNB2w1UUS+BJVthYPe7/MB786FfUX/gUNQfBqCoEVXLKOoPgEn/oVBw0VUfafNHIZ9NrfGKBlpRrwH6EFl4Pw55PDhfPhaY3QLtFlHUJg/RM1lk7nwSckXNPvxEwIcfA334KdiHZkEfA5D167OQ1xyOyWcCNedzIeX3uaCiNr5A70PIfFor5Ne1ASjqxUA/fAHzQ25JkIr6C3D8zPJlVJDwlwKK+quQK2q2+6tojYNB2w1UUS+GJVtFkYOuiKL+2nvzjV9Rf+1Q1N8EoKgRVcso6q+BSf+NUHDRVR9p87chn02t9YoGWlGvBfoQWXi/C3k8OF++E5jdAu0WUdQmD9EzWWTufB9yRc0+/F7Ah98BffgD2IdmQR8DkPXrx5DXHI7JjwI15ych5feToKI2vkDvQ8h8+lnIrz8HoKgXAf3wC8wPZcVBKupfwPEzy69RQcK/Cijq30KuqNnu36I1DgZtN1BFvQiWbPnFDroiivp3780ffkX9u0NR/xGAokZULaOofwcm/R9CwUVXfaTN/wv5bOpnr2igFfXPQB8iC++fIY8H58ufArNboN0iitrkIXomi8yddSFX1OzDdQI+/BPow7/APjQL+hiArF9/h7zmcEz+Fqg5fFBBxdqeQ3FDSlEbX6D3IWQ+ZQj5NSMmr6gXAv0QhfmhINCrvqPg+JklFhMkHIvht5sZC7eiZrszYzUOBm03UEW9EHbwKQvsqu8sz+d1TGUyr1mxDRU1ryStqBFVyyjqLGDS14nJBBdd9ZE2142FezaV4RUNtKLOAPoQWXjrhTwenC/1YvjZLdBuEUVt8hA9k0XmTn1hH8Zrt6zfl+sL+LAe0IcNwD40C/oYgKxfDUNeczgmDQVqTiMh5ddIUFEbX6D3IWQ+ZQv5NTsARb0AqKgbw/yQXxCkom4Mjp9ZmsQECTcRUNRNQ66o2e6myhX1ApyiLnPQFVHUzTyfb+VX1M0cinqrABQ1omoZRd0MmPRbxWSCi676SJubh3w2le0VDbSizgb6EFl4tw55PDhfthaY3QLtFlHUJg/RM1lk7rQIuaJmH7YQ8OHWQB9uo0RRI+vXtiGvORyTbQVqznZCym87QUVtfIHeh5D5tL2QX7cPQFHPByrqHXDzycIgFfUO4PiZZceYIOEdBRT1TiFX1Gz3TsoV9XyYos4vddAVUdQtPZ+38ivqlg5F3SoARY2oWkZRtwQmfauYTHDRVR9p884hn01t7xUNtKLeHuhDZOHNCXk8OF9yBGa3QLtFFLXJQ/RMFpk7rUOuqNmHrQV8mAP04S5KFDWyfu0a8prDMdlVoObsJqT8dhNU1MYX6H0ImU9thPzaJgBFPQ+oqNvC/FAc6NOz2oLjZ5Z2MUHC7QQU9e4hV9Rs9+7KFfU8mKIuCuzpWXt4Pm/vV9R7OBR1+wAUNaJqGUW9BzDp28dkgouu+kib9wz5bKqNVzTQiroN0IfIwtsh5PHgfOkgMLsF2i2iqE0eomeyyNzZK+SKmn24l4APOwB9uLcSRY2sX/uEvOZwTPYRqDlxIeUXF1TUxhfofQiZTwkhvyYCUNRzgYo6V6mizgXHzyx5MUHCeQKKOj/kiprtzleuqOcqVNQFns8L/Yq6wKGoCwNQ1IiqZRR1ATDpC5UoaqTNRSGfTSW8ooFW1AmgD5GFtzjk8eB8KRaY3QLtFlHUJg/RM1lk7pSEXFGzD0sEfFgM9OG+ShQ1sn51DHnN4Zh0FKg5+wkpv/0EFbXxBXofQuZTJyG/dgpAUZ8LVNT7w/xQEOi9vvcHx88sB8QECR8goKg7h1xRrw+UckV9LkxRlwZ2r+8uns+7+hV1F4ei7hqAokZULaOouwCTvmtMJrjoqo+0+cCQz6Y6eUUDrag7AX2ILLzdQh4PzpduArNboN0iitrkIXomi8yd7iFX1OzD7gI+7Ab04UFKFDWyfvUIec3hmPQQqDk9hZRfT0FFbXyB3oeQ+dRLyK+9AlDUc4CK+mCcoq4IUlEfDI6fWXrHBAn3FlDUh4RcUbPdhyhX1HNwijrPQVdEUffxfN7Xr6j7OBR13wAUNaJqGUXdB5j0fWMywUVXfaTNh4Z8NtXLKxpoRd0L6ENk4T0s5PHgfDlMYHYLtFtEUZs8RM9kkblzeMgVNfvwcAEfHgb04RFKFDWyfvULec3hmPQTqDlHCim/IwUVtfEFeh9C5lN/Ib/2D0BRzwYq6qNgfsgN9Dfqo8DxM8uAmCDhAQKK+uiQK2q2+2jlino2TFFXBPYb9UDP58f4FfVAh6I+JgBFjahaRlEPBCb9MTGZ4KKrPtLmY0M+m+rvFQ20ou4P9CGy8A4KeTw4XwYJzG6BdosoapOH6JksMneOC7miZh8eJ+DDQUAfHq9EUSPr1+CQ1xyOyWCBmnOCkPI7QVBRG1+g9yFkPpUK+bU0AEV9DlBRl8H8kJcXpKIuA8fPLOUxQcLlAoq6IuSKmu2uUK6oz4Ep6vIKB10RRZ30fF7pV9RJh6KuDEBRI6qWUdRJYNJXxmSCi676SJtPDPlsqtQrGmhFXQr0IbLwDgl5PDhfhgjMboF2iyhqk4fomSwyd4aGXFGzD4cK+HAI0IcnKVHUyPo1LOQ1h2MyTKDmDBdSfsMFFbXxBXofQubTCCG/jghAUc8CKuqRMD8kA/2NeiQ4fmYZFRMkPEpAUY8OuaJmu0crV9SzYIo6Edhv1Cd7Ph/jV9QnOxT1mAAUNaJqGUV9MjDpx8Rkgouu+kibx4Z8NjXCKxpoRT0C6ENk4a0KeTw4X6oEZrdAu0UUtclD9EwWmTvjQq6o2YfjBHxYBfThKUoUNbJ+nRrymsMxOVWg5pwmpPxOE1TUxhfofQiZT+OF/Do+AEU9E6ioT4f5IT9QRX06OH5mOSMmSPgMAUV9ZsgVNdt9pnJFPROmqMsCU9QTPJ9P9CvqCQ5FPTEARY2oWkZRTwAm/cSYTHDRVR9p81khn02N94oGWlGPB/oQWXirQx4Pzpdqgdkt0G4RRW3yED2TRebOpJAravbhJAEfVgN9eLYSRY2sX5NDXnM4JpMFas4UIeU3RVBRG1+g9yFkPk0V8uvUABT1DKCingbzQ1FJkIp6Gjh+ZpkeEyQ8XUBRzwi5oma7ZyhX1DNgirq4yEFXRFHP9Hw+y6+oZzoU9awAFDWiahlFPROY9LNiMsGFn0cF2nxOyGdTU72igVbUU4E+RBbe2SGPB+fLbIHZLdBuEUVt8hA9k0XmzpyQK2r24RwBH84G+vBcJYoaWb/mhrzmcEzmCtSceULKb56goja+QO9DyHyaL+TX+QEo6ulARb0A9wtNoIp6ATh+ZlkYEyS8UEBRLwq5oma7FylX1NNhijo/MEW92PP5Er+iXuxQ1EsCUNSIqmUU9WJg0i+JyQQXXfWRNp8X8tnUfK9ooBX1fKAPkYV3acjjwfmyVGB2C7RbRFGbPETPZJG5c37IFTX78HwBHy4F+vACJYoaWb+WhbzmcEyWCdScC4WU34WCitr4Ar0PIfPpIiG/XhSAop4GVNQX436jjgepqC8Gx88sl8QECV8ioKiXh1xRs93LlSvqaTBFXRJ30BVR1Jd6Pr/Mr6gvdSjqywJQ1IiqZRT1pcCkvywmE1x01UfafHnIZ1MXeUUDragvAvoQWXivCHk8OF+uEJjdAu0WUdQmD9EzWWTuXBlyRc0+vFLAh1cAfXiVEkWNrF9Xh7zmcEyuFqg51wgpv2sEFbXxBXofQubTtUJ+vTYART0VqKivw80nE0Eq6uvA8TPL9TFBwtcLKOobQq6o2e4blCvqqTBFXVjpoCuiqG/0fH6TX1Hf6FDUNwWgqBFVyyjqG4FJf1NMJrjoqo+0+eaQz6au9YoGWlFfC/QhsvDeEvJ4cL7cIjC7BdotoqhNHqJnssjcuTXkipp9eKuAD28B+vA2JYoaWb9uD3nN4ZjcLlBz7hBSfncIKmrjC/Q+hMynO4X8emcAinoKUFHfBfNDfqBPz7oLHD+z3B0TJHy3gKK+J+SKmu2+R7mingJT1GWBPT1rhefze/2KeoVDUd8bgKJGVC2jqFcAk/7emExw0VUfafN9IZ9N3ekVDbSivhPoQ2ThvT/k8eB8uV9gdgu0W0RRmzxEz2SRufNAyBU1+/ABAR/eD/Thg0oUNbJ+PRTymsMxeUig5jwspPweFlTUxhfofQiZT48I+fWRABT1ZKCifhTmh2Sgv1E/Co6fWR6LCRJ+TEBRPx5yRc12P65cUU+GKepEYL9Rr/R8/oRfUa90KOonAlDUiKplFPVKYNI/EZMJLrrqI21+MuSzqUe8ooFW1I8AfYgsvE+FPB6cL08JzG6BdosoapOH6JksMneeDrmiZh8+LeDDp4A+fEaJokbWr2dDXnM4Js8K1JznhJTfc4KK2vgCvQ8h82mVkF9XBaCozwYq6udhfqgsCFJRPw+On1leiAkSfkFAUb8YckXNdr+oXFGfDVPU8TIHXRFFvdrz+Ut+Rb3aoahfCkBRI6qWUdSrgUn/UkwmuOiqj7T55ZDPplZ5RQOtqFcBfYgsvK+EPB6cL68IzG6BdosoapOH6JksMndeDbmiZh++KuDDV4A+fE2JokbWr9dDXnM4Jq8L1Jw3hJTfG4KK2vgCvQ8h8+lNIb++GYCingRU1G/B/FAS6FXfb4HjZ5a3Y4KE3xZQ1O+EXFGz3e8oV9STYIq6MLCrvtd4Pn/Xr6jXOBT1uwEoakTVMop6DTDp343JBBdd9ZE2vxfy2dSbXtFAK+o3gT5EFt73Qx4Pzpf3BWa3QLtFFLXJQ/RMFpk7H4RcUbMPPxDw4ftAH36oRFEj69dHIa85HJOPBGrOx0LK72NBRW18gd6HkPn0iZBfPwlAUVcDFfWnuN+oA73X96fg+Jnls5gg4c8EFPXnIVfUbPfnyhV1NUxRJwK71/daz+df+BX1Woei/iIARY2oWkZRrwUm/RcxmeCiqz7S5i9DPpv6xCsaaEX9CdCHyML7VcjjwfnylcDsFmi3iKI2eYieySJz5+uQK2r24dcCPvwK6MNvlChqZP36NuQ1h2PyrUDN+U5I+X0nqKiNL9D7EDKfvhfy6/eeX4NUl2dFsbaY5YeYIOEfBNTljyFXl2z3jwLq0sUVsYP8KLATA3c88XiH1YdIu39SMpn4HmjzzyGfTLCtPwlMJn4J+eSb4/KLcM2prQ9/FZo4/Pr/MHGYKDRx+C0mSPg3gYnD7yGfOLDdvyuZOHAi/y6wEwN3PPF4h9WHSLv/UDJx+BVo8/9CPnFgW/8QmDj8GfKJA8flT+GaU1sfrhOaOKyLyf+GPwH4G/5fwH0oyMnSX+D4meXvmCDhvwUmS5HMcE+W2G7mGMFuV4TrOo8r+qfDdcgJDjDeGZnhPoByoWOO6ANoNDPcecg2RwXsjmXKHPR4u/5LQNA+kY4ZYh/nfRM96UHu75khz3v2YaaADzOAPswC+9As6Eki8phTJ+THCY5JHYF6WVeoXtbNlPu51/gCvQ8h86me0D6E9mU95FyLtlHH45hHwfnLa+db7f2i/xxHud3Jau9vtQ+w2p2tdher3dVqH2i1u1nt7lb7IKvdw2r3tNq9rPbBVru31T7Eavex2n2t9qFW+zCrfbjVPsJq97PaR1rt/lb7KKs9wGofbbUHWu1jrPaxVnuQ1T7Oah9vtQdb7ROsdqnVLrPa5Va7wmonrXal1T7Rag+x2kOt9klWe5jVHm61R1jtkVZ7lNUebbVPttpjrPZYq11ltcdZ7VOs9qlW+zSrPd5qn261z/DaOZF/Fu670Pp8mdW+wGqfb7WXWu3zrPYSq73Yai+y2gut9gKrPd9qz7Pac632uVZ7jtWebbXPsdqzrPZMqz3Dak+32tOs9lSrPcVqT7baZ1vtSVa72mqfZbUnWu0JXru+pdVNPHjp7L3Ga7ck6oPPV2yMZ2233QB2jMrLl+TZMH2eFf4O5tY8UnO6ht+zH8zxKW4dqxJWu6G3jhnXiBrZhMaEJpn/Of2zfkH/PSA3ittWI2B+NhWa56D9lwf0XzbQf82U+C8f6L/GQP9tBdYv/trQ1KoNzaz2Vla7ia82NKfG1oQWhG0CqA0FwNg0B8ZmWyW5XQj039ZA/22nxH9FQP+1APpve+HasK1VA7az2ttb7W18tWEHauxI2InQMoDaUAyMzQ7A2LRSktslQP/tCPTfzkr8ty/QfzsB/ZcjXBtaWTVgZ6udY7Vb+mpDa2rsQtiVsFsAtaEjMDatgbFpIxybNlYMdrHau1rt3XyxaUuNdoTdCXs4YoPWvO1xPqiU5Lln+jzz/B2uWLW3YtLWap9pafM9fbHqQI29CHsT9nHEKgr2QUYEtx91AOZ+luefaGTjC4p3RqQmt9DfkV9UUVpeUZTn3Dg6mEintIvIHKTDnMC7K7E5CrR5DyGb0Sem24P3k43FJl67JbEnkOfOUR2x6WBtK7egtKA8WVBUXpRXXF6azCsuyyuqKMwvLS5MluXRKe2KgrLKZDyvNFmYKMzLzSvNqyjJi5fkFyRLC5PxktxSSZ57RXT4c28lPPdRwjOuhGdCCc9cJTzzlPDMV8KzQAnPQiU8i5TwLFbCs0QJz32V8OyohOd+Snh2UsJzfyU8D1DCs7MSnl2U8OyqhOeBSnh2U8KzuxKeBynh2UMJz55KePZSwvNgJTx7K+F5iBKefZTw7KuE56FKeB6mhOfhSngeoYRnPyU8j1TCs78Snkcp4TlACc+jlfAcqITnMUp4HquE5yAlPI9TwvN4JTwHK+F5ghKepUp4linhWa6EZ4USnkklPCuV8DxRCc8hSngOVcLzJCU8hynhOVwJzxFKeI5UwnOUEp6jlfA8WQnPMUp4jlXCs0oJz3FKeJ6ihOepSniepoTneCU8T1fC8wwlPM9UwnOCEp4TlfA8SwnPaiU8JynhebYSnpOV8JyihOdUJTynKeE5XQnPGUp4zlTCc5YSnuco4TlbCc85Snieq4TnXCU85ynhOV8JzwVKeC5UwnOREp6LlfBcooTneUp4LlXC83wlPC9QwnOZEp4XKuF5kRKeFyvheYkSnsuV8LxUCc/LlPC8XAnPK5TwvFIJz6uU8LxaCc9rlPC8VgnP65TwvF4JzxuU8LxRCc+blPC8WQnPW5TwvFUJz9uU8LxdCc87lPC8UwnPu5TwvFsJz3uU8FyhhOe9Snjep4Tn/Up4PqCE54NKeD6khOfDSng+ooTno0p4PqaE5+NKeK5UwvMJJTyfVMLzKSU8n1bC8xklPJ9VwvM5JTxXKeH5vBKeLyjh+aISnquV8HxJCc+XlfB8RQnPV5XwfE0Jz9eV8HxDCc83lfB8SwnPt5XwfEcJzzVKeL6rhOd7Sni+r4TnB0p4fqiE50dKeH6shOcnSnh+qoTnZ0p4fq6E51olPL9QwvNLJTy/UsLzayU8v1HC81slPL9TwvN7JTx/UMLzRyU8f1LC82clPH9RwvNXJTx/U8LzdyU8/1DC839KeP6phOc6JTz/UsLzbyU8eYMaeGYo4RlVwjOmhGemEp5ZSnjWUcKzrhKe9ZTwrK+EZwMlPBsq4dlICc9sJTwbK+HZRAnPpkp4NlPCcyslPJsr4bm1Ep4tlPDcRgnPbZXw3E4Jz+2V8NxBCc8dlfDcSQnPlkp4tlLCc2clPHOU8GythOcuSnjuqoTnbkp4tlHCs60Snu2U8NxdCc89lPBsr4Tnnkp4dlDCcy8lPPdWwnMfJTzjSngmlPDMVcIzTwnPfCU8C5TwLFTCs0gJz2IlPEuU8NxXCc+OSnjup4RnJyU891fC8wAlPDsr4dlFCc+uSngeqIRnNyU8uyvheZASnj2U8OyphGcvJTwPVsKztxKehyjh2UcJz75KeB6qhOdhSngeroTnEUp49lPC80glPPsr4XmUEp4DlPA8WgnPgUp4HqOE57FKeA5SwvM4JTyPV8JzsBKeJyjhWaqEZ5kSnuVKeFYo4ZlUwrNSCc8TlfAcooTnUCU8T1LCc5gSnsOV8ByhhOdIJTxHKeE5WgnPk5XwHKOE51glPKuU8BynhOcpSnieqoTnaUp4jlfC83QlPM9QwvNMJTwnKOE5UQnPs5TwrFbCc5ISnmcr4TlZCc8pSnhOVcJzmhKe05XwnKGE50wlPGcp4XmOEp6zlfCco4TnuUp4zlXCc54SnvOV8FyghOdCJTwXKeG5WAnPJUp4nqeE51IlPM9XwvMCJTyXKeF5oRDPqI9nXrwwPz9ZlJtM5CVK47klZcUF8fyCssLiRHGioLigIrc4Ly9ZnF9cVFJWUhQvSeTnJROVBSV5ld622wBtviggm+O1WxIXZ+D8t2tURz5eomS/Wa6E56VKeF6mhOflSnheoYTnlUp4XqWE59VKeF6jhOe1Snhep4Tn9Up43qCE541KeN6khOfNSnjeooTnrUp43qaE5+1KeN6hhOedSnjepYTn3Up43qOE5wolPO9VwvM+JTzvV8LzASU8H1TC8yElPB9WwvMRJTwfVcLzMSU8H1fCc6USnk8o4fmkEp5PKeH5tBKezyjh+awSns8p4blKCc/nlfB8QQnPF5XwXK2E50tKeL6shOcrSni+qoTna0p4vq6E5xtKeL6phOdbSni+rYTnO0p4rlHC810lPN9TwvN9JTw/UMLzQyU8P1LC82MlPD9RwvNTJTw/U8LzcyU81yrh+YUSnl8q4fmVEp5fK+H5jRKe3yrh+Z0Snt8r4fmDEp4/KuH5kxKePyvh+YsSnr8q4fmbEp6/K+H5hxDPqI9nbf8HnQm0+X9KbM4C2vynEpvrAG1ep8TmukCb/1Jicz2gzX8rsbk+0GYmp8HmBkCbM5TY3BBoc1SJzY2ANseU2JwNtDlTic2NgTZnKbG5CdDmOkpsbgq0ua4Sm5sBba6nxOatgDbXV2Jzc6DNDZTYvDXQ5oZKbG4BtLmREpu3AdqcrcTmbYE2N1Zi83ZAm5sosXl7oM1Nldi8A9DmZkps3hFo81ZKbN4JaHNzJTa3BNq8tRKbWwFtbqHE5p2BNm+jxOYcoM3bKrG5NdDm7ZTYvAvQ5u2V2Lwr0OYdlNi8G9DmHYE28+/ifE3Az96FAe0IuxP2ILQn7EnoQNiLsDdhH/5OQoKQy34h5BMKCIWEIkIxoYSwL6EjYT9CJ8L+hAM8P3QhdCUcSOhG6E44iNCD0JPQi3AwoTfhEEIfQl/CoYTDCIcTjiD0IxxJ6E84ijCAcDRhIOEYwrGEQYTjCMcTBhNOIJQSygjlhApCklBJOJEwhDCUcBJhGGE4YQRhJGEUYTThZMIYwlhCFWEc4RTCqYTTCOMJpxPOIJxJmECYSDiLUE2YRDibMJkwhTCVMI0wnTCDMJMwi3AOYTZhDuFcwlzCPMJ8wgLCQsIiwmLCEsJ5hKWE8wkXEJYRLiRcRLiYcAlhOeFSwmWEywlXEK4kXEW4mnAN4VrCdYTrCTcQbiTcRLiZcAvhVsJthNsJdxDuJNxFuJtwD2EF4V7CfYT7CQ8QHiQ8RHiY8AjhUcJjhMcJKwlPEJ4kPEV4mvAM4VnCc4RVhOcJLxBeJKwmvER4mfAK4VXCa4TXCW8Q3iS8RXib8A5hDeFdwnuE9wkfED4kfET4mPAJ4VPCZ4TPCWsJXxC+JHxF+JrwDeFbwneE7wk/EH4k/ET4mfAL4VfCb4TfCX8Q/kf4k7CO8BfhbwLvcBmEKCFGyCRkEeoQ6hLqEeoTGhAaEhoRsgmNCU0ITQnNCFsRmhO2JrQgbEPYlrAdYXvCDoQdCTsRWhJaEXYm5BBaE3Yh7ErYjdCG0JbQjrA7YQ9Ce8KehA6EvQh7E/YhxAkJQi4hj5BPKCAUEooIxYQSwr6EjoT9CJ0I+xMO4N/aCV0IXQkHEroRuhMOIvQg9CT0IhxM6E04hNCH0JdwKOEwwuGEIwj9CEcS+hOOIgwgHE0YSDiGcCxhEOE4wvGEwYQTCKWEMkI5oYKQJFQSTiQMIQwlnEQYRhhOGEEYSRhFGE04mcDPtOfnxfOz2Pk55/wMcX4+Nz/7mp8rzc9s5uch87OG+Tm+/Ixcfv5sNYGfm8rPJOXnffKzNPk5lfwMSH6+Ij+7kJ8LyM/c4+fZ8bPi+Dls/Iwzfn4YP5uLn3vFz5Ti5zXxs5D4OUP8DB9+Pg4/e4af68LPTOHnkfCzPvjZF/xcCX7OwnICPx+A773P97Xne8bz/dj5Xud8H3G+Rzff/5rvLc33beZ7IvP9hvlevnyfXL4HLd/fle+dyvcl5Xt+8v00+V6VfB9Ivsci37+Q7w3I993je9rx/eL4Xmx8n7OHCXx/Lr73Fd9Xiu/ZxPdD4nsN8X18+B45fP8ZvrcL3zeF70nC9/vge2nwfSr4HhB8fwW+dwHfF4D/c8//Z+f/ivP/sPk/zvz/Yf5vLv/vlf9Tyv/X5P9C8v8M+T98/P84/u8Z/6+L/zPF/0fi//rw/2j4Pyr8/w/+bwX/b4H/E8DX2/O17HydOF+Dzdc387XDfF0uX/PKx0++VpOvg+RrDPn6Pb42jq8V42un+FoivraGrzXhyQVfi8C/zfNv1fzbLf+Wyb/t8W9d/NsP/xbCvw3wuXI+d8znUvncIp9r43NPfC6Gz02wVmftylqOtQ3P9Xnuy3NBnhvxXCH6T8mJ8LGel3aRmsWjE4l5n/M1Y3wNFV9TxNfY8DUnfA0GX5PAv9Hzb9b8Gy7/psm/8fFvXvwbEP8mwr8R8DlzPofM51T5HCOfc+NzUHxOhs9RsGZnDcuaLofQmsBzYJ4T8hyJn/fSNrLh0tNqN7PaO3mvpVVVyRGjq3KqRuWUVlTknDq0akjOqFOSYyqHj+JD8nqOZunkvR40bmR51dBRI3NovaGV4wePHjP0lNKq5ODScVVDaAM55aUjc0aNHD4+pyxJ7eHDkxU5Y6tKq4Zym4/v6w+WW0rk2jTGrEhjzH1pjHk2jTGr0hizJo0x76Ux5ts0xnyfxhg+mG/pmFgaY5qnMaZFGmPapDGmXRpjitIYU5LGmF5pjOmdxphj0xhzXBpjRqQxZlQaY85KY8ykNMbMT2PMwjTGXJ7GmCvTGHNnGmPuTmPMk2mMeTqNMW+mMebtNMZ8mcaYr9MYsy6NMX+nMaZJdMvHNEtjTOs0xuyaxpi8NMYUpDGmexpjeqQxZkAaYwamMWZoGmOGpTHmjDTGTEhjzJw0xsxNY8zSNMZcmsaYa60xrTccM2Lc8Kqho0kHbDDw5jS+7CnHl/VJjh1bemIyZ+SoqhxWH6PGDD2d1EbZ+JzS8vJR40byGYb1UoqX22rG/9vXZcyY0vE5Q0dWJE/LGTWuKmdUZU4ZjasYaw9cke7AxyNbZqY99rlajH0xXcJvpTvwk1qw/dUa29h77VdVWj6MRo7KqUgm+bxR5Gkv/Htvcu1/9Xpj79BT33tvEoi7Wbd39t7Ha7ck6lvbRW+/mH4TqR/57wLmn1c/UnM+Q8o/ZpsC21//Py5eDqyu2b7fFl6yvffWjOTfMXzOpqW1Hi/drO1l+D7r7vgu89lB1e7v5qWH9Vmm77Oe1mdZvs96WZ/V8X12sPVZXd9nva3P6vk+O8T6rL7vsz7WZw18n/W1Pmvo++xQ67NGkZo2o0mkZol5fdlWn/GjyZem1njc/lQQN9tvJrD9eDw/bmyKVddsv4nPT5nWZ019n2VZnxmOHLu1vvXmWeuZUsjnE7t5/X2ssT9ZY+28NON5MX7JlPFLMsP3fZHIf2tCxPf9DSKidSOR4fs+w8fvH5OXjSw/n5is6kITjgFDq0bSHMRmb2+xj8M623rXOv71/OvXd3yegfNKPDuyoVf8GZJl9QMzJLG5GWK+v0FEMmNrMiTLx8fvH3/lqiPjn3iGb/s2nzoO/5hY1nV8ZrZljgpZ1rbs9etYNtrr220z3u7L816bOrbpz926kQ3tsfuMf5nLXl67icOeTN92XXHLcmy3qWO834f2uIyNvJrv8ff5v8fF2bVfI3NHtrrH47K5XzOLrCuz/XIT56gjNmzTAVb/xvabqG8d87m9/lPWNrt6bf93RyLp51h2ZMN901+/bcUC9GHF5tZv8/0NIhvWFIn6Xd/Hx+8ff/1uYH3WGcPl3/2joYyt5Rm+7du2NnT43uRJI8dnZlv/zkitbdnrN7T8Z69vt814u6+f99rUsc0GPg6NIhvaY/fZx4Y+vu3a+6OJdxOHrfV83+nKl/qO72zqGO/3r533dj0ZuJHvtH1tj61rfW6vf5O1zUE+G+3xUd9nLt9kOD7z17ZN2e+vga5je4ZjW/66aq9v1/zMLbAD/d11fN+d6fhu4eNgbiquqWxLVQNdttl2108xzl7PXqeOwzf25y6/+o9TQj7MS+WTVD5s4Fi/vsOOJg4/NQjGtvxUXFPZ5jpuNEhhm213w2BsK0jFNZVtrmNIwxS22XY3SjHOXs9ep47DN/bnLr8GlPuFqXySyofZjvUbOexo4vBTdjC2FaXimsq2xo71s1PYZtvdOBjbilNxTWWb66xr4xS22XY3STHOXs9ep47DN/bnLr8GlPslqXySyodNHes3cdjRxOGnpsHYVpqKayrbmjnWb5rCNtvuZsHYVpaKayrbtnKs3yyFbbbdW/nG2bbZ67m42OtvbBsZvm245uzmPJHwedfyVP51nQnfXP9m+Wxz+TfbYZtfQ9lzjWzfZ9k+TvZnti/950dc53n85765Xc/3mT2na+T7zHU8zI5sGPsGvs/s+UBj32euWuL/FYfbdX2f2fPrhr7P7GOz2Z8bRtxzO/+5EdtGYA5W+I/dG9PBjazP7fVv917tnLSXDN/4SGTzcnxT8x7//ptq3mPnqsS5n8aWb1y+s31rr3+v97ox37l+0axv2cZLZrWIbRW8v/1u8fDHMMv63k3Fi5ctnfsZ/zWNbLg/NvStl0pPuuq/GV9nI+vb54Ts9Vd6rxuLl+v8l79Wub7HPi/l0rBZm2Gv/Z3+33waOOyNprDXrL8qktpe2XOrNbXJrj0u/d/Qx9+sv3oT/P35EIlsXm3alK413GqjazM2Yau9jQaO77ZzRTBG8VQxijp4+2P0tve6JTXQPufHS2a1iG0JVw209z1/DXTFxnX+enPzyH++N9X5ete5Pvv7/DVwUzXB/p3NXv9T73VTNTDVvNL1PfZvfWb9utU16yF/MzU1uF51jY0x33eu7/faUd/6/naWr+9Hy7719ljrmu+JWX3mO82csI71mRmbaluZjm01daxfx7etuo5t2X32bzxfeG3OT8n9rqi4Jj7GR3Z87CXT+txe/zfv/cZy1My519tWXdNv1xhejC8yre+31zf+yfKtv86sG/H+QR/Z8Coz+/t4veyMja+XsZHX9dtw9GV6Y/+dK1bXrCOxHzWorvFDzPedNp+ob31/O8vX1zCjhvf699Ub2m3vR+Y7TWztfdSMTbWtLMe2mjrWr+fblmuftPvs/SjqDWrg+05wbBJ2TnG+m9vF6L4qO7/APp4K8M8Tvmo6V/p6INdV2bYt5ntjvvVcY1JduS159TrFOV/YT4mgfi9OdQ2j/f2prhDenLpvf1dQV/C6bHPpps25/u7/Iw62f/xX99tzAf8/DTKrN/S56ypyYyPPcXew1nPtN2a9Nl6bryjv7m0rYvmKF63z4t0sm9fbY62rdV68o9fmYyzHb89IzbY2lneua3pc17b4z/vEHNtyXVfbKFKjI0eXlg87Ilk1bszIsXb58G8+4tiM/dWmf2OHE/+YmLW+vWiQD/t471PJB/9p2K0jeFvi1nSqhcz243Ud9m1ttVv47LTj3BnEwWzv32l4ZMPFL7Xskmnzy8DzS/i5uCSXWZpb7X/LqY+jfeoGPbXkRehSV2eu2Jc7NfR9ZmKW6RiXsZH3Ud9rqnUzUmw32/GZ2WZzR9//AbmtyJMwvgMA","debug_symbols":"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","brillig_names":["get_auth_witness","pack_returns_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnPioMwEIDxd8nZg2mTmYyvsixFWy0B0aJ2YRHffe3+YQs9fxdxdPLdfqes7tI29+spD904u+ptdf14rpc8Dvu0boVrptz3+Xp6/uzKxyOE7/35Vg+PcV7qaXGVHArXDpf9RffTXe5bV4VQbsXLpv5t6v9mtO29cCFiZcHKipUTVjaqHEus7LHyASsfsTJmMGIGI2YwYgYjZjBiBgUzKJhBwQwKZlAwg4IZFMygYAYFMyiYQcUMKmZQMYOKGVTMoGIGFTOomEHFDCpmMGEGE2YwYQYTZjBhBhNmMGEGE2YwYQYTZtAwg4YZNMygYQYNM2iYQcMMGmbQMIOGGfRlyaU9lz5w6SOXDlw6cmnh0sqlE5fmNHpOo+c0ekjjtk8f9ZTrpm9/bx66+3B+uohYPm8/f/blLw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrSingleKeyAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrSingleKeyAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"SchnorrSingleKeyAccount::entrypoint_parameters"}}],"kind":"struct","path":"SchnorrSingleKeyAccount::entrypoint_abi"}]}},"file_map":{"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"313":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"438":{"path":"/usr/src/noir-projects/noir-contracts/contracts/schnorr_single_key_account_contract/src/util.nr","source":"use std::schnorr::verify_signature;\nuse dep::aztec::prelude::AztecAddress;\nuse crate::auth_oracle::AuthWitness;\n\npub fn recover_address(message_hash: Field, witness: AuthWitness) -> AztecAddress {\n    let message_bytes: [u8; 32] = message_hash.to_be_bytes();\n    // In a single key account contract we re-used ivpk_m as signing key\n    let verification = verify_signature(\n        witness.keys.ivpk_m.inner.x,\n        witness.keys.ivpk_m.inner.y,\n        witness.signature,\n        message_bytes,\n    );\n    assert(verification == true);\n\n    AztecAddress::compute(witness.keys.hash(), witness.partial_address)\n}\n"},"439":{"path":"/usr/src/noir-projects/noir-contracts/contracts/schnorr_single_key_account_contract/src/auth_oracle.nr","source":"use dep::authwit::auth_witness;\nuse dep::aztec::protocol_types::{\n    address::PartialAddress, utils::arr_copy_slice, public_keys::{PublicKeys, PUBLIC_KEYS_LENGTH},\n};\n\npub struct AuthWitness {\n    keys: PublicKeys,\n    signature: [u8; 64],\n    partial_address: PartialAddress,\n}\n\nimpl AuthWitness {\n    fn deserialize(values: [Field; 77]) -> Self {\n        let mut signature = [0; 64];\n        for i in 0..64 {\n            signature[i] = values[i + PUBLIC_KEYS_LENGTH] as u8;\n        }\n        Self {\n            keys: PublicKeys::deserialize(arr_copy_slice(values, [0; PUBLIC_KEYS_LENGTH], 0)),\n            signature,\n            partial_address: PartialAddress::from_field(values[76]),\n        }\n    }\n}\n\npub unconstrained fn get_auth_witness(message_hash: Field) -> AuthWitness {\n    let witness: [Field; 77] = auth_witness::get_auth_witness(message_hash);\n    AuthWitness::deserialize(witness)\n}\n"},"440":{"path":"/usr/src/noir-projects/noir-contracts/contracts/schnorr_single_key_account_contract/src/main.nr","source":"mod util;\nmod auth_oracle;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract SchnorrSingleKeyAccount {\n    use dep::aztec::prelude::PrivateContext;\n\n    use dep::authwit::{entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions};\n\n    use crate::{util::recover_address, auth_oracle::get_auth_witness};\n\n    use dep::aztec::macros::functions::{private, view};\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[private]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        let witness = unsafe { get_auth_witness(outer_hash) };\n        recover_address(outer_hash, witness).eq(context.this_address())\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"73":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, CANONICAL_AUTH_REGISTRY_ADDRESS,\n    }, hash::poseidon2_hash_with_separator,\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let result: Field = context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n            [on_behalf_of.to_field(), inner_hash].as_slice(),\n            GasOpts::default(),\n        )\n        .deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n            [message_hash, authorize as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n            [context.this_address().to_field(), reject as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n"},"75":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"76":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator,\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"79":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: u32 = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            fields.extend_from_array(self.function_calls[i].serialize());\n        }\n        fields.push(self.nonce);\n        fields.push(self.is_fee_payer as Field);\n        fields.storage\n    }\n}\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"}}}
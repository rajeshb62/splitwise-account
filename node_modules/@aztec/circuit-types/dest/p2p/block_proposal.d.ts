/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Buffer32 } from '@aztec/foundation/buffer';
import { type EthAddress } from '@aztec/foundation/eth-address';
import { Signature } from '@aztec/foundation/eth-signature';
import { type Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
export declare class BlockProposalHash extends Buffer32 {
    constructor(hash: Buffer);
}
/**
 * BlockProposal
 *
 * A block proposal is created by the leader of the chain proposing a sequence of transactions to
 * be included in the head of the chain
 */
export declare class BlockProposal extends Gossipable {
    /** The payload of the message, and what the signature is over */
    readonly payload: ConsensusPayload;
    /** The signer of the BlockProposal over the header of the new block*/
    readonly signature: Signature;
    static p2pTopic: string;
    private sender;
    constructor(
    /** The payload of the message, and what the signature is over */
    payload: ConsensusPayload, 
    /** The signer of the BlockProposal over the header of the new block*/
    signature: Signature);
    p2pMessageIdentifier(): Buffer32;
    get archive(): Fr;
    static createProposalFromSigner(payload: ConsensusPayload, payloadSigner: (payload: Buffer32) => Promise<Signature>): Promise<BlockProposal>;
    /**Get Sender
     * Lazily evaluate the sender of the proposal; result is cached
     */
    getSender(): EthAddress;
    getPayload(): Buffer;
    toBuffer(): Buffer;
    static fromBuffer(buf: Buffer | BufferReader): BlockProposal;
    getSize(): number;
}
//# sourceMappingURL=block_proposal.d.ts.map
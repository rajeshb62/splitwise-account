import { ClientIvcProof, PrivateKernelTailCircuitPublicInputs } from '@aztec/circuits.js';
import { PrivateExecutionResult } from '../private_execution_result.js';
import { NestedProcessReturnValues, PublicSimulationOutput } from './public_simulation_output.js';
import { Tx } from './tx.js';
export declare class PrivateSimulationResult {
    privateExecutionResult: PrivateExecutionResult;
    publicInputs: PrivateKernelTailCircuitPublicInputs;
    constructor(privateExecutionResult: PrivateExecutionResult, publicInputs: PrivateKernelTailCircuitPublicInputs);
    getPrivateReturnValues(): NestedProcessReturnValues;
    toSimulatedTx(): Tx;
    toJSON(): {
        privateExecutionResult: any;
        publicInputs: string;
    };
    static fromJSON(obj: any): PrivateSimulationResult;
}
export declare class TxSimulationResult extends PrivateSimulationResult {
    publicOutput?: PublicSimulationOutput | undefined;
    constructor(privateExecutionResult: PrivateExecutionResult, publicInputs: PrivateKernelTailCircuitPublicInputs, publicOutput?: PublicSimulationOutput | undefined);
    getPublicReturnValues(): NestedProcessReturnValues[];
    static fromPrivateSimulationResultAndPublicOutput(privateSimulationResult: PrivateSimulationResult, publicOutput?: PublicSimulationOutput): TxSimulationResult;
    toJSON(): {
        privateExecutionResult: any;
        publicInputs: string;
        publicOutput: {
            encryptedLogs: {
                functionLogs: {
                    logs: object[];
                }[];
            };
            unencryptedLogs: {
                functionLogs: {
                    logs: object[];
                }[];
            };
            revertReason: import("../simulation_error.js").SimulationError | undefined;
            constants: string;
            end: string;
            publicReturnValues: any[];
            gasUsed: Partial<Record<import("./processed_tx.js").PublicKernelPhase, {
                daGas: number;
                l2Gas: number;
            }>>;
        } | undefined;
    };
    static fromJSON(obj: any): TxSimulationResult;
}
export declare class TxProvingResult {
    privateExecutionResult: PrivateExecutionResult;
    publicInputs: PrivateKernelTailCircuitPublicInputs;
    clientIvcProof: ClientIvcProof;
    constructor(privateExecutionResult: PrivateExecutionResult, publicInputs: PrivateKernelTailCircuitPublicInputs, clientIvcProof: ClientIvcProof);
    toTx(): Tx;
    toJSON(): {
        privateExecutionResult: any;
        publicInputs: string;
        clientIvcProof: string;
    };
    static fromJSON(obj: any): TxProvingResult;
}
/**
 * Recursively accummulate the return values of a call result and its nested executions,
 * so they can be retrieved in order.
 * @param executionResult
 * @returns
 */
export declare function accumulatePrivateReturnValues(executionResult: PrivateExecutionResult): NestedProcessReturnValues;
//# sourceMappingURL=simulated_tx.d.ts.map
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { ClientIvcProof, PrivateKernelTailCircuitPublicInputs, type PublicKernelCircuitPublicInputs } from '@aztec/circuits.js';
import { type Buffer32 } from '@aztec/foundation/buffer';
import { BufferReader } from '@aztec/foundation/serialize';
import { type GetUnencryptedLogsResponse } from '../logs/get_unencrypted_logs_response.js';
import { type L2LogsSource } from '../logs/l2_logs_source.js';
import { EncryptedNoteTxL2Logs, EncryptedTxL2Logs, UnencryptedTxL2Logs } from '../logs/tx_l2_logs.js';
import { Gossipable } from '../p2p/gossipable.js';
import { PublicExecutionRequest } from '../public_execution_request.js';
import { type TxStats } from '../stats/stats.js';
import { TxHash } from './tx_hash.js';
/**
 * The interface of an L2 transaction.
 */
export declare class Tx extends Gossipable {
    /**
     * Output of the private kernel circuit for this tx.
     */
    readonly data: PrivateKernelTailCircuitPublicInputs;
    /**
     * Proof from the private kernel circuit.
     * TODO(#7368): This client IVC object currently contains various VKs that will eventually be more like static data.
     *
     */
    readonly clientIvcProof: ClientIvcProof;
    /**
     * Encrypted note logs generated by the tx.
     */
    noteEncryptedLogs: EncryptedNoteTxL2Logs;
    /**
     * Encrypted logs generated by the tx.
     */
    encryptedLogs: EncryptedTxL2Logs;
    /**
     * Unencrypted logs generated by the tx.
     */
    unencryptedLogs: UnencryptedTxL2Logs;
    /**
     * Enqueued public functions from the private circuit to be run by the sequencer.
     */
    readonly enqueuedPublicFunctionCalls: PublicExecutionRequest[];
    /**
     * Public function call to be run by the sequencer as part of teardown.
     */
    readonly publicTeardownFunctionCall: PublicExecutionRequest;
    static p2pTopic: string;
    constructor(
    /**
     * Output of the private kernel circuit for this tx.
     */
    data: PrivateKernelTailCircuitPublicInputs, 
    /**
     * Proof from the private kernel circuit.
     * TODO(#7368): This client IVC object currently contains various VKs that will eventually be more like static data.
     *
     */
    clientIvcProof: ClientIvcProof, 
    /**
     * Encrypted note logs generated by the tx.
     */
    noteEncryptedLogs: EncryptedNoteTxL2Logs, 
    /**
     * Encrypted logs generated by the tx.
     */
    encryptedLogs: EncryptedTxL2Logs, 
    /**
     * Unencrypted logs generated by the tx.
     */
    unencryptedLogs: UnencryptedTxL2Logs, 
    /**
     * Enqueued public functions from the private circuit to be run by the sequencer.
     */
    enqueuedPublicFunctionCalls: PublicExecutionRequest[], 
    /**
     * Public function call to be run by the sequencer as part of teardown.
     */
    publicTeardownFunctionCall: PublicExecutionRequest);
    p2pMessageIdentifier(): Buffer32;
    hasPublicCalls(): boolean;
    getNonRevertiblePublicExecutionRequests(): PublicExecutionRequest[];
    getRevertiblePublicExecutionRequests(): PublicExecutionRequest[];
    getPublicTeardownExecutionRequest(): PublicExecutionRequest | undefined;
    /**
     * Deserializes the Tx object from a Buffer.
     * @param buffer - Buffer or BufferReader object to deserialize.
     * @returns An instance of Tx.
     */
    static fromBuffer(buffer: Buffer | BufferReader): Tx;
    /**
     * Serializes the Tx object into a Buffer.
     * @returns Buffer representation of the Tx object.
     */
    toBuffer(): Buffer;
    /**
     * Convert a Tx class object to a plain JSON object.
     * @returns A plain object with Tx properties.
     */
    toJSON(): {
        data: string;
        noteEncryptedLogs: string;
        encryptedLogs: string;
        unencryptedLogs: string;
        clientIvcProof: string;
        enqueuedPublicFunctions: string[];
        publicTeardownFunctionCall: string;
    };
    /**
     * Gets unencrypted logs emitted by this tx.
     * @param logsSource - An instance of `L2LogsSource` which can be used to obtain the logs.
     * @returns The requested logs.
     */
    getUnencryptedLogs(logsSource: L2LogsSource): Promise<GetUnencryptedLogsResponse>;
    /**
     * Convert a plain JSON object to a Tx class object.
     * @param obj - A plain Tx JSON object.
     * @returns A Tx class object.
     */
    static fromJSON(obj: any): Tx;
    /**
     * Construct & return transaction hash.
     * @returns The transaction's hash.
     */
    getTxHash(): TxHash;
    /** Returns stats about this tx. */
    getStats(): TxStats;
    getSize(): number;
    /**
     * Convenience function to get a hash out of a tx or a tx-like.
     * @param tx - Tx-like object.
     * @returns - The hash.
     */
    static getHash(tx: Tx | HasHash): TxHash;
    /**
     * Convenience function to get array of hashes for an array of txs.
     * @param txs - The txs to get the hashes from.
     * @returns The corresponding array of hashes.
     */
    static getHashes(txs: (Tx | HasHash)[]): TxHash[];
    /**
     * Clones a tx, making a deep copy of all fields.
     * @param tx - The transaction to be cloned.
     * @returns The cloned transaction.
     */
    static clone(tx: Tx): Tx;
    /**
     * Filters out logs from functions that are not present in the provided kernel output.
     *
     * The purpose of this is to remove logs that got dropped due to a revert,
     * in which case, we only have the kernel's hashes to go on, as opposed to
     * this grouping by function maintained in this class.
     *
     * The logic therefore is to drop all FunctionLogs if any constituent hash
     * does not appear in the provided hashes: it is impossible for part of a
     * function to revert.
     *
     * @param logHashes the individual log hashes we want to keep
     * @param out the output to put passing logs in, to keep this function abstract
     */
    filterRevertedLogs(kernelOutput: PublicKernelCircuitPublicInputs): void;
}
/** Utility type for an entity that has a hash property for a txhash */
type HasHash = {
    hash: TxHash;
};
export {};
//# sourceMappingURL=tx.d.ts.map
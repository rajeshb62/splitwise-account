import { type TxHash } from '@aztec/circuit-types';
import { Fr } from '@aztec/circuits.js';
import { type ConfigMappingsType } from '@aztec/foundation/config';
import { type EpochProver } from './epoch-prover.js';
import { type MerkleTreeReadOperations } from './merkle_tree_operations.js';
import { type ProvingJobSource } from './proving-job.js';
/**
 * The prover configuration.
 */
export type ProverConfig = {
    /** The URL to the Aztec node to take proving jobs from */
    nodeUrl?: string;
    /** Whether to construct real proofs */
    realProofs: boolean;
    /** Whether this prover has a local prover agent */
    proverAgentEnabled: boolean;
    /** The interval agents poll for jobs at */
    proverAgentPollInterval: number;
    /** The maximum number of proving jobs to be run in parallel */
    proverAgentConcurrency: number;
    /** Jobs are retried if not kept alive for this long */
    proverJobTimeoutMs: number;
    /** The interval to check job health status */
    proverJobPollIntervalMs: number;
    /** Artificial delay to introduce to all operations to the test prover. */
    proverTestDelayMs: number;
    /** Identifier of the prover */
    proverId?: Fr;
};
export declare const proverConfigMappings: ConfigMappingsType<ProverConfig>;
/**
 * The interface to the prover client.
 * Provides the ability to generate proofs and build rollups.
 */
export interface EpochProverManager {
    createEpochProver(db: MerkleTreeReadOperations): EpochProver;
    start(): Promise<void>;
    stop(): Promise<void>;
    getProvingJobSource(): ProvingJobSource;
    updateProverConfig(config: Partial<ProverConfig>): Promise<void>;
}
export declare class BlockProofError extends Error {
    #private;
    readonly txHashes: TxHash[];
    name: string;
    constructor(message: string, txHashes: TxHash[]);
    static isBlockProofError(err: any): err is BlockProofError;
}
//# sourceMappingURL=prover-client.d.ts.map
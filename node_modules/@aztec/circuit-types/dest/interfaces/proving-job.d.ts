import { type AvmCircuitInputs, type BaseOrMergeRollupPublicInputs, type BaseParityInputs, type BaseRollupInputs, type BlockMergeRollupInputs, type BlockRootOrBlockMergePublicInputs, type BlockRootRollupInputs, type EmptyBlockRootRollupInputs, type KernelCircuitPublicInputs, type MergeRollupInputs, type NESTED_RECURSIVE_PROOF_LENGTH, type PrivateKernelEmptyInputData, type Proof, type PublicKernelCircuitPrivateInputs, type PublicKernelCircuitPublicInputs, type PublicKernelInnerCircuitPrivateInputs, type PublicKernelTailCircuitPrivateInputs, type RECURSIVE_PROOF_LENGTH, type RecursiveProof, type RootParityInput, type RootParityInputs, type RootRollupInputs, type RootRollupPublicInputs, type TUBE_PROOF_LENGTH, type TubeInputs, type VMCircuitPublicInputs, type VerificationKeyData } from '@aztec/circuits.js';
import { type CircuitName } from '../stats/index.js';
export type ProofAndVerificationKey<P> = {
    proof: P;
    verificationKey: VerificationKeyData;
};
export declare function makeProofAndVerificationKey<P>(proof: P, verificationKey: VerificationKeyData): ProofAndVerificationKey<P>;
export type PublicInputsAndRecursiveProof<T, N extends number = typeof NESTED_RECURSIVE_PROOF_LENGTH> = {
    inputs: T;
    proof: RecursiveProof<N>;
    verificationKey: VerificationKeyData;
};
export declare function makePublicInputsAndRecursiveProof<T, N extends number = typeof NESTED_RECURSIVE_PROOF_LENGTH>(inputs: T, proof: RecursiveProof<N>, verificationKey: VerificationKeyData): PublicInputsAndRecursiveProof<T, N>;
export type ProvingJob<T extends ProvingRequest> = {
    id: string;
    request: T;
};
export declare enum ProvingRequestType {
    PRIVATE_KERNEL_EMPTY = 0,
    PUBLIC_VM = 1,
    PUBLIC_KERNEL_INNER = 2,
    PUBLIC_KERNEL_MERGE = 3,
    PUBLIC_KERNEL_TAIL = 4,
    BASE_ROLLUP = 5,
    MERGE_ROLLUP = 6,
    EMPTY_BLOCK_ROOT_ROLLUP = 7,
    BLOCK_ROOT_ROLLUP = 8,
    BLOCK_MERGE_ROLLUP = 9,
    ROOT_ROLLUP = 10,
    BASE_PARITY = 11,
    ROOT_PARITY = 12,
    TUBE_PROOF = 13
}
export declare function mapProvingRequestTypeToCircuitName(type: ProvingRequestType): CircuitName;
export type PublicKernelInnerRequest = {
    type: ProvingRequestType.PUBLIC_KERNEL_INNER;
    inputs: PublicKernelInnerCircuitPrivateInputs;
};
export type PublicKernelMergeRequest = {
    type: ProvingRequestType.PUBLIC_KERNEL_MERGE;
    inputs: PublicKernelCircuitPrivateInputs;
};
export type PublicKernelTailRequest = {
    type: ProvingRequestType.PUBLIC_KERNEL_TAIL;
    inputs: PublicKernelTailCircuitPrivateInputs;
};
export type ProvingRequest = {
    type: ProvingRequestType.PUBLIC_VM;
    inputs: AvmCircuitInputs;
} | PublicKernelInnerRequest | PublicKernelMergeRequest | PublicKernelTailRequest | {
    type: ProvingRequestType.BASE_PARITY;
    inputs: BaseParityInputs;
} | {
    type: ProvingRequestType.ROOT_PARITY;
    inputs: RootParityInputs;
} | {
    type: ProvingRequestType.BASE_ROLLUP;
    inputs: BaseRollupInputs;
} | {
    type: ProvingRequestType.MERGE_ROLLUP;
    inputs: MergeRollupInputs;
} | {
    type: ProvingRequestType.BLOCK_ROOT_ROLLUP;
    inputs: BlockRootRollupInputs;
} | {
    type: ProvingRequestType.EMPTY_BLOCK_ROOT_ROLLUP;
    inputs: EmptyBlockRootRollupInputs;
} | {
    type: ProvingRequestType.BLOCK_MERGE_ROLLUP;
    inputs: BlockMergeRollupInputs;
} | {
    type: ProvingRequestType.ROOT_ROLLUP;
    inputs: RootRollupInputs;
} | {
    type: ProvingRequestType.PRIVATE_KERNEL_EMPTY;
    inputs: PrivateKernelEmptyInputData;
} | {
    type: ProvingRequestType.TUBE_PROOF;
    inputs: TubeInputs;
};
export type ProvingRequestPublicInputs = {
    [ProvingRequestType.PRIVATE_KERNEL_EMPTY]: PublicInputsAndRecursiveProof<KernelCircuitPublicInputs>;
    [ProvingRequestType.PUBLIC_VM]: ProofAndVerificationKey<Proof>;
    [ProvingRequestType.PUBLIC_KERNEL_INNER]: PublicInputsAndRecursiveProof<VMCircuitPublicInputs>;
    [ProvingRequestType.PUBLIC_KERNEL_MERGE]: PublicInputsAndRecursiveProof<PublicKernelCircuitPublicInputs>;
    [ProvingRequestType.PUBLIC_KERNEL_TAIL]: PublicInputsAndRecursiveProof<KernelCircuitPublicInputs>;
    [ProvingRequestType.BASE_ROLLUP]: PublicInputsAndRecursiveProof<BaseOrMergeRollupPublicInputs>;
    [ProvingRequestType.MERGE_ROLLUP]: PublicInputsAndRecursiveProof<BaseOrMergeRollupPublicInputs>;
    [ProvingRequestType.EMPTY_BLOCK_ROOT_ROLLUP]: PublicInputsAndRecursiveProof<BlockRootOrBlockMergePublicInputs>;
    [ProvingRequestType.BLOCK_ROOT_ROLLUP]: PublicInputsAndRecursiveProof<BlockRootOrBlockMergePublicInputs>;
    [ProvingRequestType.BLOCK_MERGE_ROLLUP]: PublicInputsAndRecursiveProof<BlockRootOrBlockMergePublicInputs>;
    [ProvingRequestType.ROOT_ROLLUP]: PublicInputsAndRecursiveProof<RootRollupPublicInputs>;
    [ProvingRequestType.BASE_PARITY]: RootParityInput<typeof RECURSIVE_PROOF_LENGTH>;
    [ProvingRequestType.ROOT_PARITY]: RootParityInput<typeof NESTED_RECURSIVE_PROOF_LENGTH>;
    [ProvingRequestType.TUBE_PROOF]: ProofAndVerificationKey<RecursiveProof<typeof TUBE_PROOF_LENGTH>>;
};
export type ProvingRequestResult<T extends ProvingRequestType> = ProvingRequestPublicInputs[T];
export interface ProvingJobSource {
    /**
     * Gets the next proving job. `heartbeat` must be called periodically to keep the job alive.
     * @returns The proving job, or undefined if there are no jobs available.
     */
    getProvingJob(): Promise<ProvingJob<ProvingRequest> | undefined>;
    /**
     * Keeps the job alive. If this isn't called regularly then the job will be
     * considered abandoned and re-queued for another consumer to pick up
     * @param jobId The ID of the job to heartbeat.
     */
    heartbeat(jobId: string): Promise<void>;
    /**
     * Resolves a proving job.
     * @param jobId - The ID of the job to resolve.
     * @param result - The result of the proving job.
     */
    resolveProvingJob<T extends ProvingRequestType>(jobId: string, result: ProvingRequestResult<T>): Promise<void>;
    /**
     * Rejects a proving job.
     * @param jobId - The ID of the job to reject.
     * @param reason - The reason for rejecting the job.
     */
    rejectProvingJob(jobId: string, reason: Error): Promise<void>;
}
//# sourceMappingURL=proving-job.d.ts.map
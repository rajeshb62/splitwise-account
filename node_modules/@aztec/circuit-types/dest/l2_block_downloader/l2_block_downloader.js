import { INITIAL_L2_BLOCK_NUM } from '@aztec/circuits.js/constants';
import { createDebugLogger } from '@aztec/foundation/log';
import { FifoMemoryQueue, Semaphore, SerialQueue } from '@aztec/foundation/queue';
import { InterruptibleSleep } from '@aztec/foundation/sleep';
const log = createDebugLogger('aztec:l2_block_downloader');
/**
 * Downloads L2 blocks from a L2BlockSource.
 * The blocks are stored in a queue and can be retrieved using the getBlocks method.
 * The queue size is limited by the maxQueueSize parameter.
 * The downloader will pause when the queue is full or when the L2BlockSource is out of blocks.
 */
export class L2BlockDownloader {
    constructor(l2BlockSource, opts) {
        this.l2BlockSource = l2BlockSource;
        this.running = false;
        this.from = 0;
        this.interruptibleSleep = new InterruptibleSleep();
        this.jobQueue = new SerialQueue();
        this.blockQueue = new FifoMemoryQueue();
        this.pollIntervalMS = opts.pollIntervalMS ?? 1000;
        this.proven = opts.proven ?? false;
        this.semaphore = new Semaphore(opts.maxQueueSize);
    }
    /**
     * Starts the downloader.
     * @param from - The block number to start downloading from. Defaults to INITIAL_L2_BLOCK_NUM.
     */
    start(from = INITIAL_L2_BLOCK_NUM) {
        if (this.running) {
            this.interruptibleSleep.interrupt();
            return;
        }
        this.from = from;
        this.running = true;
        const fn = async () => {
            while (this.running) {
                try {
                    await this.jobQueue.put(() => this.collectBlocks());
                    await this.interruptibleSleep.sleep(this.pollIntervalMS);
                }
                catch (err) {
                    log.error(`Error downloading L2 block`, err);
                    await this.interruptibleSleep.sleep(this.pollIntervalMS);
                }
            }
        };
        this.jobQueue.start();
        this.runningPromise = fn();
    }
    /**
     * Repeatedly queries the block source and adds the received blocks to the block queue.
     * Stops when no further blocks are received.
     * @param targetBlockNumber - Optional block number to stop at.
     * @param proven - Optional override of the default "proven" setting.
     * @returns The total number of blocks added to the block queue.
     */
    async collectBlocks(targetBlockNumber, onlyProven) {
        let totalBlocks = 0;
        while (true) {
            // If we have a target and have reached it, return
            if (targetBlockNumber !== undefined && this.from > targetBlockNumber) {
                log.verbose(`Reached target block number ${targetBlockNumber}`);
                return totalBlocks;
            }
            // If we have a target, then request at most the number of blocks to get to it
            const limit = targetBlockNumber !== undefined ? Math.min(targetBlockNumber - this.from + 1, 10) : 10;
            const proven = onlyProven === undefined ? this.proven : onlyProven;
            // Hit the archiver for blocks
            const blocks = await this.l2BlockSource.getBlocks(this.from, limit, proven);
            // If there are no more blocks, return
            if (!blocks.length) {
                return totalBlocks;
            }
            log.verbose(`Received ${blocks.length} blocks from archiver after querying from ${this.from} limit ${limit} (proven ${proven})`);
            // Push new blocks into the queue and loop
            await this.semaphore.acquire();
            this.blockQueue.put(blocks);
            this.from += blocks.length;
            totalBlocks += blocks.length;
        }
    }
    /**
     * Stops the downloader.
     */
    async stop() {
        this.running = false;
        this.interruptibleSleep.interrupt();
        await this.jobQueue.cancel();
        this.blockQueue.cancel();
        await this.runningPromise;
    }
    /**
     * Gets the next batch of blocks from the queue.
     * @param timeout - optional timeout value to prevent permanent blocking
     * @returns The next batch of blocks from the queue.
     */
    async getBlocks(timeout) {
        try {
            const blocks = await this.blockQueue.get(timeout);
            if (!blocks) {
                return [];
            }
            this.semaphore.release();
            return blocks;
        }
        catch (err) {
            // nothing to do
            return [];
        }
    }
    /**
     * Forces an immediate request for blocks.
     * Repeatedly queries the block source and adds the received blocks to the block queue.
     * Stops when no further blocks are received.
     * @param targetBlockNumber - Optional block number to stop at.
     * @param proven - Optional override of the default "proven" setting.
     * @returns A promise that fulfills once the poll is complete
     */
    pollImmediate(targetBlockNumber, onlyProven) {
        return this.jobQueue.put(() => this.collectBlocks(targetBlockNumber, onlyProven));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibDJfYmxvY2tfZG93bmxvYWRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sMl9ibG9ja19kb3dubG9hZGVyL2wyX2Jsb2NrX2Rvd25sb2FkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDcEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDbEYsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFLN0QsTUFBTSxHQUFHLEdBQUcsaUJBQWlCLENBQUMsMkJBQTJCLENBQUMsQ0FBQztBQUUzRDs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyxpQkFBaUI7SUFXNUIsWUFDVSxhQUE0QixFQUNwQyxJQUlDO1FBTE8sa0JBQWEsR0FBYixhQUFhLENBQWU7UUFWOUIsWUFBTyxHQUFHLEtBQUssQ0FBQztRQUNoQixTQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ1QsdUJBQWtCLEdBQUcsSUFBSSxrQkFBa0IsRUFBRSxDQUFDO1FBRXJDLGFBQVEsR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDO1FBQzdCLGVBQVUsR0FBRyxJQUFJLGVBQWUsRUFBYSxDQUFDO1FBWTdELElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsSUFBSSxJQUFJLENBQUM7UUFDbEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQztRQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksS0FBSyxDQUFDLElBQUksR0FBRyxvQkFBb0I7UUFDdEMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDakIsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3BDLE9BQU87UUFDVCxDQUFDO1FBQ0QsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFFcEIsTUFBTSxFQUFFLEdBQUcsS0FBSyxJQUFJLEVBQUU7WUFDcEIsT0FBTyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ3BCLElBQUksQ0FBQztvQkFDSCxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO29CQUNwRCxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUMzRCxDQUFDO2dCQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7b0JBQ2IsR0FBRyxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFDN0MsTUFBTSxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDM0QsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDLENBQUM7UUFDRixJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLEtBQUssQ0FBQyxhQUFhLENBQUMsaUJBQTBCLEVBQUUsVUFBb0I7UUFDMUUsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLE9BQU8sSUFBSSxFQUFFLENBQUM7WUFDWixrREFBa0Q7WUFDbEQsSUFBSSxpQkFBaUIsS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksR0FBRyxpQkFBaUIsRUFBRSxDQUFDO2dCQUNyRSxHQUFHLENBQUMsT0FBTyxDQUFDLCtCQUErQixpQkFBaUIsRUFBRSxDQUFDLENBQUM7Z0JBQ2hFLE9BQU8sV0FBVyxDQUFDO1lBQ3JCLENBQUM7WUFFRCw4RUFBOEU7WUFDOUUsTUFBTSxLQUFLLEdBQUcsaUJBQWlCLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDckcsTUFBTSxNQUFNLEdBQUcsVUFBVSxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO1lBRW5FLDhCQUE4QjtZQUM5QixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBRTVFLHNDQUFzQztZQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNuQixPQUFPLFdBQVcsQ0FBQztZQUNyQixDQUFDO1lBRUQsR0FBRyxDQUFDLE9BQU8sQ0FDVCxZQUFZLE1BQU0sQ0FBQyxNQUFNLDZDQUE2QyxJQUFJLENBQUMsSUFBSSxVQUFVLEtBQUssWUFBWSxNQUFNLEdBQUcsQ0FDcEgsQ0FBQztZQUVGLDBDQUEwQztZQUMxQyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDO1lBQzNCLFdBQVcsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQy9CLENBQUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsSUFBSTtRQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNwQyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDN0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUN6QixNQUFNLElBQUksQ0FBQyxjQUFjLENBQUM7SUFDNUIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxLQUFLLENBQUMsU0FBUyxDQUFDLE9BQWdCO1FBQ3JDLElBQUksQ0FBQztZQUNILE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNaLE9BQU8sRUFBRSxDQUFDO1lBQ1osQ0FBQztZQUNELElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDekIsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFDYixnQkFBZ0I7WUFDaEIsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxhQUFhLENBQUMsaUJBQTBCLEVBQUUsVUFBb0I7UUFDbkUsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFDcEYsQ0FBQztDQUNGIn0=
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { EncryptedFunctionL2Logs, EncryptedL2Log, EncryptedL2NoteLog, EncryptedNoteFunctionL2Logs, Note, PublicExecutionRequest, UnencryptedFunctionL2Logs, UnencryptedL2Log } from '@aztec/circuit-types';
import { type IsEmpty, PrivateCircuitPublicInputs } from '@aztec/circuits.js';
import { NoteSelector } from '@aztec/foundation/abi';
import { Fr } from '@aztec/foundation/fields';
/**
 * The contents of a new note.
 */
export declare class NoteAndSlot {
    /** The note. */
    note: Note;
    /** The storage slot of the note. */
    storageSlot: Fr;
    /** The note type identifier. */
    noteTypeId: NoteSelector;
    constructor(
    /** The note. */
    note: Note, 
    /** The storage slot of the note. */
    storageSlot: Fr, 
    /** The note type identifier. */
    noteTypeId: NoteSelector);
    toJSON(): {
        note: string;
        storageSlot: string;
        noteTypeId: string;
    };
    static fromJSON(json: any): NoteAndSlot;
}
export declare class CountedLog<TLog extends UnencryptedL2Log | EncryptedL2NoteLog | EncryptedL2Log> implements IsEmpty {
    log: TLog;
    counter: number;
    constructor(log: TLog, counter: number);
    isEmpty(): boolean;
}
export declare class CountedNoteLog extends CountedLog<EncryptedL2NoteLog> {
    noteHashCounter: number;
    constructor(log: EncryptedL2NoteLog, counter: number, noteHashCounter: number);
    toJSON(): {
        log: object;
        counter: number;
        noteHashCounter: number;
    };
    static fromJSON(json: any): CountedNoteLog;
}
export declare class CountedPublicExecutionRequest {
    request: PublicExecutionRequest;
    counter: number;
    constructor(request: PublicExecutionRequest, counter: number);
    isEmpty(): boolean;
    toJSON(): {
        request: string;
        counter: number;
    };
    static fromJSON(json: any): CountedPublicExecutionRequest;
}
/**
 * The result of executing a private function.
 */
export declare class PrivateExecutionResult {
    /** The ACIR bytecode. */
    acir: Buffer;
    /** The verification key. */
    vk: Buffer;
    /** The partial witness. */
    partialWitness: Map<number, string>;
    /** The call stack item. */
    publicInputs: PrivateCircuitPublicInputs;
    /** Mapping of note hash to its index in the note hash tree. Used for building hints for note hash read requests. */
    noteHashLeafIndexMap: Map<bigint, bigint>;
    /** The notes created in the executed function. */
    newNotes: NoteAndSlot[];
    /** Mapping of note hash counter to the counter of its nullifier. */
    noteHashNullifierCounterMap: Map<number, number>;
    /** The raw return values of the executed function. */
    returnValues: Fr[];
    /** The nested executions. */
    nestedExecutions: PrivateExecutionResult[];
    /** Enqueued public function execution requests to be picked up by the sequencer. */
    enqueuedPublicFunctionCalls: CountedPublicExecutionRequest[];
    /** Public function execution requested for teardown */
    publicTeardownFunctionCall: PublicExecutionRequest;
    /**
     * Encrypted note logs emitted during execution of this function call.
     * Note: These are preimages to `noteEncryptedLogsHashes`.
     */
    noteEncryptedLogs: CountedNoteLog[];
    /**
     * Encrypted logs emitted during execution of this function call.
     * Note: These are preimages to `encryptedLogsHashes`.
     */
    encryptedLogs: CountedLog<EncryptedL2Log>[];
    /**
     * Unencrypted logs emitted during execution of this function call.
     * Note: These are preimages to `unencryptedLogsHashes`.
     */
    unencryptedLogs: CountedLog<UnencryptedL2Log>[];
    constructor(
    /** The ACIR bytecode. */
    acir: Buffer, 
    /** The verification key. */
    vk: Buffer, 
    /** The partial witness. */
    partialWitness: Map<number, string>, 
    /** The call stack item. */
    publicInputs: PrivateCircuitPublicInputs, 
    /** Mapping of note hash to its index in the note hash tree. Used for building hints for note hash read requests. */
    noteHashLeafIndexMap: Map<bigint, bigint>, 
    /** The notes created in the executed function. */
    newNotes: NoteAndSlot[], 
    /** Mapping of note hash counter to the counter of its nullifier. */
    noteHashNullifierCounterMap: Map<number, number>, 
    /** The raw return values of the executed function. */
    returnValues: Fr[], 
    /** The nested executions. */
    nestedExecutions: PrivateExecutionResult[], 
    /** Enqueued public function execution requests to be picked up by the sequencer. */
    enqueuedPublicFunctionCalls: CountedPublicExecutionRequest[], 
    /** Public function execution requested for teardown */
    publicTeardownFunctionCall: PublicExecutionRequest, 
    /**
     * Encrypted note logs emitted during execution of this function call.
     * Note: These are preimages to `noteEncryptedLogsHashes`.
     */
    noteEncryptedLogs: CountedNoteLog[], 
    /**
     * Encrypted logs emitted during execution of this function call.
     * Note: These are preimages to `encryptedLogsHashes`.
     */
    encryptedLogs: CountedLog<EncryptedL2Log>[], 
    /**
     * Unencrypted logs emitted during execution of this function call.
     * Note: These are preimages to `unencryptedLogsHashes`.
     */
    unencryptedLogs: CountedLog<UnencryptedL2Log>[]);
    toJSON(): any;
    static fromJSON(json: any): PrivateExecutionResult;
}
export declare function collectNoteHashLeafIndexMap(execResult: PrivateExecutionResult, accum?: Map<bigint, bigint>): Map<bigint, bigint>;
export declare function collectNoteHashNullifierCounterMap(execResult: PrivateExecutionResult, accum?: Map<number, number>): Map<number, number>;
/**
 * Collect all encrypted logs across all nested executions and sorts by counter.
 * @param execResult - The topmost execution result.
 * @returns All encrypted logs.
 */
export declare function collectSortedNoteEncryptedLogs(execResult: PrivateExecutionResult): EncryptedNoteFunctionL2Logs;
/**
 * Collect all encrypted logs across all nested executions and sorts by counter.
 * @param execResult - The topmost execution result.
 * @returns All encrypted logs.
 */
export declare function collectSortedEncryptedLogs(execResult: PrivateExecutionResult): EncryptedFunctionL2Logs;
/**
 * Collect all unencrypted logs across all nested executions and sorts by counter.
 * @param execResult - The topmost execution result.
 * @returns All unencrypted logs.
 */
export declare function collectSortedUnencryptedLogs(execResult: PrivateExecutionResult): UnencryptedFunctionL2Logs;
/**
 * Collect all enqueued public function calls across all nested executions.
 * @param execResult - The topmost execution result.
 * @returns All enqueued public function calls.
 */
export declare function collectEnqueuedPublicFunctionCalls(execResult: PrivateExecutionResult): PublicExecutionRequest[];
export declare function collectPublicTeardownFunctionCall(execResult: PrivateExecutionResult): PublicExecutionRequest;
export declare function getFinalMinRevertibleSideEffectCounter(execResult: PrivateExecutionResult): number;
export declare function collectNested<T>(executionStack: PrivateExecutionResult[], extractExecutionItems: (execution: PrivateExecutionResult) => T[]): T[];
//# sourceMappingURL=private_execution_result.d.ts.map
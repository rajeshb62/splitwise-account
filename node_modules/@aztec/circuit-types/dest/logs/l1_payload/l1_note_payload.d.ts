/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { AztecAddress } from '@aztec/circuits.js';
import { NoteSelector } from '@aztec/foundation/abi';
import { type Fq, Fr } from '@aztec/foundation/fields';
import { type EncryptedL2NoteLog } from '../encrypted_l2_note_log.js';
import { Note } from './payload.js';
/**
 * A class which wraps note data which is pushed on L1.
 * @remarks This data is required to compute a nullifier/to spend a note. Along with that this class contains
 * the necessary functionality to encrypt and decrypt the data.
 */
export declare class L1NotePayload {
    /**
     * A note as emitted from Noir contract. Can be used along with private key to compute nullifier.
     */
    note: Note;
    /**
     * Address of the contract this tx is interacting with.
     */
    contractAddress: AztecAddress;
    /**
     * Storage slot of the underlying note.
     */
    storageSlot: Fr;
    /**
     * Type identifier for the underlying note, required to determine how to compute its hash and nullifier.
     */
    noteTypeId: NoteSelector;
    constructor(
    /**
     * A note as emitted from Noir contract. Can be used along with private key to compute nullifier.
     */
    note: Note, 
    /**
     * Address of the contract this tx is interacting with.
     */
    contractAddress: AztecAddress, 
    /**
     * Storage slot of the underlying note.
     */
    storageSlot: Fr, 
    /**
     * Type identifier for the underlying note, required to determine how to compute its hash and nullifier.
     */
    noteTypeId: NoteSelector);
    static fromIncomingBodyPlaintextAndContractAddress(plaintext: Buffer, contractAddress: AztecAddress): L1NotePayload | undefined;
    static decryptAsIncoming(log: EncryptedL2NoteLog, sk: Fq): L1NotePayload | undefined;
    static decryptAsOutgoing(log: EncryptedL2NoteLog, sk: Fq): L1NotePayload | undefined;
    /**
     * Serializes the L1NotePayload object into a Buffer.
     * @returns Buffer representation of the L1NotePayload object.
     */
    toIncomingBodyPlaintext(): Buffer;
    /**
     * Create a random L1NotePayload object (useful for testing purposes).
     * @param contract - The address of a contract the note was emitted from.
     * @returns A random L1NotePayload object.
     */
    static random(contract?: AztecAddress): L1NotePayload;
    equals(other: L1NotePayload): boolean;
}
//# sourceMappingURL=l1_note_payload.d.ts.map
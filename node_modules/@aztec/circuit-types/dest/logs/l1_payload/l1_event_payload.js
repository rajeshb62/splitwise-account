var _a, _L1EventPayload_fromIncomingBodyPlaintextAndContractAddress;
import { __classPrivateFieldGet } from "tslib";
import { AztecAddress } from '@aztec/circuits.js';
import { EventSelector } from '@aztec/foundation/abi';
import { poseidon2HashWithSeparator } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { EncryptedLogPayload } from './encrypted_log_payload.js';
import { Event } from './payload.js';
/**
 * A class which wraps event data which is pushed on L1.
 */
export class L1EventPayload {
    constructor(
    /**
     * A event as emitted from Noir contract. Can be used along with private key to compute nullifier.
     */
    event, 
    /**
     * Address of the contract this tx is interacting with.
     */
    contractAddress, 
    /**
     * Randomness used to mask the contract address.
     */
    randomness, 
    /**
     * Type identifier for the underlying event, required to determine how to compute its hash and nullifier.
     */
    eventTypeId) {
        this.event = event;
        this.contractAddress = contractAddress;
        this.randomness = randomness;
        this.eventTypeId = eventTypeId;
    }
    static decryptAsIncoming(log, sk) {
        const decryptedLog = EncryptedLogPayload.decryptAsIncoming(log.data, sk);
        if (!decryptedLog) {
            return undefined;
        }
        return __classPrivateFieldGet(this, _a, "m", _L1EventPayload_fromIncomingBodyPlaintextAndContractAddress).call(this, decryptedLog.incomingBodyPlaintext, decryptedLog.contractAddress, log.maskedContractAddress);
    }
    static decryptAsOutgoing(log, sk) {
        const decryptedLog = EncryptedLogPayload.decryptAsOutgoing(log.data, sk);
        if (!decryptedLog) {
            return undefined;
        }
        return __classPrivateFieldGet(this, _a, "m", _L1EventPayload_fromIncomingBodyPlaintextAndContractAddress).call(this, decryptedLog.incomingBodyPlaintext, decryptedLog.contractAddress, log.maskedContractAddress);
    }
    /**
     * Serializes the L1EventPayload object into a Buffer.
     * @returns Buffer representation of the L1EventPayload object.
     */
    toIncomingBodyPlaintext() {
        const fields = [this.randomness, this.eventTypeId.toField(), ...this.event.items];
        return serializeToBuffer(fields);
    }
    /**
     * Create a random L1EventPayload object (useful for testing purposes).
     * @param contract - The address of a contract the event was emitted from.
     * @returns A random L1EventPayload object.
     */
    static random(contract = AztecAddress.random()) {
        return new _a(Event.random(), contract, Fr.random(), EventSelector.random());
    }
    equals(other) {
        return (this.event.equals(other.event) &&
            this.contractAddress.equals(other.contractAddress) &&
            this.randomness.equals(other.randomness) &&
            this.eventTypeId.equals(other.eventTypeId));
    }
}
_a = L1EventPayload, _L1EventPayload_fromIncomingBodyPlaintextAndContractAddress = function _L1EventPayload_fromIncomingBodyPlaintextAndContractAddress(plaintext, contractAddress, maskedContractAddress) {
    let payload;
    try {
        const reader = BufferReader.asReader(plaintext);
        const fields = reader.readArray(plaintext.length / Fr.SIZE_IN_BYTES, Fr);
        const randomness = fields[0];
        const eventTypeId = EventSelector.fromField(fields[1]);
        const event = new Event(fields.slice(2));
        payload = new _a(event, contractAddress, randomness, eventTypeId);
    }
    catch (e) {
        return undefined;
    }
    ensureMatchedMaskedContractAddress(contractAddress, payload.randomness, maskedContractAddress);
    return payload;
};
function ensureMatchedMaskedContractAddress(contractAddress, randomness, maskedContractAddress) {
    if (!poseidon2HashWithSeparator([contractAddress, randomness], 0).equals(maskedContractAddress)) {
        throw new Error('The provided masked contract address does not match with the incoming address from header and randomness from body');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibDFfZXZlbnRfcGF5bG9hZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9sb2dzL2wxX3BheWxvYWQvbDFfZXZlbnRfcGF5bG9hZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdEQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDdEUsT0FBTyxFQUFXLEVBQUUsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxZQUFZLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUc5RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNqRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRXJDOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGNBQWM7SUFDekI7SUFDRTs7T0FFRztJQUNJLEtBQVk7SUFDbkI7O09BRUc7SUFDSSxlQUE2QjtJQUNwQzs7T0FFRztJQUNJLFVBQWM7SUFDckI7O09BRUc7SUFDSSxXQUEwQjtRQVoxQixVQUFLLEdBQUwsS0FBSyxDQUFPO1FBSVosb0JBQWUsR0FBZixlQUFlLENBQWM7UUFJN0IsZUFBVSxHQUFWLFVBQVUsQ0FBSTtRQUlkLGdCQUFXLEdBQVgsV0FBVyxDQUFlO0lBQ2hDLENBQUM7SUEyQkosTUFBTSxDQUFDLGlCQUFpQixDQUFDLEdBQW1CLEVBQUUsRUFBTTtRQUNsRCxNQUFNLFlBQVksR0FBRyxtQkFBbUIsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3pFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUNsQixPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO1FBRUQsT0FBTyx1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
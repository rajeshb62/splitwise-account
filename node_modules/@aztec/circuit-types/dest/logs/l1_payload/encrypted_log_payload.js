import { AztecAddress, Fr, GrumpkinScalar, NotOnCurveError, Point, computeOvskApp, derivePublicKeyFromSecretKey, } from '@aztec/circuits.js';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { decrypt, encrypt } from './encryption_util.js';
import { derivePoseidonAESSecret } from './shared_secret_derivation.js';
// Both the incoming and the outgoing header are 48 bytes../shared_secret_derivation.js
// 32 bytes for the address, and 16 bytes padding to follow PKCS#7
const HEADER_SIZE = 48;
// The outgoing body is constant size of 144 bytes.
// 128 bytes for the secret key, address and public key, and 16 bytes padding to follow PKCS#7
const OUTGOING_BODY_SIZE = 144;
/**
 * Encrypted log payload with a tag used for retrieval by clients.
 */
export class EncryptedLogPayload {
    constructor(incomingTag, outgoingTag, contractAddress, incomingBodyPlaintext) {
        this.incomingTag = incomingTag;
        this.outgoingTag = outgoingTag;
        this.contractAddress = contractAddress;
        this.incomingBodyPlaintext = incomingBodyPlaintext;
    }
    encrypt(ephSk, recipient, ivpk, ovKeys) {
        if (ivpk.isZero()) {
            throw new Error(`Attempting to encrypt an event log with a zero ivpk.`);
        }
        const ephPk = derivePublicKeyFromSecretKey(ephSk);
        const incomingHeaderCiphertext = encrypt(this.contractAddress.toBuffer(), ephSk, ivpk);
        const outgoingHeaderCiphertext = encrypt(this.contractAddress.toBuffer(), ephSk, ovKeys.pkM);
        if (incomingHeaderCiphertext.length !== HEADER_SIZE) {
            throw new Error(`Invalid incoming header size: ${incomingHeaderCiphertext.length}`);
        }
        if (outgoingHeaderCiphertext.length !== HEADER_SIZE) {
            throw new Error(`Invalid outgoing header size: ${outgoingHeaderCiphertext.length}`);
        }
        const incomingBodyCiphertext = encrypt(this.incomingBodyPlaintext, ephSk, ivpk);
        // The serialization of Fq is [high, low] check `outgoing_body.nr`
        const outgoingBodyPlaintext = serializeToBuffer(ephSk.hi, ephSk.lo, recipient, ivpk.toCompressedBuffer());
        const outgoingBodyCiphertext = encrypt(outgoingBodyPlaintext, ovKeys.skAppAsGrumpkinScalar, ephPk, derivePoseidonAESSecret);
        if (outgoingBodyCiphertext.length !== OUTGOING_BODY_SIZE) {
            throw new Error(`Invalid outgoing body size: ${outgoingBodyCiphertext.length}`);
        }
        return serializeToBuffer(this.incomingTag, this.outgoingTag, ephPk.toCompressedBuffer(), incomingHeaderCiphertext, outgoingHeaderCiphertext, outgoingBodyCiphertext, incomingBodyCiphertext);
    }
    /**
     * Decrypts a ciphertext as an incoming log.
     *
     * This is executable by the recipient of the note, and uses the ivsk to decrypt the payload.
     * The outgoing parts of the log are ignored entirely.
     *
     * Produces the same output as `decryptAsOutgoing`.
     *
     * @param ciphertext - The ciphertext for the log
     * @param ivsk - The incoming viewing secret key, used to decrypt the logs
     * @returns The decrypted log payload
     */
    static decryptAsIncoming(ciphertext, ivsk) {
        const reader = BufferReader.asReader(ciphertext);
        try {
            const incomingTag = reader.readObject(Fr);
            const outgoingTag = reader.readObject(Fr);
            const ephPk = Point.fromCompressedBuffer(reader.readBytes(Point.COMPRESSED_SIZE_IN_BYTES));
            const incomingHeader = decrypt(reader.readBytes(HEADER_SIZE), ivsk, ephPk);
            // Skipping the outgoing header and body
            reader.readBytes(HEADER_SIZE);
            reader.readBytes(OUTGOING_BODY_SIZE);
            // The incoming can be of variable size, so we read until the end
            const incomingBodyPlaintext = decrypt(reader.readToEnd(), ivsk, ephPk);
            return new EncryptedLogPayload(incomingTag, outgoingTag, AztecAddress.fromBuffer(incomingHeader), incomingBodyPlaintext);
        }
        catch (e) {
            // Following error messages are expected to occur when decryption fails
            if (!(e instanceof NotOnCurveError) &&
                !e.message.endsWith('is greater or equal to field modulus.') &&
                !e.message.startsWith('Invalid AztecAddress length') &&
                !e.message.startsWith('Selector must fit in') &&
                !e.message.startsWith('Attempted to read beyond buffer length')) {
                // If we encounter an unexpected error, we rethrow it
                throw e;
            }
            return;
        }
    }
    /**
     * Decrypts a ciphertext as an outgoing log.
     *
     * This is executable by the sender of the event, and uses the ovsk to decrypt the payload.
     * The outgoing parts are decrypted to retrieve information that allows the sender to
     * decrypt the incoming log, and learn about the event contents.
     *
     * Produces the same output as `decryptAsIncoming`.
     *
     * @param ciphertext - The ciphertext for the log
     * @param ovsk - The outgoing viewing secret key, used to decrypt the logs
     * @returns The decrypted log payload
     */
    static decryptAsOutgoing(ciphertext, ovsk) {
        const reader = BufferReader.asReader(ciphertext);
        try {
            const incomingTag = reader.readObject(Fr);
            const outgoingTag = reader.readObject(Fr);
            const ephPk = Point.fromCompressedBuffer(reader.readBytes(Point.COMPRESSED_SIZE_IN_BYTES));
            // We skip the incoming header
            reader.readBytes(HEADER_SIZE);
            const outgoingHeader = decrypt(reader.readBytes(HEADER_SIZE), ovsk, ephPk);
            const contractAddress = AztecAddress.fromBuffer(outgoingHeader);
            const ovskApp = computeOvskApp(ovsk, contractAddress);
            let ephSk;
            let recipientIvpk;
            {
                const outgoingBody = decrypt(reader.readBytes(OUTGOING_BODY_SIZE), ovskApp, ephPk, derivePoseidonAESSecret);
                const obReader = BufferReader.asReader(outgoingBody);
                // From outgoing body we extract ephSk, recipient and recipientIvpk
                ephSk = GrumpkinScalar.fromHighLow(obReader.readObject(Fr), obReader.readObject(Fr));
                const _recipient = obReader.readObject(AztecAddress);
                recipientIvpk = Point.fromCompressedBuffer(obReader.readBytes(Point.COMPRESSED_SIZE_IN_BYTES));
            }
            // Now we decrypt the incoming body using the ephSk and recipientIvpk
            const incomingBody = decrypt(reader.readToEnd(), ephSk, recipientIvpk);
            return new EncryptedLogPayload(incomingTag, outgoingTag, contractAddress, incomingBody);
        }
        catch (e) {
            // Following error messages are expected to occur when decryption fails
            if (!(e instanceof NotOnCurveError) &&
                !e.message.endsWith('is greater or equal to field modulus.') &&
                !e.message.startsWith('Invalid AztecAddress length') &&
                !e.message.startsWith('Selector must fit in') &&
                !e.message.startsWith('Attempted to read beyond buffer length')) {
                // If we encounter an unexpected error, we rethrow it
                throw e;
            }
            return;
        }
    }
    toBuffer() {
        return serializeToBuffer(this.incomingTag, this.outgoingTag, this.contractAddress.toBuffer(), this.incomingBodyPlaintext);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jcnlwdGVkX2xvZ19wYXlsb2FkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xvZ3MvbDFfcGF5bG9hZC9lbmNyeXB0ZWRfbG9nX3BheWxvYWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFlBQVksRUFDWixFQUFFLEVBQ0YsY0FBYyxFQUVkLGVBQWUsRUFDZixLQUFLLEVBRUwsY0FBYyxFQUNkLDRCQUE0QixHQUM3QixNQUFNLG9CQUFvQixDQUFDO0FBQzVCLE9BQU8sRUFBRSxZQUFZLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUU5RSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3hELE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBRXhFLHVGQUF1RjtBQUN2RixrRUFBa0U7QUFDbEUsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBRXZCLG1EQUFtRDtBQUNuRCw4RkFBOEY7QUFDOUYsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sbUJBQW1CO0lBQzlCLFlBQ2tCLFdBQWUsRUFDZixXQUFlLEVBQ2YsZUFBNkIsRUFDN0IscUJBQTZCO1FBSDdCLGdCQUFXLEdBQVgsV0FBVyxDQUFJO1FBQ2YsZ0JBQVcsR0FBWCxXQUFXLENBQUk7UUFDZixvQkFBZSxHQUFmLGVBQWUsQ0FBYztRQUM3QiwwQkFBcUIsR0FBckIscUJBQXFCLENBQVE7SUFDNUMsQ0FBQztJQUVHLE9BQU8sQ0FDWixLQUFxQixFQUNyQixTQUF1QixFQUN2QixJQUFlLEVBQ2YsTUFBNEI7UUFFNUIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQztZQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7UUFDMUUsQ0FBQztRQUVELE1BQU0sS0FBSyxH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
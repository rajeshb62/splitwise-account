import { Fr, MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX, MAX_UNENCRYPTED_LOGS_PER_TX, } from '@aztec/circuits.js';
import { sha256Trunc } from '@aztec/foundation/crypto';
import { BufferReader, prefixBufferWithLength } from '@aztec/foundation/serialize';
import isEqual from 'lodash.isequal';
import { EncryptedFunctionL2Logs, EncryptedNoteFunctionL2Logs, UnencryptedFunctionL2Logs, } from './function_l2_logs.js';
/**
 * Data container of logs emitted in 1 tx.
 */
export class TxL2Logs {
    constructor(
    /** * An array containing logs emitted in individual function invocations in this tx. */
    functionLogs) {
        this.functionLogs = functionLogs;
    }
    /**
     * Serializes logs into a buffer.
     * @returns A buffer containing the serialized logs.
     */
    toBuffer() {
        const serializedFunctionLogs = this.functionLogs.map(logs => logs.toBuffer());
        // Concatenate all serialized function logs into a single buffer and prefix it with 4 bytes for its total length.
        return prefixBufferWithLength(Buffer.concat(serializedFunctionLogs));
    }
    /**
     * Get the total length of serialized data.
     * @returns Total length of serialized data.
     */
    getSerializedLength() {
        return this.functionLogs.reduce((acc, logs) => acc + logs.getSerializedLength(), 0) + 4;
    }
    /**
     * Get the total length of all chargable data (raw log data + 4 for each log)
     * TODO: Rename this? getChargableLength? getDALength?
     * @returns Total length of data.
     */
    getKernelLength() {
        return this.functionLogs.reduce((acc, logs) => acc + logs.getKernelLength(), 0);
    }
    /** Gets the total number of logs. */
    getTotalLogCount() {
        return this.functionLogs.reduce((acc, logs) => acc + logs.logs.length, 0);
    }
    /**
     * Adds function logs to the existing logs.
     * @param functionLogs - The function logs to add
     * @remarks Used by sequencer to append unencrypted logs emitted in public function calls.
     */
    addFunctionLogs(functionLogs) {
        this.functionLogs.push(...functionLogs);
    }
    /**
     * Convert a TxL2Logs class object to a plain JSON object.
     * @returns A plain object with TxL2Logs properties.
     */
    toJSON() {
        return {
            functionLogs: this.functionLogs.map(log => log.toJSON()),
        };
    }
    /**
     * Unrolls logs from this tx.
     * @returns Unrolled logs.
     */
    unrollLogs() {
        return this.functionLogs.flatMap(functionLog => functionLog.logs);
    }
    /**
     * Checks if two TxL2Logs objects are equal.
     * @param other - Another TxL2Logs object to compare with.
     * @returns True if the two objects are equal, false otherwise.
     */
    equals(other) {
        return isEqual(this, other);
    }
    /**
     * Filter the logs from functions from this TxL2Logs that
     * appear in the provided logHashes
     * @param logHashes hashes we want to keep
     * @param output our aggregation
     * @returns our aggregation
     */
    filter(logHashes, output) {
        for (const fnLogs of this.functionLogs) {
            let include = false;
            for (const log of fnLogs.logs) {
                if (logHashes.findIndex(lh => lh.value.equals(Fr.fromBuffer(log.getSiloedHash()))) !== -1) {
                    include = true;
                }
            }
            if (include) {
                output.addFunctionLogs([fnLogs]);
            }
        }
        return output;
    }
    /**
     * Filter the logs from functions from this TxL2Logs that
     * appear in the provided scopedLogHashes
     * @param logHashes hashes we want to keep
     * @param output our aggregation
     * @returns our aggregation
     */
    filterScoped(scopedLogHashes, output) {
        for (const fnLogs of this.functionLogs) {
            let include = false;
            for (const log of fnLogs.logs) {
                let contractAddress;
                if ('contractAddress' in log) {
                    contractAddress = log.contractAddress;
                }
                else if ('maskedContractAddress' in log) {
                    contractAddress = log.maskedContractAddress;
                }
                else {
                    throw new Error("Can't run filterScoped in logs without contractAddress or maskedContractAddress");
                }
                if (scopedLogHashes.findIndex(slh => slh.contractAddress.equals(contractAddress) && slh.value.equals(Fr.fromBuffer(log.hash()))) != -1) {
                    include = true;
                }
            }
            if (include) {
                output.addFunctionLogs([fnLogs]);
            }
        }
        return output;
    }
}
export class UnencryptedTxL2Logs extends TxL2Logs {
    /** Creates an empty instance. */
    static empty() {
        return new UnencryptedTxL2Logs([]);
    }
    /**
     * Deserializes logs from a buffer.
     * @param buf - The buffer containing the serialized logs.
     * @param isLengthPrefixed - Whether the buffer is prefixed with 4 bytes for its total length.
     * @returns A new L2Logs object.
     */
    static fromBuffer(buf, isLengthPrefixed = true) {
        const reader = BufferReader.asReader(buf);
        // If the buffer is length prefixed use the length to read the array. Otherwise, the entire buffer is consumed.
        const logsBufLength = isLengthPrefixed ? reader.readNumber() : -1;
        const serializedFunctionLogs = reader.readBufferArray(logsBufLength);
        const functionLogs = serializedFunctionLogs.map(logs => UnencryptedFunctionL2Logs.fromBuffer(logs, false));
        return new UnencryptedTxL2Logs(functionLogs);
    }
    /**
     * Creates a new `TxL2Logs` object with `numCalls` function logs and `numLogsPerCall` logs in each invocation.
     * @param numCalls - The number of function calls in the tx.
     * @param numLogsPerCall - The number of logs emitted in each function call.
     * @param logType - The type of logs to generate.
     * @returns A new `TxL2Logs` object.
     */
    static random(numCalls, numLogsPerCall) {
        if (numCalls * numLogsPerCall > MAX_UNENCRYPTED_LOGS_PER_TX) {
            throw new Error(`Trying to create ${numCalls * numLogsPerCall} logs for one tx (max: ${MAX_UNENCRYPTED_LOGS_PER_TX})`);
        }
        const functionLogs = [];
        for (let i = 0; i < numCalls; i++) {
            functionLogs.push(UnencryptedFunctionL2Logs.random(numLogsPerCall));
        }
        return new UnencryptedTxL2Logs(functionLogs);
    }
    /**
     * Convert a plain JSON object to a TxL2Logs class object.
     * @param obj - A plain TxL2Logs JSON object.
     * @returns A TxL2Logs class object.
     */
    static fromJSON(obj) {
        const functionLogs = obj.functionLogs.map((log) => UnencryptedFunctionL2Logs.fromJSON(log));
        return new UnencryptedTxL2Logs(functionLogs);
    }
    /**
     * Computes unencrypted logs hash as is done in the kernel and decoder contract.
     * @param logs - Logs to be hashed.
     * @returns The hash of the logs.
     * Note: This is a TS implementation of `computeKernelUnencryptedLogsHash` function in Decoder.sol. See that function documentation
     *       for more details.
     */
    hash() {
        const unrolledLogs = this.unrollLogs();
        return UnencryptedTxL2Logs.hashSiloedLogs(unrolledLogs.map(log => log.getSiloedHash()));
    }
    /**
     * Hashes siloed unencrypted logs as in the same way as the base rollup would.
     * @param siloedLogHashes - The siloed log hashes
     * @returns The hash of the logs.
     */
    static hashSiloedLogs(siloedLogHashes) {
        if (siloedLogHashes.length == 0) {
            return Buffer.alloc(32);
        }
        let allSiloedLogHashes = Buffer.alloc(0);
        for (const siloedLogHash of siloedLogHashes) {
            allSiloedLogHashes = Buffer.concat([allSiloedLogHashes, siloedLogHash]);
        }
        // pad the end of logs with 0s
        for (let i = 0; i < MAX_UNENCRYPTED_LOGS_PER_TX - siloedLogHashes.length; i++) {
            allSiloedLogHashes = Buffer.concat([allSiloedLogHashes, Buffer.alloc(32)]);
        }
        return sha256Trunc(allSiloedLogHashes);
    }
}
export class EncryptedNoteTxL2Logs extends TxL2Logs {
    /** Creates an empty instance. */
    static empty() {
        return new EncryptedNoteTxL2Logs([]);
    }
    /**
     * Deserializes logs from a buffer.
     * @param buf - The buffer containing the serialized logs.
     * @param isLengthPrefixed - Whether the buffer is prefixed with 4 bytes for its total length.
     * @returns A new L2Logs object.
     */
    static fromBuffer(buf, isLengthPrefixed = true) {
        const reader = BufferReader.asReader(buf);
        // If the buffer is length prefixed use the length to read the array. Otherwise, the entire buffer is consumed.
        const logsBufLength = isLengthPrefixed ? reader.readNumber() : -1;
        const serializedFunctionLogs = reader.readBufferArray(logsBufLength);
        const functionLogs = serializedFunctionLogs.map(logs => EncryptedNoteFunctionL2Logs.fromBuffer(logs, false));
        return new EncryptedNoteTxL2Logs(functionLogs);
    }
    /**
     * Creates a new `TxL2Logs` object with `numCalls` function logs and `numLogsPerCall` logs in each invocation.
     * @param numCalls - The number of function calls in the tx.
     * @param numLogsPerCall - The number of logs emitted in each function call.
     * @param logType - The type of logs to generate.
     * @returns A new `TxL2Logs` object.
     */
    static random(numCalls, numLogsPerCall) {
        if (numCalls * numLogsPerCall > MAX_NOTE_ENCRYPTED_LOGS_PER_TX) {
            throw new Error(`Trying to create ${numCalls * numLogsPerCall} logs for one tx (max: ${MAX_NOTE_ENCRYPTED_LOGS_PER_TX})`);
        }
        const functionLogs = [];
        for (let i = 0; i < numCalls; i++) {
            functionLogs.push(EncryptedNoteFunctionL2Logs.random(numLogsPerCall));
        }
        return new EncryptedNoteTxL2Logs(functionLogs);
    }
    /**
     * Convert a plain JSON object to a TxL2Logs class object.
     * @param obj - A plain TxL2Logs JSON object.
     * @returns A TxL2Logs class object.
     */
    static fromJSON(obj) {
        const functionLogs = obj.functionLogs.map((log) => EncryptedNoteFunctionL2Logs.fromJSON(log));
        return new EncryptedNoteTxL2Logs(functionLogs);
    }
    /**
     * Computes encrypted logs hash as is done in the kernel and decoder contract.
     * @param logs - Logs to be hashed.
     * @returns The hash of the logs.
     * Note: This is a TS implementation of `computeKernelNoteEncryptedLogsHash` function in Decoder.sol. See that function documentation
     *       for more details.
     */
    hash() {
        return EncryptedNoteTxL2Logs.hashNoteLogs(this.unrollLogs().map(log => log.hash()));
    }
    /**
     * Hashes encrypted note logs hashes as in the same way as the base rollup would.
     * @param siloedLogHashes - The note log hashes
     * @returns The hash of the log hashes.
     */
    static hashNoteLogs(logHashes) {
        if (logHashes.length == 0) {
            return Buffer.alloc(32);
        }
        let allSiloedLogHashes = Buffer.alloc(0);
        for (const siloedLogHash of logHashes) {
            allSiloedLogHashes = Buffer.concat([allSiloedLogHashes, siloedLogHash]);
        }
        // pad the end of logs with 0s
        for (let i = 0; i < MAX_NOTE_ENCRYPTED_LOGS_PER_TX - logHashes.length; i++) {
            allSiloedLogHashes = Buffer.concat([allSiloedLogHashes, Buffer.alloc(32)]);
        }
        return sha256Trunc(allSiloedLogHashes);
    }
}
export class EncryptedTxL2Logs extends TxL2Logs {
    /** Creates an empty instance. */
    static empty() {
        return new EncryptedTxL2Logs([]);
    }
    /**
     * Deserializes logs from a buffer.
     * @param buf - The buffer containing the serialized logs.
     * @param isLengthPrefixed - Whether the buffer is prefixed with 4 bytes for its total length.
     * @returns A new L2Logs object.
     */
    static fromBuffer(buf, isLengthPrefixed = true) {
        const reader = BufferReader.asReader(buf);
        // If the buffer is length prefixed use the length to read the array. Otherwise, the entire buffer is consumed.
        const logsBufLength = isLengthPrefixed ? reader.readNumber() : -1;
        const serializedFunctionLogs = reader.readBufferArray(logsBufLength);
        const functionLogs = serializedFunctionLogs.map(logs => EncryptedFunctionL2Logs.fromBuffer(logs, false));
        return new EncryptedTxL2Logs(functionLogs);
    }
    /**
     * Creates a new `TxL2Logs` object with `numCalls` function logs and `numLogsPerCall` logs in each invocation.
     * @param numCalls - The number of function calls in the tx.
     * @param numLogsPerCall - The number of logs emitted in each function call.
     * @param logType - The type of logs to generate.
     * @returns A new `TxL2Logs` object.
     */
    static random(numCalls, numLogsPerCall) {
        if (numCalls * numLogsPerCall > MAX_ENCRYPTED_LOGS_PER_TX) {
            throw new Error(`Trying to create ${numCalls * numLogsPerCall} logs for one tx (max: ${MAX_ENCRYPTED_LOGS_PER_TX})`);
        }
        const functionLogs = [];
        for (let i = 0; i < numCalls; i++) {
            functionLogs.push(EncryptedFunctionL2Logs.random(numLogsPerCall));
        }
        return new EncryptedTxL2Logs(functionLogs);
    }
    /**
     * Convert a plain JSON object to a TxL2Logs class object.
     * @param obj - A plain TxL2Logs JSON object.
     * @returns A TxL2Logs class object.
     */
    static fromJSON(obj) {
        const functionLogs = obj.functionLogs.map((log) => EncryptedFunctionL2Logs.fromJSON(log));
        return new EncryptedTxL2Logs(functionLogs);
    }
    /**
     * Computes encrypted logs hash as is done in the kernel and decoder contract.
     * @param logs - Logs to be hashed.
     * @returns The hash of the logs.
     * Note: This is a TS implementation of `computeKernelEncryptedLogsHash` function in Decoder.sol. See that function documentation
     *       for more details.
     */
    hash() {
        const unrolledLogs = this.unrollLogs();
        return EncryptedTxL2Logs.hashSiloedLogs(unrolledLogs.map(log => log.getSiloedHash()));
    }
    /**
     * Hashes siloed unencrypted logs as in the same way as the base rollup would.
     * @param siloedLogHashes - The siloed log hashes
     * @returns The hash of the logs.
     */
    static hashSiloedLogs(siloedLogHashes) {
        if (siloedLogHashes.length == 0) {
            return Buffer.alloc(32);
        }
        let allSiloedLogHashes = Buffer.alloc(0);
        for (const siloedLogHash of siloedLogHashes) {
            allSiloedLogHashes = Buffer.concat([allSiloedLogHashes, siloedLogHash]);
        }
        // pad the end of logs with 0s
        for (let i = 0; i < MAX_UNENCRYPTED_LOGS_PER_TX - siloedLogHashes.length; i++) {
            allSiloedLogHashes = Buffer.concat([allSiloedLogHashes, Buffer.alloc(32)]);
        }
        return sha256Trunc(allSiloedLogHashes);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHhfbDJfbG9ncy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sb2dzL3R4X2wyX2xvZ3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLEVBQUUsRUFFRix5QkFBeUIsRUFDekIsOEJBQThCLEVBQzlCLDJCQUEyQixHQUU1QixNQUFNLG9CQUFvQixDQUFDO0FBQzVCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsWUFBWSxFQUFFLHNCQUFzQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFbkYsT0FBTyxPQUFPLE1BQU0sZ0JBQWdCLENBQUM7QUFJckMsT0FBTyxFQUNMLHVCQUF1QixFQUN2QiwyQkFBMkIsRUFFM0IseUJBQXlCLEdBQzFCLE1BQU0sdUJBQXVCLENBQUM7QUFHL0I7O0dBRUc7QUFDSCxNQUFNLE9BQWdCLFFBQVE7SUFHNUI7SUFDRSx3RkFBd0Y7SUFDeEUsWUFBb0M7UUFBcEMsaUJBQVksR0FBWixZQUFZLENBQXdCO0lBQ25ELENBQUM7SUFFSjs7O09BR0c7SUFDSSxRQUFRO1FBQ2IsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQzlFLGlIQUFpSDtRQUNqSCxPQUFPLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7O09BR0c7SUFDSSxtQkFBbUI7UUFDeEIsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUYsQ0FBQztJQUVEOzs7O09B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
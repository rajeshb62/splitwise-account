{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"EcdsaKAccount","functions":[{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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7rTnnfaC01Y4baXTXnTaS05b5bTVTnvZaa84bY3T1jrtVae95rTXnbbOaW847U2nrXfaBqe95bS3nbbRaZuc9o7T3nXaZqdtcdp7TnvfaR84bavTPnTaR07b5rTtTvvYaZ84bYfTdjrtU6d95rTPnbbLaV847UunfeW03U772mnfOO1bp+1x2ndO+95pe522z2k/OO1Hp+132gGn/eS0n532i9MOOu1Xp/3mtENOO+y03532h9P+dNoRp/3ltL+ddtRp7gGYOKflcFq803I6LZfTcjstj9PyOi2f0/I7rYDTCjqtkNMKO62I04o6rZjTijuthNMSnFbSaaWcVtppZZxW1mmnOK2c08o7rYLTKjqtktOiTqvstCpOq+q0ak471WnVnVbDaTWddprTTndaLafVdtoZTjvTaXWclug047S6TqvntCSn1XdaA6c1dFojpzV22llOO9tpTZx2jtPOdVpT97NgTjvPaec7rbnTWjjtAqdd6LSWTmvltIucdrHTWjutjdMucVpbp7VzWnundXDapU7r6LROTrvMaZc7rbPTujitq9OucFo3p3V3Wg+nXem0nk7r5bTeTuvjtL5O6+e0ZKf1d9oApw102iCnXeW0wU4b4rShThvmtOFOG+G0q5020mmjnJbitNFOG+O0sU4b57TxTrvGaROcNtFp1zrtOqdNctpkp13vtBucNsVpU512o9Nucto0p0132s1Ou8VpM5w202m3Ou02p93utFlOu8NpdzrtLqfNdtrdTrvHaXOcNtdp9zrtPqfNc9p8p93vtAectsBpC532oNMectrDTlvktEec9qjT3O+gd79H3f1ecfd7l93vDna/W9X9vkj3Ow/d7wB0vyPN/Z4v93uv3O+Ucr+vyf0uJPd7htzv8HG/H8f97hn3e13c70xxv4/E/a4P97sv3O+VWOs09zsM3O8HcJ+97z7X3n1mvPs8dvdZ5+5zxN1ndLvPv3afLe0+t9l9JrL7vGH3Wb7uc3LdZ9C6z3d1n53qPpfUfean+zxN91mV7nMg3Wcsus8vdJ8N6D53z32mnfu8OPdZbLuc5j5DzH0+l/vsK/e5Uu4zm9znIbnPGnKf4+M+I8d9/oz7bBf3uSnuM0nc5324z9Jwn1PhPgPCfb6C++wC97kAbuxyP8/uflbc/Ry2+xln9/PD7mdz3c+9up8pdT+v6X4W0g3s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","debug_symbols":"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0JR60JR60JR60JR6wJTaFphS2wJTaltgSm0LTKltgSm1LTCltgWm1LbAlNoWmFLbQlNqoSm10JRaaEotNKUWmlILTamFptRCU2qhKbXQlFppSq00pVaaUitNqZWm1EpTahp1bzTq3mjUvSlNqY2m1EZTaqMptdGU2mhKbTSlNppSG02pjabURlNqpym105TaaUrtNKV2mlI7TamdptROU2qnKbXTlDpoSh00pQ6aUgdNqYOm1EFT6qApddCUOmhKHTSlpjGKRmMUrb1UOm+kXLKpYz0df9v6Z7svlc273a7Xavelcnm322W/72D3dtlvPNi9Xdjbl6zB3r5kCXtPniXsPXmWSisI9p4824Vr3bUg2HvyLButINh78ixpSp00pe40pe40pe40pe40pe40pe40pe40pe40pe40pe40pR40pR40pR40pR40pR40pR40pR40pR40pR40pR4wpfYFptS+wJTaF5hS+wJTal9gSu0LTKl9gSm1LzCl9gWm1L7QlFpoSi00pRaaUgtNqYWm1EJTaqEptdCUWmhKLTSlVppSK02plabUSlNqpSm10pRaaUqtNKVWmlIrTamNptRGU2qjKbXRlNpoSm00pTaaUhtNqY2m1EZTaqcptdOU2mlK7TSldppSO02pnabUTlNqpym105Q6aEodNKUOmlIHTamDptRBU+qgKXXQlDpoSh00pW40pW40pW40pW40pW40pW40pW40pW40paYxik5jFJ3GKDqNUXQao+g0RtFpjKLTGEWnMYpOYxSdxig6jVF0GqPoNEbRaYyi0xhFpzGKTmMUncYoOo1RdBqj6DRG0WmMotMYRacxik5jFJ3GKDqNUXQao+g0RtFpjKLTGMWgMYpBYxSDxigGjVGMBabUQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8Yo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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","build_msg_block","attach_len_to_msg_block","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7P3bjiTZFp3pvUtd94Uflp/4KoIgUGq2QKBBCiJ1RejdO/auisgspo+wSNos8xm2Pl4VSUdm+D/mNpvjt0hb/+OP//0//T//f//v/8d//i//x3/9b3/8h//b//jj//yv/6//+N//83/9L2//t//xx+327/+3//b/+Y//5V//1//23//j//e///EfjtfH4X/74z/9l//97T9vh8P//3/74//4z//nf/rjP4x//fcvnz7d7re/Pn26Hx4fnz5ej08+fR7X+1+fPl/GceHTx+Phenz/UY6H2/j4/Pl0efb5cTq9f3z89Kefx9M//PT4+LNv958//H//3/643aFJaB7QBDT3AzQJzRGahOYETUJzhiahGdAkNBdoEporNAmNbTiisQ1HNLbhhOZhG45obMMRjW04orENRzQDmoTGNhzR2IYjGttwRGMbjmhswwnN8WAdzmzsw5mNhTizsRFnNgObyMZOnNlYijMbW3FmYy3ObOzFkc3RXpzZ2IszG3txZmMvzmwGNpGNvTizsRdnNvbizMZenNnYiyObk704s7EXZzb24szGXpzZDGwiG3txZmMvzmzsxZmNvTizsRdHNmd7cWZjL85s7MWZjb04sxnYRDb24szGXpzZ2IszG3txZmMvjmyGvTizsRdnNvbizMZenNkMbCIbe3FmYy/ObOzFmY29OLOxF0c2F3txZmMvzmzsxZmNvTizGdhENvbizMZenNnYizMbe3FmYy+ObK799+LH/ePnf/syS2zu9+v7xx+Hyzo2/ffi17Hpvxe/jk3BXnx+jPdLwvlxu/34tvfrn3/H2ODvqNjTfqA6vV2If/o7nqZ2GB9XtsP9R8aPx58/0HX7H+j40w90+vkHevJHH47vP8hpnH4ai9P1yafH8fo+/eNt+n769O3PL3ub6cveZ/qyj4m+7O0w05c9zvRlTzN92fNMX3bM9GUvM33ZXW1Q58f7H/1Wg8+/ftldbVBLX3ZXG9TSl93VBrXwZe+72qCWvuyuNqilL7urDWrpy+5qg1r6smOmL7urDWrpy+5qg7oeP9bF6/nXdfG+qw1q6cvuaoNa+rK72qAWvuxjVxvU0pfd1Qa19GV3tUEtfdldbVBLX3bM9GV3tUEtfdldbVD3j2eo4379dV187GqDWvqyu9qglr7srjaoz7/s6bCrDWrpy+5qg1r6srvaoJa+7K42qKUvO2b6srvaoJa+7PYb1Ol+fv+zz4elL3u9vv8u3el6vy182fPxA835dL7+7cs+o349fXzLw/X8M5x/+HdlT4cb7K/Afof9FdgfsL8A+/EA+yuwH2F/BfYT7K/Afob9FdgH7K/AfoH9Fdi11Jdg11Jfgl1LfQl2LfUV2E9a6kuwT91SL7cf2G/HJex1/6D7dJq6pb4Oe/OWeju8f/h0vx8XsB/f9uH3P/p0/wn74f7k0z+g33+GeHh0uyANEXWPqHn7FdHp1Lwp94nodfei5q1aRKdT8wb+exEdf4rocVuI6Hg5jvdPX+/npU+/MqTmfV1IbyGdu7f78/EjpMdpKaTr4QPM7frTu/X+9U6wXti7t/udYn9tu//p35j++ZqzU8k5fMf75f0HOl1uCz/Q6To+fj3xdr0u/fivDGtgE9lUNL23O+D7tz0fL3/7tv/+Oyqqyvn28d7H8dNV5znR8+H8ntb5cDn87ULy75/o1u4nurf7iSq2rnH4uMSNn/6O5z/R7fB+r7j97Bj/+nlKTimr/HmOzX6eU7Of51wy0dcfP8/xlytLOEnqeL18XPJ+qqrP/47j6ceLlM8/XU3/dbH8999x2eDvuG7wd9w2+DvuBX/H+fbxd4zD+Nvf8Z2fw4WTdrB5YxNO2sHmX2yO2EQ2J2wimzM2kc3AJrK5YBPZXLGJbG7YRDb24szGXhzZXO3FmU3/vfhlVvfafy9+HZuSvXh8/BXjtMTm+zzWupbsxedTYvPvv+P5fnkZH0cvXa73pb/jdPi47Jx+euLwfNrOH6c6jfPPnvv5ZB7Gx5c9HB5LV7Tz4+OtG+fT5+xP9x/P++7jvBBUZarPt9bL/eN/39fjoom9jA8Te7n9+OGP52czfLkf3mfg7W/5+dHmNTxbe//423/fj3/7/L+/we3bf4N7xTd4fDyDvI7Lwje4Pd5n4n766ec5Pn15zOHjTx7H0+2nn+Ppk6O3p80f1/rbj+vB6c9H0eGoou/5Vc8/jjs7/3Qx+OurhoOKdvlVj/N81dM8X/U8z1cd83zVyzxf9TrPV73N81X3tC0tfNV5tqX7PNvSfZ5t6T7PtnSfZ1u6z7Mt3XtvS8cf73U9/qQt/peq+b33tvR7X3Uh1d7b0vHjGPtx+kkv/a+l2ntb+r2vupBq722p8qs+em9LpV+197ZU+lV7b0ulX7X3tlT6Vcc8X7X5tlT5VZtvS5VfdU/b0sJXnWdbekyzLZ0P02xL58M029L5MM22dD5Msy2dD6P1V/1RtsfpellVzc+H3tvS733VhVR7b0tvD1rev+r5eFyZau9t6fe+6kKqrbel8+P6cVk6P8bSV719fPp8/+kVGqfx51fdfFu63z9+5/Ewlr7r9f7+K4/3n/9l9uH87x/+uPn+8/Yj//jpb4eFn/5yPb3/L+pyHT//y/L/pd+nOx+Pk33f5U3oPBa+7/n6/gXOt59+o/H0lM1pfLxL4nT56Q0m16e/g3z58XKay+Pvx/c++1/t1L+Pez6et87y419dvMW6lOXjfn//9ONxOC5M7vHw9nN/5HN83H6d3DHVt71M9W2vU33b256+7eXHqzwO18Pj1297n+rbPvb0bR8fd9jjv8Z64fOz349Ph91mfz78Mumn41Tf9jTVt916szx/eJLT3/6N6NNve/944dz9ukTmfP14udj5evzp35M+rdHvH338pDv+9ef+m8nA5BcmF0x+YXLtzORNOXzc7w4/vUg3UDk+fvjL09Jv0o3T5Yfc/+n37p6+o/cyPv4x8+Xnf957+usKdEOxgOIdxQKKDxTXUzwfUCygeESxgOIJxQKKrVvCt6E4UCyg2LqJfBuKuksFRd2lgqLuUkFRdymgOHSXCoq6SwVF3aWCou5SQXGgWEBRd6mgqLtUUNRdKijqLhUUdZcCihfdpYKi7lJBUXepoKi7VFAcKBZQ1F0qKOouFRR1lwqKuksFRd2lgOJVd6mgqLtUUNRdKijqLhUUB4oFFHWXCoq6SwVF3aWCou5SQVF3KaB4010qKOouFRR1lwqKuksFxYFiAcV5u8v1MN4pXk+HX8DMW0cWwMzbMBbAzFsaFsDM2wOul49zwa63X8Dc513tF8DMu60vgJl3AV8AM+9OvQBmuCs9vSvdbb4BjM03gLH5BjATb76fX3xtvs/BPGy+AYzNN4Cx+QYwNt8AZgDzHMzEm+/nYCbefD8HM/Hm+zkYm28AY/N9CmYcbL4BjM03gJl48/1MO4zDxJvv52AGMM/BcL4BjM03XHxtvgGMzTeAsfk+B3O0+QYwNt8AhvMNYDjfAGYA8xwM5xvA2HwDGJtvAGPzDWBsvs/BnCbefD/VDqeJN9/PwXC+AQznG8AMF9/nF1+bbwBj8w1gbL4BjM03gLH5Pgcz8WGtC2A43wCG8w1gON8AZgDzHIzNN4Cx+QYwNt8AxrsdnmuHic8F/RzMxEd9LoDhfAMYm+/zi+/EZ2wugBnAPAdj8w1gbL4BjM03gOF8AxjO9zmYiQ+KXADD+QYwNt8AxuYbwAxgnoOx+QYw3mr2XDtMfNrhAhjON4DhfJ+DmfiYwc8vvhOfHLgAxuYbwNh8A5gBzHMwNt8AhvMNYDjfAIbzDWA43+dgJj6kbgGMzTeAsfkGMDbfAGbQDk+1gzPcEhjON4DhfAMYm2+4+Np8n4NxhlsCY/MNYGy+AYzNN4AZwDwHw/kGMJxvAMP5BjA23wDG5vscjDPcEhibbwDjrWbPtcPMZ7h9DmYA8xwM5xvA2HzDxdfmG8DYfAMYm+9TMBdnuCUwNt8AhvMNYDjfAGYA8xwM5xvA2HwDGJtvAGPzDWBsvs/BzHyG22fa4TLzGW6fg+F8AxjON4AZLr7PL7423wDG5hvA2HwDGJtvAGPzfQ5m5jPcPgfD+QYwnG8Aw/kGMAOY52BsvgGMzTeAsfkGMN5q9lw7zHyG26dgZj7D7XMwnG8AY/N9fvF1hlsCM4B5DsbmG8DYfAMYm28Aw/kGMJzvczAzn+H2ORjON4Cx+QYwNt8AZgDzHIzNN4DxVrPn2mHmM9w+B8P5BjCc73MwznALF19nuCUwNt8AxuYbwAxgnoOx+QYwnG8Aw/kGMJxvAMP5PgfjDLcExuYbwNh8AxibbwAzaIen2mHmM9w+B8P5BjCcbwBj8w0XX5vvczDOcEtgbL4BjM03gLH5BjADmOdgON8AhvMNYDjfAMbmG8DYfJ+DcYZbAmPzDWC81ey5dpj5DLfPwQxgnoPhfAMYm2+4+Np8AxibbwBj830OxhluCYzNN4DhfAMYzjeAGcA8B8P5BjA23wDG5hvA2HwDGJvvUzDXmc9w+0w7XGc+w+1zMJxvAMP5BjDDxff5xdfmG8DYfAMYm28AY/MNYGy+z8HMfIbb52A43wCG8w1gON8AZgDzHIzNN4Cx+QYwNt8AxlvNnmuHmc9w+xTMzGe4fQ6G8w1gbL7PL77OcEtgBjDPwdh8AxibbwBj8w1gON8AhvN9DmbmM9w+B8P5BjA23wDG5hvADGCeg7H5BjDeavZcO8x8htvnYDjfAIbzfQ7GGW7h4usMtwTG5hvA2HwDmAHMczA23wCG8w1gON8AhvMNYDjf52Cc4ZbA2HwDGJtvAGPzDWAG7fBUO8x8htvnYDjfAIbzDWBsvuHia/N9DsYZbgmMzTeAsfkGMDbfAGYA8xwM5xvAcL4BDOcbwNh8Axib73MwznBLYGy+AYy3mj3XDjOf4fY5mAHMczCcbwBj8w0XX5tvAGPzDWBsvs/BOMMtgbH5BjCcbwDD+QYwA5jnYDjfAMbmG8DYfAMYm28AY/N9DmbmM9w+1Q4zn+H2ORjON4DhfAOY4eL7/OJr8w1gbL4BjM03gLH5BjA236dgbjOf4fY5GM43gOF8AxjON4AZwDwHY/MNYGy+AYzNN4DxVrOn2uE28xlun4KZ+Qy3z8FwvgGMzff5xdcZbgnMAOY5GJtvAGPzDWBsvgEM5xvAcL7Pwcx8htvnYDjfAMbmG8DYfAOYAcxzMDbfAMZbzZ5rh5nPcPscDOcbwHC+z8E4wy1cfJ3hlsDYfAMYm28AM4B5DsbmG8BwvgEM5xvAcL4BDOf7HIwz3BIYm28AY/MNYGy+AcygHZ5qh5nPcPscDOcbwHC+AYzNN1x8bb7PwTjDLYGx+QYwNt8AxuYbwAxgnoPhfAMYzjeA4XwDGJtvAGPzfQ7GGW4JjM03gPFWs+faYeYz3D4HM4B5DobzDWBsvuHia/MNYGy+AYzN9zkYZ7glMDbfAIbzDWA43wBmAPMcDOcbwNh8AxibbwBj8w1gbL7Pwcx8htun2mHmM9w+B8P5BjCcbwAzXHyfX3xtvgGMzTeAsfkGMDbfAMbm+xzMzGe4fQ6G8w1gON8AhvMNYAYwz8HYfAMYm28AY/MNYLzV7Ll2mPkMt8/A3Gc+w+1zMJxvAGPzfXrxvTvDLYEZwDwHY/MNYGy+AYzNN4DhfAMYzvc5mJnPcPscDOcbwNh8AxibbwAzgHkOxuYbwHir2XPtMPMZbp+D4XwDGM73ORhnuIWLrzPcEhibbwBj8w1gBjDPwdh8AxjON4DhfAMYzjeA4Xyfg3GGWwJj8w1gbL4BjM03gBm0w1PtMPMZbp+D4XwDGM43gLH5houvzfc5GGe4JTA23wDG5hvA2HwDmAHMczCcbwDD+QYwnG8AY/MNYGy+z8E4wy2BsfkGMN5q9lw7zHyG2+dgBjDPwXC+AYzNN1x8bb4BjM03gLH5PgfjDLcExuYbwHC+AQznG8AMYJ6D4XwDGJtvAGPzDWBsvgGMzfc5mJnPcPtUO8x8htvnYDjfAIbzDWCGi+/zi6/NN4Cx+QYwNt8AxuYbwNh8n4OZ+Qy3z8FwvgEM5xvAcL4BzADmORibbwBj8w1gbL4BjLeaPdcOM5/h9imYmc9w+xyMzff5NcYZbgmMzTeAGcA8B2PzDWBsvgGMdzuE27XNN4Cx+T4F85j5DLfPrjGPmc9w+xyMzTeAsfkGMAOY52BsvgGMt5qF27XNN4Cx+QYwNt/nYJzhFi6+znBLYGy+AYzNN4AZwDwHY/MNYDjfAMZvOwQwfs83gPF7vs/BOMMtgZl38719fMe3/zz/Ambezfd0ub2DOd3+BubXD1/G4f0HuYzT+IXivGtyJcWBYgHFeRfwSorzbuuVFOdd7SspztsDKinOWxoKKU58Vl4lxXnrSCVF3aWCou5SQXGgWEBRd6mgqLtUUNRdKijqLhUUdZcCihOfdlhJUXepoKi7VFDUXSooDhQLKOouFRR1lwqKuksFRd2lgqLuUkBx4vMqKynqLhUUdZcKirpLBcWBYgFF3aWCou5SQVF3qaCou1RQ1F0KKE584mglRd2lgqLuUkFRd6mgOFAsoKi7VFDUXSoo6i4VFHWXCoq6SwHFic+MraTogNk/nr6qzAGzCYwDZgOYAcxzMF489cfTd584YDaB8eKpAMaLpwIYL556DmbmA2Y/vSvNfMDs52BsvgGMzTeAGS6+zy++Nt8AxuYbwNh8AxibbwBj830OZuYDZj8H47CBAMZhAwGMwwYCmAHMczA23wDG5hvA2HwDGMdsPdcODph9DuZ4mPmE2QUyrG8iY/l9ev19I2P7TWQGMoGM/TeRsQAnMjbgRIb8TWTY30DGWbORDP+byNiBExk7cCIzkAlk7MCJzMQ78OcWYuYjZxfI0MCJDA8cyDh1Nl2BJz52domMHTiRsQMnMgOZQMYOnMjwwIkMD5zI8MCJDA8cyEx8LuoSGTtwImMHTmTswInMYCGeW4iJzw5dIsMDJzI8cCJjB05XYDtwIDPx+ZpLZOzAiYwdOJGxAycyA5lAhgdOZHjgRIYHTmTswImMHTiQmficxiUyduBExqvQgoWY+IzEJTIDmUCGB05k7MDpCmwHTmTswImMHTiQmfi8vyUyduBEhgdOZHjgRGYgE8jwwImMHTiRsQMnMnbgRMYOHMhMfG7cgoVwFlwkwwMnMjxwIjNcgcMV2A6cyNiBExk7cCJjB05k7MCBzMyHwi2Q4YETGR44keGBE5mBTCBjB05k7MCJjB04kfFutGAhZj4d7nMyMx8Pt0CGB05k7MDhCuyEuEhmIBPI2IETGTtwImMHTmR44ESGB35O5jjzOXELZHjgRMYOnMjYgROZgUwgYwdOZLwb7bmFOM58TtwCGR44keGBAxnnxKUrsHPiIhk7cCJjB05kBjKBjB04keGBExkeOJHhgRMZHjiQcU5cJGMHTmTswImMHTiRGSzEcwsx8zlxC2R44ESGB05k7MDpCmwHDmScExfJ2IETGTtwImMHTmQGMoEMD5zI8MCJDA+cyNiBExk7cCDjnLhIxg6cyHg3WrAQM58Tt0BmIBPI8MCJjB04XYHtwImMHTiRsQMHMs6Ji2TswIkMD5zI8MCJzEAmkOGBExk7cCJjB05k7MCJjB04kJn5nLjPLcTM58QtkOGBExkeOJEZrsDhCmwHTmTswImMHTiRsQMnMnbgQGbmc+IWyPDAiQwPnMjwwInMQCaQsQMnMnbgRMYOnMh4N1qwEDOfE/c5mZnPiVsgwwMnMnbgcAV2TlwkM5AJZOzAiYwdOJGxAycyPHAiwwMHMjOfE7dAhgdOZOzAiYwdOJEZyAQyduBExrvRgoWY+Zy4BTI8cCLDAz8nc3JOXLgCn5wTF8nYgRMZO3AiM5AJZOzAiQwPnMjwwIkMD5zI8MCBjHPiIhk7cCJjB05k7MCJzGAhnluImc+JWyDDAycyPHAiYwdOV2A7cCDjnLhIxg6cyNiBExk7cCIzkAlkeOBEhgdOZHjgRMYOnMjYgQMZ58RFMnbgRMa70YKFmPmcuAUyA5lAhgdOZOzA6QpsB05k7MCJjB04kHFOXCRjB05keOBEhgdOZAYygQwPnMjYgRMZO3AiYwdOZOzAgczM58R9biFmPidugQwPnMjwwInMcAUOV2A7cCJjB05k7MCJjB04kbEDBzIznxO3QIYHTmR44ESGB05kBjKBjB04kbEDJzJ24ETGu9GChZj5nLjPycx8TtwCGR44kbEDhyuwc+IimYFMIGMHTmTswImMHTiR4YETGR44kJn5nLgFMjxwImMHTmTswInMQCaQsQMnMt6NFizEzOfELZDhgRMZHjiQcU5cugI7Jy6SsQMnMnbgRGYgE8jYgRMZHjiR4YETGR44keGBn5M5OycukrEDJzJ24ETGDpzIDBbiqYU4z3xO3AIZHjiR4YETGTtwugLbgQMZ58RFMnbgRMYOnMjYgROZgUwgwwMnMjxwIsMDJzJ24ETGDhzIOCcukrEDJzLejRYsxMznxC2QGcgEMjxwImMHTldgO3AiYwdOZOzAgYxz4iIZO3AiwwMnMjxwIjOQCWR44ETGDpzI2IETGTtwImMHDmRmPifucwsx8zlxC2R44ESGB05khitwuALbgRMZO3AiYwdOZOzAiYwdOJCZ+Zy4BTI8cCLDAycyPHAiM5AJZOzAiYwdOJGxAycy3o0WLMTM58R9Tmbmc+IWyPDAiYwdOFyBnRMXyQxkAhk7cCJjB05k7MCJDA+cyPDAgczM58QtkOGBExk7cCJjB05kBjKBjB04kfFutGAhZj4nboEMD5zI8MCBjHPi0hXYOXGRjB04kbEDJzIDmUDGDpzI8MCJDA+cyPDAiQwPHMg4Jy6SsQMnMnbgRMYOnMgMFuK5hZj5nLgFMjxwIsMDJzJ24HQFtgM/JzOcExfJ2IETGTtwImMHTmQGMoEMD5zI8MCJDA+cyNiBExk7cCDjnLhIxg6cyHg32nMLMWY+J26BzEAmkOGBExk7cLoC24ETGTtwImMHDmScExfJ2IETGR44keGBE5mBTCDDAycyduBExg6cyNiBExk7cCAz8zlxn1uImc+JWyDDAycyPHAiM1yBwxXYDpzI2IETGTtwImMHTmTswIHMzOfELZDhgRMZHjiR4YETmYFMIGMHTmTswImMHTiR8W60YCFmPifuczIznxO3QIYHTmTswOEK7Jy4SGYgE8jYgRMZO3AiYwdOZHjgRIYHDmRmPidugQwPnMjYgRMZO3AiM5AJZOzAiYx3owULMfM5cQtkeOBEhgcOZJwTl67AzomLZOzAiYwdOJEZyAQyduBEhgdOZHjgRIYHTmR44EDGOXGRjB04kbEDJzJ24ERmsBDPLcTM58QtkOGBExk7cLrO2IETGTtwIOOcuEjGDpzI2IETGe+FCHdt58RFMnbgRIYHTtcZO3AiYwdOZOzAz8lcnBMXydiBExnvRnt+177MfE7cApmBTCBjB05k7MDpCmwHTmTswImMHTiQcU5cJGMHTmR44ETG70IkMgOZQMbvAycyduBEZt4d+PbxHd/+8/wrmXl34NPl9k7mdPsbmV8/fBmH9x/kMk7jV4zzLsyVGCc+ga4U47yreCnGeff2UozzLvmlGAeMFRjnrQ+lGOftGqUY5y0mpRi1mBKMWkwFxonPECzFqMWUYNRiSjBqMSUYB4wVGLWYEoxaTAlGLaYEoxZTglGLqcA48SmQpRi1mBKMWkwJRi2mBOOAsQKjFlOCUYspwajFlGDUYkowajEVGCc+x7MUoxZTglGLKcGoxZRgHDBWYNRiSjBqMSUYtZgSjFpMCUYtpgLjxCexlmLUYkowajElGLWYEowDxgqMWkwJRi2mBKNDbP94/qIzh9hGMg6xDWRmPsR2gYyXVv3x/JUpDrGNZLy0KpEZyAQyXlqVyDjAK92b7MCJjB04kbEDBzIOsU1XYIfYRjJ24ETGDpzIDGQCGTtwIuPFrYmMwwsSGYcXJDIOLwhkHGIbydiBExk7cCJjB05kBgvx3EI4xDaS4YETGR44kbEDpyuwHfg5matDbCMZO3AiYwdOZOzAicxAJpDhgRMZHjiR4YETGTtwImMHDmQcYhvJ2IETmYl34E8txHXmQ2wXyAxkAhkeOJGxA6crsB04kbEDJzJ24EBm4qNml8jYgRMZHjiR4YETmYFMIMMDJzJ24ETGDpzI2IETGTtwIDPxQaULFmLis0eXyPDAiQwPnMgMV+BwBbYDJzJ24ETGDpzI2IETGTtwIDPxMZdLZHjgRIYHTmR44ERmIBPI2IETGTtwImMHTmS8Gy1YiIlPVFwgM/EhiUtkeOBExg4crsATn064RGYgE8jYgRMZO3AiYwdOZHjgRIYHDmQmPmJviQwPnMjYgRMZO3AiM5AJZOzAiYx3owUL4Zy4SIYHTmR44EBm5nPiPr8COycukrEDJzJ24ERmIBPI2IETGR44keGBExkeOJHhgQMZ58RFMnbgRMYOnMjYgROZwUI8txAznxO3QIYHTmR44ETGDpyuwHbgQMY5cZGMHTiRsQMnMnbgRGYgE8jwwIkMD5zI8MCJjB04kbEDPydzc05cJGMHTmS8G+25hbjNfE7cApmBTCDDAycyduB0BbYDJzJ24ETGDhzIOCcukrEDJzI8cCLDAycyA5lAhgdOZOzAiYwdOJGxAycyduBAZuZz4j63EDOfE7dAhgdOZHjgRGa4AocrsB04kbEDJzJ24ETGDpzI2IEDmZnPiVsgwwMnMjxwIsMDJzIDmUDGDpzI2IETGTtwIuPdaMFCzHxO3OdkZj4nboEMD5zI2IHDFdg5cZHMQCaQsQMnMnbgRMYOnMjwwIkMDxzIzHxO3AIZHjiRsQMnMnbgRGYgE8jYgRMZ70YLFmLmc+IWyPDAiQwPHMg4Jy5dgZ0TF8nYgRMZO3AiM5AJZOzAiQwPnMjwwIkMD5zI8MCBjHPiIhk7cCJjB05k7MCJzGAhnluImc+JWyDDAycyPHAiYwdOV2A7cCDjnLhIxg6cyNiBExk7cCIzkAlkeOBEhgdOZHjgRMYOnMjYgQMZ58RFMnbgRMa70YKFmPmcuAUyA5lAhgdOZOzA6QpsB05k7MCJjB34OZm7c+IiGTtwIsMDJzI8cCIzkAlkeOBExg6cyNiBExk7cCJjBw5kZj4n7lMLcZ/5nLgFMjxwIsMDJzLDFThcge3AiYwdOJGxAycyduBExg4cyMx8TtwCGR44keGBExkeOJEZyAQyduBExg6cyNiBExnvRgsWYuZz4j4nM/M5cQtkeOBExg4crsDOiYtkBjKBjB04kbEDJzJ24ESGB05keOBAZuZz4hbI8MCJjB04kbEDJzIDmUDGDpzIeDdasBAznxO3QIYHTmR44EDGOXHpCuycuEjGDpzI2IETmYFMIGMHTmR44ESGB05keOBEhgcOZJwTF8nYgRMZO3AiYwdOZAYL8dxCzHxO3AIZHjiR4YETGTtwugLbgQMZ58RFMnbgRMYOnMjYgROZgUwgwwMnMjxwIsMDJzJ24ETGDhzIOCcukrEDJzLejRYsxMznxC2QGcgEMjxwImMHTldgO3AiYwdOZOzAgYxz4iIZO3AiwwMnMjxwIjOQCWR44ETGDpzI2IETGTtwImMHfk7mMfM5cZ9aiMfM58QtkOGBExkeOJEZrsDhCmwHTmTswImMHTiRsQMnMnbgQGbmc+IWyPDAiQwPnMjwwInMQCaQsQMnMnbgRMYOnMh4N1qwEDOfE/c5mZnPiVsgwwMnMnbgcAV2TlwkM5AJZOzAiYwdOJGxAycyPHAiwwMHMjOfE7dAhgdOZOzAiYwdOJEZyAQyduBExrvRgoWY+Zy4BTI8cCLDAwcyzolLV2DnxEUyduBExg6cyAxkAhk7cCLDAycyPHAiwwMnMjxwIOOcuEjGDpzI2IETGTtwIjNYiOcWYuZz4hbI8MCJDA+cyNiB0xXYDhzIOCcukrEDJzJ24ETGDpzIDGQCGR44keGBExkeOJGxAycyduBAxjlxkYwdOJHxbrRgIWY+J26BzEAmkOGBExk7cLoC24ETGTtwImMHDmScExfJ2IETGR44keGBE5mBTCDDAycyduBExg6cyNiBExk7cCAz8zlxn1uImc+JWyDDAycyPHAiM1yBwxXYDpzI2IETGTtwImMHTmTswE/JnA4znxO3QIYHTmR44ESGB05kBjKBjB04kbEDJzJ24ETGu9GeWog3Mt6NFsjMfE7cAhkeOJGxA4crsHPiIpmBTCBjB05k7MCJjB04keGBExkeOJCZ+Zy4BTI8cCJjB05k7MCJzEAmkLEDJzLejRYsxMznxC2Q4YETGR44kHFOXLoCOycukrEDJzJ24ERmIBPI2IETGR44keGBExkeOJHhgQMZ58RFMnbgRMYOnMjYgROZwUI8txAznxO3QIYHTmR44ETGDpyuwHbgQMY5cZGMHTiRsQMnMnbgRGYgE8jwwIkMD5zI8MCJjB04kbEDBzLOiYtk7MCJjHejBQsx8zlxC2QGMoEMD5zI2IHTFdgOnMjYgRMZO3Ag45y4SMYOnMjwwIkMD5zIDGQCGR44kbEDJzJ24ETGDpzI2IEDmZnPifvcQsx8TtwCGR44kbEDp+vMQCaQsQMnMnbgRMYOnMjYgRMZ74UId23nxEUyduBEhgcO15mZz4lbIDOQCWTswImMHTiRsQMnMt6Nlu7aduDnZI4znxO3QMYOnMjYgZ9fgY/OiYtkBjKBjB04kbEDJzJ24ESGB05k/C5EIDPzOXELZPw+cCJjB05k5t2Bbx/f8e0/z7+SGdOSOV1u72ROt7+R+fXDl3F4/0Eu4zR+xTjvwlyKcd7tuhTjvKt4KcZ59/ZSjPMu+ZUYJz41rxTjvPWhFOO8XaMU47zFpBTjgLECoxZTglGLKcGoxZRg1GJKMGoxFRgnPvewFKMWU4JRiynBqMWUYBwwVmDUYkowajElGLWYEoxaTAlGLaYC48QnV5Zi1GJKMGoxJRi1mBKMA8YKjFpMCUYtpgSjFlOCUYspwajFVGCc+OzRUoxaTAlGLaYEoxZTgnHAWIFRiynBqMWUYNRiSjBqMSUYtZgKjBOfHluKUYspwajFlGB0iO0fz1905hDbSMYhtonMxC+tWiDjpVV/PH9likNsIxkvrQpkHGIbyXhpVSLjAK9wb5r5ENsFMgOZQMYOnMh4cWu6AtuBExk7cCJjBw5kZj7EdoGMHTiR8eLWRMbhBYnMQCaQcXhBImMHTmTswImMHTiRsQMHMg6xTRbCIbaRDA+cyPDAicxwBQ5XYDtwImMHTmTswImMHTiRsQM/J3Oa+RDbBTI8cCLDAycyPHAiM5AJZOzAiYwdOJGxAycyE+/An1qI08yH2H5OZuZDbBfI8MCJjB04XIEnPsR2icxAJpCxAycyduBExg6cyPDAiQwPHMhMfGzrEhkeOJGxAycyduBEZiATyNiBExnvhQgWYuKzR5fI8MCJDA8cyEx86OfCFXjiczyXyNiBExk7cCIzkAlk7MCJDA+cyPDAiQwPnMjwwIHMxEdGLpGxAycyduBExg6cyAwW4rmFmPhExSUyPHAiwwMnMnbgdAW2AwcyEx84uETGDpzI2IETGTtwIjOQCWR44ESGB05keOBExg6cyNiBA5mJj6tbImMHTmS8Gy1YCOfERTIDmUCGB05k7MDpCmwHTmTswImMHTiQcU5cJGMHTmR44ESGB05kBjKBDA+cyNiBExk7cCJjB05k7MCBzMznxH1uIWY+J26BDA+cyPDAicxwBQ5XYDtwImMHTmTswImMHTiRsQMHMjOfE7dAhgdOZHjgRIYHTmQGMoGMHTiRsQMnMnbgRMa70YKFmPmcuE/JnGc+J26BDA+cyNiBn1+Bz86Ji2QGMoGMHTiRsQMnMnbgRIYHTmR44EBm5nPiFsjwwImMHTiRsQMnMgOZQMYOnMh4N1qwEDOfE7dAhgdOZHjgQMY5cekK7Jy4SMYOnMjYgROZgUwgYwdOZHjgRIYHTmR44ESGBw5knBMXydiBExk7cCJjB05kBgvx3ELMfE7cAhkeOJHhgRMZO3C6AtuBAxnnxEUyduBExg6cyNiBE5mBTCDDAycyPHAiwwMnMnbgRMYOHMg4Jy6SsQMnMt6NFizEzOfELZAZyAQyPHAiYwdOV2A7cCJjB05k7MCBjHPiIhk7cCLDAycyPHAiM5AJZHjgRMYOnMjYgRMZO3AiYwcOZGY+J+5zCzHzOXELZHjgRIYHTmSGK3C4AtuBExk7cCJjB05k7MCJjB04kJn5nLgFMjxwIsMDJzI8cCIzkAlk7MCJjB04kbEDJzLejRYsxMznxH1OZuZz4hbI8MCJjB04XIGdExfJDGQCGTtwImMHTmTswIkMD5zI8MDPyYyZz4lbIMMDJzJ24ETGDpzIDGQCGTtwIuPdaM8txJj5nLgFMjxwIsMDBzLOiUtXYOfERTJ24ETGDpzIDGQCGTtwIsMDJzI8cCLDAycyPHAg45y4SMYOnMjYgRMZO3AiM1iI5xZi5nPiFsjwwIkMD5zI2IHTFdgOHMg4Jy6SsQMnMnbgRMYOnMgMZAIZHjiR4YETGR44kbEDJzJ24EDGOXGRjB04kfFutGAhZj4nboHMQCaQ4YETGTtwugLbgRMZO3AiYwcOZJwTF8nYgRMZHjiR4YETmYFMIMMDJzJ24ETGDpzI2IETGTtwIDPzOXGfW4iZz4lbIMMDJzI8cCIzXIHDFdgOnMjYgRMZO3AiYwdOZOzAgczM58QtkOGBExkeOJHhgROZgUwgYwdOZOzAiYwdOJHxbrRgIWY+J+5zMjOfE7dAhgdOZOzA4QrsnLhIZiATyNiBExk7cCJjB05keOBEhgcOZGY+J26BDA+cyNiBExk7cCIzkAlk7MCJjHejBQsx8zlxC2R44ESGB35O5uKcuHAFvjgnLpKxAycyduBEZiATyNiBExkeOJHhgRMZHjiR4YEDGefERTJ24ETGDpzI2IETmcFCPLcQM58Tt0CGB05keOBExg6crsB24EDGOXGRjB04kbEDJzJ24ERmIBPI8MCJDA+cyPDAiYwdOJGxAwcyzomLZOzAiYx3owULMfM5cQtkBjKBDA+cyNiB0xXYDpzI2IETGTtwIOOcuEjGDpzI8MCJDA+cyAxkAhkeOJGxAycyduBExg6cyNiBA5mZz4n73ELMfE7cAhkeOJHhgROZ4QocrsB24ETGDpzI2IETGTtwImMHDmRmPidugQwPnMjwwIkMD5zIDGQCGTtwImMHTmTswImMd6MFCzHzOXGfk5n5nLgFMjxwImMHDldg58RFMgOZQMYOnMjYgRMZO3AiwwMnMjxwIDPzOXELZHjgRMYOnMjYgROZgUwgYwdOZLwbLViImc+JWyDDAycyPHAg45y4dAV2TlwkYwdOZOzAicxAJpCxAycyPHAiwwMnMjxwIsMDPydzdU5cJGMHTmTswImMHTiRGSzEUwtxnfmcuAUyPHAiwwMnMnbgdAW2AwcyzomLZOzAiYwdOJGxAycyA5lAhgdOZHjgRIYHTmTswImMHTiQcU5cJGMHTmS8Gy1YiJnPiVsgM5AJZHjgRMYOnK7AduBExg6cyNiBAxnnxEUyduBEhgdOZHjgRGYgE8jwwImMHTiRsQMnMnbgRMYOHMjMfE7c5xZi5nPiFsjwwIkMD5zIDFfgcAW2AycyduBExg6cyNiBExk7cCAz8zlxC2R44ESGB05keOBEZiATyNiBExk7cCJjB05kvBstWIiZz4n7nMzM58QtkOGBExk7cLgCOycukhnIBDJ24ETGDpzI2IETGR44keGBA5mZz4lbIMMDJzJ24ETGDpzIDGQCGTtwIuPdaMFCzHxO3AIZHjiRsQOH64xz4iIZO3AiYwdOZOzAicxAJpDxXohw13ZOXCRjB05keOB0nbEDBzLOiYtk7MCJjB04kbEDJzLDXfv5XXvmc+IWyNiBExk7cCJjB05XYDvwczI358RFMnbgRMYOnMjYgROZgUwg43chEhm/D5zI+H3gRMYOnMjMuwPfPr7j23+efyEz8Tlxp8vtnczp9jcyv374Mg7vP8hlnMavGOddmEsxzrtdl2KcdxUvxThgrMA475JfinHeRlCKcd76UIpx3q5RinHeYlKJceKT/koxajElGLWYEoxaTAnGAWMFRi2mBKMWU4JRiynBqMWUYNRiKjBOfFZjKUYtpgSjFlOCUYspwThgrMCoxZRg1GJKMGoxJRi1mBKMWkwFxolP2yzFqMWUYNRiSjBqMSUYB4wVGLWYEoxaTAlGLaYEoxZTglGLqcA48XmppRi1mBKMWkwJRi2mBOOAsQKjFlOCUYspwajFlGDUYkowOsT2j6cvOrs5xDaScYhtIjPxS6sWyHhp1R/PX5niENtIxkurEhkvrUpkvLQqkXGAV7o32YEDmZkPsV0gYwdOZLy4NVyBHWIbyQxkAhk7cCJjB05k7MCJjBe3JjIOLwhkHGIbyTi8IJGxAycyduBEZiATyNiBExkHeAUL4RDbSIYHTmR44EDGIbbpCuwQ20jGDpzI2IETmYFMIGMHTmR44ESGB05keOBEhgd+TubuENtIxg6cyNiBExk7cCIzWIinFuI+8yG2C2R44ESGB05k7MDpCmwHDmQmPsR2iYwdOJGxAycyduBEZiATyPDAiQwPnMjwwImMHTiRsQMHMhMfgbpExg6cyHgvRLAQE589ukRmIBPI8MCJjB04XYHtwImMHTiRsQMHMhMfoLlExg6cyPDAiQwPnMgMZAIZHjiRsQMnMnbgRMYOnMjYgQOZiY9fXLAQE5+ouESGB05keOBEZrgChyuwHTiRsQMnMnbgRMYOnMjYgQOZiQ/vWyLDAycyPHAiwwMnMgOZQMYOnMjYgRMZO3Ai491owUI4Jy6RcU5cJMMDJzJ24HAFdk5cJDOQCWTswImMHTiRsQMnMjxwIsMDBzIznxO3QIYHTmTswImMHTiRGcgEMnbgRMa70YKFmPmcuAUyPHAiwwMHMs6JS1dg58RFMnbgRMYOnMgMZAIZO3AiwwMnMjxwIsMDJzI8cCDjnLhIxg6cyNiBExk7cCIzWIjnFmLmc+IWyPDAiQwPnMjYgdMV2A78nMzDOXGRjB04kbEDJzJ24ERmIBPI8MCJDA+cyPDAiYwdOJGxAwcyzomLZOzAiYx3oz23EI+Zz4lbIDOQCWR44ETGDpyuwHbgRMYOnMjYgQMZ58RFMnbgRIYHTmR44ERmIBPI8MCJjB04kbEDJzJ24ETGDhzIzHxO3OcWYuZz4hbI8MCJDA+cyAxX4HAFtgMnMnbgRMYOnMjYgRMZO3AgM/M5cQtkeOBEhgdOZHjgRGYgE8jYgRMZO3AiYwdOZLwbLViImc+J+5zMzOfELZDhgRMZO3C4AjsnLpIZyAQyduBExg6cyNiBExkeOJHhgQOZmc+JWyDDAycyduBExg6cyAxkAhk7cCLj3WjBQsx8TtwCGR44keGBAxnnxKUrsHPiIhk7cCJjB05kBjKBjB04keGBExkeOJHhgRMZHjiQcU5cJGMHTmTswImMHTiRGSzEcwsx8zlxC2R44ESGB05k7MDpCmwHDmScExfJ2IETGTtwImMHTmQGMoEMD5zI8MCJDA+cyNiBExk78FMy54Nz4iIZO3Ai491oTy3EGxnvRktkBjKBDA+cyNiB0xXYDpzI2IETGTtwIOOcuEjGDpzI8MCJDA+cyAxkAhkeOJGxAycyduBExg6cyNiBA5mZz4n73ELMfE7cAhkeOJHhgROZ4QocrsB24ETGDpzI2IETGTtwImMHDmRmPidugQwPnMjwwIkMD5zIDGQCGTtwImMHTmTswImMd6MFCzHzOXGfk5n5nLgFMjxwImMHDldg58RFMgOZQMYOnMjYgRMZO3AiwwMnMjxwIDPzOXELZHjgRMYOnMjYgROZgUwgYwdOZLwbLViImc+JWyDDAycyPHAg45y4dAV2TlwkYwdOZOzAicxAJpCxAycyPHAiwwMnMjxwIsMDBzLOiYtk7MCJjB04kbEDJzKDhXhuIWY+J26BDA+cyPDAiYwdOF2B7cCBjHPiIhk7cCJjB05k7MCJzEAmkOGBExkeOJHhgRMZO3AiYwcOZJwTF8nYgRMZ70YLFmLmc+IWyAxkAhkeOJGxA6crsB04kbEDJzJ24Odkjs6Ji2TswIkMD5zI8MCJzEAmkOGBExk7cCJjB05k7MCJjB04kJn5nLhPLcRx5nPiFsjwwIkMD5zIDFfgcAW2AycyduBExg6cyNiBExk7cCAz8zlxC2R44ESGB05keOBEZiATyNiBExk7cCJjB05kvBstWIiZz4n7nMzM58QtkOGBExk7cLgCOycukhnIBDJ24ETGDpzI2IETGR44keGBA5mZz4lbIMMDJzJ24ETGDpzIDGQCGTtwIuPdaMFCzHxO3AIZHjiR4YEDGefEpSuwc+IiGTtwImMHTmQGMoGMHTiR4YETGR44keGBExkeOJBxTlwkYwdOZOzAiYwdOJEZLMRzCzHzOXELZHjgRIYHTmTswOkKbAcOZJwTF8nYgRMZO3AiYwdOZAYygQwPnMjwwIkMD5zI2IETGTtwIOOcuEjGDpzIeDdasBAznxO3QGYgE8jwwImMHThdge3AiYwdOJGxAwcyzomLZOzAiQwPnMjwwInMQCaQ4YETGTtwImMHTmTswImMHfg5mdPM58R9aiFOM58Tt0CGB05keOBEZrgChyuwHTiRsQMnMnbgRMYOnMjYgQOZmc+JWyDDAycyPHAiwwMnMgOZQMYOnMjYgRMZO3Ai491owULMfE7c52RmPidugQwPnMjYgcMV2DlxkcxAJpCxAycyduBExg6cyPDAiQwPHMjMfE7cAhkeOJGxAycyduBEZiATyNiBExnvRgsWYuZz4hbI8MCJDA8cyDgnLl2BnRMXydiBExk7cCIzkAlk7MCJDA+cyPDAiQwPnMjwwIGMc+IiGTtwImMHTmTswInMYCGeW4iZz4lbIMMDJzI8cCJjB05XYDtwIOOcuEjGDpzI2IETGTtwIjOQCWR44ESGB05keOBExg6cyNiBAxnnxEUyduBExrvRgoWY+Zy4BTIDmUDGDpyuM3bgRMYOnMjYgRMZO3Ag45y4SMZ7IcJd2zlxkYwdOJEZrjPhOmMHTmTswImMHTiRsQMnMnbgQGbmc+I+v2vPfE7cAhk7cCJjB05khitwuALbgRMZO3AiYwdOZOzAiYwd+DmZ88znxC2Q8bsQiYzfB05k/D5wIjOQCWTm3YFvH9/x7T/Pv5LpvQMfr4f3n+M0zgufvh/ef+j7+fDTZ6/PfubTR5/814FEf/v0n2B6r8D/HJjz7f3D5/Pjvojx/GMYb9cf4/X4i2LvdbkLxfP46dPnXyn2Xq3/OYrjeHv/occ4LXx6jOPp/VL39n9+UBzP/ujb9eOPvh/PP3/438ibn2v3LZHfHx9T/niGvHcZ2CXy3i1jl8h715ddIh+Qb428d+HaJfJZm9wLkc/aEV+IfNZC+ULkO2qfj4+i/bheFyBezu8/8+X+85/7jOHlcvr47O3HZ2+3/4Xq2fw4ye/He2G+mx9SuT/eOyqd34L3jhrnt+A98N6U94665rfgvaOi+S1476hlfgveO6qY34K3frnI+3p8/5GvP5f/p7zvt/cf+H6//PjsuP2Ju/lJrd8O9+ODxeM+/ob7iZc5Xd6r/zjd/vbbOE9+4HF4/7WgyziNnz/8Z5B6606CVIh3EqSmvZMghyD3ESQ3sJMgSYedBMlm7CRImmQnQfIv+wiy+fnjgvxykMzOToJkdnYSJLOzkyCHIPcRJLOzkyCZnZ0EyezsJEhmZydBMjv7CPLC7OwkSGZnJ0EyOzsJktnZSZBDkPsIktnZSZDMzk6CZHZ2EiSzs5MgmZ19BHlldnYSJLOzkyCZnZ0EyezsJMghyH0EyezsJEhmZydBMjs7CZLZ2UmQzM4+grwxOzsJktnZSZDMzk6CZHZ2EuQQ5D6CZHZ2EiSzs5MgmZ2dBMns7CRIZmcfQd6ZndcFef04t3tcT4dfsyFr+mbDv/TNhlLpm82QzeuyuVw+srk9yYb46JsNl9E3G3qibzaMQ99sSIS2e9qDF+ibDS/QNxteoG82vEDbXeAxZNM2G16gbza8QN9seIG+2fACfbPhBbpm8wZbNm2z4QX6ZsML9M2GF+ibzZBN22x4gb7Z8AJ9s+EFuj4jGAdeoG82vEDbbI68QN9seIG2u8CRF+ibDS/QN5shm7bZ8AJ9s+EF+mbDC/TNhhfomw0v0DabEy/QNxteoG82vEDfbHiBvtkM2bTNhhdo+4zgxAv0zYYX6JsNL9A3G16g7S5w5gX6ZsML9M2GF+ibDS/QN5shm7bZ8AJ9s+EF+mbDC/TNhhfomw0v0DabwQv0zYYX6JsNL9A3G16g7TOCMWTTNhteoG82vEDfbHiBvrsAL9A3G16gbTYXXqBvNrxA32x4gb7Z8AJ9sxmyaZsNL9A3G16gbza8QN9seIG+2fACbbO58gJ9s+EF2j4juPICfbPhBfpmM2TTNhteoO8uwAv0zYYX6JsNL9A3G16gbTY3XqBvNrxA32x4gb7Z8AJ9sxmyaZsNL9A3G16gbza8QN9seIG+2fACbZ8R3HmBvtnwAn2z4QX6ZsMLtN0F7kM2bbPhBfpmwwv0zYYX6JsNL9A3G16gbTYPXqBvNrxA32x4gb7Z8AJ9sxmyaZsNL9A3G16gbza8QNtnBA9eoG82vEDXbC4HXqBvNrxA113gcuAF+mbDC/TNZsimbTa8QN9seIG+2fACfbPhBfpmwwu0zebIC/TNhhfomw0v0DcbXqBvNkM2bbPhBdo+IzjyAn2z4QX6ZsML9M2GF2i7C5x4gb7Z8AJ9s+EF+mbDC/TNZsimbTa8QN9seIG+2fACfbPhBfpmwwu0zebMC/TNhhfomw0v0DcbXqDtM4LzkE3bbHiBvtnwAn2z4QX67gK8QN9seIG22QxeoG82vEDfbHiBvtnwAn2zGbJpmw0v0DcbXqBvNrxA32x4gb7Z8AJts7nwAn2z4QXaPiO48AJ9s+EF+mYzZNM2G16g7y7AC/TNhhfomw0v0DcbXqBtNldeoG82vEDfbHiBvtnwAn2zGbJpmw0v0DcbXqBvNrxA32x4gb7Z8AJtnxHceIG+2fACfbPhBfpmwwu03QVuQzZts+EF+mbDC/TNhhfomw0v0DcbXqBtNndeoG82vEDfbHiBvtnwAn2zGbJpmw0v0DcbXqBvNrxA22cEd16gbza8QNtsHrxA32x4gba7wIMX6JsNL9A3myGbttnwAn2z4QX6ZsML9M2GF+ibDS/QNZvrgRfomw0v0DcbXqBvNrxA32yGbNpmwwt0fUZwPfACfbPhBfpmwwv0zYYXaLsLHHmBvtnwAn2z4QX6ZsML9M1myKZtNrxA32x4gb7Z8AJ9s+EF+mbDC7TN5sQL9M2GF+ibDS/QNxteoO0zgtOQTdtseIG+2fACfbPhBfruArxA32x4gbbZnHmBvtnwAn2z4QX6ZsML9M1myKZtNrxA32x4gb7Z8AJ9s+EF+mbDC7TNZvACfbPhBdo+Ixi8QN9seIG+2QzZtM2GF+i7C/ACfbPhBfpmwwv0zYYXaJvNhRfomw0v0DcbXqBvNrxA32yGbNpmwwv0zYYX6JsNL9A3G16gbza8QNtnBFdeoG82vEDfbHiBvtnwAm13geuQTdtseIG+2fACfbPhBfpmwwv0zYYXaJvNjRfomw0v0DcbXqBvNrxA32yGbNpmwwv0zYYX6JsNL9D2GcGNF+ibDS/QNps7L9A3G16g7S5w5wX6ZsML9M1myKZtNrxA32x4gb7Z8AJ9s+EF+mbDC7TN5sEL9M2GF+ibDS/QNxteoG82QzZts+EF2j4jePACfbPhBfpmwwv0zYYX6LoL3A68QN9seIG+2fACfbPhBfpmM2TTNhteoG82vEDfbHiBvtnwAn2z4QXaZnPkBfpmwwv0zYYX6JsNL9D1GcHtOGTTNhteoG82vEDfbHiBvrsAL9A3G16gbTYnXqBvNrxA32x4gb7Z8AJ9sxmyaZsNL9A3G16gbza8QN9seIG+2fACbbM58wJ9s+EF2j4jOPMCfbPhBfpmM2TTNhteoO8uwAv0zYYX6JsNL9A3G16gbTaDF+ibDS/QNxteoG82vEDfbIZs2mbDC/TNhhfomw0v0DcbXqBvNrxA22cEF16gbza8QN9seIG+2fACbXeBy5BN22x4gb7Z8AJ9s+EF+mbDC/TNhhdom82VF+ibDS/QNxteoG82vEDfbIZs2mbDC/TNhhfomw0v0PYZwZUX6JsNL9A2mxsv0DcbXqDtLnDjBfpmwwv0zWbIpm02vEDfbHiBvtnwAn2z4QX6ZsMLtM3mzgv0zYYX6JsNL9A3G16gbzZDNm2z4QXaPiO48wJ9s+EF+mbDC/TNhhdouws8eIG+2fACfbPhBfpmwwv0zWbIpm02vEDfbHiBvtnwAn2z4QX6ZsMLdM3mfuAF+mbDC/TNhhfomw0v0PUZwf0wZNM2G16gbza8QN9seIG+uwAv0DcbXqBtNkdeoG82vEDfbHiBvtnwAn2zGbJpmw0v0DcbXqBvNrxA32x4gb7Z8AJtsznxAn2z4QXaPiM48QJ9s+EF+mYzZNM2G16g7y7AC/TNhhfomw0v0DcbXqBtNmdeoG82vEDfbHiBvtnwAn2zGbJpmw0v0DcbXqBvNrxA32x4gb7Z8AJtnxEMXqBvNrxA32x4gb7Z8AJtd4ExZNM2G16gbza8QN9seIG+2fACfbPhBdpmc+EF+mbDC/TNhhfomw0v0DebIZu22fACfbPhBfpmwwu0fUZw4QX6ZsMLtM3mygv0zYYXaLsLXHmBvtnwAn2zGbJpmw0v0DcbXqBvNrxA32x4gb7Z8AJts7nxAn2z4QX6ZsML9M2GF+ibzZBN22x4gbbPCG68QN9seIG+2fACfbPhBdruAndeoG82vEDfbHiBvtnwAn2zGbJpmw0v0DcbXqBvNrxA32x4gb7Z8AJts3nwAn2z4QX6ZsML9M2GF2j7jOAxZNM2G16gbza8QN/7DS/QNxteoG82vEDXbB4HXqBvNrxA32x4ga479OPAC/TNZsimbTa8QN/7DS/QNxteoG82vEDfbHiBttkceYG+2fACbXfoIy/QNxteoG82QzZts+EF+u4CvEDfbHiBvtnwAn2z4QXaZnPiBfpmwwv0zYYX6JsNL9A3myGbttnwAn2z4QVel83tg/Lbf55/zYYXKM3mOM7v/1s4vrnMhXSul8P7j3G9nI8/p/ME8/3+rkb/9W9Bf3z4GYvz5ePnOF/G8ecP/5k75zBn7nzGlLmfuZI5c+dh9pn79fIRyvU2fs2d45kzd/5op7k/zh+hHO4LHz59/BLF+XS8fv7h0/X6keD1vvDht37/3iYfv5bJ8zB8hu9Vw8cAGr7fG77b4fGe4O18WjV8FKfhe9nwcbiG7/eG73E5vSf4eBwXPnz6yOR0uo5Vk8o6m9TvMak8uUn9Jyf1/hH3+bCq9wxm36R+j0n1LMKknt+i+JjUy8KffLo8xoceOv76dGt4ymGifm+i6oTj8KjF8L1s+IbhM3yvGj6PWgzf7w1fne0eHrUYvpcNn0cthu/3hu9++nDS9399q/+5wnokYqJqJ8qjCxNVOlEXjxhMVO1EeRRgon5von7rodXh8fHh4/H86/h5bmD8Xjh+nhwYv39w/Op+DeoyTKpJ/RaT6pmESf0ek+oBhkn9Jye17Bf2Lp52mNTvMameopjU8/n4keD5sraje4piokon6uopion6vYmqKx1XD1wM38uGz+MWw/ey4fOwxfD95vCV9dLrMHyG71XD55HIPofvdn18hHIfS/rud/5l+MK/t716dGGiXvWCv6unEYbvZcPnAYPhe9nweRZh+F71dsmbxxaG72XD57GF4fu94Vv4l0c3zyJMVO1EecBgomonapgoE1U6UR4FmKh/8CWxC7/6dvPcwPi9cPw8OTB+3+LYgZvHDCb1e0yqZxIm9VtM6t0DDJP6LQ7IuHvaYVK/x6R6imJSX/X6+bsHLobvZcM3DJ/he9Hr5+8e4xi+lw2fhziG71u8Ye3ueY9J/R6T6nmPSf0Wb1i7e95jUr/FpD487zGppW9ue3guY6JqJ8rzExP1qjdiPTw/MXwvG75h+Azfq4bP8xPD96rXsT08PzF8Lxs+j0Rqh+/+8Vz1eP9XHj8N35/Amf2NgRPUWwJ/A8izbgychvzngB/vT4CzdBsDZ6Y2Bj4A3xY4A7ExcK17Y+Ca5sZroaa5MXBNc1vgR01zY+Ca5sbANc2NgWuaGwMfgG8LXNPcGLimuTFwTXNj4JrmZr/B8CdwTXNb4CdNc2PgmubGwDXNjYFrmovAb5f33137297xFPh1fPwe3/Wn33O7j79wD7i3xK1lbopbx9wUt4a5KW79clPc2uWWuM+65aa4NctNceuVm+LWKjfFPeDeErdWuSlurXJT3Frlpri1yk1xa5Vb4h5a5aa4tcpNcWuVm+LWKjfFPeDeErdWuSlurXJT3Frlpri1yk1xa5Vb4r5olZvi1io3xa1Vbopbq9wU94B7S9xa5aa4tcpNcWuVm+LWKjfFrVVuifuqVW6KW6vcFLdWuSlurXJT3APuLXFrlZvi1io3xa1Vbopbq9wUt1a5Je6bVrkpbq1yU9xa5aa4tcpNcQ+4t8StVW6KW6vcFLdWuSlurXJT3FrllrjvWuWmuLXKTXFrlYu4Hx8Hhj8uhwXcx7cnCO8/8eEnGuenX+/Hsd7H8+H++YfPx8PpHfO/Tzb/8eE/k1RY95LkkOROklSz95KkBr+XJMmBvSTJO+wlSUpjJ0k+2JK9JEnE7CVJjmcvSXI8e0lySHInSXI8e0mS49lLkhzPXpLkePaSJMezjySPB45nL0lyPHtJkuPZS5Icz16SHJLcSZIcz16S5Hj2kiTHs5ckOZ69JMnx7CTJI8ezlyQ5nr0kyfHsJUmOZy9JDknuJEmOZy9JcjzfJcnzx49xPv/r+3/24ev1/vjrw9fb6fBr7ITQlLGzR1PGTjXNGPuJl5oydhJrytgZryljp8emjH2IfcbYibcpY2fppoydpZsydpZuythZuhljP7N0U8bO0k0ZO0s3Zews3ZSxD7HPGDtLN2XsLN2UsbN0U8bO0k0ZO0s3Y+yDpZsydpZuythZuiljZ+mmjH2IfcbYWbopY2fppoydpZsydpZuythZuu8S+7iNd8yX0/nzD9/GuP314dv4+4z8O/YLSzdl7CzdlLGzdFPGztJNGfsQ+4yxs3RTxs7STRk7Szdl7CzdlLGzdDPGfmXppoydpZsydpZuythZuiljH2KfMXaWbsrYWbopY2fppoydpZsydpZuxthvLN2UsbN0U8bO0k0ZO0s3ZexD7DPGztJNGTtLN2XsLN2UsbN0U8bO0s0Y+52l+yaxj8vl/cPjenySJPG2lyS5tL0kSY/tJckhyZ0kSWLtJUleai9JUk17SZI92kuShNBOknxwPHtJkuPZS5Icz16S5Hj2kuSQ5E6S5Hj2kiTHs5ckOZ69JMnx7CVJjmcfSZ4OHM9ekuR49pIkx7OXJDmevSQ5JLmTJDmevSTJ8ewlSY5nL0lyPHtJkuPZSZJHjmcvSXI8e0mS49lLkhzPXpIcktxJkhzPXpLkePaSJMezlyQ5nr0kyfHsJMkTx7OXJDme75Lk9faR5O288OH7W2p/ffh+vR5/jZ0QmjJ29mjK2IfYZ4ydl5oydhJrytgZryljp8emjJ1LmzH2M/E2Zews3ZSxs3RTxs7STRn7EPuMsbN0U8bO0k0ZO0s3Zews3ZSxs3Qzxj5YuiljZ+mmjJ2lmzJ2lm7K2IfYZ4ydpZsydpZuythZuiljZ+mmjJ2lmzH2C0s3Zews3ZSxs3RTxs7STRn7EPuMsbN0U8bO0k0ZO0s3Zews3ZSxs3Qzxn5l6aaMnaWbMnaWbsrYWbopYx9inzF2lm7K2Fm6KWNn6aaMnaWbMnaWbsbYbyzdlLGzdFPGztJNGTtLN2XsQ+wzxs7STRk7Szdl7CzdLmN/3D5+5sPh8WvsLN2UsbN0M8Z+Z+m+S+y3y/Ej9vvx8w8/Tvfb+898Pi58+HL8AeN4Gb/OCKVnRpZmhP8zI0szQhaakaUZGWbEjCzMCA1pRpZmhLM0I0szQnCakaUZYUPNyNKMUKdmZGFGHjyrGVmaEZ7VjCzNCM9qRpZmhGc1I0szMsyIGVmYEZ7VjCzNCM9qRpZmhGc1I0szwrOakaUZ4VnNyOczcj7wrGZkaUZ4VjOyNCM8qxlZmhGe1YwszcgwI2ZkYUZ4VjOyNCM8qxlZmhGe1YwszQjPakaWZoRnNSMLM3LkWc3I0ozwrGZkaUZ4VjOyNCM8qxlZmpFhRszIwozwrGZkaUZ4VjOyNCM8qxlZmhGe1YwszQjPakYWZuTEs5qRpRnhWc3I0ozwrGZkaUZ4VjOyNCPDjJiRhRnhWc3I0ozwrGZkaUZ4VjOyNCM8qxlZmhGe1YwszMiZZzUjSzPCs5qRpRnhWc3I0ozwrGZkaUaGGTEjCzPCs5qRpRnhWc3I0ozwrGZkaUZ4VjOyNCM8qxlZmJHBs5qRpRnhWc3I0ozwrGZkaUZ4VjOyNCPDjJiRhRnhWc3I0ozwrGZkaUZ4VjOyNCM8qxlZmhGe1YwszMiFZzUjSzPCs5qRpRnhWc3I0ozwrGZkaUaGGTEjCzPCs5qRpRnhWc3I0ozwrGZkaUZ4VjOyNCM8qxlZmJErz2pGlmaEZzUjSzPCs5qRpRnhWc3I0owMM2JGFmaEZzUjSzPCs5qRpRnhWc3I0ozwrGZkaUZ4VjOyMCM3ntWMLM0Iz2pGlmaEZzUjSzPCs5qRpRkZZsSMLMwIz2pGlmaEZzUjSzPCs5qRpRnhWc3I0ozwrGZkYUbuPKsZWZoRntWMLM0Iz2pGlmaEZzUjSzMyzIgZWZgRntWMLM0Iz2pGlmaEZzUjSzPCs5qRpRnhWfc5Ix+ZvM3I45fYH9TplLGzoVPGTnBOGTtnOWXsQ+wzxs4sThk7WThl7PzflLFTelPGztLtMvZxPL3/zGPcPv/w6XG+vGfyuPz4k09PwR0+RuNyeDx+/vC/BuptQgyUgaocKGbRQJUOFGdpoEoHig01UKUDNQyUgaocKAbXQJUOFDdsoEoHinU2UKUDxWcbqNKBYsoNVOVAHZlyA1U6UEy5gSodKKbcQJUOFFNuoEoHahgoA1U5UEy5gSodKKbcQJUOFFNuoEoHiik3UKUDxZQbqMqBOjHlBqp0oJhyA1U6UEy5gSodKKbcQJUO1DBQBqpyoJhyA1U6UEy5gSodKKbcQJUOFFNuoEoHiik3UJUDdWbKDVTpQDHlBqp0oJhyA1U6UEy5gSodqGGgDFTlQDHlBqp0oJhyA1U6UEy5gSodKKbcQJUOFFNuoCoHajDlBqp0oJhyA1U6UEy5gSodKKbcQJUO1DBQBqpyoJhyA1U6UEy5gSodKKbcQJUOFFNuoEoHiik3UJUDdWHKDVTpQDHlBqp0oJhyA1U6UEy5gSodqGGgDFTlQE1qym+P9x/jfrovDNQ4XW7vUZ5u5wXg4/A+UZdxGr8Cn9Qkvw74pKb1dcAnNZGvAz6pqXsZ8OukJut1wCc1Pa8DPqkJeR3wSU3B64APwLcFrmluDFzT3Bi4prkxcE1zY+Ca5rbAb5rmxsA1zY2Ba5obA9c0NwY+AN8WuKa5MXBNc2PgmubGwDXNjYFrmtsCv2uaGwPXNDcGrmluDFzT3Bj4AHxb4JrmxsA1zY2Ba5obA9c0NwauaW4L/KFpbgxc09wYuKa5MXBNc2PgA/BtgWuaGwPXNDcGrmluDFzT3Bi4prkp8MtB09wYuKa5MXBNc2PgmubGwAfgi8Cvh/EO/Ho6/MpQeVzPUB9cz1DFW89Qa/sCw8vlg+HtCUNFbDXDo261nqG6tJ6hBrSeoVKz+r58HBiuZqinrGeop6xnqKesv6foKesZ6imrGZ70lPUM9ZT1DPWU9Qz1lPUMB4arGeop6xnqKesZ6inrGeop6xnqKasZnvWU9Qz1lNXu66ynrGeop6xnODBczVBPWX9P0VPWM9RT1jPUU9Yz1FNWMxx6ynqGesp6hnrKeoZ6ynqGA8PVDPWU9Qz1lPUM9ZT1DPWU9Qz1lNXu66KnrGeop6xnqKesZ6inrL6nXAaGqxnqKesZ6inrGeop6xnqKesZ6imrGV71lPUM9ZT1DPWU9Qz1lPUMB4arGeop6xnqKesZ6imr3ddVT1nPUE9ZzfCmp6xnqKesvqfc9JT1DPWU9QwHhqsZ6inrGeop6xnqKesZ6inrGeopqxne9ZT1DPWU9Qz1lPUM9ZT1DAeGqxnqKavd111PWc9QT1nPUE9Zz1BPWX1Peegp6xnqKesZ6inrGeop6xkODFcz1FPWM9RT1jPUU9Yz1FPWM9RT1jK8HvSU9Qz1lPUM9ZT1DPWUte7r7f8Xw9UM9ZT1DPWU9Qz1lPX3FD1lPUM9ZTVD59EXMNRT1jPUU9Yz1FPWMxwYrmaop6xnqKesZ6inrGeop6xnqKesZug8+gKGespq9+U8+gKGesp6hgPD1Qz1lPX3FD1lPUM9ZT1DPWU9Qz1lNUPn0Rcw1FPWM9RT1jPUU9YzHBiuZqinrGeop6xnqKesZ6inrGeop6x2X86jL2Cop6xnqKesZ6inrL6nOI++gKGesp6hnrKeoZ6ynqGesp6hnrKaofPoCxjqKesZ6inrGeop6xkODFcz1FPWM9RT1jPUU1a7L+fRFzDUU1YzdB59AUM9ZfU9xXn0BQz1lPUMB4arGeop6xnqKesZ6inrGeop6xnqKasZOo++gKGesp6hnrKeoZ6ynuHAcDVDPWW1+3IefQFDPWU9Qz1lPUM9ZfU9xXn0BQz1lPUM9ZT1DPWU9QwHhqsZ6inrGeop6xnqKesZ6inrGeopqxk6j76AoZ6ynqGesp6hnrLafTmPvoChnrKeoZ6ynqGesv6eoqesZ6inrGV4cx59AUM9ZT1DPWU9Qz1lPcOB4WqGesp6hnrKeoZ6ynqGesp6hnrKaobOoy9gqKesdV8359EXMNRT1jMcGK5mqKesv6foKesZ6inrGeop6xnqKasZOo++gKGesp6hnrKeoZ6ynuHAcDVDPWU9Qz1lPUM9ZT1DPWU9Qz1ltftyHn0BQz1lPUM9ZT1DPWX1PcV59AUM9ZT1DPWU9Qz1lPUM9ZT1DPWU1QydR1/AUE9Zz1BPWc9QT1nPcGC4mqGesp6hnrKeoZ6y2n05j76AoZ6ymqHz6AsY6imr7ynOoy9gqKesZzgwXM1QT1nPUE9Zz1BPWc9QT1nPUE9ZzdB59AUM9ZT1DPWU9Qz1lPUMB4arGeopq92X8+gLGOop6xnqKesZ6imr7ynOoy9gqKesZ6inrGeop6xnODBczVBPWc9QT1nPUE9Zz1BPWc9QT1nN0Hn0BQz1lPUM9ZT1DPWU1e7LefQFDPWU9Qz1lPUM9ZT19xQ9ZT1DPWU1Q+fRFzDUU9Yz1FPWM9RT1jMcGK5mqKesZ6inrGeop6xnqKesZ6inrGV4dx59AUM9Za37ujuPvoChnrKe4cBwNUM9Zf09RU9Zz1BPWc9QT1nPUE9ZzdB59AUM9ZT1DPWU9Qz1lPUMB4arGeop6xnqKesZ6inrGeop6xnqKavdl/PoCxjqKesZ6inrGeopq+8pzqMvYKinrGeop6xnqKesZ6inrGeop6xm6Dz6AoZ6ynqGesp6hnrKeoYDw9UM9ZT1DPWU9Qz1lNXuy3n0BQz1lNUMnUdfwFBPWX1PcR59AUM9ZT3DgeFqhnrKeoZ6ynqGesp6hnrKeoZ6ymqGzqMvYKinrGeop6xnqKesZzgwXM1QT1ntvpxHX8BQT1nPUE9Zz1BPWX1PcR59AUM9ZT1DPWU9Qz1lPcOB4WqGesp6hnrKeoZ6ynqGesp6hnrKaobOoy9gqKesZ6inrGeop6x2X86jL2Cop6xnqKesZ6inrL+n6CnrGeopqxk6j76AoZ6ynqGesp6hnrKe4cBwNUM9ZT1DPWU9Qz1lPUM9ZT1DPWU1Q+fRFzDUU1a7L+fRFzDUU9YzHBiuZqinrL+n6CnrGeop6xnqKesZ6ilrGT6cR1/AUE9Zz1BPWc9QT1nPcGC4mqGesp6hnrKeoZ6ynqGesp6hnrLWfT2cR1/AUE9Zz1BPWc9QT1l9T3EefQFDPWU9Qz1lPUM9ZT1DPWU9Qz1lNUPn0Rcw1FPWM9RT1jPUU9YzHBiuZqinrGeop6xnqKesdl/Ooy9gqKesZug8+gKGesrqe4rz6AsY6inrGQ4MVzPUU9Yz1FPWM9RT1jPUU9Yz1FNWM3QefQFDPWU9Qz1lPUM9ZT3DgeFqhnrKavflPPoChnrKeoZ6ynqGesrqe4rz6AsY6inrGeop6xnqKesZDgxXM9RT1jPUU9Yz1FPWM9RT1jPUU1YzdB59AUM9ZT1DPWU9Qz1ltftyHn0BQz1lPUM9ZT1DPWX9PUVPWc9QT1nN0Hn0BQz1lPUM9ZT1DPWU9QwHhqsZ6inrGeop6xnqKesZ6inrGeopqxk6j76AoZ6y2n05j76AoZ6ynuHAcDVDPWX9PUVPWc9QT1nPUE9Zz1BPWc3QefQFDPWU9Qz1lPUM9ZT1DAeGqxnqKesZ6inrGeop6xnqKesZ6ikr3dfl4Dz6AoZ6ynqGesp6hnrKynvKG8OB4WqGesp6hnrKeoZ6ynqGesp6hnrKaobOoy9gqKesZ6inrGeop6xnODBczVBPWc9QT1nPUE9Z7b6cR1/AUE9ZzdB59Ouvh86jL2Cop6xnqKesZzgwXM1QT1nPUE9Zv9voKesZ6inrGeopq6+HzqMvYKinrGeop6xnqKesZzgwXM1QT1m92ziPvoChnrKeoZ6ynqGesvqe4jz6AoZ6ynqGesp6hnrKeoYDw9UM9ZT1DPWU9Qz1lPUM9ZT1DPWU1QydR/8FhrcPGm//ef6V4aQ95T7e/+D7bfyN4Z9YdlQ9jm8Pb98/fbiMBTCX8/tPfbmfF4brcjl9fPb247O32zMat+vtHcf9+NMgvhPfUVFpQvz+eGd3fjwjPhDfmPiOStA3Ib6jyvRNiO+oYH0T4juqY9+E+I7K2/cgft1R1fsmxHdUDL8JcZ3zC8Svx/cf+jpOC8Tvt4+Sf7/8+Oy4/QVc5SwG/vig8biPvwF/YqZOl3chME63v5mpJz/wOFzff+JxGr9orOsQ5V6iVJJ3E6X2vZso1frdRMkX7CZKImIvUd4Yjt1ESZ3sJkpOZjdRsj27iXKIci9Rsj27iZLt2U2UbM9uomR7dhMl27OXKO9sz26iZHt2EyXbs5so2Z7dRDlEuZco2Z7dRMn27CZKtmc3UbI9u4mS7dlLlA+2ZzdRsj27iZLt2U2UbM9uohyi3EuUbM9uomR7dhMl27ObKNme3UTJ9uwkyuOB7dlNlGzPbqJke3YTJduzmyiHKPcSJduzmyjZnt1EyfbsJkq2ZzdRsj17ifLI9uwmSrZnN1GyPbuJku15ZZSfn7d9PA7pNE6Hk+mcDs3SOR3m5KXpfHr25/FIhnROh99onM6JsuicDgvROR1iofHOduIKOqczpNM4Ha6gczpcQeetgCvonA5X0DkdrqBxOmeuoHM6XEHndLiCzulwBZ3TGdJpnA5X0DkdrqBzOlxB53S4gs7pcAWN0xlcQeMnCIMr6JwOV9A5Ha6gczpDOo23Aq6gczpcQed0uILO6XAFndPhChqnc+EKOqfDFXROhyvonA5X0DmdIZ3G6XAFndPhCjqnwxV0TocraPwE4cIVNE7nyhV0Tocr6JwOV9B4K7hyBZ3TGdJpnA5X0DkdrqBzOlxB53S4gs7pcAWN07lxBZ3T4Qo6p8MVdE6HK+iczpBO43S4gs7pcAWNnyDcuILO6XAFndPhChqnc+cKGm8Fd66gczpcQed0uILO6QzpNE6HK+icDlfQOR2uoHM6XEHndLiCxuk8uILO6XAFndPhCjqnwxV0TmdIp+8ThAdX0DkdrqBzOlxB53S4gs5bAVfQN53TgSvonA5X0DkdrqBzOlxB53SGdBqnwxV0Tocr6JwOV9A5Ha6gczpcQeN0jlxB53S4gs7pcAV9nyCcjlxB53SGdBqnwxV0Tocr6LwVcAWd0+EKOqfDFTRO58QVdE6HK+icDlfQOR2uoHM6QzqN0+EKOqfDFXROhyvonA5X0DkdrqBxOmeuoPEThDNX0DkdrqBzOlxB53SGdBpvBVxB53S4gs7pcAWd0+EKOqfDFTROZ3AFndPhCjqnwxV0Tocr6JzOkE7jdLiCzulwBZ3T4Qo6p8MVNH6CMLiCxulcuILO6XAFndPhChpvBReuoHM6QzqN0+EKOqfDFXROhyvonA5X0DkdrqBxOleuoHM6XEHndLiCzulwBZ3TGdJpnA5X0DkdrqDxE4QrV9A5Ha6gczpcQeN0blxB463gxhV0Tocr6JwOV9A5nSGdxulwBZ3T4Qo6p8MVdE6HK+icDlfQOJ07V9A5Ha6gczpcQed0uILO6Qzp9H2CcOcKOqfDFXROhyvonA5X0Hkr4Aoap/PgCjqnwxV0Tocr6JwOV9A5nSGdxulwBZ3T4Qo6p8MVdE6HK+icDlfQN53zgSvonA5X0DkdrqDvE4TzgSvonM6QTuN0uILO6XAFnbcCrqBzOlxB53S4gsbpHLmCzulwBZ3T4Qo6p8MVdE5nSKdxOlxB53S4gs7pcAWd0+EKOqfDFTRO58QVNH6CcOIKOqfDFXROhyvonM6QTuOtgCvonA5X0DkdrqBzOlxB53S4gsbpnLmCzulwBZ3T4Qo6p8MVdE5nSKdxOlxB53S4gs7pcAWd0+EKGj9BOHMFjdMZXEHndLiCzulwBY23gsEVdE5nSKdxOlxB53S4gs7pcAWd0+EKOqfDFTRO58IVdE6HK+icDlfQOR2uoHM6QzqN0+EKOqfDFTR+gnDhCjqnwxV0TocraJzOlStovBVcuYLO6XAFndPhCjqnM6TTOB2uoHM6XEHndLiCzulwBZ3T4Qoap3PjCjqnwxV0Tocr6JwOV9A5nSGdvk8QblxB53S4gs7pcAWd0+EKOm8FXEHjdO5cQed0uILO6XAFndPhCjqnM6TTOB2uoHM6XEHndLiCzulwBZ3T4Qoap/PgCjqnwxV0TocraPwE4cEVdE5nSKdxOlxB53S4gs5bAVfQOR2uoHM6XEHfdN5wS6dxOlxB53S4gs7pcAWd0xnSaZwOV9A5Ha6gczpcQed0uILO6XAFjdM5cgV9nyCMI1fQOR2uoHM6XEHndIZ0Gm8FXEHndLiCzulwBZ3T4Qo6p8MVNE7nxBV0Tocr6JwOV9A5Ha6gczpDOo3T4Qo6p8MVdE6HK+icDlfQ+AnCiStonM6ZK+icDlfQOR2uoPFWcOYKOqczpNM4Ha6gczpcQed0uILO6XAFndPhChqnM7iCzulwBZ3T4Qo6p8MVdE5nSKdxOlxB53S4gsZPEAZX0DkdrqBzOlxB43QuXEHjreDCFXROhyvonA5X0DmdIZ3G6XAFndPhCjqnwxV0Tocr6JwOV9A4nStX0DkdrqBzOlxB53S4gs7pDOn0fYJw5Qo6p8MVdE6HK+icDlfQeSvgChqnc+MKOqfDFXROhyvonA5X0DmdIZ3G6XAFndPhCjqnwxV0Tocr6JwOV9A4nTtX0DkdrqBzOlxB4ycId66gczpDOo3T4Qo6p8MVdN4KuILO6XAFndPhChqn8+AKOqfDFXROhyvonA5X0DmdIZ3G6XAFndPhCjqnwxV0Tocr6JwOV9A3ncuBK+j7BOFy4Ao6p8MVdE6HK+iczpBO462AK+icDlfQOR2uoHM6XEHndLiCxukcuYLO6XAFndPhCjqnwxV0TmdIp3E6XEHndLiCzulwBZ3T4QoaP0E4cgWN0zlxBZ3T4Qo6p8MVNN4KTlxB53SGdBqnwxV0Tocr6JwOV9A5Ha6gczpcQeN0zlxB53S4gs7pcAWd0+EKOqczpNM4Ha6gczpcQeMnCGeuoHM6XEHndLiCxukMrqDxVjC4gs7pcAWd0+EKOqczpNM4Ha6gczpcQed0uILO6XAFndPhChqnc+EKOqfDFXROhyvonA5X0DmdIZ2+TxAuXEHndLiCzulwBZ3T4Qo6bwVcQeN0rlxB53S4gs7pcAWd0+EKOqczpNM4Ha6gczpcQed0uILO6XAFndPhChqnc+MKOqfDFXROhyto/AThxhV0TmdIp3E6XEHndLiCzlsBV9A5Ha6gczpcQeN07lxB53S4gs7pcAWd0+EKOqczpNM4Ha6gczpcQed0uILO6XAFndPhChqn8+AKGj9BeHAFndPhCjqnwxV0TmdIp/FWwBV0Tocr6JwOV9A5Ha6gczpcQd90rgeuoHM6XEHndLiCzulwBZ3TGdJpnA5X0DkdrqBzOlxB53S4gr5PEK4HrqBxOkeuoHM6XEHndLiCxlvBkSvonM6QTuN0uILO6XAFndPhCjqnwxV0TocraJzOiSvonA5X0DkdrqBzOlxB53SGdBqnwxV0TocraPwE4cQVdE6HK+icDlfQ+L5z5go6p8MVdE6HK+icDlfQOZ0hncbpcAWNN+ozV9A5Ha6gczpcQef7DlfQOJ3BFXROhyvonA5X0DkdrqBzOkM6fTfqwRV0Tocr6JwOV9A5Ha6g81bAFTRO58IVdE6HK+icDlfQOR2uoHM6QzqN0+EKOqfDFXROhyvonA5X0DkdruCV6dw+OL/95/mXdK5cQXE6x3F+/9/D8c1yLuTzJmvef4y3dnP8OZ8noO/3d2l6vj9+/CCnZzTOl4+f43wZx58//GfyPMSsyXMcsybPn8ya/JD8TpN/6z/vH77exq/J8z6zJs8p7Tb5x/kjlsN94cOnj1+1OJ+O188/fHrbEd4zvN4XPvzW99+75eNJtSTNjN8Lx48VNH6/O363wzvn0+18WjV+tKfxe9343Xhd4/e74/e4nN4zfDyOCx8+jfdROp2uY9WsMtFm9bvMKnduVv/ZWb1/BH4+rGpAN7bfrH6XWR1m1ay+Deg4fMzqZeFPPl0e40MWHX995nXz5MNM/e5M1QnIm8cvxu+F4+fxi/F74fh5/GL8fnf8Cv23xy/G73Xjd/f4xfj97vjdTx+W+v6vb/U/1dm7xyRmqnqmPM4wU9Uz5bGDmaqeqWGmzNRvztRvPco6PD4+fDyefx1AzxIM4EsH0NMEA/iPDmDdL0ndPXowq99lVj2nMKvfZVY91DCr/+yslv1C38MTELP6XWbVkxWz+vaJ8/Ejw/NlZV9/eLJipqpnypMVM/W7M1VXPx7D+Bm/142fRzDG74Xj5wGM8fvt8avrqJ6pGL8Xjp/HJHsdv9v18RHLfSzpvN/5t+QL/z734XGGmfrdmSr7F2q3gycUxu+F4+ehg/F74fh5PmH8fnf8yv6B5O3gUYbxe+H4DeNn/H5z/D7/N0q3g+cTZqp6pjx0MFPVM+VJgpmqnimPB8zU785U4T+PfGsGBtAAvnAAj54mGMB/dADLfpXpdvTowax+l1n1nMKsfpdZ9VDDrP6zs1r1C3234zCrZvWbzKonK2b1j1e9yv529BDG+L1w/DyvMX6/O351vypz9GjH+L1w/DzYMX6/O34v8j8nz4DM6neZVc+AzOo/O6tl/ufkGZBZ/S6z6hmQWf2j9L1vt9MwU2aqeKY8UzFTf7zqbVq3k2cqxu+F4+eZivF74fh5pmL8/njVy9xuJ89UjN/rxu/sMUn1+N0/nrce7/9K5Kfx+xM52785ctJ6c+Tc6+bIB+T/IPLj/Qly5m5z5GzV5sgZms2RsxKbI9fEt95Yhva5OXLtc3Pk2ufmyLXPzZEPyLdGrn1ujlz73By59rk5cu1zc+Ta59bIL9rnho/e/0SufW6OXPvcHLn2uTnyAfnWyLXPLyC/Xd5//epvO8hT5Nfx8ato159+Ves+/gKue24MXPPcGLjeuTFwrXNb4Fedc2PgGufGwPXNjYFrmxsDH4BvC1zT3Bi4prkxcE1zY+Ca5sbANc1tgd80zY2Ba5obA9c0NwauaW4MfAC+LXBNc2PgmubGwDXNjYFrmhsD1zS3BX7XNDcGrmluDFzT3Bi4prkx8AH4tsA1zY2Ba5pfAP74eBvm43JYAH48XK8fP8VPPM5Pf+Qf76w8ng/3zz98fvuC76D//drOHx/+M0sldj9Z6sf7yVL13k2WD61+P1kSBvvJkovYT5Y0x36yHLLcTZbkzH6y5H32kyXvs58seZ/9ZMn77CXL+4H32U+WvM9+suR99pMl77OfLIcsd5Ml77OfLHmf/WTJ++wnS95nP1nyPrvJ8sj77CdL3mc/WfI++8mS99lPlkOWu8mS99lPlrzPfrLkffaTJe+znyx5n91keeJ9vk+W548f43z+F4HPPny93t9hXG+nw6/Bk0STBs8oTRo8/TRp8EPwcwZPbE0aPAs2afCU2aTB82uTBk/GzRn8mbmbNHjmbtLgmbtJg2fuJg1+CH7O4Jm7SYNn7iYNnrmbNHjmbtLgmbs5gx/M3aTBM3eTBs/cTRo8czdp8EPwcwbP3E0aPHM3afDM3aTBM3eTBs/czRn8hbmbNHjmbtLgmbtJg2fuvk/w4zbeQV9O588/fBvj9teHb+PvU/Jn8EPwcwbP3E0aPHM3afDM3aTBM3eTBs/czRn8lbmbNHjmbtLgmbtJg2fuJg1+CH7O4Jm7SYNn7iYNnrmbNHjmbtLgmbs5g78xd5MGz9xNGjxzN2nwzN2kwQ/Bzxk8czdp8MzdpMEzd5MGz9xNGjxzN2fwd+Zu0uCZu0mDZ+4mDZ65mzT4IfjvEvy4XN4/PK7HJ1mScfvJkl/bT5aU2X6yZMH2kyWxtZssH1zVfrKkn/aTJaO0nyxJov1kOWS5myx5n/1kyfvsJ0veZz9Z8j77yZL32UuWjwPvs58seZ/9ZMn77CdL3mc/WQ5Z7iZL3mc/WfI++8mS99lPlrzPfrLkfXaT5ZH32U+WvM9+suR99pMl77OfLIcsd5Ml77OfLHmf/WTJ++wnS95nP1nyPrvJ8sT77CdL3mc/WfI++8mS99lPlkOWu8mS9/k+WV5vH1nezgsfvr/l9teH79fr8dfgSaJJg2eUJg2efpo0eK5qzuDPxNakwbNgkwZPmU0aPL82afBD8HMGz9xNGjxzN2nwzN2kwTN3kwbP3M0Z/GDuJg2euZs0eOZu0uCZu0mDH4KfM3jmbtLgmbtJg2fuJg2euZs0eOZuzuAvzN2kwTN3kwbP3E0aPHM3afBD8HMGz9xNGjxzN2nwzN2kwTN3kwbP3M0Z/JW5mzR45m7S4Jm7SYNn7iYNfgh+zuCZu0mDZ+4mDZ65mzR45m7S4Jm7OYO/MXeTBs/cTRo8czdp8MzdpMEPwc8ZPHM3afDM3aTBM3eTBs/cTRo8czdn8HfmbtLgmbudBv92F3//mQ+Hx6/BM3eTBs/cTRr8EPy3Cf52OX4Efz9+/uHH6X57/5nPx4UPX44/YBx/IvcxJTSfKVmeEk7QlCxPCYFoSpanhG00JctTQk2aksUpefCYpmR5SkhPU7I8JQypKVmeEjrVlCxPyTAlpmRxSrhXU7I8JdyrKVmeEu7VlCxPCfdqSpanhHs1JQtTcj0cuFdTsjwl3KspWZ4S7tWULE8J92pKlqdkmBJTsjgl3KspWZ4S7tWULE8J92pKlqeEezUly1PCvZqSxSk5cq+mZHlKuFdTsjwl3KspWZ4S7tWULE/JMCWmZHFKuFdTsjwl3KspWZ4S7tWULE8J92pKlqeEezUli1Ny4l5NyfKUcK+mZHlKuFdTsjwl3KspWZ6SYUpMyeKUcK+mZHlKuFdTsjwl3KspWZ4S7tWULE8J92pKFqfkzL2akuUp4V5NyfKUcK+mZHlKuFdTsjwlw5SYksUp4V5NyfKUcK+mZHlKuFdTsjwl3KspWZ4S7tWULE7J4F5NyfKUcK+mZHlKuFdTsjwl3KspWZ6SYUpMyeKUcK+mZHlKuFdTsjwl3KspWZ4S7tWULE8J92pKFqfkwr2akuUp4V5NyfKUcK+mZHlKuFdTsjwlw5SYksUp4V5NyfKUcK+mZHlKuFdTsjwl3KspWZ4S7tWULE7JlXs1JctTwr2akuUp4V5NyfKUcK+mZHlKhikxJYtTwr2akuUp4V5NyfKUcK+mZHlKuFdTsjwl3KspWZySG/dqSpanhHs1JctTwr2akuUp4V5NyfKUDFNiShanhHs1JctTwr2akuUp4V5NyfKUcK+mZHlKuFdTsjgld+7VlCxPCfdqSpanhHs1JctTwr2akuUpGabElCxOCfdqSpanhHs1JctTwr2akuUp4V5NyfKUcK+mZHFKHtyrKVmeEu7VlCxPCfdqSpanhHvd65R8pPI2JY9fgx+C32fw43h6/5nHuH3+4dPjfHlP5XH58SefnoI7fAzH5fB4/PzhP0eKezVSxSNF1Bqp4pFidY1U8UhRwEaqeKT4YiNVOlLHA7lspIpHiok2UsUjRVsbqeKR4riNVPFIDSNlpGpHij03UsUjxZ4bqeKRYs+NVPFIsedGqnik2HMjVTtSR/bcSBWPFHtupIpHij03UsUjxZ4bqeKRGkbKSNWOFHtupIpHij03UsUjxZ4bqeKRYs+NVPFIsedGqnakTuy5kSoeKfbcSBWPFHtupIpHij03UsUjNYyUkaodKfbcSBWPFHtupIpHij03UsUjxZ4bqeKRYs+NVO1IndlzI1U8Uuy5kSoeKfbcSBWPFHtupIpHahgpI1U7Uuy5kSoeKfbcSBWPFHtupIpHij03UsUjxZ4bqdqRGuy5kSoeKfbcSBWPFHtupIpHij03UsUjNYyUkaodKfbcSBWPFHtupIpHij03UsUjxZ4bqeKRYs+NVO1IXaa157fH+w9yP90XRmqcLrf3ME+38wLycXifqcs4jV+RT2uXX4d8Wvv6OuTT2snXIR+Qb418Wrv1OuTT2p/XIZ/WjrwO+bT24HXIp23XL0N+1T43R659bo5c+9wcufa5OfIB+dbItc/NkWufmyPXPjdHrn1ujlz73Br5TfvcHLn2uTly7XNz5Nrn5sgH5Fsj1z43R659bo5c+9wcufa5OXLtc2vkd+1zc+Ta5+bItc/NkWufmyMfkG+NXPvcHLn2uTly7XNz5Nrn5si1z62RP7TPzZFrn5sj1z43R659bo58QL41cu1zc+Ta5+bItc/NkWufmyPXPr+C/HoY78ivp8P/TPF0UCgrKOqIFRTVvgqKmtyXKF4uHxRvTygOFAso6lsVFFWoCopaUQVFRafiHq27FFA86i4VFHWXCoq6S8Hd5ai7VFAcKBZQ1F0qKOouFRR1lwqKuksFRd2lgOJJd6mgqLtUUNRdKijqLhUUB4oFFHWXCoq6S4EZO+kuFRR1lwqKuksBxbPuUnB3OesuFRR1lwqKuksFxYFiAUXdpYKi7lJBUXepoKi7VFDUXQooDt2lgqLuUkFRd6mgqLtUUBworjdjQ3epoKi7VFDUXSoo6i4VdxfdpYDiRXepoKi7VFDUXSoo6i4VFAeKBRR1lwqKuksFRd2lgqLuUkFRdymgeNVdKijqLhUUdZcCM3bVXSooDhQLKOouFRR1l4q7i+5SQVF3qaCouxRQvOkuFRR1lwqKuksFRd2lguJAsYCi7lJBUXepoKi7VFDUXSoo6i4FFO+6S4EZu+suFRR1lwqKuksFxYFiwd1Fd6mgqLtUUNRdKijqLhUUdZcCig/dpYKi7lJBUXepoKi7VFAcKBZQ1F0qKOouFRR1lwqKukuBGXvoLuspng+6SwVF3aWCou6y/u5yPuguFRQHigUUdZcKirpLBUXdpYKi7lJBUXcpoHjUXSoo6i4VFHWXCoq6SwXFgWIBRd2lgqLuUmDGjrpLBUXdpYKi7lJA8aS7FNxdTrpLBUXdpYKi7lJBcaBYQFF3qaCou1RQ1F0qKOouFRR1lwKKZ92lgqLuUkFRd6mgqLtUUBworjdjZ92lgqLuUkFRd6mgqLtU3F10lwKKQ3epoKi7VFDUXSoo6i4VFAeKBRR1lwqKuksFRd2lgqLuUkFRdymgeNFdKijqLhUUdZcCM3bRXSooDhQLKOouFRR1l4q7i+5SQVF3qaCouxRQvOouFRR1lwqKuksFRd2lguJAsYCi7lJBUXepoKi7VFDUXSoo6i4FFG+6S4EZu+kuFRR1lwqKuksFxYFiwd1Fd6mgqLtUUNRdKijqLhUUdZcCinfdpYKi7lJBUXepoKi7VFAcKBZQ1F0qKOouFRR1lwqKukuBGbvrLgUUH7pLBUXdpYKi7lJwd3noLhUUB4oFFHWXCoq6SwVF3aWCou5SQVF3WU/xDQuKBRR1lwqKuksFRd2lguJAsYCi7lJBUXdZb8bGQXepoKi7VFDUXQooHnWXgrvLUXepoKi7VFDUXSooDhQLKOouFRR1lwqKuksFRd2lgqLuUkDxpLtUUNRdKijqLhUUdZcKigPF9WbspLtUUNRdKijqLhUUdZeKu4vuUkDxrLtUUNRdKijqLhUUdZcKigPFAoq6SwVF3aWCou5SQVF3qaCouxRQHLpLBUXdpYKi7lJgxobuUkFxoFhAUXepoKi7VNxddJcKirpLBUXdpYDiRXepoKi7VFDUXSoo6i4VFAeKBRR1lwqKuksFRd2lgqLuUkFRdymgeNVdCszYVXepoKi7VFDUXSooDhQL7i66SwVF3aWCou5SQVF3qaCouxRQvOkuFRR1lwqKuksFRd2lguJAsYCi7lJBUXepoKi7VFDUXQrM2E13KaB4110qKOouFRR1l4K7y113qaA4UCygqLtUUNRdKijqLhUUdZcKirpLAcWH7lJBUXepoKi7VFDUXSooDhQLKOouFRR1lwIz9tBdKijqLhUUdZf1FC8H3WX93eVy0F0qKOouFRR1lwqKA8UCirpLBUXdpYKi7lJBUXepoKi7FFA86i4VFHWXCoq6SwVF3aWC4kBxvRk76i4VFHWXCoq6SwVF3aXi7qK7FFA86S4VFHWXCoq6SwVF3aWC4kCxgKLuUkFRd6mgqLtUUNRdKijqLgUUz7pLBUXdpYKi7lJgxs66SwXFgWIBRd2lgqLuUnF30V0qKOouFRR1lwKKQ3epoKi7VFDUXSoo6i4VFAeKBRR1lwqKuksFRd2lgqLuUkFRdymgeNFdCszYRXepoKi7VFDUXSooDhQL7i66SwVF3aWCou5SQVF3qaCouxRQvOouFRR1lwqKuksFRd2lguJAsYCi7lJBUXepoKi7VFDUXQrM2FV3KaB4010qKOouFRR1l4K7y013qaA4UCygqLtUUNRdKijqLhUUdZcKirpLAcW77lJBUXepoKi7VFDUXSooDhQLKOouFRR1lwIzdtddKijqLhUUdZcCig/dpeDu8tBdKijqLhUUdZcKigPFAoq6SwVF3aWCou5SQVF3qaCou6yneD3oLhUUdZcKirpLBUXdpYLiQHG1GbsedJcKirpLBUXdpYKi7lJxd9FdCigedZcKirpLBUXdpYKi7lJBcaBYQFF3qaCou1RQ1F0qKOouFRR1lwKKJ92lgqLuUkFRdykwYyfdpYLiQLGAou5SQVF3qbi76C4VFHWXCoq6SwHFs+5SQVF3qaCou1RQ1F0qKA4UCyjqLhUUdZcKirpLBUXdpYKi7lJAceguBWZs6C4VFHWXCoq6SwXFgWLB3UV3qaCou1RQ1F0qKOouFRR1lwKKF92lgqLuUkFRd6mgqLtUUBwoFlDUXSoo6i4VFHWXCoq6S4EZu+guBRSvuksFRd2lgqLuUnB3ueouFRQHigUUdZcKirpLBUXdpYKi7lJBUXcpoHjTXSoo6i4VFHWXCoq6SwXFgWIBRd2lgqLuUmDGbrpLBUXdpYKi7lJA8a67FNxd7rpLBUXdpYKi7lJBcaBYQFF3qaCou1RQ1F0qKOouFRR1lwKKD92lgqLuUkFRd6mgqLtUUBworjdjD92lgqLuUkFRd6mgqLtU3F10l/UUbwfdpYKi7lJBUXepoKi7VFAcKBZQ1F0qKOouFRR1lwqKuksFRd2lgOJRd6mgqLtUUNRd1pux21F3qaA4UCygqLtUXBd1lwqKuksFRd2lgqLuUkDxpLtUUNRdCjadk+5SQVF3qaA4UCy4LuouFRR1lwqKuksFRd2lgqLuUkDxrLsUbDpn3aWCou5SQVF3qaA4UCy4u+guFRR1lwqKuksFRd2lgqLuUkBx6C4VFHWXCoq6SwVF3aWC4kCxgKLu8hWKtw8eb/95/pXitN3lPt7/6Ptt/I3in2D2VEfecLx/+ng9LYA5X4/v6uV8vR4XPn25nP768OV++/HZ2+3Zn3y73t7/5Pvxp2F8Z76n8tKF+f3xTu/8eMZ8T1XnmzC/7KkYfRfme6pR34X5nkrXd2G+p4r2XZgPzDdnvqf6912Y76ksfhfmeuiXmF+P7z/2dZwWmN9vH9X/fvnx2XH7C7kaWo788cHjcR9/Q/7EWZ0u75pgnG5/c1ZP/rc2Dtf3/7GN0/hFcF302/2EeVWcdxSmRr6jMFX9HYXJIewozCHM/YTJeuwoTDplR2HyNDsKkwHaUZgM0H7CvDFAOwqTAdpRmAzQjsJkgHYU5hDmfsJkgHYUJgO0ozAZoB2FyQDtKEwGaD9h3hmgHYXJAO0oTAZoR2EyQDsKcwhzP2EyQDsKkwHaUZgM0I7CZIB2FCYDtJ8wHwzQjsJkgHYUJgO0ozAZoB2FOYS5nzAZoB2FyQDtKEwGaEdhMkA7CpMB2k2Y9wMDtKMwGaAdhckA7ShMBmhHYQ5h7idMBmhHYTJAOwqTAdpRmAzQa8P8/BTw+4HUaZ3PkafpnQ/10jsfNuXF+Xx6Bun9SJD0zmfIp3U+NEbvfJiJ3vmQDb33N/6gdz78Qet8TvxB73z4g9b7wYk/6J0Pf9A7nyGf1vnwB73z4Q9658Mf9M6HP+idD3/QOp8zf9A7H/6gdz78Qe98+IPe+Qz5tM6HP2j9fOHMH/TOhz/onQ9/0Dsf/qD1fjD4g9758Ae98+EPeufDH/TOZ8indT78Qe98+IPe+fAHvfPhD3rnwx+0zufCH/TOhz/onQ9/0Dsf/qD184XLkE/rfPiD3vnwB73z4Q967wf8Qe98+IPW+Vz5g9758Ae98+EPeufDH/TOZ8indT78Qe98+IPe+fAHvfPhD3rnwx+0zufGH/TOhz9o/Xzhxh/0zoc/6J3PkE/rfPiD3vsBf9A7H/6gdz78Qe98+IPW+dz5g9758Ae98+EPeufDH/TOZ8indT78Qe98+IPe+fAHvfPhD3rnwx+0fr7w4A9658Mf9M6HP+idD3/Qej94DPm0zoc/6J0Pf9A7H/6gdz78Qe98+IPO+TwO/EHvfPiD3vnwB73z4Q965zPk0zof/qB3PvxB73z4g87PFx4H/qB3PvxB63yO/EHvfPiD1vvBkT/onQ9/0DufIZ/W+fAHvfPhD3rnwx/0zoc/6J0Pf9A6nxN/0Dsf/qB3PvxB73z4g975DPm0zoc/aP184cQf9M6HP+idD3/QOx/+oPV+cOYPeufDH/TOhz/onQ9/0DufIZ/W+fAHvfPhD3rnwx/0zoc/6J0Pf9A6n8Ef9M6HP+idD3/QOx/+oPXzhTHk0zof/qB3PvxB73z4g977AX/QOx/+oHU+F/6gdz78Qe98+IPe+fAHvfMZ8mmdD3/QOx/+oHc+/EHvfPiD3vnwB63zufIHvfPhD1o/X7jyB73z4Q965zPk0zof/qD3fsAf9M6HP+idD3/QOx/+oHU+N/6gdz78Qe98+IPe+fAHvfMZ8mmdD3/QOx/+oHc+/EHvfPiD3vnwB62fL9z5g9758Ae98+EPeufDH7TeD+5DPq3z4Q9658Mf9M6HP+idD3/QOx/+oHU+D/6gdz78Qe98+IPe+fAHvfMZ8mmdD3/QOx/+oHc+/EHr5wsP/qB3PvxB43xuhwN/0Dsf/qDxfvCWD3/QOx/+oHc+Qz6t8+EPeufDH/TOhz/onQ9/0Dsf/qB1Pkf+oHc+/EHvfPiD3vnwB73zGfJpnQ9/0Pr5wpE/6J0Pf9A7H/6gdz78Qev94MQf9M6HP+idD3/QOx/+oHc+Qz6t8+EPeufDH/TOhz/onQ9/0Dsf/qB1Pmf+oHc+/EHvfPiD3vnwB62fL5yHfFrnwx/0zoc/6J0Pf9B7P+APeufDH7TOZ/AHvfPhD3rnwx/0zoc/6J3PkE/rfPiD3vnwB73z4Q9658Mf9M6HP2idz4U/6J0Pf9D6+cKFP+idD3/QO58hn9b58Ae99wP+oHc+/EHvfPiD3vnwB63zufIHvfPhD3rnwx/0zoc/6J3PkE/rfPiD3vnwB73z4Q9658Mf9M6HP2j9fOHGH/TOhz/onQ9/0Dsf/qD1fnAb8mmdD3/QOx/+oHc+/EHvfPiD3vnwB63zufMHvfPhD3rnwx/0zoc/6J3PkE/rfPiD3vnwB73z4Q9aP1+48we98+EPWufz4A9658MftN4PHvxB73z4g975DPm0zoc/6J0Pf9A7H/6gdz78Qe98+IPO+RwP/EHvfPiD3vnwB73z4Q965zPk0zof/qDz84XjgT/onQ9/0Dsf/qB3PvxB6/3gyB/0zoc/6J0Pf9A7H/6gdz5DPq3z4Q9658Mf9M6HP+idD3/QOx/+oHU+J/6gdz78Qe98+IPe+fAHrZ8vnIZ8WufDH/TOhz/onQ9/0Hs/4A9658MftM7nzB/0zoc/6J0Pf9A7H/6gdz5DPq3z4Q9658Mf9M6HP+idD3/QOx/+oHU+gz/onQ9/0Pr5wuAPeufDH/TOZ8indT78Qe/9gD/onQ9/0Dsf/qB3PvxB63wu/EHvfPiD3vnwB73z4Q965zPk0zof/qB3PvxB73z4g9758Ae98+EPWj9fuPIHvfPhD3rnwx/0zoc/aL0fXId8WufDH/TOhz/onQ9/0Dsf/qB3PvxB63xu/EHvfPiD3vnwB73z4Q965zPk0zof/qB3PvxB73z4g9bPF278Qe98+IPW+dz5g9758Aet94M7f9A7H/6gdz5DPq3z4Q9658Mf9M6HP+idD3/QOx/+oHU+D/6gdz78Qe98+IPe+fAHvfMZ8mmdD3/Q+vnCgz/onQ9/0Dsf/qB3PvxB5/3gdOAPeufDH/TOhz/onQ9/0DufIZ/W+fAHvfPhD3rnwx/0zoc/6J0Pf9A6nyN/0Dsf/qB3PvxB73z4g87PF07HIZ/W+fAHvfPhD3rnwx/03g/4g9758Aet8znxB73z4Q9658Mf9M6HP+idz5BP63z4g9758Ae98+EPeufDH/TOhz9onc+ZP+idD3/Q+vnCmT/onQ9/0DufIZ/W+fAHvfcD/qB3PvxB73z4g9758Aet8xn8Qe98+IPe+fAHvfPhD3rnM+TTOh/+oHc+/EHvfPiD3vnwB73z4Q9aP1+48Ae98+EPeufDH/TOhz9ovR9chnxa58Mf9M6HP+idD3/QOx/+oHc+/EHrfK78Qe98+IPe+fAHvfPhD3rnM+TTOh/+oHc+/EHvfPiD1s8XrvxB73z4g9b53PiD3vnwB633gxt/0Dsf/qB3PkM+rfPhD3rnwx/0zoc/6J0Pf9A7H/6gdT53/qB3PvxB73z4g9758Ae98xnyaZ0Pf9D6+cKdP+idD3/QOx/+oHc+/EHr/eDBH/TOhz/onQ9/0Dsf/qB3PkM+rfPhD3rnwx/0zoc/6J0Pf9A7H/6gcz7nA3/QOx/+oHc+/EHvfPiDzs8Xzochn9b58Ae98+EPeufDH/TeD/iD3vnwB63zOfIHvfPhD3rnwx/0zoc/6J3PkE/rfPiD3vnwB73z4Q9658Mf9M6HP2idz4k/6J0Pf9D6+cKJP+idD3/QO58hn9b3H/6gdz78Qe98+IPe+fAHvfPhD1rnc+YPWu/XZ/6gdz78Qe98+IPe958hn9b58Ae98+EPeufDH/TOhz/onQ9/0Hq/HvxB73z4g9758Ae98+EPWu8HY8indT78Qe98+IPe+fAHvfPhD3rnwx+0zufCH/TOhz/onQ9/0Dsf/qB3PkM+L83n9kH67T/Pv+bDH5Tncxznj5/jzX8uJHS9HN7xXS/n488JPfmh7/ePH/r++PGDnJ7xeLs4vv8cb/87PP784T+z5ybmzZ73mDd7TmXe7Pma/WZ/vXwEc72NX7K/ckHzZs8z7Tj7x/kjmMN94cOnj1/IOJ+O188/fLpeP1K83hc+/Nb/35vm49eieSXSDOBLB5ApNIC/P4C3w+M9xdv5tGoAhwE0gK8cQK7XAP7+AD4up/cUH4/jwodP432YTqfrWDWt7LRp/T7Tyqeb1n96Wu8fkZ8P67qQJwCm9ftMq2cWpvXPaR2Hj2m9LPzJp8tjfKij469Pwm6ehpiq35+qOiF580jGAL50AD2SMYAvHUCPZAzg7w9gnRG/DQNoAF85gB7JGMDfH8D76cNb3//1rf7nauvRiamqnyqPOExV/VR5FGGq6qfKIwNT9ftT9VsPuA6Pjw8fj+dfRvDu+YIRfPEIesJgBP/hEaz7Faq7xxGm9ftMq2cXpvX7TOswrab1H57Wsl/4u3sqYlq/z7R62mJa//3h8/EjxfNlbXf3tMVU1U+Vpy2m6venqrCIeDBjAF85gA+PZQzgSwfQQxkD+L8wgGV99eE5iwF86QB6dLLfAbxdHx/B3MeS3vudf32+8O95H8NUmarfnqq6f8328NTCAL50AD2IMIAvHUDPLAzg7w9g3T+nfHi8YQBfOoAebxjA3x/Az/8109uYmCpTVT5VHkSYqvqp8nTBVNVPlUcGpur3p6rwH1O+TYERNIKvHUFPGIzgPzyCZb/oNA4eR5jW7zOtnl2Y1u8zrR50mNZ/elqrfuFvHDwVMa3fZlqPnraY1j+n9SWvxR9HD2YM4EsH0DMcA/j7A1j2azTj6HGPAXzpAA4DaAB/ewBfZIOOnguZ1u8zrZ4LmdZ/elrrbJDnQqb1+0yr50Km9d8fLnxr3Dh6fmOqyqfq5DmLqfr9qaorIifPWQzgSwfQcxYD+NIB9JzFAP4vDGBZXz0NA2gAXzmAHp3UD+D94zns8f6vTH4awD+hewLwAuhE9gug87EvgE5X/rPQj/dfoZ/ZvBdAZ7BeAJ21eQF0puIF0Afom28vZ430BdA10hdA10hfAF0jfQF0jXR76EMjfQF0jfQF0DXSF0DXSF8AfYC+PXSNdNOH9H9C10hfAF0jfQF0jfQF0DXS7aFfNNIvQb9d3n9l62/7yFPo1/Hx62vXn3696z7+Qq6Pbo5cG90cuS66OfIB+dbI9dDNkWuhmyPXQTdHroFujlz/3Br5VfvcHLn2uTly7XNz5Nrn5sgH5Fsj1z43R659bo5c+9wcufa5OXLtc2vkN+1zc+Ta5+bItc/NkWufmyMfkG+NXPvcHLn2uTly7XNz5Nrn5si1z62R37XPzZFrn19C/vh4/+bjclhAfjxcr+8/x+EnIuenP/SPt2Qez4f75x8+Hw/vL+s///tFoT8+/Geaiu2e0tSZ95TmkOaO0tT095QmibCnNPmJPaVJfewpTVZlR2k+CJs9pckF7SlNLmhPaXJBe0pzSHNHaXJBe0qTC9pTmlzQntLkgvaUJhe0nzQvBy5oT2lyQXtKkwvaU5pc0J7SHNLcUZpc0J7S5IL2lCYXtKc0uaA9pckF7SjNIxe0pzS5oD2lyQXtKU0uaE9pDmnuKE0u6Dulef74Mc7nfzH47MPX6/39NM7r7XT4NXriaNroWaZpo6ekpo2ev5o1+hPZNW30zNi00dNo00bPuU0b/RD9rNGzedNGz+ZNGz2bN230bN600bN5s0Z/ZvOmjZ7NmzZ6Nm/a6Nm8aaMfop81ejZv2ujZvGmjZ/OmjZ7NmzZ6Nm/W6AebN230bN600bN500bP5k0b/RD9rNGzedNGz+ZNGz2bN230bN53in7cPn7my+n8+YdvY9z++vBt/H1O/oyezZs1+gubN230bN600bN500bP5k0b/RD9rNGzedNGz+ZNGz2bN230bN600bN5s0Z/ZfOmjZ7NmzZ6Nm/a6Nm8aaMfop81ejZv2ujZvGmjZ/OmjZ7NmzZ6Nm/W6G9s3rTRs3nTRs/mTRs9mzdt9EP0s0bP5k0bPZs3bfRs3rTRs3nTRs/mfaPox+Xy/uFxPf6a5p2g21OanNue0qTR9pQmM7anNIc0d5Qmf7WnNCmpPaXJMu0pTeJoT2lyQTtK88EF7SlNLmhPaXJBe0qTC9pTmkOaO0qTC9pTmlzQntLkgvaUJhe0pzS5oP2keT1wQXtKkwvaU5pc0J7S5IL2lOaQ5o7S5IL2lCYXtKc0uaA9pckF7SlNLmhHaR65oD2lyQXtKU0uaE9pckF7SnNIc0dpckF7SpML2lOaXNCe0uSC9pQmF7SjNE9c0HdK83r7SPN2Xvjw/S25vz58//kLfkRPHE0bPcs0bfSU1LTRD9HPGj3ZNW30zNi00dNo00bPuU0bPUE3a/RnNm/a6Nm8aaNn86aNns2bNvoh+lmjZ/OmjZ7NmzZ6Nm/a6Nm8aaNn82aNfrB500bP5k0bPZs3bfRs3rTRD9HPGj2bN230bN600bN500bP5k0bPZs3a/QXNm/a6Nm8aaNn86aNns2bNvoh+lmjZ/OmjZ7NmzZ6Nm/a6Nm8aaNn82aN/srmTRs9mzdt9GzetNGzedNGP0Q/a/Rs3rTRs3nTRs/mTRs9mzdt9GzerNHf2Lxpo2fzpo2ezZs2ejZv2uiH6GeNns2bNno2b7fRP24fP/Ph8Pg1ejZv2ujZvGmjZ/O+U/S3y/Ej+vvx8w8/Tvfb+898Pi58+HI8v3/By/EyfpmTO/VnTr4yJzyhOfnKnJCK5uQrc8JAmpOvzMkwJ+bkC3PCbZqTr8wJEWpOvjInrKk5+cqcUKzm5Ctzwseaky/MyYOPNSdfmRM+1px8ZU74WHPylTnhY83JV+ZkmBNz8oU54WPNyVfmhI81J1+ZEz7WnHxlTvhYc/KVOeFjzcnynNwOfKw5+cqc8LHm5Ctzwseak6/MCR9rTr4yJ8OcmJMvzAkfa06+Mid8rDn5ypzwsebkK3PCx5qTr8wJH2tOvjAnRz7WnHxlTvhYc/KVOeFjzclX5oSPNSdfmZNhTszJF+aEjzUnX5kTPtacfGVO+Fhz8pU54WPNyVfmhI81J1+YkxMfa06+Mid8rDn5ypzwsebkK3PCx5qTr8zJMCfm5Atzwseak6/MCR9rTr4yJ3ysOfnKnPCx5uQrc8LHmpMvzMmZjzUnX5kTPtacfGVO+Fhz8pU54WPNyVfmZJgTc/KFOeFjzclX5oSPNSdfmRM+1px8ZU74WHPylTnhY83JF+Zk8LHm5Ctzwseak6/MCR9rTr4yJ3ysOfnKnAxzYk6+MCd8rDn5ypzwsebkK3PCx5qTr8wJH2tOvjInfKw5+cKcXPhYc/KVOeFjzclX5oSPNSdfmRM+1px8ZU6GOTEnX5gTPtacfGVO+Fhz8pU54WPNyVfmhI81J1+ZEz7WnHxhTq58rDn5ypzwsebkK3PCx5qTr8wJH2tOvjInw5yYky/MCR9rTr4yJ3ysOfnKnPCx5uQrc8LHmpOvzAkfa06+MCc3PtacfGVO+Fhz8pU54WPNyVfmhI81J1+Zk2FOzMkX5oSPNSdfmRM+1px8ZU74WHPylTnhY83JV+aEjzUnX5iTOx9rTr4yJ3ysOfnKnPCx5uQrc8LHmpOvzMkwJ+bkC3PCx5qTr8wJH2tOvjInfKw5+cqc8LH7nZOPXN7m5PFr9BTrbqMfx9P7zzzG7fMPnx7nd3anx+XHn3x6BuNy+BiPy+Hx+PnD/x6qBx9rqMqHirw1VOVDxfQaqvKhooUNVflQDUNlqKqHinA2VOVDxU4bqvKhorINVflQ8d6GqnyoGHVDVTxU9wOjbqjKh4pRN1TlQ8WoG6ryoWLUDVX5UA1DZaiqh4pRN1TlQ8WoG6ryoWLUDVX5UDHqhqp8qBh1Q1U9VEdG3VCVDxWjbqjKh4pRN1TlQ8WoG6ryoRqGylBVDxWjbqjKh4pRN1TlQ8WoG6ryoWLUDVX5UDHqhqp6qE6MuqEqHypG3VCVDxWjbqjKh4pRN1TlQzUMlaGqHipG3VCVDxWjbqjKh4pRN1TlQ8WoG6ryoWLUDVX1UJ0ZdUNVPlSMuqEqHypG3VCVDxWjbqjKh2oYKkNVPVSMuqEqHypG3VCVDxWjbqjKh4pRN1TlQ8WoG6rqoRqMuqEqHypG3VCVDxWjbqjKh4pRN1TlQzUMlaGqHqp5jfr99P5nn++X+98+/SeaPXnh08cP8jbF1wU0p+vh/c8+XY9LIE+Xx/jx6Z/m8fIXxz2p0H+S4/X68XNff/qzT08vL9fb+9Xlcf71f9V7EoX/JPLb4fH+6dv5tAr5njTaP4n8fnoncrr/dKt7v1pc9mSO/kmOj8vpYwt4HD8f3dPh8fHh4/H8K/Q9mZVvA31P5qEN9NP4uLycrmPNFf2ypxK/x3yGfP6BfD467ul8WLWEXvZULfeYz6767fH+Q82cF4iP8fFjj3F/LH36dPnA+NYSFnzLOLwLpcs4jV+h76oMfxfou6rD3wX6rgrxN4F+3VV7/i7Qd9Wevwv0XbXn7wJ9V5X4u0AfoG8PfVfl9btA10hfAF0jfQF0jfQF0DXS7aHfNNIXQNdIXwBdI30BdI30BdAH6NtD10hfAF0jfQF0jfQF0DXSF0DXSLeHftdIXwBdI30BdI30BdA10hdAH6BvD10jfQF0jfQF0DXSF0DXSF8AXSPdHvpDI30BdI30BdA10hdA10hfAH2Avj10jfQF0DXSF0DXSF8AXSN9AXSNdHPoj4NG+gLoGukLoGukL4Cukb4A+gB9e+ga6degXw/vL5Ed19PhV45KZg1HvbGGoypYw1G7+yLHy+WD4+1XjkeFrYajDlbDUa2q4agp1XAcOFbcr4/6TA1HfaaGoz5Tw1GfqbnP6DMlHE/6TA1HfaaGoz5Tw1GfqeE4cCzhqM/UcNRnajjqMzUc9ZkajvpMCcezPlPDUZ+p4ajPlHizsz5Tw3HgWMJRn6nhqM/U3Gf0mRqO+kwNR32mhOPQZ2o46jM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM/UcNRnSjhe9JkSb3bRZ2o46jM1HPWZGo4Dx5L7jD5Tw1GfqeGoz9Rw1GdqOOozJRyv+kwNR32mhqM+U8NRn6nhOHAs4ajP1HDUZ2o46jM1HPWZEm921WdKON70mRqO+kwNR32m5D5z02dqOA4cSzjqMzUc9ZkajvpMDUd9poajPlPC8a7P1HDUZ2o46jM1HPWZGo4DxxKO+kwNR32mxJvd9ZkajvpMDUd9poTjQ58puc889JkajvpMDUd9pobjwLGEoz5Tw1GfqeGoz9Rw1GdqOOozBRzvh4M+U8NRn6nhqM/UcNRnajgOHNd7szeO+kwNR32mhqM+U8NRn6m5z+gzJRyP+kwNR32mhqM+U8NRn6nhOHAs4ajP1HDUZ2o46jM1HPWZGo76TAnHkz5Tw1GfqeGoz5R4s5M+U8Nx4FjCUZ+p4ajP1Nxn9JkajvpMDUd9poTjWZ+p4ajP1HDUZ2o46jM1HAeOJRz1mRqO+kwNR32mhqM+U8NRnynhOPSZEm829JkajvpMDUd9pobjwLHkPqPP1HDUZ2o46jM1HPWZGo76TAnHiz5Tw1GfqeGoz9Rw1GdqOA4cSzjqMzUc9ZkajvpMDUd9psSbXfSZEo5XfaaGoz5Tw1GfKbnPXPWZGo4DxxKO+kwNR32mhqM+U8NRn6nhqM+UcLzpMzUc9ZkajvpMDUd9pobjwLGEoz5Tw1GfKfFmN32mhqM+U8NRnynheNdnSu4zd32mhqM+U8NRn6nhOHAs4ajP1HDUZ2o46jM1HPWZGo76TAnHhz5Tw1GfqeGoz9Rw1GdqOA4cK7zZQ5+p4ajP1HDUZ2o46jM19xl9poLj8aDP1HDUZ2o46jM1HPWZGo4DxxKO+kwNR32mhqM+U8NRn6nhqM+UcDzqMzUc9ZkajvpMhTc7HvWZGo4DxxKO+kwNR32m5j6jz9Rw1GdqOOozJRxP+kwNR32mhqM+U8NRn6nhOHAs4ajP1HDUZ2o46jM1HPWZGo76TAnHsz5T4s3O+kwNR32mhqM+U8Nx4Fhyn9FnajjqMzUc9ZkajvpMDUd9poTj0GdqOOozNRz1mRqO+kwNx4FjCUd9poajPlPDUZ+p4ajPlHizoc+UcLzoMzUc9ZkajvpMyX3mos/UcBw4lnDUZ2o46jM1HPWZGo76TA1HfaaE41WfqeGoz9Rw1GdqOOozNRwHjiUc9ZkajvpMiTe76jM1HPWZGo76TAnHmz5Tcp+56TM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM/UcNRnSjje9ZkajvpMDUd9poajPlPDceBY4c3u+kwNR32mhqM+U8NRn6m5z+gzJRwf+kwNR32mhqM+U8NRn6nhOHAs4ajP1HDUZ2o46jM1HPWZGo76TAXH00GfqeGoz9Rw1GcqvNnpoM/UcBw4lnDUZ2o46jM19xl9poajPlPDUZ8p4XjUZ2o46jM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM/UcNRnSjie9JkSb3bSZ2o46jM1HPWZGo4Dx5L7jD5Tw1GfqeGoz9Rw1GdqOOozJRzP+kwNR32mhqM+U8NRn6nhOHAs4ajP1HDUZ2o46jM1HPWZEm921mdKOA59poajPlPDUZ8puc8MfaaG48CxhKM+U8NRn6nhqM/UcNRnajjqMyUcL/pMDUd9poajPlPDUZ+p4ThwLOGoz9Rw1GdKvNlFn6nhqM/UcNRnSjhe9ZmS+8xVn6nhqM/UcNRnajgOHEs46jM1HPWZGo76TA1HfaaGoz5TwvGmz9Rw1GdqOOozNRz1mRqOA8cKb3bTZ2o46jM1HPWZGo76TM19Rp8p4XjXZ2o46jM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM/UcNRnSjg+9JkajvpMDUd9psSbPfSZGo4DxxKO+kwNR32m5j6jz9Rw1GdqOOozFRzPB32mhqM+U8NRn6nhqM/UcBw4lnDUZ2o46jM1HPWZGo76TA1HfaaE41GfqfBm56M+U8NRn6nhqM/UcBw4ltxn9JkajvpMDUd9poajPlPDUZ8p4XjSZ2o46jM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM+UeLOTPlPC8azP1HDUZ2o46jMl95mzPlPDceBYwlGfqeGoz9Rw1GdqOOozNRz1mRKOQ5+p4ajP1HDUZ2o46jM1HAeOJRz1mRqO+kyJNxv6TA1HfaaGoz5TwvGiz5TcZy76TA1HfaaGoz5Tw3HgWMJRn6nhqM/UcNRnajjqMzUc9ZkSjld9poajPlPDUZ+p4ajP1HAcOFZ4s6s+U8NRn6nhqM/UcNRnau4z+kwJx5s+U8NRn6nhqM/UcNRnajgOHEs46jM1HPWZGo76TA1HfaaGoz5TwvGuz9Rw1GdqOOozJd7srs/UcBw4lnDUZ2o46jM19xl9poajPlPDUZ8p4fjQZ2o46jM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM/UcNRnKji+gcGxwJuNgz5Tw1GfqeGoz9RwHDiW3Gf0mRqO+kwNR32mhqM+U8NRnynheNRnajjqMzUc9ZkajvpMDceBYwlHfaaGoz5Tw1GfqeGoz5R4s6M+U8LxpM/UcNRnSq6PJ32mhqM+U8Nx4FjCUZ+p4ajP1HDUZ2r2Hn2mhqM+U8LxrM+UXB/P+kwNR32mhqM+U8Nx4FjCUZ+p4ajP1Ow9+kwNR32mhqM+U8Jx6DMl95mhz9Rw1GdqOOozNRwHjiUc9ZkajvpMDUd9poajPlPDUZ8p4XjRZ2o46jNf43j7IPL2n+dfOc7bZy7njwm7XK5Lnz5dbu+fPt3+xvHXD1/G4frXhy/jNH6FPm/5eSH0Afr20OetVS+EPm8HeyH0eQvbC6HP2+5eCH3eKvg66Nd5e+MLoc9bMl8IXSN9AXSN9AXQB+jbQ9dIXwBdI30BdI30BdA10hdA10i3h37TSF8AXSN9AXSN9AXQNdIXQB+gbw9dI30BdI30BdA10hdA10hfAF0j3R76XSN9AXSN9AXQNdIXQNdIXwB9gL49dI30BdA10hdA10hfAF0jfQF0jXR76A+N9AXQNdIXQNdIXwBdI30B9AH69tA10hdA10hfAF0jfQF0jfQF0DXSzaFfDhrpC6BrpF+D/vnLgC8HJbOGo95Yw3HgWMJRu/six09finc5KGw1HHWwGo5qVQ1HTamE41H5KblfH/WZGo76TA1HfaaG48Cx5D6jz9Rw1GdqOOozNRz1mRqO+kwJx5M+U8NRn6nhqM/UcNRnajgOHEs46jM1HPWZGo76TA1HfabEm530mRKOZ32mhqM+U8NRnym5z5z1mRqOA8cSjvpMDUd9poajPlPDUZ+p4ajPlHAc+kwNR32mhqM+U8NRn6nhOHAs4ajP1HDUZ0q82dBnajjqMzUc9ZkSjhd9puQ+c9FnajjqMzUc9ZkajgPHEo76TA1HfaaGoz5Tw1GfqeGoz5RwvOozNRz1mRqO+kwNR32mhuPAscKbXfWZGo76TA1HfaaGoz5Tc5/RZ0o43vSZGo76TA1HfaaGoz5Tw3HgWMJRn6nhqM/UcNRnajjqMzUc9ZkSjnd9poajPlPDUZ8p8WZ3faaG48CxhKM+U8NRn6m5z+gzNRz1mRqO+kwJx4c+U8NRn6nhqM/UcNRnajgOHEs46jM1HPWZGo76TA1HfaaGoz5TwfF60GcqvNn1oM/UcNRnajjqMzUcB44l9xl9poajPlPDUZ+p4ajP1HDUZ0o4HvWZGo76TA1HfaaGoz5Tw3HgWMJRn6nhqM/UcNRnajjqMyXe7KjPlHA86TM1HPWZGo76TMl95qTP1HAcOJZw1GdqOOozNRz1mRqO+kwNR32mhONZn6nhqM/UcNRnajjqMzUcB44lHPWZGo76TIk3O+szNRz1mRqO+kwJx6HPlNxnhj5Tw1GfqeGoz9RwHDiWcNRnajjqMzUc9ZkajvpMDUd9poTjRZ+p4ajP1HDUZ2o46jM1HAeOFd7sos/UcNRnajjqMzUc9Zma+4w+U8Lxqs/UcNRnajjqMzUc9ZkajgPHEo76TA1HfaaGoz5Tw1GfqeGoz5RwvOkzNRz1mRqO+kyJN7vpMzUcB44lHPWZGo76TM19Rp+p4ajP1HDUZ0o43vWZGo76TA1HfaaGoz5Tw3HgWMJRn6nhqM/UcNRnajjqMzUc9ZkSjg99psSbPfSZGo76TA1HfaaG48Cx5D6jz9Rw1GdqOOozNRz1mRqO+kwFx9tBn6nhqM/UcNRnajjqMzUcB44lHPWZGo76TA1HfaaGoz5T4c1uB32mhONRn6nhqM/UcNRnSu4zR32mhuPAsYSjPlPDUZ+p4ajP1HDUZ2o46jMlHE/6TA1HfaaGoz5Tw1GfqeE4cCzhqM/UcNRnSrzZSZ+p4ajP1HDUZ0o4nvWZkvvMWZ+p4ajP1HDUZ2o4DhxLOOozNRz1mRqO+kwNR32mhqM+U8Jx6DM1HPWZGo76TA1HfaaG48CxwpsNfaaGoz5Tw1GfqeGoz9TcZ/SZEo4XfaaGoz5Tw1GfqeGoz9RwHDiWcNRnajjqMzUc9ZkajvpMDUd9poTjVZ+p4ajP1HDUZ0q82VWfqeE4cCzhqM/UcNRnau4z+kwNR32mhqM+U8Lxps/UcNRnajjqMzUc9ZkajgPHEo76TA1HfaaGoz5Tw1GfqeGoz5RwvOszJd7srs/UcNRnajjqMzUcB44l9xl9poajPlPDUZ+p4ajP1HDUZ0o4PvSZGo76TA1HfaaGoz5Tw3HgWMJRn6nhqM/UcNRnajjqMyXe7KHPVHC8H/SZGo76TA1HfabiPnM/6DM1HAeOJRz1mRqO+kwNR32mhqM+U8NRnynheNRnajjqMzUc9ZkajvpMDceBYwlHfaaGoz5T4s2O+kwNR32mhqM+U8LxpM+U3GdO+kwNR32mhqM+U8Nx4FjCUZ+p4ajP1HDUZ2o46jM1HPWZEo5nfaaGoz5Tw1GfqeGoz9RwHDhWeLOzPlPDUZ+p4ajP1HDUZ2ruM/pMCcehz9Rw1GdqOOozNRz1mRqOA8cSjvpMDUd9poajPlPDUZ+p4ajPlHC86DM1HPWZGo76TIk3u+gzNRwHjiUc9ZkajvpMzX1Gn6nhqM/UcNRnSjhe9ZkajvpMDUd9poajPlPDceBYwlGfqeGoz9Rw1GdqOOozNRz1mRKON32mxJvd9JkajvpMDUd9pobjwLHkPqPP1HDUZ2o46jM1HPWZGo76TAnHuz5Tw1GfqeGoz9Rw1GdqOA4cSzjqMzUc9ZkajvpMDUd9psSb3fWZEo4PfaaGoz5Tw1GfKbnPPPSZGo4DxxKO+kwNR32mhqM+U8NRn6nhqM9UcHwc9JkajvpMDUd9poajPlPDceBYwlGfqeGoz1R4s8dBn6nhqM/UcNRnSjge9ZmS+8xRn6nhqM/UcNRnajgOHEs46jM1HPWZGo76TA1HfaaGoz5TwvGkz9Rw1GdqOOozNRz1mRqOA8cKb3bSZ2o46jM1HPWZGo76TM19Rp8p4XjWZ2o46jM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM/UcNRnSjgOfaaGoz5Tw1GfKfFmQ5+p4ThwLOGoz9Rw1Gdq7jP6TA1HfaaGoz5TwvGiz9Rw1GdqOOozNRz1mRqOA8cSjvpMDUd9poajPlPDUZ+p4ajPlHC86jMl3uyqz9Rw1GdqOOozNRwHjiX3GX2mhqM+U8NRn6nhqM/UcNRnSjje9JkajvpMDUd9poajPlPDceBYwlGfqeGoz9Rw1GdqOOozJd7sps+UcLzrMzUc9ZkajvpMyX3mrs/UcBw4lnDUZ2o46jM1HPWZGo76TA1HfaaE40OfqeGoz9Rw1GdqOOozNRwHjiUc9ZkajvpMiTd76DM1HPWZGo76TAHHx+GgzxTcZ9446jM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM/UcNRnSjge9ZkajvpMDUd9poajPlPDceBY4c2O+kwNR32mhqM+U3N91GdqOOozJRxP+kwNR32mhqM+U8NRnynZe04DxxKO+kwNR32m5vqoz9Rw1GdqOOozJRzP+kwNR32mhqM+U7L3nPWZGo4DxxKO+kwNR32m5j6jz9Rw1GdqOOozJRyHPlPDUZ+p4ajP1HDUZ2o4DhxLOOozNRz1mRqO+szXON4+iLz95/lXjhP3mcePCTvdlj59utzeP326/Y3jrx++jMP1rw9fxmn8Cn3i8vMy6JeJm9LroE9cq14HfeIO9jroExe210EfoG8PfeIq+DroE/fG10GfuGS+DrpG+gLoGun20K8a6Quga6QvgK6RvgC6RvoC6AP07aFrpC+ArpG+ALpG+gLoGukLoGuk20O/aaQvgK6RvgC6RvoC6BrpC6AP0LeHrpG+ALpG+gLoGukLoGukL4CukW4P/a6RvgC6RvoC6BrpC6BrpC+APkDfHrpG+gLoGukLoGukL4Cukb4Auka6PfSHRvoC6BrpC6BrpC+ArpG+APoAfXvoGukLoGukL4CukX4N+sLLgB9KZg1HvbGC4/GgCtZw1O6+yPHTl+IdDwpbDUcdrIbjwLGEo6ZUw1H5qblf6zM1HPWZGo76TAnHoz5Tcp856jM1HPWZGo76TA3HgWMJR32mhqM+U8NRn6nhqM/UcNRnSjie9JkajvpMDUd9poajPlPDceBY4c1O+kwNR32mhqM+U8NRn6m5z+gzJRzP+kwNR32mhqM+U8NRn6nhOHAs4ajP1HDUZ2o46jM1HPWZGo76TAnHoc/UcNRnajjqMyXebOgzNRwHjiUc9ZkajvpMzX1Gn6nhqM/UcNRnSjhe9JkajvpMDUd9poajPlPDceBYwlGfqeGoz9Rw1GdqOOozNRz1mRKOV32mxJtd9ZkajvpMDUd9pobjwLHkPqPP1HDUZ2o46jM1HPWZGo76TAnHmz5Tw1GfqeGoz9Rw1GdqOA4cSzjqMzUc9ZkajvpMDUd9psSb3fSZEo53faaGoz5Tw1GfKbnP3PWZGo4DxxKO+kwNR32mhqM+U8NRn6nhqM+UcHzoMzUc9ZkajvpMDUd9pobjwLGEoz5Tw1GfKfFmD32mhqM+U8NRn6ngeDroMxX3mf+rvbfbcWNt2+POxdvZYHff/ZeTCWwjCD7ggx3YToAg8Ll7tJZI6ZXIoabXpbtLw7IB410wH2mm6pGadc1IGi/2TIajPZPhaM9kOJYcIxztmQxHeybD0Z7JcLRnMhztmQjHwZ7JcLRnMhztmQxHeybDseSY2M0GeybD0Z7JcLRnMhztmcxzxp6JcBztmQxHeybD0Z7JcLRnMhxLjhGO9kyGoz2T4WjPZDjaMxmO9kyE42TPZDjaMxmO9kxkN5vsmQzHkmOEoz2T4WjPZJ4z9kyGoz2T4WjPRDiWPZPhaM9kONozGY72TIZjyTHC0Z7JcLRnMhztmQxHeybD0Z6JcJztmchuNtszGY72TIajPZPhWHKMPGfsmQxHeybD0Z7JcLRnMhztmQjHxZ7JcLRnMhztmQxHeybDseQY4WjPZDjaMxmO9kyGoz0T2c0WeybCcbVnMhztmQxHeybynFntmQzHkmOEoz2T4WjPZDjaMxmO9kyGoz0T4bjZMxmO9kyGoz2T4WjPZDiWHCMc7ZkMR3smsptt9kyGoz2T4WjPRDju9kzkObPbMxmO9kyGoz2T4VhyjHC0ZzIc7ZkMR3smw9GeyXC0ZxIcp4s9k+Foz2Q42jMZjvZMhmPJMbCbTRd7JsPRnslwtGcyHO2ZzHPGnolwHOyZDEd7JsPRnslwtGcyHEuOEY72TIajPZPhaM9kONozGY72TITjaM9kONozGY72TGQ3G+2ZDMeSY4SjPZPhaM9knjP2TIajPZPhaM9EOE72TIajPZPhaM9kONozGY4lxwhHeybD0Z7JcLRnMhztmQxHeybCseyZyG5W9kyGoz2T4WjPZDiWHCPPGXsmw9GeyXC0ZzIc7ZkMR3smwnG2ZzIc7ZkMR3smw9GeyXAsOUY42jMZjvZMhqM9k+Foz0R2s9meiXBc7JkMR3smw9GeiTxnFnsmw7HkGOFoz2Q42jMZjvZMhqM9k+Foz0Q4rvZMhqM9k+Foz2Q42jMZjiXHCEd7JsPRnonsZqs9k+Foz2Q42jMRjps9E3nObPZMhqM9k+Foz2Q4lhwjHO2ZDEd7JsPRnslwtGcyHO2ZCMfdnslwtGcyHO2ZDEd7JsOx5JjYzXZ7JsPRnslwtGcyHO2ZzHPGnklwfAMjxwhHeybD0Z7JcLRnMhxLjhGO9kyGoz2T4WjPZDjaMxmO9kyE42DPZDjaMxmO9kxiN6vBnslwLDlGONozGY72TOY5Y89kONozGY72TITjaM9kONozGY72TIajPZPhWHKMcLRnMhztmQxHeybD0Z7JcLRnIhwneyaym032TIajPZPhaM9kOJYcI88ZeybD0Z7JcLRnMhztmQxHeybCseyZDEd7JsPRnslwtGcyHEuOEY72TIajPZPhaM9kONozkd2s7JkIx9meyXC0ZzIc7ZnIc2a2ZzIcS44RjvZMhqM9k+Foz2Q42jMZjvZMhONiz2Q42jMZjvZMhqM9k+FYcoxwtGcyHO2ZyG622DMZjvZMhqM9E+G42jOR58xqz2Q42jMZjvZMhmPJMcLRnslwtGcyHO2ZDEd7JsPRnolw3OyZDEd7JsPRnslwtGcyHEuOid1ss2cyHO2ZDEd7JsPRnsk8Z+yZCMfdnslwtGcyHO2ZDEd7JsOx5BjhaM9kONozGY72TIajPZPhaM8kOM4XeybD0Z7JcLRnErvZfLFnMhxLjhGO9kyGoz2Tec7YMxmO9kyGoz0T4TjYMxmO9kyGoz2T4WjPZDiWHCMc7ZkMR3smw9GeyXC0ZzIc7ZkIx9Geiexmoz2T4WjPZDjaMxmOJcfIc8aeyXC0ZzIc7ZkMR3smw9GeiXCc7JkMR3smw9GeyXC0ZzIcS44RjvZMhqM9k+Foz2Q42jOR3WyyZyIcy57JcLRnMhztmchzpuyZDMeSY4SjPZPhaM9kONozGY72TIajPRPhONszGY72TIajPZPhaM9kOJYcIxztmQxHeyaym832TIajPZPhaM9EOC72TOQ5s9gzGY72TIajPZPhWHKMcLRnMhztmQxHeybD0Z7JcLRnIhxXeybD0Z7JcLRnMhztmQzHkmNiN1vtmQxHeybD0Z7JcLRnMs8ZeybCcbNnMhztmQxHeybD0Z7JcCw5RjjaMxmO9kyGoz2T4WjPZDjaMxGOuz2T4WjPZDjaM5HdbLdnMhxLjhGO9kyGoz2Tec7YMxmO9kyGoz2T4Lhc7JkMR3smw9GeyXC0ZzIcS44RjvZMhqM9k+Foz2Q42jMZjvZMhONgzyR2s2WwZzIc7ZkMR3sm8/tjyTHC0Z7JcLRnMhztmQxHeybD0Z6JvO8Z7ZkMR3smw9Geifz+ONozGY4lxwhHeybD0Z7JcLRnMhztmcz7HnsmwnGyZzIc7ZkMR3sm8pyZ7JkMx5JjhKM9k+Foz2Q42jMZjvZMhqM9E+FY9kyGoz2T4WjPZDjaM7/Gcb0Refuf088c62U5Lst6I3PZnrx6W68fyLbN315b61eMr5szH8K43z7Hfat/wXjnRx7n2488rv9ydX9+8VyX5euL5xrr53v+up30hwh63QD7QwS9btn9IYJeNxn/DEHz67boHyLodSP3DxH0uvX8hwh63Sz/QwSVgtiCXBLgglwS4IJcEuCCXBLgglwS2IIWlwS4IJcEuCCXBLgglwS4oFIQW5BLAlyQSwJckEsCXJBLAlyQSwJb0OqSABfkkgAX5JIAF+SSABdUCmILckmAC3JJgAtySYALckmAC3JJYAvaXBLgglwS4IJcEuCCXBLggkpBbEEuCXBBLglwQS4JcEEuCXBBLglsQbtLAlyQSwJckEsCXJBLAlxQKYgtyCUhL+jJP8axOw70M7f3+5mb8P3MrfLfwPzdv0R7vRja/cxt537m5nA/cwu3n3nJvPl9y3qxQ/uZ26H9zO3QfuZ2aP8z1A5tZz7Yof3M7dB+5nZoP3M7tJ95ybyduR3az9wO7Wduh/Yzt0P7mduh7cxHO7SfuR3az9wObd9yRzu0n3nJvJ25HdrP3A7tf4baof3M7dB+5nZoO/PJDu1nbof2M7dD+5nbof3MS+btzO3QfuZ2aD9zO7SfuR3az9wObWdedmj7llt2aD9zO7SfuR3az7xk3v4MtUP7mduh/czt0H7mdmg/czu0nflsh/Yzt0P7mduh/czt0H7mJfN25nZoP3M7tJ+5HdrP3A5t33JnO7Sd+WKH9jO3Q/uZ26Htz9DFDu1nXjJvZ26H9jO3Q/uZ26H9zO3QfuZ2aDvz1Q7tZ26H9jO3Q/uZ26H9zEvm7czt0H7mdmj7lrvaof3M7dB+5nZoO/PNDm1/hm52aD9zO7SfuR3az7xk3s7cDu1nbof2M7dD+5nbof3M7dB25rsd2s/cDu1nbof2M7dD+5mXzLu33N0O7Wduh/Yzt0P7mduh/c9QO7Sb+XaxQ/uZ26H9zO3QfuZ2aD/zknk7czu0n7kd2s/cDu1nbof2M7dD25kPdmg/czu0n7kd2r3lboMd2s+8ZN7O3A7tZ26H9j9D7dB+5nZoP3M7tJ35aIf2M7dD+5nbof3M7dB+5iXzduZ2aD9zO7SfuR3az9wO7Wduh7Yzn+zQ9i13skP7mduh/czt0H7mJfP2Z6gd2s/cDu1nbof2M7dD+5nboe3Myw7tZ26H9jO3Q/uZ26H9zEvm7czt0H7mdmg/czu0n7kd2r7llh3azny2Q/uZ26H9zO3Q9mfobIf2My+ZtzO3Q/uZ26H9zO3QfuZ2aD9zO7Sd+WKH9jO3Q/uZ26H9zO3QfuYl83bmdmg/czu0fctd7NB+5nZoP3M7tJ35aoe2P0NXO7SfuR3az9wO7WdeMm9nbof2M7dD+5nbof3M7dB+5nZoO/PNDu1nbof2M7dD+5nbof3MS+bdW+5mh/Yzt0P7mduh/czt0P5nqB3azny3Q/uZ26H9zO3QfuZ2aD/zknk7czu0n7kd2s/cDu1nbof2M7dDu5nvFzu0n7kd2s/cDu3ecveLHdrPvGTeztwO7Wduh/Y/Q+3QfuZ2aD9zO7Sd+WCH9jO3Q/uZ26H9zO3QfuYl83bmdmg/czu0n7kd2s/cDu1nboe2Mx/t0PYtd7RD+5nbof3M7dB+5iXz9meoHdrP3A7tZ26H9jO3Q/uZ26HtzCc7tJ+5HdrP3A7tZ26H9jMvmbczt0P7mduh/czt0H7mdmj7ljvZoe3Myw7tZ26H9jO3Q9ufoWWH9jMvmbczt0P7mduh/czt0H7mdmg/czu0nflsh/Yzt0P7mduh/czt0H7mJfN25nZoP3M7tH3Lne3QfuZ2aD9zO7Sd+WKHtj9DFzu0n7kd2s/cDu1nXjJvZ26H9jO3Q/uZ26H9zO3QfuZ2aDvz1Q7tZ26H9jO3Q/uZ26H9zEvm3Vvuaof2M7dD+5nbof3M7dD+Z6gd2s58s0P7mduh/czt0H7mdmg/85J5O3M7tJ+5HdrP3A7tZ26H9jO3Q9uZ73ZoP3M7tJ+5Hdq+5e52aD/zknk7czu0n7kd2v8MtUP7mduh/czt0Gbmw+Xt/wi9H7olegJ0U/QE6LboCdBL6P3QrdEToJujJ0C3R0+AbpCeAN0i7Yc+WKTNs+4X6BbpCdAt0hOgW6QnQC+h9z9ILdIToFukJ0C3SE+AbpGeAN0i7Yc+WqQnQLdIT4BukZ4A3SI9AXoJvR+6RXoCdIv0BOgW6QnQLdL+aXe0SPuhTxbpCdAt0hOgW6T9D9LJIj0Begm9H7pFegJ0i/QE6BbpCdAt0hOgW6T90MsiPQG6RXoCdIv0BOgW6QnQS+j90C3SE6BbpP3TblmkJ0C3SE+AbpH2Q58t0v4H6WyRngDdIj0BukV6AvQSej90i/QE6BbpCdAt0hOgW6QnQLdI+6EvFukJ0C3SE6BbpCdAt0hPgF5Cb592F4v0BOgW6QnQLdIToFukJzxILdJ+6KtFegJ0i/QE6BbpCdAt0hOgl9D7oVukJ0C3SE+AbpGeAN0iPQG6RdoPfbNIT4BukZ4A3SLtn3Y3i/QE6CX0fugW6QnQLdITHqQW6QnQLdIToFuk/dB3i/QE6BbpCdAt0hOgW6QnQC+h90O3SE+AbpGeAN0iPQG6RXoCdIu0HfobdqF3T7tv/1fo/dAt0hOgW6QnQC+h9z9ILdIToFukJ0C3SE+AbpGeAN0i7Yc+WKQnQLdIT4BukZ4A3SI9AXoJvR+6RXoCdIv0BOgW6QnQLdL+aXewSPuhjxbpCdAt0hOgW6T9D9LRIj0Begm9H7pFegJ0i/QE6BbpCdAt0hOgW6T90CeL9AToFukJ0C3SE6BbpCdAL6H3Q7dIT4BukfZPu5NFegJ0i/QE6BZpP/SySPsfpGWRngDdIj0BukV6AvQSej90i/QE6BbpCdAt0hOgW6QnQLdI+6HPFukJ0C3SE6BbpCdAt0hPgF5Cb592Z4v0BOgW6QnQLdIToFukJzxILdJ+6ItFegJ0i/QE6BbpCdAt0hOgl9D7oVukJ0C3SE+AbpGeAN0iPQG6RdoPfbVIT4BukZ4A3SLtn3ZXi/QE6CX0fugW6QnQLdITHqQW6QnQLdIToFuk/dA3i/QE6BbpCdAt0hOgW6QnQC+h90O3SE+AbpGeAN0iPQG6RXoCdIu0H/pukfZPu7tFegJ0i/QE6BbpCdBL6P0PUov0BOgW6QnQLdIToFukJ0C3SNuhjxeL9AToFukJ0C3SE6BbpCdAL6H3Q7dIT4BukZ4A3SI9AbpF2j7tjheLtB/6YJGeAN0i7f89fbBIT4BukZ4AvYTeD90iPQG6RXoCdIv0hLeMFukJ0C3SfuijRdr/e/pokZ4A3SI9AbpFegL0Eno/dIv0BOgW6QlvGS3SE6BbpCdAt0j7oU8Waf+DdLJIT4BukZ4A3SI9AXoJvR+6RXoCdIv0BOgW6QnQLdIToFuk/dDLIj0BukWah77e6L39z+kOdIv0l6APNV1v7/A2aD3BvsyX60eyzNPwPfY7+Lbtuo9N2z5+e/G9z3Gabx/HNNfw/Yu/CrV2P5nQUujnEmqlfzKhLgB/ltBlvsFe1roj1HXhkwl1ufjDhO7TDfZ3H/X9F4+3ry9P47C8/+JxWW5mlu3Ji+sbu/1eOznNeKvit2p2e/JW/W1mvexXM+s0/rNb5bjmrcrfKtdDb9XfZvZ5vJrZ9+HJi9+2/uuLx6X+2RV07/QKnnwFyyvoFTxwBbebxunyD6PBTdkrePIVdAX/zFewLrcrOD/5kcd5r9saMtz5gsnsvu5VyQ9njvzeqvytcuT3VsVv1eLI762Kz7GLI7+3Kn+rHPm9VX+b2cbbaLp9+ax+DLvFMd6r8otXpbwqXpVfuyqO216VX7wqjtBelb/NfOjrIJf99uJhmO7cKxdr79XvuFdu1t6rA/cq+N0riwO3V/DcK7i6hnsFT76CTudewSNXMPcNVKs7u1fw5Cvofv+Jr+B0AzJN8z8t17W8Kl6VX7sq7vdelfw7dqd+b1X+Vjn0e6vyt8qZ31uVrzWXe29V/FZtjvF/1q1al/0Ge6tnM9RH/ijpsz/Htzmae1X+NhP8szGbO7i3Kn+rnLa9VflbVd4qb9VfZoJ/4mpzMPdW5W+Vg7m36m8zz/4YxeYK7lX5xavitO1V+cWr4l7tVfm1q7I7QntV/jYT/fNWu4u19+p33Cs3a+/VgXsV/B6T3YHbK3jyFSyvoFfw3CvodO4VPHIFc99AtbuzewVPvoLu95/5Cp70lxbvTv3eqvyt8qsC3qq/zeS+2WG6+AUEb1X+VvnlA2/VqQPHdPErDV7Bk6+gX2nwCp46cEyX8gp6Bc+9gn6l4RNfweRfgPR207wqXpVfuyou916V/Dt2l3tvVf5Wudx7q+K3anC591bFa21wufdW5W+VY/yv3art9jW4YfsC+rtb9ZWkm3KKZEkyRNKFL0XSAezjJIftHkn3oRRJN5EUSXeAEMnR9k2RtPdCz+7RxkmRtHFSJEuSIZI2ToqkjZMiaeOkSNo4KZI2TojkZOOkSNo4KZI2zj/+6uBXkjZOimRJMkTSxkmRtHFSJF+3cfbxyqb2+V9f/ZXN61bLczav2yFP2dTrlsVzNq/bCs/ZvO67/+dsXvf9/HM2JZuHbF73PfdzNq/7Lvo5G98XP2bj++LHbHxf/JDN7Pvix2x8X/yYje+LH7PxffFjNiWbh2x8X/yYje+LH7PxffFjNr4vfszG98UP2Sy+L37MxvfFj9n4vvgxG98XP2ZTsnnIxvfFj9n4vvgxG98XP2bzsu+L50tdP5J52OrJq4fLMt4+lMsyffvRp7t/KchQ4/Uv8Ruqvv11I19g3vk0x9s3nw7r9v2Lv1p62Xfof5Kl9WVb4Y+y9LLV8mFL8/rN0jo8s7Rty/Xl+2X+p5Zetp/+KEsvW3J/lKXS0v8+j99xfPBuebxJqnH99mPf/Zvq5rpcFc011vcv/kr9ZWv1VOov28GnUn/Zwj6Vuu1+BnVb/ATqm219BnVb+Qzqtu8Z1G3ZM6iX1E+gbpueQd02PYO6bXoGddv0DOq26QnUd9v0DOq26RnUbdMzqNumZ1AvqZ9A3TY9g7ptegZ12/QM6rbpGdRt037qbxilfgJ12/QM6rbpGdRt0zOol9RPoG6bnkHdNj2Dum16BnXb9AzqtukJ1Afb9AzqtukZ1G3TM6jbpmdQL6mfQN02PYO6bXoGddv0DOq26RnUbdMTqI+26RnUbdMzqNumZ1C3TX+N+nKpK/Xly2f2E8gSZAakBRkCaRSGQNp5vwhyvv09v8t6D6TpFgJpjWVATgZWCKTNFAJpBmWe2pNlEwJZgsyAtGxCIC2b0MPGsgmBtGxCIC2bDMiybEIgLZsQSMsmBNKyCYEsQWZAWjYhkJZNCKRlEwJp2YRAWjYZkLNlk5nRZssmBNKyCYG0bEIgS5CZh41lEwJp2YRAWjYhkJZNCKRlkwG5WDYhkJZNCKRlEwJp2YRAliAzIC2bEEjLJgTSsgmBtGwyM9pi2WRArpZNCKRlEwJp2WQeNqtlEwJZgsyAtGxCIC2bEEjLJgTSsgmBtGwyIDfLJgTSsgmBtGxCIC2bEMgSZAakZRMCadlkZrTNsgmBtGxCIC2bDMjdssk8bHbLJgTSsgmBtGxCIEuQGZCWTQikZRMCadmEQFo2IZCWTQTkfLFsQiAtmxBIyyYE0rIJgSxBJma0+WLZhEBaNiGQlk0IpGUTethYNhmQg2UTAmnZhEBaNiGQlk0IZAkyA9KyCYG0bEIgLZsQSMsmBNKyyYAcLZsQSMsmBNKyycxoo2UTAlmCzIC0bEIgLZvQw8ayCYG0bEIgLZsMyMmyCYG0bEIgLZsQSMsmBLIEmQFp2YRAWjYhkJZNCKRlEwJp2WRAlmWTmdHKsgmBtGxCIC2bEMgSZOZhY9mEQFo2IZCWTQikZRMCadlkQM6WTQikZRMCadmEQFo2IZAlyAxIyyYE0rIJgbRsQiAtm8yMNls2GZCLZRMCadmEQFo2mYfNYtmEQJYgMyAtmxBIyyYE0rIJgbRsQiAtmwzI1bIJgbRsQiAtmxBIyyYEsgSZAWnZhEBaNpkZbbVsQiAtmxBIyyYDcrNsMg+bzbIJgbRsQiAtmxDIEmQGpGUTAmnZhEBaNiGQlk0IpGWTAblbNiGQlk0IpGUTAmnZhECWICMz2m7ZhEBaNiGQlk0IpGUTethYNhGQy8WyCYG0bEIgLZsQSMsmBLIEmQFp2YRAWjYhkJZNCKRlEwJp2WRADpZNCKRlEwJp2URmtGWwbEIgS5AZkJZNCKRlE3rYWDYhkJZNCKRlkwE5WjYhkJZNCKRlEwJp2YRAliAzIC2bEEjLJgTSsgmBtGxCIC2bDMjJssnMaJNlEwJp2YRAWjYhkCXIzMPGsgmBtGxCIC2bEEjLJgTSssmALMsmBNKyCYG0bEIgLZsQyBJkBqRlEwJp2YRAWjYhkJZNZkYryyYDcrZsQiAtmxBIyybzsJktmxDIEmQGpGUTAmnZhEBaNiGQlk0IpGWTAblYNiGQlk0IpGUTAmnZhECWIDMgLZsQSMsmM6Mtlk0IpGUTAmnZZECulk3mYbNaNiGQlk0IpGUTAlmCzIC0bEIgLZsQSMsmBNKyCYG0bDIgN8smBNKyCYG0bEIgLZsQyBJkZEbbLJsQSMsmBNKyCYG0bEIPG8smA3K3bEIgLZsQSMsmBNKyCYEsQWZAWjYhkJZNCKRlEwJp2YRAWjYRkOvFsgmBtGxCIC2byIy2XiybEMgSZAakZRMCadmEHjaWTQikZRMCadlkQA6WTQikZRMCadmEQFo2IZAlyAxIyyYE0rIJgbRsQiAtmxBIyyYDcrRsMjPaaNmEQFo2IZCWTQhkCTLzsLFsQiAtmxBIyyYE0rIJgbRsMiAnyyYE0rIJgbRsQiAtmxDIEmQGpGUTAmnZhEBaNiGQlk1mRpssmwzIsmxCIC2bEEjLJvOwKcsmBLIEmQFp2YRAWjYhkJZNCKRlEwJp2WRAzpZNCKRlEwJp2YRAWjYhkCXIDEjLJgTSssnMaLNlEwJp2YRAWjYZkItlk3nYLJZNCKRlEwJp2YRAliAzIC2bEEjLJgTSsgmBtGxCIC2bDMjVsgmBtGxCIC2bEEjLJgSyBBmZ0VbLJgTSsgmBtGxCIC2b0MPGssmA3CybEEjLJgTSsgmBtGxCIEuQGZCWTQikZRMCadmEQFo2IZCWTQbkbtmEQFo2IZCWTWZG2y2bEMgSZAakZRMCadmEHjaWTQikZRMCadlEQG4XyyYE0rIJgbRsQiAtmxDIEmQGpGUTAmnZhEBaNiGQlk0IpGWTATlYNpEZbRssmxBIyyYE0rIJgSxBZh42lk0IpGUTAmnZhEBaNiGQlk0G5GjZhEBaNiGQlk0IpGUTAlmCzIC0bEIgLZsQSMsmBNKyycxoo2WTATlZNiGQlk0IpGWTedhMlk0IZAkyA9KyCYG0bEIgLZsQSMsmBNKyyYAsyyYE0rIJgbRsQiAtmxDIEmQGpGUTAmnZZGa0smxCIC2bEEjLJgNytmwyD5vZsgmBtGxCIC2bEMgSZAakZRMCadmEQFo2IZCWTQikZZMBuVg2IZCWTQikZRMCadmEQJYgIzPaYtmEQFo2IZCWTQikZRN62Fg2GZCrZRMCadmEQFo2IZCWTQhkCTID0rIJgbRsQiAtmxBIyyYE0rLJgNwsmxBIyyYE0rLJzGibZRMCWYLMgLRsQiAtm9DDxrIJgbRsQiAtmwzI3bIJgbRsQiAtmxBIyyYEsgSZAWnZhEBaNiGQlk0IpGUTAmnZREDuF8smMqPtF8smBNKyCYG0bEIgS5CZh41lEwJp2YRAWjYhkJZNCKRlkwE5WDYhkJZNCKRlEwJp2YRAliAzIC2bEEjLJgTSsgmBtGwyM9pg2WRAjpZNCKRlEwJp2WQeNqNlEwJZgsyAtGxCIC2bEEjLJgTSsgmBtGwyICfLJgTSsgmBtGxCIC2bEMgSZAakZRMCadlkZrTJsgmBtGxCIC2bzO+RZdmEQFo2IZCWTQikZRMCWYLMgLRsMm9/yrIJgbRsQiAtm9DvkZZNBuRs2YRAWjYhkJZNCKRlEwJZgoy8/ZktmxBIyyYE0rIJgbRsQg8byyYDcrFsQiAtmxBIyyYE0rIJgSxBZkBaNiGQlk0IpGUTAmnZhEBaNr8Gcr0Refuf088g19ctm2lZryDrMv7Lq7+yed1Yec7mM/VHDcv11TVtT9hs6/WH3rbvfvnVeiXzmYLiQ2T220e9b/UvZO78xjTO1xtW4/ovvzHduY51WW7Xcaw7v4uVzNuZf6ZM+VOYf6ai+VOYf6b4+VOYf6ZO+lOYf6ak+kOYb5+pvv4U5p+p6v4U5i9biycyt0P7mZfM25nbof3M7dB+5nZoP3M7tJ+5HdrOfLdD+5nbof3M7dB+5nZoP/OSeTtzO7SfuR3az9wO7Wduh/Yzt0ObmQ+Xix3az9wO7Wduh/Yzt0P7mZfM25nbof3M7dB+5nZoP3M7tJ+5HdrOfLBD+5nbof3M7dB+5nZoP/OSeTtzO7SfuR3az9wO7Wduh/Yzt0PbmY92aD9zO7SfuR3az9wO/RXm7/9l5W8YS4wJjNZiBKMBGMFo0/0Sxnf/ls43jGZaBKPllcA4GVMRjPZRBKPJk3hST1ZMBGOJMYHRiolgtGIijxgrJoLRiolgtGISGMuKiWC0YiIYrZgIRismgrHEmMBoxUQwWjERjFZMBKMVE8FoxSQwzlZMYiibrZgIRismgtGKiWAsMSYeMVZMBKMVE8FoxUQwWjERjFZMAuNixUQwWjERjFZMBKMVE8FYYkxgtGIiGK2YCEYrJoLRikkMZYsVk8C4WjERjFZMBKMVk3jErFZMBGOJMYHRiolgtGIiGK2YCEYrJoLRiklg3KyYCEYrJoLRiolgtGIiGEuMCYxWTASjFZMYyjYrJoLRiolgtGISGHcrJvGI2a2YCEYrJoLRiolgLDEmMFoxEYxWTASjFRPBaMVEMFoxAYzDxYqJYLRiIhitmAhGKyaCscT4z4ey4WLFRDBaMRGMVkwEoxUTecRYMQmMgxUTwWjFRDBaMRGMVkwEY4kxgdGKiWC0YiIYrZgIRismgtGKSWAcrZgIRismgtGKSQxloxUTwVhiTGC0YiIYrZjII8aKiWC0YiIYrZgExsmKiWC0YiIYrZgIRismgrHEmMBoxUQwWjERjFZMBKMVE8FoxSQwlhWTGMrKiolgtGIiGK2YCMYSY+IRY8VEMFoxEYxWTASjFRPBaMUkMM5WTASjFRPBaMVEMFoxEYwlxgRGKyaC0YqJYLRiIhitmMRQNlsxCYyLFRPBaMVEMFoxiUfMYsVEMJYYExitmAhGKyaC0YqJYLRiIhitmATG1YqJYLRiIhitmAhGKyaCscSYwGjFRDBaMYmhbLViIhitmAhGKyaBcbNiEo+YzYqJYLRiIhitmAjGEmMCoxUTwWjFRDBaMRGMVkwEoxWTwLhbMRGMVkwEoxUTwWjFRDCWGAND2W7FRDBaMRGMVkwEoxUTecRYMQGM48WKiWC0YiIYrZgIRismgrHEmMBoxUQwWjERjFZMBKMVE8FoxSQwDlZMBKMVE8FoxQSGsnGwYiIYS4wJjFZMBKMVE3nEWDERjFZMBKMVk8A4WjERjFZMBKMVE8FoxUQwlhgTGK2YCEYrJoLRiolgtGIiGK2YBMbJikkMZZMVE8FoxUQwWjERjCXGxCPGiolgtGIiGK2YCEYrJoLRiklgLCsmgtGKiWC0YiIYrZgIxhJjAqMVE8FoxUQwWjERjFZMYigrKyaBcbZiIhitmAhGKybxiJmtmAjGEmMCoxUTwWjFRDBaMRGMVkwEoxWTwLhYMRGMVkwEoxUTwWjFRDCWGBMYrZgIRismMZQtVkwEoxUTwWjFJDCuVkziEbNaMRGMVkwEoxUTwVhiTGC0YiIYrZgIRismgtGKiWC0YhIYNysmgtGKiWC0YiIYrZgIxhJjYCjbrJgIRismgtGKiWC0YiKPGCsmgXG3YiIYrZgIRismgtGKiWAsMSYwWjERjFZMBKMVE8FoxUQwWjEBjNPFiolgtGIiGK2YwFA2XayYCMYSYwKjFRPBaMVEHjFWTASjFRPBaMUkMA5WTASjFRPBaMVEMFoxEYwlxgRGKyaC0YqJYLRiIhitmAhGKyaBcbRiEkPZaMVEMFoxEYxWTARjiTHxiLFiIhitmAhGKyaC0YqJYLRiEhgnKyaC0YqJYLRiIhitmAjGEmMCoxUTwWjFRDBaMRGMVkxiKJusmATGsmIiGK2YCEYrJvGIKSsmgrHEmMBoxUQwWjERjFZMBKMVE8FoxSQwzlZMBKMVE8FoxUQwWjERjCXGBEYrJoLRikkMZbMVE8FoxUQwWjEJjIsVk3jELFZMBKMVE8FoxUQwlhgTGK2YCEYrJoLRiolgtGIiGK2YBMbViolgtGIiGK2YCEYrJoKxxBgYylYrJoLRiolgtGIiGK2YyCPGiklg3KyYCEYrJoLRiolgtGIiGEuMCYxWTASjFRPBaMVEMFoxEYxWTALjbsVEMFoxEYxWTGIo262YCMYSYwKjFRPBaMVEHjFWTASjFRPBaMUEML5xEWMCoxUTwWjFRDBaMRGMJcYERismgtGKiWC0YiIYrZgIRismgXGwYgJDWQ1WTASjFRPBaMVEMJYYE48YKyaC0YqJYLRiIhitmAhGKyaBcbRiIhitmAhGKyaC0YqJYCwxJjBaMRGMVkwEoxUTwWjFJIay0YpJYJysmAhGKyaC0YpJPGImKyaCscSYwGjFRDBaMRGMVkwEoxUTwWjFJDCWFRPBaMVEMFoxEYxWTARjiTGB0YqJYLRiEkNZWTERjFZMBKMVk8A4WzGJR8xsxUQwWjERjFZMBGOJMYHRiolgtGIiGK2YCEYrJoLRiklgXKyYCEYrJoLRiolgtGIiGEuMgaFssWIiGK2YCEYrJoLRiok8YqyYBMbViolgtGIiGK2YCEYrJoKxxJjAaMVEMFoxEYxWTASjFRPBaMUkMG5WTASjFRPBaMUkhrLNiolgLDEmMFoxEYxWTOQRY8VEMFoxEYxWTALjbsVEMFoxEYxWTASjFRPBWGJMYLRiIhitmAhGKyaC0YqJYLRiAhjnixUTGMrmixUTwWjFRDBaMRGMJcbEI8aKiWC0YiIYrZgIRismgtGKSWAcrJgIRismgtGKiWC0YiIYS4wJjFZMBKMVE8FoxUQwWjGJoWywYhIYRysmgtGKiWC0YhKPmNGKiWAsMSYwWjERjFZMBKMVE8FoxUQwWjEJjJMVE8FoxUQwWjERjFZMBGOJMYHRiolgtGISQ9lkxUQwWjERjFZM4vfGsmIiGK2YCEYrJoLRiolgLDEmMFoxiTc8ZcVEMFoxEYxWTOT3RismgXG2YiIYrZgIRismgtGKiWAsMQbe8MxWTASjFRPBaMVEMFoxkUeMFZPAuFgxEYxWTASjFRPBaMVEMJYYExitmAhGKyaC0YqJYLRiIhitmF/BuN54vP3P6WeM68tWzNtL5turl8sTkMt8uX6SyzwN34O8A2TbrkvGtO3jtxff+6in+fZxTHMN37/4q6KXLaQ/R9HL1tefo+hly+7PUVQqOlnRMt/wLWvdUfSyRfrnKHrZ2uUo2qcbvsv25MXj7ate0zgs7794XJYb62V78uK3brq+9d/vvfN/2Zz3nnzonrzsXvEC92S97FfW6zT+s3vysoOM9+Qj92Rzcfq892SfxyvrfR+evHisq/JxXOqfXSo3Mi9V/FK56nmp/r5U203MdPlnb6c3d0gvVfxSlZfqj7pUdbldqvnJjzzOe91afrgzm29usp9XfnDI2RyGvSe/ck8chr0nv3JPHIY/7z1JDn4Ow96TX7gnu8Pw570n23ib5bYvn9WPEbM74L6wfIfWF5bvIPrC8kv5n1b+h9bwy3578TBMd26KK6c35dduijunN+WvFwe/F2B3FPVSxS+VC6qXKn6pnFu9VH9fqtg3mCwXt1kvVfxSufn+UZdqGm6sp/kfVtpycfN9Yfluvp9Xfu697HIp74n35BfuieOw9+RX7onT8Ce+J8Eyce31nvzKPXHAPfuerMt+w7fVs1nkI3+Y68mfu1kuDq2fV37u++SXwe3Ue/Ir98Q51HvyK/fE5fTz3pPcn6dYBkdW78mv3JPynnzae/LkG7CXweX0heU7h76wfDfOF5bvcPl55Sf/NMUyuHJ6U37ppozunN6Uv14c/Ir96CjqpYpfKhdUL1X8Ujm3eqn+vlS5bzAZy0vlpUpfKjffP+tSnfMXPC6j87D35FfuiUvy570nwS80j47O3pNfuSdOzp/3npyV55PrtJcqfqlcp71U6TyfXKe9VPFL5Tr9R12q6F+3MZXyX1e+a+/nlZ98L+va6z35lXvi2us9+ZV74tr7ie9JsExce70nv3BP6nUH3O32tZVh+4Luu3vylc3r7pDP2bzunPaczeuuQs/ZlGze/uew3WPzupvCczav29HP2bxuOz5n87q99JzN6zbC0+fU7Pvix2x8X/yYje+LH7PxffFjNiWbh2x8X/yYje+LH7PxffFjNr4vfszG98UP2Sx+w+9/+PnrCl/Z+H2rj9n47ZeP2fhdhI/ZlGwesvlU74v322c7D5d/YfP1s/1U73Sffraf6r3r08/2U70bffrZfqr3l88+2/VTvWN8+tl+qveATz/bT/Wu7uln+6nepz39bOulPtuXei+1vtR7qfWl3kutL/Vean2p91LbS72X2l7qvdT2Uu+ltpd6L7XVS322L/Veanup91LbS72X2l7qvdT2Uu+l9pd6L7W/1Hup/aXeS+0v9V5qr5f6bF/qvdTOfi81LnX7bPdnr95v/9D5cBm//SHN6e6f0hwuy+1Lw5fvPuzp/sdx+/Ofw3TZnrx4r9u39OzffdDT9W8y2dnv6D4nc/b7yj+R+Tjevl1iHL/7s9l3X/z2BeeroLevYV3uCGK/FX55QeuF/e5dQRd2cCjowm4kBV3YWaegSymILYgdzwq62PtwQY4DcEEuCXBBLglsQYNLAlyQSwJckEsCXJBLAlxQKYgtyCUBLsglAS7IJQEuyCUBLsglgS1odEmAC3JJgAtySYALckmACyoFsQW5JMAFuSTABbkkwAW5JMAFuSSwBU0uCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLagckmAC3JJgAtySYALckmACyoFsQW5JMAFuSTABbkkwAW5JMAFuSSwBc0uCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLagxSUBLsglAS7IJSEuaNlvn+Ja95g7DqSZP/t3stalZN7O3ITvZ26V9zM3tPuZ2879zM3hduarhdvP3GjtZ26H9jO3Q/uZl8zbmduh/czt0H7mdmg/czu0n7kd2s58s0P7mduh/czt0H7mdmg/85J5O3M7tJ+5HdrP3A7tZ26H9jO3Q9uZ73ZoP3M7tJ+5HdrP3A7tZ14yb2duh/Yzt0P7mduh/czt0H7mdmg38+1ih/Yzt0P7mduh/czt0H7mJfN25nZoP3M7tJ+5HdrP3A7tZ26HtjMf7NB+5nZoP3M7tJ+5HdrPvGTeztwO7Wduh/Yzt0P7mduh/czt0Hbmox3az9wO7Wduh/Yzt0P7mZfM25nbof3M7dB+5nZoP3M7tJ+5HZpmHv3HL7bJaIULsnDhgsxhuCDbGS6oFMQWZJXDBZnwcEH2PlyQ4wBckEsCW1C5JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtiCZpcEuCCXBLgglwS4IJcEuKBSEFuQSwJckEsCXJBLAlyQSwJckEsCW9DikgAX5JIAF+SSABfkkgAXVApiC3JJgAtySYALckmAC3JJgAtySWALWl0S4IJcEuCCXBLgglwS4IJKQWxBLglwQS4JcEEuCXBBLglwQS4JbEGbSwJckEsCXJBLAlyQSwJcUCmILcglAS7IJQEuyCUBLsglAS7IJYEtaHdJgAtySYALckmAC3JJiAtah/H6Ka7T8v6L52G6wpuHue4IKgWxBbkkwAW5JMAFuSTABbkkwAW5JKAF7ReXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ4JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgCxpdEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBk0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLahcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBs0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhxSYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFrS4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtqDNJQEuyCUBLsglAS7IJQEuqBTEFuSSABfkkgAX5JIAF+SSABfkksAWtLskwAW5JMAFuSTABbkkwAWVgtiCXBLgglwS4IJcEuCCXBLgglwSyILGy8UlAS7IJQEuyCUBLsglAS6oFMQW5JIAF+SSABfkkgAX5JIAF+SSwBY0uCTABbkkwAW5JMAFuSTABZWC2IJcEuCCXBLgglwS4IJcEuCCXBLYgkaXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ5JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgCyqXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ7JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgC1pcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCXFBy377FNe6/Mx8dRxIMx/22q8v3vc793y19/uZm/D9zK3yfuYl83bmtnM/c3O4n7mF28/caO1nboe2M9/s0H7mdmg/czu0n7kd2s+8ZN7O3A7tZ26H9jO3Q/uZ26H9zO3Qdua7HdrP3A7tZ26H9jO3Q/uZl8zbmduh/czt0H7mdmg/czu0n7kd2s18uNih/czt0H7mdmg/czu0n3nJvJ25HdrP3A7tZ26H9jO3Q/uZ26HtzAc7tJ+5HdrP3A7tZ26H9jMvmbczt0P7mduh/czt0H7mdmg/czu0nfloh/Yzt0P7mduh/czt0H7mJfN25nZoP3M7tJ+5HdrP3A7tZ26HtjOf7NB+5nZoP3M7tJ+5HdrPvGTeztwO7Wduh6aZj+M0Xz/FcR/ff/GybFdBy/qF2E+CjFa4IAsXLsgcZgsq2xkuyNCGC7LK4YJMeLigUhBbkOMAXJBLAlyQSwJckEsCXJBLAlvQ7JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgC1pcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBq0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhzSYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAF7S4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtKDx4pIQF7QO4/VTXKfl/RfPw3SFNw9z3RHkkgAX5JIAF+SSABdUCmILckmAC3JJgAtySYALckmAC3JJYAsaXBLgglwS4IJcEuCCXBLggkpBbEEuCXBBLglwQS4JcEEuCXBBLglsQaNLAlyQSwJckEsCXJBLAlxQKYgtyCUBLsglAS7IJQEuyCUBLsglgS1ockmAC3JJgAtySYALckmACyoFsQW5JMAFuSTABbkkwAW5JMAFuSSwBZVLAlyQSwJckEsCXJBLAlxQKYgtyCUBLsglAS7IJQEuyCUBLsglgS1odkmAC3JJgAtySYALckmACyoFsQW5JMAFuSTABbkkwAW5JMAFuSSwBS0uCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLag1SUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFrS5JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtiCdpcEuCCXBLgglwS4IJcEuKBSEFuQSwJckEsCXJBLAlyQSwJckEsCWtB0cUmAC3JJgAtySYALckmACyoFsQW5JMAFuSTABbkkwAW5JMAFuSSwBQ0uCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLag0SUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFjS5JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtiCyiUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFjS7JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtiCFpcEuCCXBLgglwS4IJcEuKBSEFuQSwJckEsCXJBLAlyQSwJckEsCW9DqkgAX5JIAF+SSABfkkgAXVApiC3JJgAtySYgLWvbbp7jW5Q5zx4E082Gv/frifb93z+39fuYmfDvzzSrvZ25o9zO3nfuZm8P9zEvm7cyN1n7mdmg/czu0n7kd2s/cDm1nvtuh/czt0H7mdmg/czu0n3nJvJ25HdrP3A7tZ26H9jO3Q/uZ26HdzN8gyryduR3az9wO7Wduh/YzL5m3M7dD+5nbof3M7dB+5nZoP3M7tJ35YIf2M7dD+5nbof3M7dB+5iXzduZ2aD9zO7SfuR3az9wO7Wduh7YzH+3QfuZ2aD9zO7SfuR3az7xk3s7cDu1nbof2M7dD+5nbof3M7dB25pMd2s/cDu1nbof2M7dD+5mXzNuZ26H9zO3QfuZ2aD9zO7SfuR3azrzs0H7mdmg/czu0n7kdmmY+jtN8/RTHfXz/xcuyXQUt6xdiPwkqBbEFWbhwQeYwXJDtDBdkaMMFWeVsQbMJDxdk78MFOQ7ABbkkwAWVgtiCXBLgglwS4IJcEuCCXBLgglwS2IIWlwS4IJcEuCCXBLgglwS4oFIQW5BLAlyQSwJckEsCXJBLAlyQSwJb0OqSABfkkgAX5JIAF+SSABdUCmILckmAC3JJgAtySYALckmAC3JJYAvaXBLgglwS4IJcEuCCXBLggkpBbEEuCXBBLglwQS4JcEEuCXBBLglsQbtLAlyQSwJckEsCXJBLAlxQKYgtyCUBLsglAS7IJQEuyCUBLsglAS1ovrgkwAW5JMAFuSTABbkkwAWVgtiCXBLgglwS4IJcEuKC1mG8forrtLz/4nmYrvDmYa47glwS4IJcEtiCBpcEuCCXBLgglwS4IJcEuKBSEFuQSwJckEsCXJBLAlyQSwJckEsCW9DokgAX5JIAF+SSABfkkgAXVApiC3JJgAtySYALckmAC3JJgAtySWALmlwS4IJcEuCCXBLgglwS4IJKQWxBLglwQS4JcEEuCXBBLglwQS4JbEHlkgAX5JIAF+SSABfkkgAXVApiC3JJgAtySYALckmAC3JJgAtySWALml0S4IJcEuCCXBLgglwS4IJKQWxBLglwQS4JcEEuCXBBLglwQS4JbEGLSwJckEsCXJBLAlyQSwJcUCmILcglAS7IJQEuyCUBLsglAS7IJYEtaHVJgAtySYALckmAC3JJgAsqBbEFuSTABbkkwAW5JMAFuSTABbkksAVtLglwQS4JcEEuCXBBLglwQaUgtiCXBLgglwS4IJcEuCCXBLgglwS2oN0lAS7IJQEuyCUBLsglAS6oFMQW5JIAF+SSABfkkgAX5JIAF+SSgBa0XFwS4IJcEuCCXBLgglwS4IJKQWxBLglwQS4JcEEuCXBBLglwQS4JbEGDSwJckEsCXJBLAlyQSwJcUCmILcglAS7IJQEuyCUBLsglAS7IJYEtaHRJgAtySYALckmAC3JJgAsqBbEFuSTABbkkwAW5JMAFuSTABbkksAVNLglwQS4JcEEuCXBBLglwQaUgtiCXBLgglwS4IJcEuCCXBLgglwS2oHJJgAtySYALckmAC3JJgAsqBbEFuSTABbkkwAW5JMAFuSTABbkksAXNLglwQS4JcEEuCXBBLglwQaUgtiCXBLgglwS4IJcEuCCXBLgglwS2oMUlAS7IJQEuyCUBLsglAS6oFMQW5JIAF+SSABfkkgAX5JIAF+SSwBa0uiTABbkkwAW5JMAFuSTABZWC2IJcEuCCXBLgglwS4IJcEuCCXBLYgjaXBLgglwS4IJcEuCCXhLigZb99imtd7jAvmYeZD3vt1xfv+717bu/3Mzfh+5lb5f3MDe1+5rZzO/PdHO5nbuH2Mzda+5nbof3MS+btzO3QfuZ2aD9zO7SfuR3az9wO7Wa+XuzQfuZ2aD9zO7SfuR3az7xk3s7cDu1nbof2M7dD+5nbof3M7dB25oMd2s/cDu1nbof2M7dD+5mXzNuZ26H9zO3QfuZ2aD9zO7SfuR3azny0Q/uZ26H9zO3QfuZ2aD/zknk7czu0n7kd2s/cDu1nbof2M7dD25lPdmg/czu0n7kd2s/cDu1nXjJvZ26H9jO3Q/uZ26H9zO3QfuZ2aDvzskP7mduh/czt0H7mdmg/85J5O3M7tJ+5HdrP3A7tZ26H9jO3Q9uZz3Zomvk4TvP1Uxz38f0XL8t2FbSsX4j9JMhohQuycOGCzGG4oFIQW5ChDRdklcMFmfBwQfY+XJDjAFvQ4pIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgC1pdEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBm0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWh3SYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JKAFbReXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ4JIAF+SSABfkkgAX5JIAF1QKSgtah/H6Ka7T8v6L52G6wpuHue4IckmAC3JJgAtySYALckmAC3JJYAsaXRLgglwS4IJcEuCCXBLggkpBbEEuCXBBLglwQS4JcEEuCXBBLglsQZNLAlyQSwJckEsCXJBLAlxQKYgtyCUBLsglAS7IJQEuyCUBLsglgS2oXBLgglwS4IJcEuCCXBLggkpBbEEuCXBBLglwQS4JcEEuCXBBLglsQbNLAlyQSwJckEsCXJBLAlxQKYgtyCUBLsglAS7IJQEuyCUBLsglgS1ocUmAC3JJgAtySYALckmACyoFsQW5JMAFuSTABbkkwAW5JMAFuSSwBa0uCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLagzSUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFrS7JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtCC9otLAlyQSwJckEsCXJBLAlxQKYgtyCUBLsglAS7IJQEuyCUBLsglgS1ocEmAC3JJgAtySYALckmACyoFsQW5JMAFuSTABbkkwAW5JMAFuSSwBY0uCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLagySUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFlQuCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLag2SUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFrS4JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtiCVpcEuCCXBLgglwS4IJcEuKBSEFuQSwJckEsCXJBLAlyQSwJckEsCW9DmkgAX5JIAF+SSABfkkgAXVApiC3JJgAtySYALckmAC3JJgAtySWAL2l0S4oKW/fYprnW5w9xxIM182Gu/vnjf791ze7+fuQnfz7xk3s7c0O5nbjv3MzeH+5lbuP3MjdZm5tPlYof2M7dD+5nbof3M7dB+5iXzduZ2aD9zO7SfuR3az9wO7Wduh7YzH+zQfuZ2aD9zO7SfuR3az7xk3s7cDu1nbof2M7dD+5nbof3M7dB25qMd2s/cDu1nbof2M7dD+5mXzNuZ26H9zO3QfuZ2aD9zO7SfuR3aznyyQ/uZ26H9zO3QfuZ2aD/zknk7czu0n7kd2s/cDu1nbof2M7dD25mXHdrP3A7tZ26H9jO3Q/uZl8zbmduh/czt0H7mdmg/czu0n7kd2s58tkP7mduh/czt0H7mdmg/85J5O3M7tJ+5HdrP3A5NMx/Hab5+iuM+vv/iZdmugpb1C7GfBBmtcEEWLlvQYg7DBdnOcEGGNlyQVQ4XVApiC7L34YIcB+CCXBLgglwS4IJcEtiCVpcEuCCXBLgglwS4IJcEuKBSEFuQSwJckEsCXJBLAlyQSwJckEsCW9DmkgAX5JIAF+SSABfkkgAXVApiC3JJgAtySYALckmAC3JJgAtySWAL2l0S4IJcEuCCXBLgglwS4IJKQWxBLglwQS4JcEEuCXBBLglwQS4JaEHDxSUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFjS4JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtiCRpcEuCCXhLigdRivn+I6Le+/eB6mK7x5mOuOIJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ5JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgCyqXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ7JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgC1pcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBq0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhzSYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAF7S4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtKDx4pIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgCxpcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBo0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhySYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFlUsCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWh2SYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFLS4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtqDVJQEuyCUBLsglAS7IJQEuqBTEFuSSABfkkgAX5JIAF+SSABfkksAWtLkkwAW5JMAFuSTABbkkwAWVgtiCXBLgglwS4IJcEuCCXBLgglwS2IJ2lwS4IJcEuCCXBLgglwS4oFIQW5BLAlyQSwJckEtCXNCy3z7FtS53mDsOpJkPe+3XF+/7vXtu73czny4mfD9zq7yfuaHdz9x27mdeMm9nbuH2Mzda+5nbof3M7dB+5nZoO/PBDu1nbof2M7dD+5nbof3MS+btzO3QfuZ2aD9zO7SfuR3az9wObWc+2qH9zO3QfuZ2aD9zO7Sfecm8nbkd2s/cDu1nbof2M7dD+5nboe3MJzu0n7kd2s/cDu1nbof2My+ZtzO3Q/uZ26H9zO3QfuZ2aD9zO7Sdedmh/czt0H7mdmg/czu0n3nJvJ25HdrP3A7tZ26H9jO3Q/uZ26HtzGc7tJ+5HdrP3A7tZ26H9jMvmbczt0P7mduh/czt0H7mdmg/czu0nflih/Yzt0P7mduh/czt0H7mJfP0v60wTvP1Uxz38f0XL8t2FbSsX4j9JMhohQuycOGCzGG4INsZLsjQZgtarXK4IBMeLsjehwtyHIALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFbS4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtqDdJQEuyCUBLsglAS7IJQEuqBTEFuSSABfkkgAX5JIAF+SSABfkkoAW9EZcQWxBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLagwSUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFjS6JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4oLWYbx+iuu0vP/ieZiu8OZhrjuCXBLYgiaXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAltQuSTABbkkwAW5JMAFuSTABZWC2IJcEuCCXBLgglwS4IJcEuCCXBLYgmaXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ4pIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgC1pdEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBm0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWh3SYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JKAFzReXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ4JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgCxpdEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBk0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLahcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBs0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhxSYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFrS4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtqDNJQEuyCUBLsglAS7IJQEuqBTEFuSSABfkkgAX5JIAF+SSABfkksAWtLskwAW5JMAFuSTABbkkwAWVgtiCXBLgglwS4IJcEuCCXBLgglwS0IKWi0sCXJBLAlyQSwJckEsCXFApKC1o2W+f4lqXO8wdB9LMh73264v3/d49t/f7mZvw/cyt8n7mhnY788F27mduDvczt3D7mRut/cxL5u3M7dB+5nZoP3M7tJ+5HdrP3A5tZz7aof3M7dB+5nZoP3M7tJ95ybyduR3az9wO7Wduh/Yzt0P7mduh7cwnO7SfuR3az9wO7Wduh/YzL5m3M7dD+5nbof3M7dB+5nZoP3M7tJ152aH9zO3QfuZ2aD9zO7Sfecm8nbkd2s/cDu1nbof2M7dD+5nboe3MZzu0n7kd2s/cDu1nbof2My+ZtzO3Q/uZ26H9zO3QfuZ2aD9zO7Sd+WKH9jO3Q/uZ26H9zO3QfuYl83bmdmg/czu0n7kd2s/cDu1nboe2M1/t0H7mdmia+ThO8/VTHPfx/Re//eZ+FbSsX4j9JMhohQuycOGCSkFsQbYzXJChDRdklcMFmfBwQfY+W9DmOAAX5JIAF+SSABfkkgAXVApiC3JJgAtySYALckmAC3JJgAtySWAL2l0S4IJcEuCCXBLgglwS4IJKQWxBLglwQS4JcEEuCXBBLglwQS4JaEHrxSUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFjS4JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtiCRpcEuCCXBLgglwS4IJcEuKBSEFuQSwJckEsCXJBLAlyQSwJckEsCW9DkkgAX5JIAF+SSABfkkgAXVApiC3JJiAtah/H6Ka7T8v6L52G6wpuHue4IckmAC3JJgAtySYALcklgCyqXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ7JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgC1pcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBq0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhzSYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAF7S4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtKDt4pIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgCxpcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBo0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhySYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFlUsCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWh2SYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFLS4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtqDVJQEuyCUBLsglAS7IJQEuqBTEFuSSABfkkgAX5JIAF+SSABfkksAWtLkkwAW5JMAFuSTABbkkwAWVgtiCXBLgglwS4IJcEuCCXBLgglwS2IJ2lwS4IJcEuCCXBLgglwS4oFIQW5BLAlyQSwJckEsCXJBLAlyQSwJa0H5xSYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFDS4JcEEuCXFBy377FNe63GHuOJBmPuy1X1+87/fuub3fz7xk3s7cKu9nbmj3M7ed+5mbw/3MLdx25qPR2s/cDu1nbof2M7dD+5mXzNuZ26H9zO3QfuZ2aD9zO7SfuR3aznyyQ/uZ26H9zO3QfuZ2aD/zknk7czu0n7kd2s/cDu1nbof2M7dD25mXHdrP3A7tZ26H9jO3Q/uZl8zbmduh/czt0H7mdmg/czu0n7kd2s58tkP7mduh/czt0H7mdmg/85J5O3M7tJ+5HdrP3A7tZ26H9jO3Q9uZL3ZoP3M7tJ+5HdrP3A7tZ14yb2duh/Yzt0P7mduh/czt0H7mdmg789UO7Wduh/Yzt0P7mduh/cxL5u3M7dB+5nZoP3M7tJ+5HZpmPo7TfP0Ux318/8XLsl0FLesXYj8JMlrZgjYLFy7IHIYLsp3hggxtuKBSEFuQCQ8XZO/DBTkOwAW5JMAFuSSwBe0uCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLKgN+AuCXBBLglwQS4JcEEuCXBBpSC2IJcEuCCXBLgglwS4IJcEuCCXBLagwSUBLsglAS7IJQEuyCUBLqgUxBbkkgAX5JIAF+SSABfkkgAX5JLAFjS6JMAFuSTABbkkwAW5JMAFlYLYglwS4IJcEuCCXBLgglwS4IJcEtiCJpcEuCCXBLgglwS4IJcEuKBSEFuQSwJckEsCXJBLAlyQSwJckEsCW1C5JMAFuSTABbkkxAWtw3j9FNdpef/F8zBd4c3DXHcEuSTABZWC2IJcEuCCXBLgglwS4IJcEuCCXBLYgmaXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ4pIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgC1pdEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBm0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWh3SYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JKAFDReXBLgglwS4IJcEuCCXBLigUhBbkEsCXJBLAlyQSwJckEsCXJBLAlvQ4JIAF+SSABfkkgAX5JIAF1QKYgtySYALckmAC3JJgAtySYALcklgCxpdEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBk0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLahcEuCCXBLgglwS4IJcEuCCSkFsQS4JcEEuCXBBLglwQS4JcEEuCWxBs0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhxSYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkwAW5JLAFrS4JcEEuCXBBLglwQS4JcEGlILYglwS4IJcEuCCXBLgglwS4IJcEtqDNJQEuyCUBLsglAS7IJQEuqBTEFuSSABfkkgAX5JIAF+SSABfkksAWtLskwAW5JMAFuSTABbkkwAWVgtiCXBLgglwS4IJcEuCCXBLgglwS0ILGi0sCXJBLAlyQSwJckEsCXFApiC3IJQEuyCUBLsglAS7IJQEuyCWBLWhwSYALckmAC3JJgAtySYALKgWxBbkkwAW5JMAFuSTABbkkxAUt++1TXOtyh7njQJp5zfP1xbUM88/MR3u/n7kJ38/cKu9nbmj3My+ZtzM3h/uZW7j9zI3WfuZ2aJz5st6Yr9OTF29veL++eFuW4Y4go5UtaLJw4YLMYbgg2xkuyNCGCyoFsQWZ8HBB9j5ckOMAXJBLAlyQSwJbULkkwAW5JMAFuSTABbkkwAWVgtiCXBLgglwS4IJcEuCCXBLgglwS2IJmlwS4IJcEuCCXBLgglwS4oFIQW5BLAlyQSwJckEsCXJBLAlyQSwJb0OKSABfkkgAX5JIAF+SSABdUCmILckmAC3JJgAtySYALckmAC3JJYAtaXRLgglwS4IJcEuCCXBLggkpBbEEuCXBBLglwQS4JcEEuCXBBLglsQZtLAlyQSwJckEsCXJBLAlxQKehUQft6hbdfLvsdQS4JcEEuCXBBLglxQes83ARtw/sv3t8MXAVNw5MXP/0HBzdnh89k043iE9ncHTQ+k03Xj89k06nkM9l0V/lMNkubn8imi81nsum885lsugV9JptuQZ/JplvQ57E5XdyCPpNNt6DPZNMt6DPZdAv6TDZLm5/IplvQZ7LpFvSZbLoFfSabbkEn27zBe7O53xHkvMMWNLjYnCuohvEqqGp9/8XjPs1XePv87Uf+8sn+/Jvn5eZwvuz79y/+qt5552XVuwW9rHqHo5dVX6p/VfVOUi+r3v3qZdU7dr2sepexl1Xv5vaq6kfXvJdV75r3supd815WvWvey6ov1b+qete8l1Xvmvey6l3zXla9a97LqnfNe1X1k2vey6p3zXtZ9a55L6veNe9l1ZfqX1W9a97LqnfNe1n1rnkvq94172XVu+a9qvpyzXtZ9a55L6veNe9l1bvmvaz6Uv2rqnfNe1n1rnkvq94172XVu+a9rHrXvFdVP7vmvax617yXVe+a97LqXfNeVn2p/lXVu+a9rHrXvJdV75r3supd815WvWveq6pfXPNeVr1r3suqd817WfWueS+rvlT/qupd815WffeaV0Pd1E/7M/XT2/+9MR/qG/Rhu/fpjsM2X0m+/e/vuH95/dfPeH25z3hjf8Zvbzhvn3ENzz7jqusPPn/363vfrp/s/bVi2S/Xn2P98gm++8muy/71xev+PdDh3q+w7XL96N+A7gFd6+UP/gze/us//bd/+/d//7f/6//49//6n//j//i3//pf/vuX05cv/8/9f3dluf22uo7fPq+336y+4Ng+fGL/6In7/zjAuyeGD58YP3bi7T+GLy+8//dY13S9CvUd//2vC3T/rz9+98T84RPLh0+sHz6xffjEXfPz7bbOy48n7v9Fcu+eGD58YvzwibvO59s7lXmdfzxRHz4xf/jE8uETd53Pt9/G5u/ej3w9sX34xP7RE/f/uPG7J4b3TyyX9ccT44dPTB8+cdf5slz/FfFlXX48MX/4xPLhE+uHTzz4Hf763uTtsffjif2jJ+bLh08MHz5x1/l6ub5XX4f68cT04RP14RPzh08sT06M448n1g+f2D584q7zt/c2X09slx993P/Sxbsnhg+fGD984q7z7faZbz/5uD/LvHti/vCJ5cMn7jrfxuu7zm3afjyxffjE/tET9985v3tieHKifvz9ah0/fGL68Im7zvfh+m5x/+nXxzp/+MTy4RPrh0/cdb6P16fBPv34VFv3j57YLh8+MXz4xF3n++093L78+Jlv04dP1IdPzB8+sTw5sf74+9W2fvjE9uET94v9Ut+mufnHXyH75cCZ4cCZ8aNn3v5j/Kt179+Z9dvB7x4Od8fJ5dbwy7p+/9K3j+v+v1Ye+9HrH//o+3bnHcbXH33+5z/6enunsP34oy+/9Udf/+mPvs7X+Wr97tfn1x99+60/+v6Pf/Tv3tn8eGfurygf+9GvtbONw48/+vBPf/RtulrdfiIzjsEf/YdfTW//MX154YO/13C53H6Stb772sZlehzE7x56+6/66/ef+7W3X0+u8/Tt963p3s66fNtZL9+/9OEvstQPvv7OH3z7nT/4/ht/8AczZegHH/7hD/62xd8GrfX9l+77+O3X1Xe/0N++BvHw1+IpH8mE+UgK85HMfR/J28//7TfgYf7pQ1k4H8rK+VA2zoeyd34oty8MvP3P/ccPZbpwPpSB86GMnA9lOulD+e67La4fSnE+lJnzobT+brvevjPhsl1++lBWzoeycT6UHfKhvP3X/FeA3P09t9brm9Da1u/KZfjr4PJ4ORm+fUvDsG77//yVPeTJmTpwZj5wZjlw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","brillig_names":["get_contract_instance_internal","get_public_keys_and_partial_address","decompose_hint","notify_created_note_oracle_wrapper","get_key_validation_request","random","lt_32_hint","lte_16_hint","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","noinitcheck","view"],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7V3bjiS3lfyXefYDeS68+FcWhiHbsiFAkAxLXmBh+N83u2eqqmcqKznDYbLiNM8+LDS7yWJkJA95Irsi6j8f/vbjX/79jz//9Mvff/3twx//5z8ffv71rz/8/tOvv2z/+s+HSK//t9/++cMvL//87fcf/vX7hz/GVMMfPvz4y9+2/8wh/PcPH/7+088/fvijvPz33dWUS/50NZVQr1fHFHeuZknl09WsEhtXxxjq5fK4/Q9dr2fSvetLSZfLa9Db1bL74VSvn53L24v/9IcPkZ2aR9SIU/OIGnVqHlGTvp8arhIvN1tzvt1sSa9T5POnKN86xcugujeImK7PmTW3VkUluuAK9XZ1TnsXh1T48tmh0G1ZZN57cCHRFX9IzK1VIVcsUd6suY5VQcGpeURNdGoeUUPw1Gi+UZPjvG2W2Kl5RI04NY+o0e+nhuMVPcfKDWq0XuBQotRiveQrj/VtS8S0B4T4cjVTktvV8eO9poXuNS90r2Whe63r3CuHhe41LnSvtNC98kL3Kgvd60J9Ey/UN/FCfRMv1DfxQn2TLNQ3yUJ9kyzUN8lCfZPIQve6UN8kC/VNslDfJAv1TbJQ36QL9U26UN+kC/VNulDfpLLQvS7UN+lCfZMu1DfpQn2TLtQ3pYX6prRQ35QW6pvSQn1TkoXudaG+KS3UN6WF+qa0UN+UFuqb8kJ9U16ob8oL9U15ob4py0L3ulDflBfqm/JCfVNeqG/KC/VNZaG+qSzUN5WF+qayUN9UZKF7XahvKgv1TWWhvqks1DeVhfqmulDfVN9V3yR6jSaRWj671/urY9Kr4TsHvmPmXXVZ38ZMfsNMvV8z76onU77FA+UmMyHfEj3qLRwovsxzd7WEqp+ulkhvKYmtSs23u6T6Sro46WeQzrc0I35DySfS31WXaoX0d9UuWyH9XfXtVkh/VwLCCunvSskYIT2Gd6WpzLD+rtSdGdbflXI0w7qr0mewLs76E1h3XfoM1l2YPoN1V6bPYN2l6TNYd236BNaja9OvZD1eeZSYucX64d8zYnRtegrrjbXu2vRrWb/+yIhQrN+51l2bnsJ6Y62Ls/4E1l2bPoN116bPYN216TNYd236DNZdmz6BdXJt+gzWXZs+g3XXps9g3bXpM1gXZ/0JrLs2fQbrrk2fwbpr02ew7tr0Gay7Nv1K1m9/pxBK2mL9+K8a7+t3B3FYP17r7+sXEE9lPV9wC8f4nWvdtekprDfWumvTr2Oda7qepvzGsfuA9Xy9mkt8w7p8ZF3WZZ3ClXWKn7P+Ss3CArJFzcIqr0XNwlKMVK7U1NTYxmKtdEES3oRVMOnuFpmunGz/nWPr+lLS5fIabm0Y7wLf4F4ujm9ukz/tkQvrvPf6SBcWke/0kb6vX3jVcnlInN68Mdl/pJXzpbOuXN4sgLKLOxa9PtPtCcTPrn+l8n3JzqdSOV1L5nC5XcpMn330K6DpMqvw5ev7VDTeAxI0QIoGKKEBymiAChqgCgZo/u94tgBFNECEBghtp1a0nVrRdmpF26kVbadWtJ1a0XbqhLZTJ7SdOqHt1Altp05oO3VC26kT2k6d0HbqhLZTJ7SdOqPt1Bltp85oO3VG26kz2k6d0XbqjLZTZ7SdOqPt1Bltpy5oO3VB26kL2k5d0HbqgrZTF7SduqDt1AVtpy5oO3VB26kr2k5d0XbqirZTV7SduqLt1BVtp65oO3VF26kr2k5dwXZqCmA7NQWwnZoC2E5NAWynpgC2U1MA26kpgO3UFMB2agpgOzUFtJ06ou3UEW2njmg7dUTbqSPaTh3RduqItlNHtJ06ou3UEW2nJrSdmtB2akLbqQltpya0nZrQdmpC26kJbacmtJ2a0HZqRtupGW2nZrSdmtF2akbbqRltp2a0nZrRdmpG26kZbacWtJ1a0HZqQdup0TyKhOZRJDSPIqF5FAnNo0hoHkVC8ygSmkeR0DyKhOZRJDSPIqF5FAnNo0hoHkVC8ygSmkeR0DyKhOZRJDSPIqF5FAnNo0hoHkVC8ygSmkeR0DyKhOZRJDSPIqF5FAnNo0hoHkVC8ygSmkeR0DyKhOZRJDSPIqF5FAnNo0hoHkVC8ygSmkeR0DyKhOZRJDSPIqF5FAnNo0hoHkVC8ygSmkeR0DyKhOZRJDSPIqF5FAnNo0hoHkVC8ygSmkeR0DyKjOZRZDSPIqN5FBnNo8gBbKdmNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqM5lFkNI8io3kUGc2jyGgeRUbzKDKaR5HRPIqC5lEUNI+ioHkUBc2jKAFspxY0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8iormUVQ0j6KieRQVzaOoAWynVjSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKiuZRVDSPoqJ5FBXNo6hoHkVF8ygqmkdR0TyKCc2jmNA8ignNo5jQPIopgO3UCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0DyKCc2jmNA8ignNo5jQPIoJzaOY0TyKGc2jmNE8ihnNo5gD2E6d0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOY0TyKGc2jmNE8ihnNo5jRPIoZzaOYp3sUOeTrxaHWxkcLXT9aKN8+mvY+WiWkTxerkLy9+PVWZZ1b1XVuNa1zq3mdWy3r3Gpd5lanO2OfeKtxnVuldW51nW5pugP5ibe6TrdU1+mW6jrdUl2nW6rLdEslLNMtlbBMt1TCMt1SCct0SyXIOre6TLdUwjLdUgnLdEslLNMtlbBOtxTX6ZbiOt1SXKdbiut0S9OTOJ54q+t0S3Gdbimu0y3FdbqluE63ROt0S7ROt0TrdEu0Trc0PQ3nibe6TrdE63RLtE63ROt0S7ROt8TrdEu8TrfE4N1SCnK51UThDj14A9RAL6bRg7cpDfTgnUdSvaLP9+jBm4kGevD+oIEe/Mg/Ri/gp3gDPfjBfLzniOmzVkyftdOTv8aiRz9rj6vW9Fkrps9aMX3WiumzVk2ftYp+1h6jRz9rj9Gjn7XH6NHP2mP0ps9aNX3WqumzVk2ftYp+1h52yAn9rD1Gb1rXJtO6Npk+a6en741Fb/qsTabP2mT6rE2mz9pkWtdm07o2m9a12bSuzabP2un5iWPRmz5rs+mzNqOftYcdckY/a4/Rm9a1xbSuLabP2mL6rEUPtWygN33WokdPNtCbPmvRAyIb6E3rWvQYx2P06MmMDfSmz1r0/MQGetNnLXrKYQO96e8ho2cRNtCb1rXoiYEN9JbP2oqe69dAb/msrejpew30ls/aGiyftRU99q6B3rKurejhdA30lnVtRY+QO0aPngrXQG/6rEXPbmugt+z5qegJaw30lnVtRc9Ba6A3fdaip5U10Js+a9EzxRroTZ+16MlfDfSmdS16PlcDvWldi56i1UBv+qxFz7pqoDd91qInUjXQW/b8VNO5UdV0blQ1nRtV4XOjjqvW9FlrOjeqms6NqqZzo6rp3KgKnxt1jN60roXPjTpGj37WHqM3fdaazo2qpnOjquncqAqfG3XYIcPnRh2jN61r4XOjjtGbPmtN50ZV07lR1XRuVDWdG1VN50ZV+NyoQ/TwuVHH6E3rWvjcqGP0ps9a07lR1XRuVDWdG1Xhc6MOO2T43Khj9KZ1LXxu1DF602et6dyoajo3qprOjaqmc6Oq6dyoCp8bdYzetK6Fz406RA+fG3WM3vRZazo3qprOjaqmc6MqfG7UYYcMnxt1jN60roXPjTpGb/qsNZ0bVU3nRlXTuVHVdG5UNZ0bVeFzo47Rm9a18LlRx+hN61rTuVExmA6O2uBbPm03+JaP2w2+Zd/PBh/9wG3At6xuN/iW5e0G3/KZu8G3fOhu8G2fuqYjpDb4tk9d0yFSG3zLKneDj37qNuBb1rkbfMtCd4Nv+9Q1HSW1wbd96poOk9rgW3YCbfAtW4E2+La1LnygVAO+7VPXdKTUBt/2qWs6VGqDb/vUNR0rtcG3rXXhg6Ua8G1rXfhoqQZ826eu6XCpDb7tU9d0vNQG37I3KAb4gKkGfNtaFz5iqgHf9qlrOmRqg2/71DUdM7XBt33qmg6a2uDb1rrwUVMN+La1LnzYVAO+7VPXdNzUBt/2qWs6cGqDb9kttMG3bBfa4NvWuvChUw34tk9d07FTG3zbp67p4KkNvu1T13T01AbfttaFD59qwLetdeHjpxrwbZ+6pgOoNvi2T13TEVQbfNvOIfgQqgZ821oXPoaqAd/2qWs6iGqDb/vUNR1FtcG3feqaDqPa4NvWuvBxVA34trUufCBVA77tU9d0JNUG3/apazqUaoNv2zkEH0vVgG9b68IHUzXg2z51TUdTbfBNn7rRdjZVtJ1NFW1nU0X4bKoGfPRTtwHftNaN8NlUDfimT91oO5sq2s6mirazqSJ8NtVhwxzhs6ka8E1r3QifTdWAb/vUtZ1NFW1nU0Xb2VTRdjZVtJ1NFeGzqRrwbWtd+GyqBnz0U7cB3/apazubKtrOpoq2s6kifDbVccMMn03VgG9b68JnUzXg2z51bWdTRdvZVNF2NlW0nU0VbWdTRfhsqmP48NlUDfi2tS58NlUDvu1T13Y2VbSdTRVtZ1NF+Gyq44YZPpuqAd+21oXPpmrAt33q2s6mirazqaLtbKpoO5sq2s6mivDZVA34trUufDbVMXz4bKoGfNunru1sqmg7myrazqaK8NlUxw0zfDZVA75trQufTdWAb/vUtZ1NFW1nU0Xb2VTRdjZVtJ1NFeGzqRrwbWtd+GyqBnzbWtd2NlW0nU0VbWdTRdvZVBE+m+q4YYbPpmrAt6114bOpGvBtn7q2s6mi7WyqaDubKtrOpoq2s6kifDZVAz76qduAb1vrwmdTNeDbPnVtZ1NF29lUZDubiuCzqQ4bZoLPpmrAN611KaCfug34pk9dsp1NRbazqch2NhXZzqYi29lUBJ9N1YBvWusSfDZVAz76qduAb/vUtZ1NRbazqch2NhXBZ1MdN8zw2VQN+La1Lnw2VQO+7VPXdjYV2c6mItvZVGQ7m4psZ1MRfDbVMXz4bKoGfNtaFz6bqgHf9qlrO5uKbGdTke1sKoLPpjpumOGzqRrwbWtd+GyqBnzbp67tbCqynU1FtrOpyHY2FdnOpiL4bKoGfNtaFz6b6hg+fDZVA77tU9d2NhXZzqYi29lUBJ9Nddwww2dTNeDb1rrw2VQN+LZPXdvZVGQ7m4psZ1OR7Wwqsp1NRfDZVA34trUufDZVA75trWs7m4psZ1OR7Wwqsp1NRfDZVMcNM3w2VQO+ba0Ln03VgG/71LWdTUW2s6nIdjYV2c6mItvZVASfTdWAj37qNuDb1rrw2VQN+LZPXdvZVGQ7m4psZ1MRfDbVccMMn03VgG9b68JnUzXg2z51bWdTke1sKrKdTUW2s6nYdjYVw2dTNeCb1roMn03VgI9+6jbgmz512XY2FdvOpmLb2VQMn0112DAzfDZVA75prcvw2VQN+LZPXdvZVGw7m4ptZ1Ox7Wwqtp1NxfDZVMfw4bOpGvBta134bKoGfNunru1sKradTcW2s6kYPpvquGGGz6ZqwLetdeGzqRrwbZ+6trOp2HY2FdvOpmLb2VRsO5uK4bOpGvBta134bKpj+PDZVA34tk9d29lUbDubim1nUzF8NtVxwwyfTdWAb1vr2s6mYtvZVGw7m4ptZ1Ox7Wwqtp1NxfDZVMcbp+1sKradTcXw2VSNtW/71LWdTcW2s6nYdjYV286mYvhsquONEz6bqgHf9qkLn03VgG/71LWdTcW2s6nYdjYV286mYtvZVAyfTdWAj37qNuDb/rsufDZVA77tUxc9myqXeIGfC9/Dn37qRqHrxbn10TGk9OnqGPLtZln3LqbCl4s5lOOLOYYbDslvL34lZn7qlRViohOzTww5MfvEsBOzT4w4MfvEqBOzT0xyYvaJyU7MPjHFidknxjvffWKqd74PiPHO9wEx3vk+IMY73wfEiBOzT4x3vg+I8c73ATHe+T4gxjvfB8R457tLjATvfB8Q453vA2K8831AjHe+D4gRJ2afGO98HxDjne8DYrzzfUCMd74PiPHOd5+Y6J3vA2K8831AjHe+D4hZtvPdrrjg4KTHF6dU6qeLU37zXfwri+IsDmBx2Z56KIvLNuBDWVy2Wx/K4rKt/VAWl9UBI1mkZUXDUBaXVRhDWVxWjgxl0bXLCBbFWRzAomuXESy6dhnBomuXESy6dhnBomuXASyya5cRLLp2GcGia5cRLLp2GcGiOIsDWHTtMoJF1y4jWHTtMoJF1y4jWHTtMoBFce0ygkXXLiNYdO0ygkXXLiNYFGdxAIvLahfJl3hgVuLji7PI5Q6zfE75RxaX1S5DWVxWuwxlcVntMpTFZbXLSBZ1We0ylMVltctQFpfVLkNZXFa7DGVRnMUBLLp2GcGia5cRLLp2GcGia5cRLLp2GcBicu0ygkXXLiNYdO0ygkXXLiNYFGdxAIuuXUaw6NplBIuuXUaw6NplBIuuXQawmF27jGDRtcsIFl27jGDRtcsIFsVZHMCia5cRLLp2GcHiqtpl++vn5eLtJesOMavKkSYxqyqMFjHL/gZyk5hVdUCTmFVb+yYxq3brTWLEidknZtWeuknMqm1ykxjvfB8Q453vA2K8890nZtnfQG4S453vA2K8831AjHe+D4gRJ2afGO98HxDjne8DYrzzfUCMd74PiPHOd5cYXfY3kJvEeOf7gBjvfB8Q453vA2LEidknxjvfB8R45/uAGO98HxDjne8DYrzz3Sdm2d9AbhLjne8DYrzzfUCMd74PiBEnZp8Y73wfEOOd7wNivPN9QMyynW/KV2IyNy4uiS/fOS8pxXsWl22TR7K47E8Ej2Vx2QZ8KIvLdutDWVy2tR/KojiLA1hcVjQMZXFZhTGUxWXlyFAWXbuMYNG1ywAWl/2J4LEsunYZwaJrlxEsunYZwaI4iwNYdO0ygkXXLiNYdO0ygkXXLiNYdO0ygMVlfyJ4LIuuXUaw6NplBIuuXUawKM7iABZdu4xg0bXLCBZdu4xg0bXLCBZduwxgcdmfCB7LomuXESy6dhnBomuXESyKsziARdcuI1h07TKCRdcuI1h07TKCRdcuA1hc9ieCx7Lo2mUEi65dRrDo2mUEi+IsDmDRtcsIFl27jGDRtcsIFl27jGDRtcsAFpf9ieCxLLp2GcGia5cRLLp2GcGiOItfwWLN5dPFNYR6z6JrlxEsunYZweKy2iVrvLJY4vHFlcrlDivHxsUa+UK5RpV7ypcVOs+jfFlV9DTK1/3B5OdRvqzeeh7ly4qz51G+rJJ7HuXilM+mfFmN+DzKlxWUz6Pc1ed0yl19Tqfc1edsytf90fLnUe7qczrlrj6nU+7qczrl4pTPptzV53TKXX1Op9zV53TKXX1Op9zV52TKU3D1OZ1yV5/TKXf1OZ1yV5/TKRenfDblrj6nU+7qczrlrj6nU+7qczrlrj5nUx5dfU6n3NXndMpdfU6n3NXndMrFKZ9NuavP6ZS7+pxOuavP6ZS7+pxOuavP2ZSTq8/plLv6nE65q8/plLv6nE65OOWzKXf1OZ1yV5/TKXf1OZ1yV5/TKXf1OZtydvU5nXJXn9Mpd/U5nXJXn9MpF6d8NuWuPqdT7upzOuWuPqdT7upzOuWuPmdTLq4+p1Pu6nM65a4+p1Pu6nM65eKUz6bc1ed0yl19Tqfc1ed0yl19Tqfc1edsytXV53TKXX1Op9zV53TKXX1Op1yc8tmUu/qcTrmrz+mUu/qcTrmrz+mUu/qcTXly9Tmdclef0yl39Tmdclef0ykXp3w25a4+p1Pu6nM65a4+p1Pu6nM65a4+Z1OeXX1Op9zV53TKXX1Op9zV53TKxSmfTbmrz+mUu/qcTrmrz+mUu/qcTrmrz9mUF1ef0yl39Tmdclef0yl39TmdcnHKv4byVG6U13sWXVCOYNE14ggWXfaNYNGV3AgWXZwNYLG63hrBokuoESy6KhrBogudESyKs/gVLEq8gK4i+fhiqqwX8qrePpn26NBQLjA01Pr24o/Px1UR9vNxvYX9fFzJYT8f14jYz8fVJ/LzycF1LfbzccWM/Xxci2M/H1f52M9H/PlAPx9/f4D9fPz9Afbz8fcH2M/H3x9gPx9/fwD9fKK/P8B+Pv7+APv5+PsD7Ofj7w+wn4/484F+Pv7+APv5+PsD7Ofj7w+wn4+/P8B+Pv7+APr5kL8/wH4+/v4A+/n4+wPs5+PvD7Cfj/jzgX4+/v4A+/n4+wPs5+PvD7Cfj78/wH4+/v4A+vmwvz/Afj7+/gD7+fj7A+zn4+8PsJ+P+POBfj7+/gD7+fj7A+zn4+8PsJ+Pvz/Afj7+/gD6+Yi/P8B+Pv7+APv5+PsD7Ofj7w+wn4/484F+Pv7+APv5+PsD7Ofj7w+wn4+/P8B+Pv7+APr56Pz3B9dfHmLm+tlHf0Q0WDFTiG8RfZxjV/W9/ErC5fnml889nCOlUj9dnTLdfhUplt3nUC8x5InfXBvyf/+0/esv//rp559/+seff/71rz/8/tOvv/z2MjK8/K/97+/k23rZFGy6fV6Ulxvc/1JJa1DsGUQ9g7hnkPQM0p5BqWdQ7hlUegb1rAjpWRHSsyKkZ0VIz4qQnhUhPStCelaE9KwI6VkR0rMitGdFaM+K0J4VoT0rQntWhPasCO1ZEdqzIrRnRWjPikg9KyL1rIjUsyJSz4pIPSsi9ayI1LMiUs+KSD0rIvWsiNyzIvL+ilC59Fa5pPzZoD8cX13up6Dzp+Dzp5Dzp9Dzp0jnT5G/fwrJga866I3Qi4H39IPw5bO5xM+vfgFU0ABVMED7P+/9TEARDRChAWI0QIIGSNEAJTRAaDt1QdupC9pOXdF26oq2U1e0nbqi7dQVbaeuaDt1RdupK9pOXdF26oq2U8eAtlXHgLZXx4C2WceAtlvHgLZdx4C2X8eAtmHHgLZjx4C2ZccAt2dHuD07wu3ZEW7PjnB7doTbsyPcnh3h9uwIt2fHAXu2bn3fBdG2wd3PUc+fg8KEOeLoOfL9HDRhDp4wh4yYI9/mKDvPQyfMkc6fQ4c883r59pnS2z/CXuYYwVVNl2/Raa3xfo40YY48YY4yYY72npjDZ3O8jEqha1TsGkVdo7hrlHSN0q5RqWtU7hpVukZ1rY3ctTZy19rIXWsjd62N3LU2ctfayF1rI3etjdy1NnLX2ihda6N0rY3StTZK19ooXWujdK2N0rU2StfaKF1ro3Stjdq1NmrX2qhda6N2rY3atTZq19qoXWujdq2N2rU2as/aoBC6RsWuUdQ1irtGSdco7RqVukblrlGla1TX2ohdayN2rY2veCP4xdcEd9xaheXT1du5cXNrafk4BZ8/hZw/hZ4/RTp/inz+FOX8KerpU3zFW6/vniKeP8X51U3nVzedX910fnXT+dVN51c3nV/ddH518/nVzedXN59f3Xx+dfP51c3nVzefX918fnXz+dXN51e3nF/dcn51y/nVLedXt5xf3XJ+dcv51S3nV7ecX91yfnXr+dWt51e3nl/den516/nVredXt55f3Xp+dev51a3nV3c6v7rT+dWdzq/udH51p/OrO51f3en86k7nV3c6v7rT+dWdz6/ufH515/OrO59f3fn86s7nV3c+v7rz+dWdz6/ufH51l/Oru5xf3eX86i7nV3c5v7rL+dU9wu6qdL1aN010u/rj9wVphD9Tla5zqMb7OcqEOerpc/AIX2RzjjhhDpowB0+YQybMMeL7zVLz4Rxpwhx5whxlwhxD6jzf5qh332nnGCbMESfMQRPm4AlzyIQ5dMIcI+o8ydXzkXRnjjxhjjJhjnr+HEO8Xenawm1z5Ps54oQ5aMIcPGEOmTCHTpgjTZgjD54jyf0cZcIc9fw5eESdF7r64IrszBEnzEET5uAJc4yo83wNut/m0M/muL/65ZcRPl29/edNBX/8dQJmRQOU0ABlNEAFDVAFAyQ0G1CKl984SXR7mbW9jPuIZ3qRJb7+cMaba694EhieDIangOEZUWAlXzuFGlMDD4V4+eztP2/vIiTEV0Qa4BBFOEQEh4jhEAkcIp2PSOoVkYZ7RAkOUYZDVOAQVTREKcAhesKeXS6nMsWQ7hERHCKGQyRPRRTLPSKFQ5TgEGU4RAUOUUVDlAMcovn70e3nRrf/lHtE82st6vVci4nvEc2vNQrX3+4k0ntEBQ5RRUNUwlMRcb5HFOEQERwihkMkcIgUDlGCQ/TcPVvqPaICh6iiIarz9+xbKugG7r4bqREOEcEhYjhEAodI4RAlOEQZDtET9uxyVUcc7t+x1QqGSEKAQxSfiijSPSKCQ8RwiAQOkcIhSnCIMhqiOH8/Yk5XRFzuEc2vte1vw1dEmu8Rza81uf4aAkms94gUDlGCQ5SfiojjPaICh6iiIaIAhyjCISI4RAyH6Ll7tvA9IoVDlOAQzd+zt/cx17O/3ncjVOAQVTREHOAQRThEBIeI4RAJHCKFQ5TgEMHt2Qy3Z/MT+uwbIr3/pq9IgEMU4RCdvGe/zsET5pAJcwz5PcDrb4tqbbpGGr+IJ0N8PmMRZThE5VxEr3OM2Ptqvay+FN68xey76yH+nbGIIhwigkPEcIgEDpGei+h1jjRhjjxhjvN/lVWG+GAacwxxtrTmiBPmoAlz8IQ5ZMIcOmGONGGOPGGOCXWeJtR5nlDneUKd5wl1nifUeZ5Q53lCnecJdZ4n1HmeUOd5Qp2XCXVeJtR5mVDnZUKdlwl1XibUeZlQ52VCnZcJdV4m1HmdUOd1Qp3XCXVeJ9R5nVDndUKd1wl1XifUeZ1Q5/X8OtcQJswRJ8xBE+bgCXPIhDl0whxpwhx5whxlwhwT6jxOqPM4oc7jhDqPE+o8TqjzOKHO44Q6jxPqPE6o8zihzmlCndOEOqcJdU4T6pwm1DlNqHOaUOc0oc5pQp3ThDrnCXXOE+qcJ9Q5T6hznlDnPKHOeUKd84Q65wl1zhPqXCbUuUyoc5lQ5zKhzmVCncuEOpcJdS4T6lwm1LlMqHOdUOc6oc51Qp3rhDrXCXWuE+pcJ9S5TqjzCd+H0wnfh9MJ34fTCd+H0wnfVdMJ31XTCd9V0wnfVdMn5OMeJ2XoE/Jx+coRcaZ7RBEOEcEhYjhE8gRE4YaI7xEpHKIEhyjDISpwiCoaohLgED1hzz7MW9In5Cy3EKFlUukTcpZbiBQOUYJDlOEQFThEFQ3RE3KWW4jg9uwKt2c/I0P48Lc69BkZwvnKUcz3CvIZGcINRAUOUQVDlJ6QIRxTuiGq94giHCKCQ8RwiAQOkcIhSnCInrBnH/7iUwoFDlFFQ/SEnOUWogiHiOAQMRwigUOkcIjQfhMvRbg9O8Lt2UO+8/xtvzsfLwdtoluX/el359OQ70d/Gx69yMeU6B4Pg+ERMDwKhidNxyPliofv8WQwPAUMT8XCM+T75yPxRDA8BIZn/v7MlwM1vbn2ikfA8CgYngSGJ4PhKWB4KhYeCWB4IhgeAsMDtj8L2P4sYPuzgO3PArY/C9j+vJ+zKKSX7x4Kvfn2EaU9OBIuilyF5O3FrzPUs2fY/0bt0Bni6TPQ6TPw6TPI6TPo6TOk02fIp89wek2X01drOX21ltNXazl9tZbTV2s5fbWW81fr6SdQPf0EqqefQPXcmt7+EV8u3f9zYc2XgTG8+bVr0r2GJl0bmpzfXrrdxf6f/oZ9unz3p187txzly0/X7//0y7PKb/808vHT06mfnr/307cW+PLpb1/Lf/z0cuqn1+/+9Hr5fcQSvlwz+8FD3/bpF21QKH756fF7P73w5amWO2aIBn76F9W0/YNe94P9A+Y6h8bbppMPVsPhiPqtI/af2uGI+M0j6NtGbP/glwv3W1TV699Ft/+8cc2vc+03nY0xpWNM/fYx++aaxpjYMYY6xnDHGOkYox1jOtZB6VgHpWMdlI51UDvWQe1YB7VjHdSOdVA71kHtWAe1Yx3sf4Vctz83X8YkqV+OKR1j6rePifvflG4Nij2DqDkoyd2gBzzk60u5HOjLQfvf29Oq10G13A+inkHcM0g6Bu1/lySF2x9cg95Rvv+FhhRyuA66n2n/r+qNmfb/9L19/LXBj/fPaf/v061B3DNIegbpg0F6G8R3g1LPoNwzqPQMqh2DJPQMij2DqGPBCvcMkp5B2jMo9QzqqVwpPYNqxyANPYNiz6CeFaE9K0J7VoT2rAjtWRH6zSti+4e8qr59P0Sp10O0hlC/7uRtDaodg/a/+N8aFHsGUc+gfSLCtW8pge9P3n14twOnxKB3g6hnEPcMkp5B2jMo9QzKPYNKz6DaMWi/Qyrx9v4lyld2SNugdB2UPqvf+xc8A99AP+i9ngeHseAIFhzFgpOw4GQsOAULToWCIwELDtauLA8KvdAVTuGva/tLvP64c6E3f8s4bPsbgzT0DIo9g6SDiP1mvFB4M1P4uma8NSj3DCo9g/afE9FtEKcvB+0HfLYGxZ5B1DOIewZJzyDtGZQ6FmzKPYN6Kjf1VG7uqdzcU7mZegZxzyDpGaQ9g3pWRO5ZEblnReSeFVF6VkTpWRFFOgR0eSA29fr3+ZDu3pGU1DMo9wwqPYNqx6D9v9S1BsWeQdQziHsGSc+gnhVRe1ZE7VkRtWdF1I4VQeGbV8T2D3259IFhiS5NVdZb/7G9NXyZ7YGn6GjIA9vP4ZD4jUP+u/3zf3/4108//OXnH3/bhrz8f//9y19//+nXXz798/f/++fH/8928f8D","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","build_msg_block","attach_len_to_msg_block","pack_returns_oracle_wrapper","directive_invert","directive_integer_quotient"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000004c141a0"},{"kind":"string","value":"EcdsaPublicKeyNote"},{"fields":[{"name":"x","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"y","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000020"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000040"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"EcdsaKAccount"}},{"name":"fields","value":{"fields":[{"name":"public_key","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"EcdsaKAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"EcdsaKAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"signing_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signing_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"EcdsaKAccount::constructor_parameters"}}],"kind":"struct","path":"EcdsaKAccount::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"EcdsaKAccount::entrypoint_parameters"}}],"kind":"struct","path":"EcdsaKAccount::entrypoint_abi"}]}},"file_map":{"101":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"120":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: &mut Note) -> NoteEmission<Note>\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"165":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"166":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"177":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"308":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"309":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"313":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"400":{"path":"/usr/src/noir-projects/noir-contracts/contracts/ecdsa_k_account_contract/src/main.nr","source":"// Account contract that uses ECDSA signatures for authentication on the same curve as Ethereum.\n// The signing key is stored in an immutable private note and should be different from the signing key.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract EcdsaKAccount {\n    use dep::aztec::prelude::{PrivateContext, PrivateImmutable};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, functions::{private, initializer, view, noinitcheck}},\n    };\n\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness,\n    };\n\n    use dep::ecdsa_public_key_note::EcdsaPublicKeyNote;\n\n    #[storage]\n    struct Storage<Context> {\n        public_key: PrivateImmutable<EcdsaPublicKeyNote, Context>,\n    }\n\n    // Creates a new account out of an ECDSA public key to use for signature verification\n    #[private]\n    #[initializer]\n    fn constructor(signing_pub_key_x: [u8; 32], signing_pub_key_y: [u8; 32]) {\n        let this = context.this_address();\n        let this_keys = get_public_keys(this);\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n        let mut pub_key_note =\n            EcdsaPublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this_keys.npk_m.hash());\n        storage.public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note(\n            &mut context,\n            this_keys.ovpk_m,\n            this_keys.ivpk_m,\n            this,\n        ));\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[private]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[noinitcheck]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Load public key from storage\n        let storage = Storage::init(context);\n        let public_key = storage.public_key.get_note();\n\n        // Load auth witness\n        let witness: [Field; 64] = unsafe { get_auth_witness(outer_hash) };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify payload signature using Ethereum's signing scheme\n        // Note that noir expects the hash of the message/challenge as input to the ECDSA verification.\n        let outer_hash_bytes: [u8; 32] = outer_hash.to_be_bytes();\n        let hashed_message: [u8; 32] = std::hash::sha256(outer_hash_bytes);\n        std::ecdsa_secp256k1::verify_signature(\n            public_key.x,\n            public_key.y,\n            signature,\n            hashed_message,\n        )\n    }\n}\n\n"},"401":{"path":"/usr/src/noir-projects/noir-contracts/contracts/ecdsa_public_key_note/src/lib.nr","source":"use dep::aztec::prelude::{NoteHeader, NoteInterface, NullifiableNote, PrivateContext};\n\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note_custom_interface, generators::Ga1 as Gx_1, generators::Ga2 as Gx_2,\n    generators::Ga3 as Gy_1, generators::Ga4 as Gy_2, generators::Ga5 as Gnpk_m_hash, generators::G_slot\n};\n\nuse std::hash::from_field_unsafe;\n\nglobal ECDSA_PUBLIC_KEY_NOTE_LEN: u32 = 5;\n\n// Stores an ECDSA public key composed of two 32-byte elements\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[note_custom_interface]\npub struct EcdsaPublicKeyNote {\n    x: [u8; 32],\n    y: [u8; 32],\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NoteInterface<ECDSA_PUBLIC_KEY_NOTE_LEN> for EcdsaPublicKeyNote {\n    // Cannot use the automatic serialization since x and y don't fit. Serialize the note as 5 fields where:\n    // [0] = x[0..31] (upper bound excluded)\n    // [1] = x[31]\n    // [2] = y[0..31]\n    // [3] = y[31]\n    // [4] = npk_m_hash\n    fn serialize_content(self) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n\n        for i in 1..32 {\n            let byte_x: Field = self.x[31 - i] as Field;\n            x = x + (byte_x * mul);\n            let byte_y: Field = self.y[31 - i] as Field;\n            y = y + (byte_y * mul);\n            mul *= 256;\n        }\n\n        let last_x = self.x[31] as Field;\n        let last_y = self.y[31] as Field;\n\n        [x, last_x, y, last_y, self.npk_m_hash]\n    }\n\n    // Cannot use the automatic deserialization for the aforementioned reasons\n    fn deserialize_content(serialized_note: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> EcdsaPublicKeyNote {\n        let mut x: [u8; 32] = [0; 32];\n        let mut y: [u8; 32] = [0; 32];\n\n        let part_x:[u8; 32] = serialized_note[0].to_be_bytes();\n        for i in 0..31 {\n            x[i] = part_x[i + 1];\n        }\n        x[31] = serialized_note[1].to_be_bytes::<32>()[31];\n\n        let part_y:[u8; 32] = serialized_note[2].to_be_bytes();\n        for i in 0..31 {\n            y[i] = part_y[i + 1];\n        }\n        y[31] = serialized_note[3].to_be_bytes::<32>()[31];\n\n        EcdsaPublicKeyNote { x, y, npk_m_hash: serialized_note[4], header: NoteHeader::empty() }\n    }\n\n    fn to_be_bytes(self, storage_slot: Field) -> [u8; ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 64] {\n        let serialized_note = self.serialize_content();\n\n        let mut buffer: [u8; ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 64] = [0; ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 64];\n\n        let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n        let note_type_id_bytes: [u8; 32] = EcdsaPublicKeyNote::get_note_type_id().to_be_bytes();\n\n        for i in 0..32 {\n            buffer[i] = storage_slot_bytes[i];\n            buffer[32 + i] = note_type_id_bytes[i];\n        }\n\n        for i in 0..serialized_note.len() {\n            let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n            for j in 0..32 {\n                buffer[64 + i * 32 + j] = bytes[j];\n            }\n        }\n        buffer\n    }\n\n    fn get_note_type_id() -> Field {\n        comptime\n        {\n            let bytes = \"EcdsaPublicKeyNote\".as_bytes();\n            let hash = aztec::protocol_types::hash::poseidon2_hash_bytes(bytes);\n            let hash_bytes = hash.to_be_bytes::<4>();\n            aztec::protocol_types::utils::field::field_from_bytes(hash_bytes, true)\n        }\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn compute_note_hash(self) -> Field {\n        let serialized = self.serialize_content();\n        std::embedded_curve_ops::multi_scalar_mul(\n            [Gx_1, Gx_2, Gy_1, Gy_2, Gnpk_m_hash, G_slot],\n            [\n            from_field_unsafe(serialized[0]),\n            from_field_unsafe(serialized[1]),\n            from_field_unsafe(serialized[2]),\n            from_field_unsafe(serialized[3]),\n            from_field_unsafe(serialized[4]),\n            from_field_unsafe(self.get_header().storage_slot)\n        ]\n        ).x\n    }\n}\n\nimpl NullifiableNote for EcdsaPublicKeyNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl EcdsaPublicKeyNote {\n    pub fn new(x: [u8; 32], y: [u8; 32], npk_m_hash: Field) -> Self {\n        EcdsaPublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"73":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, CANONICAL_AUTH_REGISTRY_ADDRESS,\n    }, hash::poseidon2_hash_with_separator,\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let result: Field = context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n            [on_behalf_of.to_field(), inner_hash].as_slice(),\n            GasOpts::default(),\n        )\n        .deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n            [message_hash, authorize as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n            [context.this_address().to_field(), reject as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n"},"75":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"76":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator,\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"79":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: u32 = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            fields.extend_from_array(self.function_calls[i].serialize());\n        }\n        fields.push(self.nonce);\n        fields.push(self.is_fee_payer as Field);\n        fields.storage\n    }\n}\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"96":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"98":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
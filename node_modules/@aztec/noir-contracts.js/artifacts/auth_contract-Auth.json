{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"Auth","functions":[{"name":"do_private_authorized_thing","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_storage_hints","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","directive_integer_quotient","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnBaoNAEIDhd9mzB1fdmR1fpZSgiYYF0aCmUMR3r2lDCeT8X8TR2f/2nXZzl669X09p7KfF1R+bG6Zzs6ZpPKZtz1w7p2FI19PrZ5c/HlX1u7/cmvExLmszr64ugmauGy/HmxTH+T4NnatLKffsbVeL56rq/2aw/TNzVQDbArYVbEewbVw75GDbg+0CbJdgG3QZQJcBdBlAlwF0GUCXAroU0KWALgV0KaBLAV0K6FJAlwK6FNClgi4VdKmgSwVdKuhSQZcKulTQpYIuFXQZQZcRdBlBlxF0GUGXEXQZQZcRdBlBlxF0aaBLA10a6NJAlwa6NNClgS4NdGmgSwNd+jwn456MF2S8JOMVGQ9kXMi4kvFIxkmhnhTqSaEeE7of01czp6YduucdSH8fzy9XIuv37e/PsfwD","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"set_authorized_delay","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"new_delay","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_authorized_delay"],"assert_messages":{"832":"attempt to add with overflow","701":"attempt to add with overflow","1082":"Array index out of bounds","119":"call to assert_max_bit_size","628":"Array index out of bounds","756":"Array index out of bounds","683":"Array index out of bounds","808":"attempt to add with overflow","936":"Array index out of bounds","28":"Not initialized","860":"Array index out of bounds","1049":"attempt to add with overflow","787":"attempt to add with overflow","208":"attempt to subtract with overflow","653":"attempt to add with overflow","842":"Array index out of bounds","1040":"attempt to add with overflow","708":"Array index out of bounds","1156":"Array index out of bounds","955":"attempt to add with overflow","690":"Array index out of bounds","815":"Array index out of bounds","748":"attempt to add with overflow","797":"Array index out of bounds","1172":"Array index out of bounds","657":"Array index out of bounds","1035":"attempt to multiply with overflow","770":"Array index out of bounds","1090":"attempt to add with overflow","764":"attempt to add with overflow","883":"Stack too deep","877":"attempt to add with overflow","676":"attempt to add with overflow","1188":"attempt to add with overflow","1054":"attempt to add with overflow","731":"Array index out of bounds","216":"attempt to add with overflow","664":"Array index out of bounds","725":"attempt to add with overflow","853":"attempt to add with overflow","1164":"Array index out of bounds","646":"attempt to add with overflow"}},{"name":"get_authorized_delay","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_authorized_delay"],"assert_messages":{"243":"attempt to add with overflow","250":"Array index out of bounds","295":"Array index out of bounds","20":"Function get_authorized_delay can only be called statically","273":"Stack too deep","314":"attempt to add with overflow","267":"attempt to add with overflow","232":"Array index out of bounds","404":"Array index out of bounds","159":"call to assert_max_bit_size","428":"attempt to add with overflow","15":"Not initialized","396":"Array index out of bounds","412":"Array index out of bounds"}},{"name":"get_authorized","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_authorized"],"assert_messages":{"192":"Array index out of bounds","237":"Array index out of bounds","256":"attempt to add with overflow","215":"Stack too deep","20":"Function get_authorized can only be called statically","209":"attempt to add with overflow","174":"Array index out of bounds","346":"Array index out of bounds","338":"Array index out of bounds","15":"Not initialized","354":"Array index out of bounds","185":"attempt to add with overflow","370":"attempt to add with overflow"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"128":"attempt to add with overflow","1396":"Not initialized","2292":"Array index out of bounds","238":"attempt to add with overflow","1707":"attempt to add with overflow","1128":"attempt to add with overflow","732":"Function get_scheduled_authorized can only be called statically","921":"attempt to subtract with overflow","2201":"Array index out of bounds","1226":"Array index out of bounds","2232":"attempt to add with overflow","2165":"Array index out of bounds","2159":"attempt to add with overflow","2342":"attempt to add with overflow","2080":"Array index out of bounds","1245":"attempt to add with overflow","1690":"Array index out of bounds","2135":"attempt to add with overflow","2324":"attempt to add with overflow","1093":"Stack too deep","2117":"Array index out of bounds","1087":"attempt to add with overflow","2300":"Array index out of bounds","2099":"attempt to add with overflow","423":"invalid admin","612":"attempt to add with overflow","929":"attempt to add with overflow","2087":"Array index out of bounds","2142":"Array index out of bounds","2209":"attempt to add with overflow","2069":"attempt to add with overflow","2215":"Array index out of bounds","2337":"attempt to multiply with overflow","2124":"Array index out of bounds","2051":"Array index out of bounds","2356":"attempt to add with overflow","1070":"Array index out of bounds","1515":"attempt to add with overflow","1064":"attempt to add with overflow","1375":"Array index out of bounds","2076":"attempt to add with overflow","784":"Function get_authorized_delay can only be called statically","1357":"attempt to add with overflow","1546":"attempt to add with overflow","260":"attempt to add with overflow","2308":"Array index out of bounds","1150":"attempt to add with overflow","443":"PublicImmutable already initialized","242":"Array index out of bounds","2351":"attempt to add with overflow","1132":"Array index out of bounds","419":"Initializer address is not the contract deployer","1504":"Array index out of bounds","413":"Initialization hash does not match","669":"Function get_authorized can only be called statically","1047":"Array index out of bounds","1114":"attempt to add with overflow","1346":"Array index out of bounds","249":"Array index out of bounds","566":"caller is not admin","1139":"Array index out of bounds","1529":"Array index out of bounds","1383":"attempt to add with overflow","1627":"call to assert_max_bit_size","2182":"attempt to add with overflow"}},{"name":"get_authorized_in_private","is_unconstrained":false,"custom_attributes":["private","view"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_storage_hints","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","pack_returns_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"authorized","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_authorized"],"assert_messages":{"637":"Array index out of bounds","765":"Array index out of bounds","759":"attempt to add with overflow","692":"Array index out of bounds","826":"attempt to add with overflow","46":"caller is not admin","619":"attempt to add with overflow","1073":"attempt to add with overflow","805":"attempt to add with overflow","674":"Array index out of bounds","290":"attempt to add with overflow","732":"attempt to add with overflow","601":"Array index out of bounds","1183":"Array index out of bounds","1207":"attempt to add with overflow","1101":"Array index out of bounds","900":"attempt to add with overflow","833":"Array index out of bounds","955":"Array index out of bounds","626":"attempt to add with overflow","751":"Array index out of bounds","815":"Array index out of bounds","1068":"attempt to add with overflow","1059":"attempt to add with overflow","1175":"Array index out of bounds","788":"Array index out of bounds","782":"attempt to add with overflow","715":"Array index out of bounds","974":"attempt to add with overflow","709":"attempt to add with overflow","889":"Array index out of bounds","630":"Array index out of bounds","685":"attempt to add with overflow","1191":"Array index out of bounds","1054":"attempt to multiply with overflow","27":"Not initialized","219":"call to assert_max_bit_size","667":"Array index out of bounds","850":"attempt to add with overflow","856":"Stack too deep","1109":"attempt to add with overflow","649":"attempt to add with overflow"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"192":"attempt to add with overflow","506":"Array index out of bounds","759":"Array index out of bounds","500":"attempt to add with overflow","529":"Stack too deep","622":"attempt to add with overflow","203":"Array index out of bounds","456":"Array index out of bounds","523":"attempt to add with overflow","706":"Array index out of bounds","767":"Array index out of bounds","791":"attempt to add with overflow","377":"invalid admin","214":"attempt to add with overflow","467":"attempt to add with overflow","403":"PublicImmutable already initialized","714":"attempt to add with overflow","775":"Array index out of bounds","196":"Array index out of bounds","603":"Array index out of bounds","373":"Initializer address is not the contract deployer","82":"attempt to add with overflow","367":"Initialization hash does not match","483":"Array index out of bounds"}},{"name":"get_scheduled_authorized","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_scheduled_authorized"],"assert_messages":{"195":"Stack too deep","189":"attempt to add with overflow","154":"Array index out of bounds","20":"Function get_scheduled_authorized can only be called statically","318":"Array index out of bounds","334":"Array index out of bounds","350":"attempt to add with overflow","165":"attempt to add with overflow","15":"Not initialized","172":"Array index out of bounds","217":"Array index out of bounds","326":"Array index out of bounds","236":"attempt to add with overflow"}}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Auth"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"authorized","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Auth::get_authorized_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::get_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Auth::get_scheduled_authorized_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::get_scheduled_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Auth::do_private_authorized_thing_parameters"}}],"kind":"struct","path":"Auth::do_private_authorized_thing_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_delay","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"Auth::set_authorized_delay_parameters"}}],"kind":"struct","path":"Auth::set_authorized_delay_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::constructor_parameters"}}],"kind":"struct","path":"Auth::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Auth::get_authorized_in_private_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::get_authorized_in_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"authorized","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Auth::set_authorized_parameters"}}],"kind":"struct","path":"Auth::set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Auth::get_authorized_delay_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"Auth::get_authorized_delay_abi"}]}},"file_map":{"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"133":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32))\n            + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change,\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"134":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32,\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T>\nwhere\n    T: ToField,\n{\n    fn serialize(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T>\nwhere\n    T: FromField,\n{\n    fn deserialize(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2]),\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"136":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{poseidon2_hash, poseidon2_hash_with_separator}, address::AztecAddress,\n    traits::{FromField, ToField}, utils::arrays::array_concat,\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{\n        scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange,\n    },\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::mem::zeroed;\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change),\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub fn get_current_value_in_private(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_block_number) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon =\n            value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash,\n                SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint),\n                \"Hint values do not match hash\",\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint,\n                ScheduledValueChange::deserialize(zeroed()),\n                \"Non-zero value change for zero hash\",\n            );\n            assert_eq(\n                delay_change_hint,\n                ScheduledDelayChange::deserialize(zeroed()),\n                \"Non-zero delay change for zero hash\",\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    ) -> Field {\n        let concatenated: [Field; 4] =\n            array_concat(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext>\nwhere\n    T: ToField + FromField + Eq,\n{\n    pub unconstrained fn get_current_value_in_unconstrained(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>)\nwhere\n    T: ToField + FromField + Eq,\n{\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number),\n        storage_read(address, dummy.get_delay_change_storage_slot(), block_number),\n    )\n}\n"},"143":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{context::{PublicContext, UnconstrainedContext}, state_vars::storage::Storage};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize},\n};\n\n// Just like SharedImmutable but without the ability to read from private functions.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context> Storage<T> for PublicImmutable<T, Context> {}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"154":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: Header,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"274":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"306":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"mod assert_array_appended;\nmod assert_array_prepended;\nmod assert_combined_array;\nmod assert_combined_sorted_transformed_value_array;\nmod assert_combined_transformed_array;\nmod assert_deduped_array;\nmod assert_exposed_sorted_transformed_value_array;\nmod assert_sorted_array;\nmod assert_sorted_transformed_value_array;\nmod assert_split_sorted_transformed_value_arrays;\nmod assert_split_transformed_value_arrays;\nmod get_sorted_result;\nmod get_sorted_tuple;\nmod sort_by;\nmod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_reversed, assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_sorted_transformed_value_array::{\n    assert_combined_sorted_transformed_value_array_asc,\n    get_combined_order_hints::{CombinedOrderHint, get_combined_order_hints_asc},\n};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_deduped_array::{assert_deduped_array, dedupe_array};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len }\n}\n\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe { find_index_hint(values, |v: Field| min.lt(v)) };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"333":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot: Field,\n    value: Field,\n    next_slot: Field,\n    next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"363":{"path":"/usr/src/noir-projects/noir-contracts/contracts/auth_contract/src/main.nr","source":"mod test;\n\n// Test contract showing basic public access control that can be used in private. It uses a SharedMutable state variable to\n// publicly store the address of an authorized account that can call private functions.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Auth {\n    use dep::aztec::{\n        protocol_types::address::AztecAddress, state_vars::{PublicImmutable, SharedMutable},\n        macros::{storage::storage, functions::{private, public, initializer, view}},\n    };\n\n    // Authorizing a new address has a certain block delay before it goes into effect.\n    global CHANGE_AUTHORIZED_DELAY_BLOCKS: u32 = 5;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin can change the value of the authorized address via set_authorized()\n        admin: PublicImmutable<AztecAddress, Context>,\n        // docs:start:shared_mutable_storage\n        authorized: SharedMutable<AztecAddress, CHANGE_AUTHORIZED_DELAY_BLOCKS, Context>,\n        // docs:end:shared_mutable_storage\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.initialize(admin);\n    }\n\n    // docs:start:shared_mutable_schedule\n    #[public]\n    fn set_authorized(authorized: AztecAddress) {\n        assert_eq(storage.admin.read(), context.msg_sender(), \"caller is not admin\");\n        storage.authorized.schedule_value_change(authorized);\n        // docs:end:shared_mutable_schedule\n    }\n\n    // docs:start:public_getter\n    #[public]\n    #[view]\n    fn get_authorized() -> AztecAddress {\n        // docs:start:shared_mutable_get_current_public\n        storage.authorized.get_current_value_in_public()\n        // docs:end:shared_mutable_get_current_public\n    }\n    // docs:end:public_getter\n\n    #[public]\n    #[view]\n    fn get_scheduled_authorized() -> AztecAddress {\n        // docs:start:shared_mutable_get_scheduled_public\n        let (scheduled_value, _block_of_change): (AztecAddress, u32) =\n            storage.authorized.get_scheduled_value_in_public();\n        // docs:end:shared_mutable_get_scheduled_public\n        scheduled_value\n    }\n\n    #[public]\n    #[view]\n    fn get_authorized_delay() -> pub u32 {\n        storage.authorized.get_current_delay_in_public()\n    }\n\n    #[public]\n    fn set_authorized_delay(new_delay: u32) {\n        storage.authorized.schedule_delay_change(new_delay);\n    }\n\n    #[private]\n    fn do_private_authorized_thing() {\n        // Reading a value from authorized in private automatically adds an extra validity condition: the base rollup\n        // circuit will reject this tx if included in a block past the block horizon, which is as far as the circuit can\n        // guarantee the value will not change from some historical value (due to CHANGE_AUTHORIZED_DELAY_BLOCKS).\n        // docs:start:shared_mutable_get_current_private\n        let authorized = storage.authorized.get_current_value_in_private();\n        // docs:end:shared_mutable_get_current_private\n        assert_eq(authorized, context.msg_sender(), \"caller is not authorized\");\n    }\n\n    #[private]\n    #[view]\n    fn get_authorized_in_private() -> AztecAddress {\n        storage.authorized.get_current_value_in_private()\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"},"92":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Deserialize<N>,\n{\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"97":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice,\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: arr_copy_slice(\n            fields,\n            [0; PUBLIC_DATA_TREE_HEIGHT],\n            1 + LEAF_PREIMAGE_LENGTH,\n        ),\n    }\n}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
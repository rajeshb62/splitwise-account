{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"TokenBridge","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7V3bjhu3EvyXffYDL02ymV85OAicxAkWMOzAdg5wYPjfo5V3qNmdGXbUoaVmky+BHbM0VSWKXZxLz9eH39798tcfPz9++P3j54ef/vP14f3HX99+efz44fS3r9/ePPzy6fH9+8c/fl7/7wfz9B9rz+M///n2w9NfP395++nLw082ZvPm4d2H305/TMacPuH3x/fvHn6C4L/9982DdRyQ54CAAwocUOSAEgeEHFBmgJzhgDgzwnFmhLt6RrzZjg4uL6MD5DLaot0Z7XMMz6N9TrAaHXZGR0D7PDpCTi9GP9GHFvSTW0ZHEwn6FkIZDTmU0TnvDMaQnsdixvXQJ+qhX+qxX+qpX+rYL/XcLXVvbk8dzIV6fM3HCuPjhPHxwviAMD5BGJ8ojM/tC0SwUOKTI5YqV+KQN7YMDXimjv1Sz91SByObOixp28VLfPbmHJ/Bdszddczdd8wdZHNPS5Zz2W+4h465x46536Go+ng5J/G6yIfbrx2nIWW0A2I/Us6nIMALL3fG2rJ3CRvfgx9EJwyiMwyiMw6iMw2iEwfRmcfQGc0gOu0gOgfJQ3GQPBRhEJ2D5KE4SB6Kg+ShOEgeioPkoTRIHkqD5KGkp66E5J/HhgQbnXrWoYDL2LC6hr/o1LMOVXWinnUowvL7jHHz+0Q961Bdp559WV2nnn1ZXScMolNP/azr1LMvq+vUsy+r69STh+o69eShqs48SB7Kg+ShPEgeysLz0OHeeeeDE5abSNLqAQ7v4lkpDKNUeCZqqFR4KrpGKUL5YAx5o1R4LmqoVHgyaqhUeDa6Rml2y33LNnt4rdQa4fGopVThCamlVOEh6SqpqZDO6LdSFeUkSiqMI1VRUqKk6olKzpQnLp2JYStVT1YipeoJS6RUPWmJkmr1pCVn0Bepq0cgi1Q9aYmUqictkVL1pCVSKuiRastTWM66tJWqJy2RUhWlJUqqorRESVWUluzlyVkbcCtVUVoipDpFaYmSqigtUVIVpSWbYpGKeStVUVqipMI4UjWlJUKqorTkTOkucPrzVqqitERJVZSWKKmK0hIh1StKS85jkRrcVqqitERJVZSWKKmK0hIlFRRJLZennMPtpWSvKC1RUjWlJUKqprRESFWUlrwpl6e83Z7y9orSEiEVFKUlSqqitERJVZSWvC+nvD1sT6OBorRESYVxpCpKS5RURWnJx3IazeN2aw6K0hIlVVNaIqRqSkt1qUFTWsplaw52uzUPmtISIVVTWiKkakpLhFRQdIuWLVtzcC8jxHY02Lh8NFhcj07fjVGUrdoao+kO8qbGaLrf/CpjfF5IA1i/NUbT3elNjdF0L3tLY6S3+/1xxsTy0RD9do2R3h/4fsZouqu+qTGa7sG/yhiE5alVwLizxsA0Zt+YYZMvZUyvyfdMvtd0eibfa4J8Iq+ol1m1t6tV1MyMEKqou2tVqKZ2Zra81tvFrVBF/czqQhU1NKsLVdThtS4U9Ag1F6FpK1RRj9e6UEVNXutCFXV5rQtV1Oa1LlRRn9eaUCe9k1k7oXqSUfVNBk56F7N2QvUkI0IojCJU0dtj6kL1JCNCqKJzRnWhg7wQyEnvW9ZMqPSuZe2EjpKMpHcsayd0lGQkvVtZO6GjJCPpncqaCW3+LOnq9qN9oSkul0hSupgS8DsdlEWnRcqIMRc6GAg64MLCB1xyq9G7L8HE0poNMYQXo5/4N3nQ8p78bef8Xef8fef8oXP+4eb8fbk6Bt7FLaMojlESxwhvP+vQXRglYtZFXJ5hWfNwp9BxZp97Zt/kYblYIpNN1lDsIZQ7RgE9wf46JtT60OR5uX7UuqHU+qHUwlBqw1Bqoya13pWHbbxfvX7stNfc+2wDeaFiTfDr9tm71c0vZwHieuxzcUvTyDZG4jSyjZF5GtnEyKgqt97TSFWR+J5Gqkrb9zRSVZC/p5EwjWxjpKrtxz2NnDubRkbOnU0jI+fOppGRc2fTxsg0dzb/3MjSDTsmuzFy7mwaGTl3No2MnDubRkbCNLKNkXNn08jIubM5MPLsztyu1NyZe5CaO3NjUXEH526h5s7cAtTcmbm+5s4M6zV3YLpTcWfG6po7MyvX3JlZuebOzMo1d2ZWrriTZ1auuTOzcs2dmZVr7sysXHMHpjsVd2ZWrrkzs3LNnZmVa+7MrFxzZ2blY3e8mVm55s7MyjV3ZlauuTOzcs0dmO5U3JlZuebOzMo1d2ZWrrkzdFYO4C/uhLh1Z+isTLljh87KpDtDZ2XSnaGzMunO0FmZdAemOxV3hs7KpDtDZ2XSnaGzMunOzMoVd9zYeWe1z4omb90ZumbFsHJn/RDJ7gMn9fFnN4eucVe6mcq7Rm3Krx/g8W7ogtjWyqGrZ1srhy61V1qJWN4IkE3YWDn0OaymVvqhT3i1tXLotNjWyqFPpbW1cujzbm2thGllKyvnbqeZlXO308zKudtpZuXc7TSzcu52WlkJc7fTzMq522lm5dztNLNy7naaWQnTyn9qpTNu+XRn/NbKudtpZuXc7TSzcu52mlk5dzvNrJy7nVZW6noh5H2tnLudZlbO3U4zK5vsdsBerPSElS7C8tkuxUiMbtlM37d5TWYvYsNIYuNIYtNIYnEksXkgsW1e2tiLWDuSWDeS2JESVJuXCPYidqQEFUdKUFFbgqq8jMRHbQmqKlZbgqqJTdoSVFWstgRVFastQVXFdp2gzgqgewVdZ52zgq4DzFlB16nkrKDrqHFW0HV+eFKAXYeCs4KuK/1ZQdfl+6yg+5rc5p1Ed1XQfU3G7msydl+TsfuajN3X5Nx9Tc7d1+TcfU3O3dfkNu8+uauC7mty7r4m5+5rcu6+JufeazKY3msymN5rMpjeazKY3msyGPE1meixCEZ8TSYViK/JpALxNZlUIL4mkwrE12RKgRVfk0kF4msyqUB8TSYViK/JpILua7KVXw/qvYnBiV+LGvcPBid+7WrZTRWc+IWurVzxq2JbueKX0JatNsCJ3wO1lSt+w9RWrvhq2lau+K1YW7ni921N5XptwYqQqy1VEXK1pSpCrrZURciFseSOlar8WKnKj5Wq/Fipyo+VqkBZqqr3rQFQlqooucpSFSVXWaqi5MJYcpWlKkquslRFyVWWqii5ylIVJbdFqkquJJm0IvQk4OkYTZpOUsewNzhGi6KNvlzlwIDEl+1P39jzaG/C5bO9dd8ZtairL3IoEIzAeHweDQbWk3X3MfEAy+gYon8x+sy/RaHEGC78qZ9PMssvM/m49TM0+YbdhU/azqJ4g2OkGxxjf6G8NL+03lriGA5sWZxOl6vLaHe6fn8+Rv7xxzhoW9b2GPbfH8O6uPyWTsDV79TvzfNozFIlonF588s7aOl1T0ZeHCMQxyiIYxTFMUriGKE4Rlkao2TEMRK3Zidxa3YSt2YncWt2ErdmJ3FrdhK3Zidxa/ZBJxvvyjF8pBmt+a8yPbid0SHCMjrEV7u3ndEeF/6nP+KG/0Efm3742875u875+875Q+f8Q+f8Y+f8U+f8sXP+ndff3Hn9zZ3X3yx9/QQLy2iwYctf+u8XvCn8fdzyv8Pv15UZERMS/IlzyMGYzvnbzvm3yM8+lGtVPpkX/M/H8Dc4BtzgGOEGx4g3OEa6wTFarKvhclU5rF85t/u7IM40BJOlMbJGHCMrjpETx8iLYwTiGAVxjKI4RkkcI3FrthW3Zjtxa7YTt2Y7cWu2E7dmO3FrthO3ZrsfvGafj5FucAy8wTGarJS5jI4O/uW35404RlYcIyeOkRfHCMQxCuIYRXGMkjhGKI6RuDUbxK3ZIG7NBnFrNohbs0Hcmg3i1uwWD9ydTtgtlwI89YyLz+WJEp8TvOCzwx5w+egIOW3ZN3gW49KdMcRAsce0XMfw+IrPdnTC8vBZOgG37KVf9a5ftQxB+lVviOUaFaTt7AnSr3pDcFX+0u86A58v/KlrhNm4ZbZlE3bUSr9HrX6NPATonL/4eywI/tLvUaP4S79HjeLf9z0uIYiv1nX+UXy1JviLr9YEf/nVus6/8/obO6+/sfP6Gzuvv7Hz+hs7r79Jfhczv2xgTn+Gy6c/vzMgJPmNySgF8nuNUQqgewXyO4JRCuQ3+aIUyO/bRSmQ34qLUiC/ZymhAOW3IaUUdF+TsfuajN3XZOy+JmP3NRm7r8kovyY7c1HgdxTIr8mUAvk1mVCQ5ddkSoH8mkwpkF+TKQXyazKlQH5NphTIr8mUAvk1mVLQfU3O3dfk3HtNjqb3mhxNk3qA+aLAEJwASidzAKTOvV/HxF+uAni/fgokspJ7NDDdqbgTpjsVd+J0p+JOmu5U3MHpTsWdPN05dseaod0h8o61052KO266U3Fn7KxMuQPTnYo7Y2dlyp2xszLlzthZmXJn7KxMuTN2VibccTMr19yZWbnmzszKNXdmVq64c/DEKJb3Jlpc3fHuDHxHwS7KlcfErVuh/DMocECRA0ocEHJABy+ySqXlqsv4GnT0xr86aN/yYMv3G+yG3sHzMAQockCJA0IO6CBHXLpunQx+DTp4vRcBshyQ44A8BwQcUOCAIgeUOCDkgDgzAjkzAjkzAjkzAjkzAjkzAjkzAjkzAjkz4uiGP3SXouk2oMwAHd3WVgdZDshxQJ4DAg4ocED7Xy6Ut39bgM1afnDnCAHK14PSwf0RBMhyQI4D8hwQcECBA4ocUOKAkAPizIiDq1OX7G4hmQ3IckCOA/IcEHBAgQOKHFDigJADygyQ48wIx5kRjjMjHGdGOM6McIxtQ3KRA0ocEGPbkPbbXCIs+3oM/jXkoMeiKR2nTlvqsAFZDshxQJ4D2p8Ppx3nArIJN6DAAUUOKHFAyAFlBuigmxsBshyQ44A8B8SZEYEzIwJnRgTOjAicGRE4M2K/4051WTlocmPs5W4avwUFDihyQIkDQg4oM0CJsygnzqKcOIty4izKB2dyCFDggCIHlDiggxkRy6/JoNuAMgN0cCaHAFkOyHFAngMCDoieETsgzoxAzow4OJNDgDIDlDlrROasEZmzRmTOGpE5a0TmrBGZMyMyZ0ZkzozIjBmBxnBAjgPyHBBwQIwvF/dPK4STq8+ggGZ9fTN8R+1+uwGh9D7GAFsU7qNcrqLyPirEgoqbPsu4v3cnUZaFciyUZ6GAhQosVNxH2XBBvew5tr3inG05m59t2n67Ll17jDMKWajMQXlzNerb6a//e/vp8e0v7999PoGe/vWvD79+efz44fmvX/7/5/d/OQ3+Gw==","brillig_names":["constructor"],"assert_messages":{"672":"Array index out of bounds","451":"Initialization hash does not match","215":"attempt to add with overflow","567":"attempt to add with overflow","197":"Array index out of bounds","773":"Array index out of bounds","805":"attempt to add with overflow","822":"Array index out of bounds","83":"attempt to add with overflow","691":"attempt to add with overflow","781":"Array index out of bounds","583":"Array index out of bounds","193":"attempt to add with overflow","606":"Array index out of bounds","830":"attempt to add with overflow","504":"SharedImmutable already initialized","789":"Array index out of bounds","600":"attempt to add with overflow","629":"Stack too deep","623":"attempt to add with overflow","204":"Array index out of bounds","457":"Initializer address is not the contract deployer","556":"Array index out of bounds"}},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiAEkeAgAAAx4CAAAEMDgAAwAEAAUkAgEBAyECABAABTkBAAAeAgEAAx4CAAAECjgDBAUhAgAVAAU5AQAAJAIAAAMqCAEEJAIEAgUAEAEFASQDBAEEACgEAgUqDAUGKg4DBioNBAUAKAUCBSoOBQQqCAEFAAABAgEqDgQFJAIEAAMkAgABBCQCBAEGKgwDAiAAKAo4AgMHIQIAMwAHIAArKg0FAgAoAgIFADgFAwYqDQYECjgEAQIhAgAyAAI5AQAAIyoNBQccDAACCAA4BAgJLAwACQAIJAIEAQoMOAIKCyECADsACzkBAAArBAAHgAMlAAQAAoAEIgBOKwiABQAJACgJAgoAOAoCCyoOCAsAOAIGBw44AgcIIQIARgAIOQEAACoOCQUqDAcCIAAoJQAEeACABA0AAACABIADIQAATYADOQEAACMrAYADgAYLAIAGAAKAByEAAFKAByAAVCsAgAOABSAAYisAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQAAYIAKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIABXJQEEAAGABSAAYiMrABjKGMo=","debug_symbols":"1ZrbbuIwEIbfxddc2J6DPbzKalWFFqpIUaiArrRCvPsmXRwOySZaoK3nBsXw2/6wx/NnouzNy3Lx/vpU1qv11sx/7E21fi525bpuWvvDzCw2ZVWVr0/nXxvbfjj7od++FXXb3O6Kzc7MHYudmWX90lwGa5sRVmW1NHMkOMx6aiE6iiVQp3XRDWhBOIlBAp6paUDNGN1RzSjhQv1zZpy7H95Z8EltyX8pvn/A2ovr6N3U4jtPktRwoR6iDwHiUR1CO94VPTyWni7p2xnw02egT5+B758BbbcRaJGngo4wqZkYetsW7gd67CmI/wvUdpIbOnl7S6fBHMPiu0WWsy35V46JmKZwVk4rAEOnlBhTRiK+2sABNcSQ1BDj9ep6rxsfdOOjbnzSjc+68YNu/KgbX1Tjg9WNr9t1Qbfrgm7XBd2ui7kfXXRp7OaSevi5Bw+C7fCBe/jfEDy+CwcOcQLfQejqTYincgWc/8An3fisG3/6lo3idYWJ8ZZOckMnyt1VxzML5e6qyF0oYeg96KDsEyP5MfzcXRVBTvhTB1msTyRiqf9nc698x02Mcq98J/Bzr3wn8HOvfCfwc698x/E5+9vncfzsPXocP3uPHsfXXbxw/h49iq/bdVm367Ju12Xdrsu6XTdodt1D0/xVbMpiUS2Pb8ys3uvnsxdodr/f/v7SiP8A","brillig_names":["_assert_token_is_same"],"assert_messages":{"69":"attempt to add with overflow","58":"Array index out of bounds","15":"Not initialized","20":"Function _assert_token_is_same can only be called internally","49":"Token address is not the same as seen in storage","76":"Stack too deep"}},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["claim_public"],"assert_messages":{"1408":"attempt to multiply with overflow","2048":"attempt to add with overflow","890":"attempt to add with overflow","963":"attempt to add with overflow","756":"attempt to multiply with overflow","945":"Array index out of bounds","1585":"attempt to subtract with overflow","488":"attempt to add with overflow","872":"Array index out of bounds","1128":"attempt to add with overflow","1250":"attempt to add with overflow","604":"L1-to-L2 message is already nullified","1372":"Array index out of bounds","2024":"Array index out of bounds","1360":"attempt to multiply with overflow","1677":"Array index out of bounds","842":"attempt to add with overflow","1031":"attempt to add with overflow","1543":"attempt to subtract with overflow","897":"attempt to add with overflow","952":"Array index out of bounds","1653":"attempt to subtract with overflow","879":"Array index out of bounds","1324":"attempt to subtract with overflow","989":"Array index out of bounds","1733":"attempt to add with overflow","1154":"Stack too deep","1148":"attempt to add with overflow","1788":"Array index out of bounds","1014":"Array index out of bounds","1904":"Array index out of bounds","941":"attempt to add with overflow","746":"attempt to add with overflow","1581":"attempt to subtract with overflow","996":"Array index out of bounds","1441":"Array index out of bounds","2032":"Array index out of bounds","923":"Array index out of bounds","472":"Array index out of bounds","1368":"attempt to add with overflow","1807":"attempt to add with overflow","1673":"attempt to subtract with overflow","1478":"attempt to add with overflow","1344":"attempt to add with overflow","1722":"Array index out of bounds","1332":"Array index out of bounds","1460":"attempt to add with overflow","1899":"Index out of bounds","296":"call to assert_max_bit_size","1448":"Array index out of bounds","930":"Array index out of bounds","607":"Tried to consume nonexistent L1-to-L2 message","729":"Array index out of bounds","985":"attempt to add with overflow","1107":"Array index out of bounds","205":"Array index out of bounds","778":"attempt to subtract with overflow","967":"Array index out of bounds","1217":"attempt to add with overflow","766":"attempt to add with overflow","1467":"Array index out of bounds","1272":"attempt to add with overflow","1589":"Array index out of bounds","1132":"Array index out of bounds","1577":"attempt to multiply with overflow","1254":"Array index out of bounds","1382":"attempt to add with overflow","864":"attempt to add with overflow","1437":"attempt to add with overflow","218":"attempt to add with overflow","919":"attempt to add with overflow","1114":"Array index out of bounds","1041":"attempt to multiply with overflow","846":"Array index out of bounds","974":"Array index out of bounds","1096":"attempt to add with overflow","901":"Array index out of bounds","1230":"attempt to subtract with overflow","1352":"attempt to add with overflow","1364":"attempt to subtract with overflow","1547":"Array index out of bounds","1596":"Array index out of bounds","1139":"Array index out of bounds","1608":"attempt to add with overflow","1261":"Array index out of bounds","1657":"Array index out of bounds","2016":"Array index out of bounds","30":"Not initialized","1566":"attempt to add with overflow","1688":"attempt to add with overflow","853":"Array index out of bounds","1103":"attempt to add with overflow","908":"Array index out of bounds","713":"Nested call failed!","1926":"attempt to add with overflow","835":"attempt to add with overflow"}},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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RtV7blS950bVe25UvecWrffcQWtUaKlyqWi95w5aKi9F1XtuVL3nRtV7btF6z88nvmi95w5aqlwqWu+5g5bKS1H1nhtV77lR9Z4bVe+5UfWeW7TecwctVS4VrffcQWtUaKm8FFXvuVH1nhtV77lF6z0/n/ii9Z47aKlyqWi95w5aKi9F1XtuVL3nRtV7blS950bVe27Res9P0dZovecOWqZcqkbrPXfQMnmpuhkVWiYvVal6z2u03vPTia9G6z130DLlUjVa77mDlspLUfWeV6re80rVe16pes8rVe95jdZ77qBlyqVqtN7zc7TRes8dtFReiqr3vFL1nleq3vMarff8fOKL1nvuoKXKpaL1njtoqbwUVe95peo9r1S955Wq97xS9Z7XaL3nDlqqXCpa77mDliqXouo9r1S955Wq97xS9Z7XaL3n5xNftN5zBy1VLhWt99xBS+WlqHrPK1XveaXqPa9UveeVqve8Rus9d9AaFVqqXCpa77mDlspLUfWeV6re80rVe16j9Z6fT3zRes8dtFS5VLTecwctlZei6j2vVL3nlar3vFL1nleq3vMarffcQUuVS0XrPXfQGhVaKi9F1XteqXrPK1XveY3We34+8UXrPXfQUuVS0XrPHbRUXoqq97xS9Z5Xqt7zStV7Xql6z2u03vNztNF6zx20VLlUtN5zBy2Vl6LqPa9UveeVqve8Rus9P5/4ovWeO2iZcqkWrffcQcvkpRpV73mj6j3fv+dUaJm8VKPqPW/Res8dtEy5VIvWe36ONlrvuYOWyktR9Z43qt7zRtV73qL1np9PfNF6zx20TLlUi9Z77qCl8lJUveeNqve8UfWeN6re80bVe96i9Z47aKlyqWi95w5aqlyKqve8UfWeN6re80bVe96i9Z6fT3zRes8dtFS5VLTecwctlZei6j1vVL3njar3vFH1njeq3vMWrffcQWtUaKlyqWi95w5aKi9F1XveqHrPG1XveYvWe34+8UXrPXfQUuVS0XrPHbRUXoqq97xR9Z43qt7zRtV73qh6z1u03nMHLVUuFa333EFrVGipvBRV73mj6j1vVL3nLVrv+fnEF6333EFLlUtF6z130FJ5Kare80bVe96oes8bVe95o+o9b9F6z8/RRus9d9BS5VLRes8dtFReiqr3vFH1njeq3vMWrff8fOKL1nvuoKXKpaL1njtoqbwUVe95o+o9b1S9542q97xR9Z63aL3nDlqqXCpa7/kp2h6t99xBy+SlOlXveafqPe+bUaFl6kTo0XrPHbRMuVSP1nvuoKXyUlS9552q97xT9Z53qt7zTtV73qP1njtomXKpHq333EHLlEt1qt7zTtV73ql6zztV73mP1nt+PvFF6z130FLlUtF6zx20VF6Kqve8U/Wed6re807Ve96pes97tN5zB61RoaXKpaL1njtoqbwUVe95p+o971S95z1a7/n5xBet99xBS5VLRes9d9BSeSmq3vNO1XveqXrPO1XveafqPe/Res8dtFS5VLTecwetUaGl8lJUveedqve8U/We92i95+cTX7TecwctVS4VrffcQUvlpah6zztV73mn6j3vVL3nnar3vEfrPT9HG6333EFLlUtF6z130FJ5Kare807Ve96pes97tN7z84kvWu+5g5Yql4rWe+6gpfJSVL3nnar3vFP1nneq3vNO1Xveo/WeO2ipcqlovefnaKP1njtoqbwUVe95p+o971S95z1a7/n5xBet99xBS5VLUfWed6re80HVez6oes8HVe/5oOo9H5sR3YEGVe/5oOo9H9F6z53fLZOXGlS954Oq93xQ9Z4Pqt7zEa33/PwOFK333EFL5aWi9Z47aKm8FFXv+aDqPR9UveeDqvd8UPWej2i95w5ao0LL9LzUiNZ77qCl8lLBes/7+Hj1/p/lM1p4L9XmA+2YHtpc++O8++/QPjkN2z7Oulq2T9Tgl6TfRw28S7uPGnhLdx818P7vPmpM1BxRA+8s76MG3obeRw28Z72PGniDex81csNH1ODX3N9HjdzwITVyw4fUyA0fUmOi5ogaueFDauSGD6mRGz6kRm74kBq54SNq8DcquI8aueFDauSGD6mRGz6kxkTNETVyw4fUyA0fUiM3fEiN3PAhNXLDR9TgbzVxHzVyw4fUyA0fUiM3fEiNiZojauSGD6mRGz6kRm74kBq54UNq5IaPqMHfLOQ+auSGD6mRGz6kRm74kBoTNUfUyA0fUiM3fEiN3PAhNbHcsFMggb8py0q0+JuyLEUby4Z6aGM5S2f5Lv6mLEvRGhXaWJbOQxvLpXloYxkv75pM5aXwN2VZiRZ/U5alaIN5qfOrFP6mLEvRUnkp/E1ZlqKl8lL4m7IsRRvMSzlog3kpB20wL3WKduJvyrIULZOXmvibsixFy+Sl5mZUaIN5qdOJb+JvyrIULVMuNfE3ZVmKlspL4W/KshQtlZfC35RlKVoqL4W/KctStEy51MTflGUpWqZcauJvyrIULZWXwt+UZSlaKi+FvynLUrTBvNT5xIe/KctStFS5FP6mLEvRUnkp/E1ZlqKl8lLB9lnx0FJ5qWC7oXhoqXKpYHuWeGipcqlgO4t4aKm8VLD9Pzy0VF4q2C4dHlqmdXwz2F4aHlqqXCrYjhceWiovFWxfCg8tlZcKtnuEh5bKSwXb48FDS5VLBduJwUNLlUsF2y/BQ0vlpYLtauChpfJSwfYe8NAydSLMYDsEeGipcqlgPf4eWiovFaxt30NL5aWCdeJ7aKm8VLDmeg8tVS4VrF/eQ0uVSwVrgffQUnmpYF3tHloqLxWsUd1DS9WJQNV7Pql6zydV7/mM1nt+fpWi6j2fVL3nk6r3fFL1nk+q3vMZrffcQUuVS0XrPT9HG6333EFL5aWoes8nVe/5pOo9n9F6z88nvmi95w5aqlwqWu+5g5bIS5WNqfd8R0vkpXa0RF5qR0vkpXa0RoWWKJfa0RLlUjtaolxqR0uUS+1oqbwUU+/5jpbKSzH1nu9oiToRdrRGhZYol9rREuVSO1oqL8XUe76jpfJSTL3nO1oqL8XUe76jpcqlovWeO2ipcqlovecOWiovxdR7vqOl8lJMvec7WqJOhB0tUSfCjpYql4rWe+6gpfJSTL3nO1oqL8XUe76jpfJSTL3nO1qqXCpa77mDliqXitZ77qCl8lJMvec7WiovxdR7vqMl6kQoW7TecwctVS4VrffcQUvlpZh6z3e0VF6Kqfd8R0vlpZh6z3e0VLlUtN5zBy1VLhWt99xBS+WlmHrPd7RUXoqp93xHS9SJsKMl6kTY0VLlUtF6zx20VF6Kqfd8R0vlpZh6z3e0VF6Kqfd8R0uVS0XrPXfQUuVS0XrPHbRUXoqp93xHS+WlmHrPd7RUnQjRes8dtFS5VLTecwctlZdi6j3f0VJ5Kabe8x0tlZdi6j3f0VLlUtF6zx20VLlUtN5zBy2Tl0pUveeJqvc8UfWep2i956cTX9qMCi1TLpWi9Z47aJm8VKLqPU9UveeJqvc8UfWeJ6re8xSt99xBa1RomXKpFK333EFL5aWoes8TVe95ouo9T9F6z88nvmi95w5aqlwqWu+5g5bKS1H1nieq3vNE1XueqHrPE1XveYrWe+6gpcqlovWeO2iNCi2Vl6LqPU9UveeJqvc8Res9P5/4ovWeO2ipcqlovecOWiovRdV7nqh6zxNV73mi6j1PVL3nKVrv+TnaaL3nDlqqXCpa77mDlspLUfWeJ6re80TVe56i9Z6fT3zRes8dtFS5VLTecwctlZei6j1PVL3niar3PFH1nieq3vMUrffcQUuVS0XrPT9HG6333EFL5aWoes8TVe95ouo9T9F6z88nvmi95w5aqlwqWu+5g5bKS1H1nieq3vNE1XueqHrPE1XveYrWe+6gpcqlovWeO2ipcimq3vNE1XueqHrPE1XveYrWe34+8UXrPXfQUuVS0XrPHbRUXoqq9zxR9Z5nqt7zTNV7nql6z3O03nMHrVGhZcqlcrTecwctk5fKVL3nmar3PFP1nudoveenE1+O1nvuoGXKpXK03nMHLZWXouo9z1S955mq9zxT9Z5nqt7zHK333EFLlUtF6z130BoVWiovRdV7nql6zzNV73mO1nt+PvFF6z130FLlUtF6zx20VF6Kqvc8U/WeZ6re80zVe56pes9ztN7zc7TRes8dtFS5VLTecwctlZei6j3PVL3nmar3PEfrPT+f+KL1njtoqXKpaL3nDloqL0XVe56pes8zVe95puo9z1S95zla77mDliqXitZ7fo42Wu+5g5bKS1H1nmeq3vNM1Xueo/Wen0980XrPHbRUuVS03nMHLZWXouo9z1S955mq9zxT9Z5nqt7zHK333EFLlUtF6z130FLlUlS955mq9zxT9Z5nqt7zHK33/Hzii9Z77qClyqWi9Z47aKm8FFXveabqPc9UveeZqvc8U/We52i95w5ao0JLlUtF6z130FJ5Kare80zVe16oes9LtN7z04mvROs9d9Ay5VJlMyq0TF6qUPWeF6re80LVe16oes8LVe95idZ77qBlyqVKtN5zB61RoaXyUlS954Wq97xQ9Z6XaL3n5xNftN5zBy1VLhWt99xBS+WlqHrPC1XveaHqPS9UveeFqve8ROs9P0cbrffcQUuVS0XrPXfQUnkpqt7zQtV7Xqh6z0u03vPziS9a77mDliqXitZ77qCl8lJUveeFqve8UPWeF6re80LVe16i9Z47aKlyqWi95+doo/WeO2ipvBRV73mh6j0vVL3nJVrv+fnEF6333EFLlUtF6z130FJ5Kare80LVe16oes8LVe95oeo9L9F6zx20VLlUtN5zBy1VLkXVe16oes8LVe95oeo9L9F6z88nvmi95w5aqlwqWu+5g5bKS1H1nheq3vNC1XteqHrPC1XveYnWe+6gNSq0VLlUtN5zBy2Vl6LqPS9UveeFqve8ROs9P5/4ovWeO2ipcimq3vNC1XteqHrPC1XveaHqPS9UvecWrff89A5kVL3nRtV7btF6z53frVGhZfJSRtV7blS950bVe27Res/P70DRes8dtFReKlrvuYOWyktR9Z4bVe+5UfWeG1XvuVH1nlu03vNztNF6zx20TM9LWbTecwctlZcK1nveR/o47z7KZ7ToXqrnB9rekoc21/447/47tE9OY4+pfntx3VX/TA268bqRGnSXdiM16JbuRmrQ/d991MAXu99IDbqzvJEadBt6IzXonvVGakzUHFEjN3xIjdzwITVyw4fUyA0fUiM3fEQNfDX/jdTIDR9SIzd8SI3c8CE1JmqOqJEbPqRGbviQGrnhQ2rkhg+pkRs+ogZ+c4UbqZEbPqRGbviQGrnhQ2pM1BxRIzd8SI3c8CE1csOH1MgNH1IjN3xEDfz2GDdSIzd8SI3c8CE1csOH1JioOaJGbviQGrnhQ2rkhg+pkRs+pEZu+Iga+A1ObqRGbviQGrnhQ2rkhg+psVDUOAUS8JuyrEUby7N6aGPZUA9tLGfpLN+F35RlKVr4TVnWoo1l6Ty0sVyahzaW8XKuyfCbsqxFS+Wl4DdlWYs2mJdyrlJUXgp+U5alaOE3ZVmLlspLwW/KshZtMC/loDUqtMG8lIM2mJdy0FJ5KfhNWdaiZfJSFX5TlrVog3mp04mvwm/KshYtUy5VN6NCy+SlKvymLGvRMnmpCr8py1q0VF4KflOWtWiZcqkKvynLWrRMuVSF35RlLVoqLwW/KctatFReCn5TlrVog3mp84kPflOWtWipcin4TVnWoqXyUvCbsqxFS+Wlgu2z4qGl8lLBdkPx0FLlUsH2LPHQUuVSwXYW8dBSealg+394aKm8VLBdOjy0TOv4arC9NDy0VLlUsB0vPLRUXirYvhQeWiovFWz3CA8tlZcKtseDh5Yqlwq2E4OHliqXCrZfgoeWyksF29XAQ0vlpYLtPeChZepEqMF2CPDQUuVSwXr8PbRUXipY276HlspLBevE99BSealgzfUeWqpcKli/vIeWKpcK1gLvoaXyUsG62j20VF4qWKO6h5aqE4Gq97xS9Z5Xqt7zGq333LlKUXkpqt7zStV7Xql6zytV73mN1nvuoDUqtFS5VLTecwctlZei6j2vVL3nlar3vEbrPT+f+KL1njtoqXKpaL3nDloqL0XVe16pes8rVe95peo9b1S95y1a77mDlimXatF6zx20RoWWyUs1qt7zRtV73qh6z1u03vPTia9F6z130DLlUi1a77mDlspLUfWeN6re80bVe96oes8bVe95i9Z7fo42Wu+5g5Yql4rWe+6gpfJSVL3njar3vFH1nrdovefnE1+03nMHLVUuFa333EFL5aWoes8bVe95o+o9b1S9542q97xF6z130FLlUtF6z8/RRus9d9BSeSmq3vNG1XveqHrPW7Te8/OJL1rvuYOWKpeK1nvuoKXyUlS9542q97xR9Z43qt7zRtV73qL1njtoqXKpaL3nDlqqXIqq97xR9Z43qt7zRtV73qL1np9PfNF6zx20VLlUtN5zBy2Vl6LqPW9UveeNqve8UfWeN6re8xat99xBa1RoqXKpaL3nDloqL0XVe96oes8bVe95i9Z7fj7xRes9d9BS5VLRes8dtFReiqr3vFH1njeq3vNG1XveqHrPW7TecwctVS4VrffcQWtUaKm8FFXveaPqPW9UvectWu/56cTXo/WeO2iZcqkerffcQcvkpfpmVGiZvFSn6j3vVL3nnar3vEfrPT9HG6333EHLlEv1aL3nDloqL0XVe96pes87Ve95j9Z7fj7xRes9d9BS5VLRes8dtFReiqr3vFP1nneq3vNO1XveqXrPe7TecwctVS4Vrff8HG203nMHLZWXouo971S9552q97xH6z0/n/ii9Z47aKlyqWi95w5aKi9F1XveqXrPO1XveafqPe9Uvec9Wu+5g5Yql4rWe+6gpcqlqHrPO1XveafqPe9Uvec9Wu/5+cQXrffcQUuVS0XrPXfQUnkpqt7zTtV73ql6zztV73mn6j3v0XrPHbRGhZYql4rWe+6gpfJSVL3nnar3vFP1nvdovefnE1+03nMHLVUuFa333EFL5aWoes87Ve95p+o971S9552q97xH6z130FLlUtF6zx20RoWWyktR9Z53qt7zTtV73qP1np9PfNF6zx20VLlUtN5zBy2Vl6LqPe9Uveedqve8U/We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z42q99yoes8tWu+5g5Yql4rWe36ONlrvuYOWyktR9Z4bVe+5UfWeW7Te8/OJL1rvuYOWKpeK1nvuoKXyUlS950bVe25UvedG1XtuVL3nFq333EFLlUtF6z130FLlUlS950bVe25UvedG1Xtu0XrPzye+aL3nDlqqXCpa77mDlspLUfWeG1XveaXqPa9UveeVqve8Rus9d9AaFVqmXKpG6z130DJ5qUrVe16pes8rVe95jdZ7fjrx1Wi95w5aplyqRus9d9BSeSmq3vNK1XteqXrPK1XveaXqPa/Res8dtFS5VLTecwetUaGl8lJUveeVqve8UvWe12i95+cTX7TecwctVS4VrffcQUvlpah6zytV73ml6j2vVL3nlar3vEbrPT9HG6333EFLlUtF6z130FJ5Kare80rVe16pes9rtN7z84kvWu+5g5Yql4rWe+6gpfJSVL3nlar3vFL1nleq3vNK1Xteo/WeO2ipcqlovefnaKP1njtoqbwUVe95peo9r1S95zVa7/n5xBet99xBS5VLRes9d9BSeSmq3vNK1XteqXrPK1XveaXqPa/Res8dtFS5VLTecwctVS5F1XteqXrPK1XveaXqPa/Res/PJ75ovecOWqpciqr3vFL1nleq3vNK1XteqXrPK1XveY3We35+B6LqPa9Uvec1Wu+587ul8lJUveeVqve8UvWeN6re8xat9/z0DtSi9Z47aJm81P6/UqFl8lKNqve8UfWeN6re80bVe96oes9btN5zBy3T3/hatN5zB61RoaXyUsF6z/tIH+fdR/mMFt1Ljfp469GrhzbX/jjv/ju0T07Dto+3rpbtMzXoxutGatBd2n3UwNev30gNuv+7kRp0s3gjNejO8kZqTNQcUYPuWW+kBt3g3kiN3PAhNXLDh9TIDR9RA1+gfyM1csOH1MgNH1IjN3xIjYmaI2rkhg+pkRs+pEZu+JAaueFDauSGj6iB3wLhRmrkhg+pkRs+pEZu+JAaEzVH1MgNH1IjN3xIjdzwITVyw4fUyA0fUQO/icWN1MgNH1IjN3xIjdzwITUmao6okRs+pEZu+JAaueFDauSGD6mRGz6iBn4bkhupkRs+pEZu+JAaueFDakzUHFEjN3xIjdzwITVyw4fUyA0fUiM3fEQN/EYyN1IjN3xIjdzwITVyw4fUmKg5okZu+JAaueFDauSGD6mRGz6kRm74iBr4rYBupCaWG3ZaLeH3DVqLNpZn9dAaFdpYztLpFIPfN2gt2lj+z0Mby9J5aGO5NAct/L5BS6/J8PsGrUVL5aXg9w1ai9aorlJUXgp+36C1aKm8FPy+QWvRMnmpDr9v0Fq0wbyUgzaYl3LQBvNSDlqjQsvkpTr8vkFr0TJ5qQ6/b9DKia/D7xu0FC38vkFr0TLlUh1+36ClVyn4fYPWojUqtFReCn7foLVoqbxUsK2APLRUuVSwDXs8tFS5VLBtdTy0VF4q2OY3HloqLxVsixpn4gu264yHliqXCrY3jIM22HYvzlUq2A4uHloqLxVsnxUPrVGhpfJSwTY48dBS5VLBtiHx0FLlUsE2C/HQUnmpYFt6eGipvFSwjTeciS/YXhoeWqpcKtiOFx5aKi8VbF8KB22wrSY8tFReKtiGEB5aKi8VbNsGDy1VLhVscwUPLVUuFWwLBA8tlZcKtlGBh5bKSwXbTsCZ+ILtEOChNSq0VLlUsGp+7ypF5aWCFeh7aKm8VLCaew8tlZcKVkbvoaXKpYJVxntoqXKpYMXuHloqLxWsft1DS+WlgpWkOxMfVe95p+o971S95z1a77lzlaLyUlS9552q97xT9Z53qt7zHq333EFLlUtF6z130FLlUlS9552q97xT9Z53qt7zHq33/Hzii9Z7fop2ROs9d9Ay5VKDqvd8UPWej82o0DJ5qUHVez6oes9HtN5zBy1TLjWi9Z47aJlyqUHVez6oes8HVe/5oOo9H9F6z88nvmi95w5aplxqROs9P0dL1Xs+qHrPB1Xv+aDqPR9UveeDqvd8ROs9d9BS5VLRes8dtFS5FFXv+aDqPR9UveeDqvd8ROs9P5/4ovWeO2ipcqlovecOWiovRdV7Pqh6zwdV7/mg6j0fVL3nI1rvuYOWKpeK1nvuoKXKpah6zwdV7/mg6j0fVL3nI1rv+fnEF6333EFrVGipcimq3vNB1Xs+qHrPB1Xv+aDqPR9UvecjWu+5g5Yql4rWe+6gpcqlqHrPB1Xv+aDqPR9UvecjWu/5+cQXrffcQUuVS0XrPXfQGtVVispLUfWeD6re80HVez6oes9HtN5zBy1VLhWt99xBS5VLUfWeD6re80HVez6oes9HtN7z84kvWu/5OdpovecOWqpciqr3fFD1ng+q3vNB1Xs+qHrPB1Xv+YjWe+6gZcqlZrTecwctUy41qXrPJ1Xv+dyMCi2Tl5rRes9PJ74ZrffcQcuUS81ovefnaKl6zydV7/mk6j2fVL3nk6r3fFL1ns9ovecOWqZcakbrPXfQUuVSVL3nk6r3fFL1nk+q3vMZrff8fOKL1nvuoKXKpaL1njtoqbwUVe/5pOo9n1S955Oq93xS9Z7PaL3nDlqqXCpa77mDliqXouo9n1S955Oq93xS9Z7PaL3n5xNftN5zB61RoaXKpah6zydV7/mk6j2fVL3nk6r3fFL1ns9ovecOWqpcKlrvuYOWKpei6j2fVL3nk6r3fFL1ns9ovefnE1+03nMHLVUuFa333EFrVFcpKi9F1Xs+qXrPJ1Xv+aTqPZ/Res8dtFS5VLTecwctVS5F1Xs+qXrPJ1Xv+aTqPZ/Res/PJ75ovefnaKP1njtoqXIpqt7zSdV7Pql6zydV7/mk6j2fVL3nM1rvuYOWKpeK1nvuoKXKpah6zydV7/mk6j2fVL3nM1rv+fnEF6333EFLlUtF6z0/Q1s3pt7zHS2Rl9rREnmpHS2Rl9rRGhVaIi+1oyXKpXa0RLnUjpYol9rREuVSdWPqPd/RUnkppt7zHS2Vl4rWe34+8UXrPXfQEuVSO1qiXGpHS+WlmHrP68bUe76jpfJSTL3nO1oqLxWt99xBS5VLRes9d9BS5VJMvec7WiovxdR7vqOl8lLRes/PJ75ovecOWqNCS5VLMfWe72ipvBRT7/mOlspLMfWe72ipvFS03nMHLVUuFa333EFLlUsx9Z7vaKm8FFPv+Y6WyktF6z0/n/ii9Z47aKlyqWi95w5ao7pKUXkppt7zHS2Vl2LqPd/RUnmpaL3nDlqqXCpa77mDliqXYuo939FSeSmm3vMdLZWXitZ7fj7xRes9P0cbrffcQUuVSzH1nu9oqbwUU+/5jpbKSzH1nu9oqbxUtN5zBy1VLhWt99xBS5VLMfWe72ipvBRT7/mOlspLRes9P5/4ovWeO2ipcqlovefnaJl6z3e0VF6Kqfd8R0vlpZh6z3e0VF4qWu+5g5Yql4rWe+6gZcqlElXveaLqPU9UveeJqvc8bUY08aVovecOWqZcKkXrPXfQMnmpRNV7nqh6zxNV73mi6j1PVL3nKVrvuYOWKZdK0XrPHbRMuVSi6j1PVL3niar3PFH1nqdovefnE1+03nMHrVGhpcqlqHrPE1XveaLqPU9UveeJqvc8UfWep2i95w5aqlwqWu+5g5Yql6LqPU9UveeJqvc8UfWep2i95+cTX7TecwctVS4VrffcQWtUVykqL0XVe56oes8TVe95ouo9T9F6zx20VLlUtN5zBy1VLkXVe56oes8TVe95ouo9T9F6z88nvmi95+doo/WeO2ipcimq3vNE1XueqHrPE1XveaLqPU9UvecpWu+5g5Yql4rWe+6gpcqlqHrPE1XveaLqPU9UvecpWu/5+cQXrffcQUuVS0XrPT9HS9V7nqh6zxNV73mi6j1PVL3niar3PEXrPXfQUuVS0XrPHbRUuRRV73mi6j1PVL3niar3PEXrPT+f+KL1njtoqXIpqt7zRNV7nqh6zzNV73mm6j3PVL3nOVrv+ekdKG9GhZbJS+VovefO75bJS2Wq3vNM1XueqXrPM1XveY7We35+B4rWe+6gNSq0VF6Kqvc8U/WeZ6re80zVe56pes8zVe95jtZ77qBl+htfjtZ77qBlel4qU/We52C9532kj/Puo3xGi+6lZuofbz1t89Dm2h/n3X+H9slp2PZx1tWyfaYG3XjdRw18o/qN1KBbuhupQfd/N1KDbhZvpMZEzRE16Db0RmrQPeuN1KAb3BupkRs+pEZu+Iga+E78G6mRGz6kRm74kBq54UNqTNQcUSM3fEiN3PAhNXLDh9TIDR9SIzd8RA38rgY3UiM3fEiN3PAhNXLDh9SYqDmiRm74kBq54UNq5IYPqZEbPqRGbviIGvh9KW6kRm74kBq54UNq5IYPqTFRc0SN3PAhNXLDh9TIDR9SIzd8SI3c8BE18DuL3EiN3PAhNXLDh9TIDR9SY6LmiBq54UNq5IYPqYnlhp0CCfhNWdaijeVZHbTwm7KsRRvLWTrLd+E3ZVmLNpb/89AaFdpYLs1DG8t4eddkKi8FvynLWrRUXgp+U5alVyn4TVnWoqXyUvCbsqxFa1RoqbwU/KYsa9EG81IO2mBeykEbzEudoi3wm7KsRcvkpQr8pixr0TJ5qbIZ0cRX4DdlWYuWKZcq8JuyrEXL5KUK/KYsS9HCb8qyFi2Vl4LflGUtWiovBb8py1q0TLlUgd+UZS1aplyqwG/KshYtlZeC35RlLVoqLwW/KcvSiQ9+U5a1aI0KLVUuBb8py9qrFJWXCrYpi4eWyksF2zrFQ0vlpYJtcOKhpcqlgm1D4qGlyqWCbRbioaXyUsG29PDQUnmpYBtvOBNfsL00PLRUuVSwHS88tEZ1laLyUsG2mvDQUnmpYBtCeGipvFSwbRs8tFS5VLDNFTy0VLlUsC0QPLRUXirYRgUeWiovFWw7AWfiC7ZDgIM2WOm/h5YqlwpWze9cpYK17XtojQotlZcKVnPvoaXyUsHK6D20VLlUsMp4Dy1VLhWs2N1DS+WlgtWve2ipvFSwknRn4qPqPS9UveeFqve8ROs9P79KUfWeF6re80LVe16oes8LVe95idZ77qClyqWi9Z47aKlyKare80LVe16oes8LVe95idZ7fj7xRes9d9BS5VLRes8dtFReiqr33Kh6z42q99yoes+NqvfcNqNCy5RLWbTecwctUy5lVL3nRtV7blS950bVe27Res9PJz6L1nvuoDUqtEy5lFH1nhtV77lR9Z4bVe+5UfWeG1XvuUXrPXfQUuVS0XrPHbRUuRRV77lR9Z4bVe+5UfWeW7Te8/OJL1rvuYOWKpeK1nvuoDWqqxSVl6LqPTeq3nOj6j03qt5zi9Z77qClyqWi9Z47aKlyKarec6PqPTeq3nOj6j23aL3n5xNftN7zc7TRes8dtFS5FFXvuVH1nhtV77lR9Z4bVe+5UfWeW7TecwctVS4VrffcQUuVS1H1nhtV77lR9Z4bVe+5Res9P5/4ovWeO2ipcqlovefnaKl6z42q99yoes+NqvfcqHrPjar33KL1njtoqXKpaL3nDlqqXIqq99yoes+NqvfcqHrPLVrv+fnEF6333EFLlUtF6z130FJ5Karec6PqPTeq3nOj6j03qt5zi9Z77qClyqWi9Z47aKlyKarec6PqPa9UveeVqve8Rus9P534arTecwetUaFlyqUqVe95peo9r1S955Wq97xS9Z5Xqt7zGq333EHLlEvVaL3nDlqmXKpS9Z5Xqt7zStV7Xql6z2u03vPziS9a77mDliqXitZ77qA1qqsUlZei6j2vVL3nlar3vFL1ntdovecOWqpcKlrvuYOWKpei6j2vVL3nlar3vFL1ntdovefnE1+03vNztNF6zx20VLkUVe95peo9r1S955Wq97xS9Z5Xqt7zGq333EFLlUtF6z130FLlUlS955Wq97xS9Z5Xqt7zGq33/Hzii9Z77qClyqWi9Z6fo6XqPa9UveeVqve8UvWeV6re80rVe16j9Z47aKlyqWi95w5aqlyKqve8UvWeV6re80rVe16j9Z6fT3zRes8dtFS5VLTecwctlZei6j2vVL3nlar3vFL1nleq3vMarffcQUuVS0XrPXfQUuVSVL3nlar3vFL1nleq3vMarff8fOKL1nvuoDUqtFS5FFXveaXqPa9UveeVqve8UfWeN6re8xat99xBy5RL7XdjKrRMuVSj6j1vVL3njar3vFH1nrdoveenE1+L1nvuoGXKpVq03nMHrVFdpai8FFXveaPqPW9UveeNqve8Res9d9BS5VLRes8dtFS5FFXveaPqPW9UveeNqve8Res9P5/4ovWen6ON1nvuoKXKpah6zxtV73mj6j1vVL3njar3vFH1nrdovecOWqpcKlrvuYOWKpei6j1vVL3njar3vFH1nrdovefnE1+03nMHLVUuFa33/BwtVe95o+o9b1S9542q97xR9Z43qt7zFq333EFLlUtF6z130FLlUlS9542q97xR9Z43qt7zFq33/Hzii9Z77qClyqWi9Z47aKm8FFXveaPqPW9UveeNqve8UfWet2i95w5aqlwqWu+5g5Yql6LqPW9UveeNqve8UfWet2i95+cTX7TecwetUaGlyqWoes8bVe95o+o9b1S9542q97xR9Z63aL3nDlqqXCpa77mDliqXouo9b1S9542q97xR9Z73aL3npxNfj9Z77qBlyqV6tN5zB61RXaWYvFSn6j3vVL3nnar3vFP1nvdovecOWqZcqkfrPXfQMuVSnar3vFP1nneq3vNO1Xveo/Wen0980XrPz9FG6z130FLlUlS9552q97xT9Z53qt7zTtV73ql6z3u03nMHLVUuFa333EFLlUtR9Z53qt7zTtV73ql6z3u03vPziS9a77mDliqXitZ7fo6Wqve8U/Wed6re807Ve96pes87Ve95j9Z77qClyqWi9Z47aKlyKare807Ve96pes87Ve95j9Z7fj7xRes9d9BS5VLRes8dtFReiqr3vFP1nneq3vNO1XveqXrPe7TecwctVS4VrffcQUuVS1H1nneq3vNO1XveqXrPe7Te8/OJL1rvuYPWqNBS5VJUveedqve8U/Wed6re807Ve96pes97tN5zBy1VLhWt99xBS5VLUfWed6re807Ve96pes97tN7z84kvWu+5g5Yql6LqPe9Uveedqve8U/Wed6re807V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reeF2HpeiK0PotTzaLhdOObCn/KOnjx1DkpXDipXDrIrB9UrB10Irw+e9lsZNT5/3G/pJ7w8GE8vD8bTy4Px9PJgPL02GN//0X55aS4Xquhz6VcOGlcOulBFn227clC6clC+clC5cpBdOaheOejKN8KufCPsyjfCrnwj6pVvRL3yjahXvhH1yjeiXvlG1CvfiHrlG1EvbE6Q67hy0Lxw0PMl095B6cpB2T3o04YLuR0QcbbhQn7+pM/5jgb5+aM+3kHlykF24aCjMvWzbRDylYrzPC9s7ZCPisfPdjTIR8Xj5weVKwfZlYMubE6QZ7tyUL9y0Lhy0Pz6QWXbrhyUrhx0oYq+bOXKQXbloHrloHbloH7loHHloAubE5S0XTkoXTnoyjciXflGpCvfiHTlG5GufCPSl78R+z/632ab53t39h+u5aeNSvfL4D8e/bHy/JD89UPK1w+xrx9Sv37Ic6P3qGers306pH/9kPH1Q+aXD3m+hKblj5G4/byF6S83wS+89h+PVtuse/v82rcvr317e+3b19e+fXvt2/fXvv147dvPl769vfZXa6/91dprf7X22l+tvfZXa6/91dprf7X22l+tvfZXa6/91dbX/mrrn//mnPX11D/P/dnS8Tpf+vZte+3bp9e+fXuptO3P/2rPmobaeO3bz5e+fd9e+/Z//ptzVqDT82vfvrz27e21b19f+/bttW/fX/v2r73e99de78drr/fjtdf7kV/79uW1b2+vffv62rdvr337/tq3f+2vdrzyV7v/a/zyyqPakO3xHGT6ycPMdDxwnx9zVBtyekz66jH7P+YvL00HW7Z/eIP+05/Nfnle/h//uv/z//2n//3P//Rf/uW///t+yC//6//51//6H//8b//62z//4//7X7/+L/uL/38=","brillig_names":["build_msg_block","attach_len_to_msg_block","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","build_msg_block","get_l1_to_l2_membership_witness","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAEceAgAAAh4CAAADMDgAAgADAAQkAgEBAiECABAABDkBAAAkAgAAAioIAQMkAgQCBAAQAQQBJAMEAQMAKAMCBCoMBAUqDgIFKg0DBAAoBAIEKg4EAyoIAQQAAAECASoOAwQkAgACAiQCBAEDJAIEAAUqDAUBIAAjCjgBBQYhAgAxAAYgACYqDQQBACgBAgMAOAMFBCoNBAIcDAACASkCAAAAAAAAAAAAAAAAAP//////////////////////////AAMOOAEDBCECAC8ABDkBAAAqDAIBIyoNBAYcDAABBwA4AgcILAwACAAHJAIEAQkMOAEJCiECADkACjkBAAArBAAGgAMlAAQAAoAEIgBMKwiABQAIACgIAgkAOAkBCioOBwoAOAEDBg44AQYHIQIARAAHOQEAACoOCAQqDAYBIAAjJQAEeACABA0AAACABIADIQAAS4ADOQEAACMrAYADgAYLAIAGAAKAByEAAFCAByAAUisAgAOABSAAYCsAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQAAXoAKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIABVJQEEAAGABSAAYCMrABjKGMo=","debug_symbols":"7ZrLbvIwEIXfxWsWHs/FNq/y61cVWqgiRaECWqlCvHuTliRQR8miN4/EBiVwiL+c2DqeUY7mYb16frwr6812b5b/jqba3heHcls3Z8fTwqx2ZVWVj3eXXxvbfoB91++firo93R+K3cEsQaJdmHX90Bx6a5srbMpqbZbEeFok6sh8FkfPvRYCjGgxSifG6OlCzSNqoQBntVD0V+r/CwPwdXiw6Dq1Zfer+O4bvI/Q08Oc+eA4dmq8Uo/Re4/hrPa+vd4nevxeer6mb0egHx+Bf3wEGR/BUfcn4TA3Rb3FnscNaiA3omahbkKzCM48ZMbgOzWGkDxkrxs/6MaPqvGd1Y0PuvGdbnzUjU+68Vk3vu7UdbpT1+lOXac7dTH3pUvQkTSHnODnPnkIbY+PkuD/weRx/XQQH+aKuqGmo6EgRbAtPFnN8KAZ3mUOD9zDhyv4VBv6gjiCzGhJOgiKw8pz8u4J3jxJPKGbJ4knfPMk8URuniSe5L6vm94Yce7dlMF7Jp80uzn3bgqxm8LPvZtCGAf8ueUXbc8dLac3m3vvZXoPzqQbP/sCbho/997LDH7uvZcZfN3lM2ef0ZP4kn1GT+Nnn9HT+Pln9CS+7tQV3akrulNXdKeu6E5d0Zy6p+b0pdiVxapan98X2zzX9xevjx1enz5+acRv","brillig_names":["get_portal_address_public"],"assert_messages":{"56":"Array index out of bounds","74":"Stack too deep","15":"Not initialized","46":"call to assert_max_bit_size","67":"attempt to add with overflow"}},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","pack_returns_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"get_token","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAEYeAgAAAh4CAAADMDgAAgADAAQkAgEBAiECABAABDkBAAAeAgoAAiQCAAEDCjgCAwQhAgAVAAQ5AQAAKggBAiQCBAIEABABBAEkAwQBAgAoAgIEKgwEBSQCAAAGKg4GBSoNAgQAKAQCBCoOBAIqCAEEAAABAgEqDgIEJAIEAAIkAgQBBSoMAgEgACcKOAECBiECADAABiAAKioNBAEAKAECBAA4BAIFKg0FAyoMAwEjKg0EBhwMAAEHADgDBwgsDAAIAAckAgQBCQw4AQkKIQIAOAAKOQEAACsEAAaAAyUABAACgAQiAEsrCIAFAAgAKAgCCQA4CQEKKg4HCgA4AQUGDjgBBgchAgBDAAc5AQAAKg4IBCoMBgEgACclAAR4AIAEDQAAAIAEgAMhAABKgAM5AQAAIysBgAOABgsAgAYAAoAHIQAAT4AHIABRKwCAA4AFIABfKwAAAYAFAQAAAYAEAAElAAQAAIAJDQCACYAEgAoXAIAKgAohAABdgAoBAIADgAmACysBgAuACAEAgAWACYALKwKACIALAQCACQACgAkgAFQlAQQAAYAFIABfIysAGMoYyg==","debug_symbols":"1ZpbbsMgEEX3wnc+gHkA2UpVVU6bVJYsp0rSSlWUvddug/OwZdQ8WuYnMvEFjhngjpG36mU+e399KuvFcq2mD1tVLZ+LTbmsm9J2N1GzVVlV5evT8d9Ktz9Gf+vXb0XdFtebYrVRU8NBT9S8fmkundZNC4uymqspEuwmPXUg2ouDo05rvBnQQuAohuDwSE0DakZv9mrG4E7UjxNlzPXwRoONak32T/HtDcY+mI7epAbfWApRDSfqIXrnwO/VzrXtndHDbenplL7tAe/eA929B76+B7IYw0aWk2FDHdUOwfbC5n4L1Fbyl1QKF1Sy+pJKg/sAWxsHgi265D7gMXZhdDgMGwytJGKMuwYxQyIkBN5FNXh/HhJrZeODbHyUjU+y8Vk2vpON72XjB9H4oGXjy3ZdkO26INt1QbbrQu47D5rYdnNJ5/iY+9xH0B0+cA//H+a+7aYDO5/AN+C6d0Lwh9cVMPYbH2Xjk2z83HOexNLNfufhLlboemdelHvOg2TH8HPPeRDCAT+1UoK2kSRo6j+sbJeg3DOkBH7uGVICP/dziQR+7ucSCfzczyUS+Nl79Dh+9h49is/Ze/Q4fv4ePYov23VZtuuybNdl2a7Lsl2XJbvuril+FKuymFXz/Wcji/f6+egrks3n28+dRvwF","brillig_names":["get_token"],"assert_messages":{"66":"attempt to add with overflow","55":"Array index out of bounds","20":"Function get_token can only be called statically","15":"Not initialized","73":"Stack too deep"}},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAo4AIBFAAAiAKgeAgAABB4CAAAFMDgABAAFAAYkAgEBBCECABEABjkBAAAeAgEABR4CAAAGCjgFBgchAgAWAAc5AQAAJAIAAAUqCAEGJAIEAgcAEAEHASQDBAEGACgGAgcqDAcIKg4FCCoNBgcAKAcCByoOBwYqCAEHAAABAgEqDgYHJAIAAQUkAgQABiQCBAEIKgwGAyAAKQo4AwYJIQIAkgAJIAAsKg0HBQAoBQIJADgJBgoqDQoHKggBBQAAAQIBKg4IBSoIAQkAAAECASQCBAELJAIEAg0AOAsNDCoIAQoAEAEMASQDBAEKACgKAgwqDgsMJAIEAgwAOAoMCyoMCwwmAgAaYtniAA0qDg0MKg4KCSQCBAIKKgwGAyAARgw4AwoGIQIAZAAGIABJKg0FASoNCQIqCAEDJAIEAwQAEAEEASQDBAEDACgDAgQqDAQFKQIAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAABioOBgUAKAUCBSoOBgUmAgDVRBsNAAQAKAMCBQAoAgIKKg0KCQAoCgIIKggBCgAAAQIBJAMEAQoAKAoCDDY/lQAFAAcACAAJAAwAAAALAAQkAgIBAQo4CwECIQIAYwACOQEAACMMOAMKBiECAGcABjkBAAAkAgQCCyQCBAINADgLDQwqCAEGABABDAEkAwQBBgAoBgIMKg4LDCQCBAIMADgGDAsqDAsMKg4BDAAoDAIMKg4CDAAoBgIMKg0MDAw4AwwNIQIAegANOQEAACQCBAINADgGDQwAOAwDDSoNDQsqDQUGKg0JDAAoBgINKwQADIADJQAEAAGABCIArSsIgAUADisIgAYADyoOCw8qDQ4GACgGAgYqDgYOKg4NBSoODgkAOAMIBg44AwYLIQIAkAALOQEAACoMBgMgAEYqDQcJHAwAAwoAOAUKCywMAAsACiQCBAEMDDgDDA0hAgCaAA05AQAAKwQACYADJQAEAAKABCIAxysIgAUACwAoCwIMADgMAw0qDgoNADgDCAkOOAMJCiECAKUACjkBAAAqDgsHKgwJAyAAKSUABHgAgAQNAAAAgASAAyEAAKyAAzkBAAAjAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAAxYANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIAC8AQCACoAHgAYjKwGAA4AGCwCABgACgAchAADLgAcgAM0rAIADgAUgANsrAAABgAUBAAABgAQAASUABAAAgAkNAIAJgASAChcAgAqACiEAANmACgEAgAOACYALKwGAC4AIAQCABYAJgAsrAoAIgAsBAIAJAAKACSAA0CUBBAABgAUgANsjKwAYyhjK","debug_symbols":"1Z3bbuIwEIbfJddceA4e232V1WpFW1ohIVq1dKVV1XffwJJACWtre9r5bypSJsmXxM5H7GF47q4Xl0+3P5brm7vH7uLbc7e6u5pvlnfrfun5ZdZdPixXq+Xtj+N/d2H7h2gX/3g/X28XHzfzh013QVbCrFusr/uXKYR+CzfL1aK70Cgvs0l0iXEfXFIcYynTmVgpNgRLSXoUHc9Em2baR5uW9Cr6+6wjfj88BeEhOkT+Unz5gHNfaKSn1sknjmWIllfR5+hTkryPTmm7vRN6/Vj6+Jp+u4f46XuwT99Dev8eNIwXQoNaq9FFHaItmkwuW34/0Mf2gvKvQP1KHN6yEr1lpbP3GLOkwzFZ4eY9Jg/RRKEczoCc66XRdLgjRTu5gGeiJachWnI+Pbss2PiKjR+x8Q0bP2HjZ2z8Ao0vARufsPGxrSvY1hVs6wq2ddV711Uatt2/jBN8741HJYz4YhP8/9B4eGwOlnIDnySNz5uSD48rQrzDN2z8hI3/l49sNuIn0QZ+//wex+f3dNSayzl8tnH4ii2F1pBOHsZ/cjgcKrPu4AswfAzI8IQMz8jwggyvyPARGd6Q4RMyPLJhI7JhDdmwhmxYQzasIRvWkA1ryIY1ZMMm57dKMhrzAIwPJLYbAUnOeyyZ2khv4ZTeeZdt0H99n+3nvAf6LKlBn5WH8Y+saZITkgwbP2HjZ2z8Ao2fAzY+YeMzNr5g4ys2PrZ1M7Z1M7Z1M7Z1M7Z1C7Z1C7Z1C7Z1C7Z1C7Z1y9db9/BNFS42yUQv5g0oeQPKzoAoQA+1UXA+L9HCdz4z0cJ3P9JZx1dsfOfzEy185zMULXznWQAtfOd5AC1855kADXzCti5hW5ewrUvY1iVs6xK2dQnbuoRtXcK2LmFbl7Gty9jWZWzrMrZ1Gdu6jG1dxrYuY1uX3Vu3ltJG7N66VXxxb906vnvr1vHdW7eOD51LS+LeunV899at47u3bh3fvXXr+NjWFWzrKrZ1Fdu6im1dxbauei+7Vi8AQ+q97praWPJD0zSnRL0XXtPIVX7vlddUyoG/VXKlBB5ISojTo43eC7XV6w1RdF/uqcHvvVRbi997rbYWv4Lze6/W1uJ3b+sGv3tbN/jd27rB79/WVX4D96+B+9fA/Wvg/jVw/xqyf1/6xZ/zh+X8crXY/9bJzdP66uinTza/7v+80wf/Bg==","brillig_names":["_call_mint_on_token"],"assert_messages":{"16":"Not initialized","164":"attempt to add with overflow","171":"Stack too deep","21":"Function _call_mint_on_token can only be called internally","98":"Nested call failed!","143":"attempt to add with overflow","121":"Array index out of bounds","102":"Index out of bounds","153":"Array index out of bounds"}},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARwABJAAEAwAkAgQEBSQCBAAGHxgABgAFgEMrCIBDAAErCIBEAAIrCIBFAAMrCIBGAAQiAAw4AIBHAAAiA9QqCAEGAAABAgEkAgEAByoOBwYqCAEHAAABAgEkAgAACCoOCAcqCAEJAAABAgEkAgACCioOCgkeAgAACx4CAAAMMDgACwAMAA0kAgEBCyECAB8ADTkBAAAqCAELAAABAgEkAgQODSoIAA4qDAEPABAADQAiA9kqBAAAKgwPDCQCBA4NKggADioMAg8AEAANACID2SoEAAAqDA8BJAIEDw4qCAAPKgwDEAAQAA4AIgPZKgQAACoMEA0kAgIyAyQCAuwOJAICaQ8kAgIAECoIAREkAgRlEgAQARIBJAMEAREAKBECEioMEhMqDg8TACgTAhMqDgMTACgTAhMkAgKNFCoOFBMAKBMCEyoODhMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMCEyoOEBMAKBMC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","debug_symbols":"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","brillig_names":["exit_to_l1_public"],"assert_messages":{"1152":"attempt to add with overflow","957":"attempt to add with overflow","762":"attempt to subtract with overflow","1140":"Array index out of bounds","939":"Array index out of bounds","921":"Array index out of bounds","848":"attempt to multiply with overflow","903":"attempt to add with overflow","1025":"attempt to add with overflow","702":"attempt to subtract with overflow","1080":"attempt to add with overflow","946":"Array index out of bounds","1062":"Array index out of bounds","1190":"attempt to add with overflow","800":"Array index out of bounds","983":"Stack too deep","1172":"attempt to subtract with overflow","977":"attempt to add with overflow","910":"attempt to add with overflow","1038":"attempt to subtract with overflow","1160":"attempt to add with overflow","837":"attempt to add with overflow","770":"Array index out of bounds","1288":"attempt to add with overflow","758":"attempt to multiply with overflow","563":"call to assert_max_bit_size","819":"attempt to add with overflow","1069":"Array index out of bounds","807":"Array index out of bounds","935":"attempt to add with overflow","728":"Array index out of bounds","789":"attempt to add with overflow","777":"Array index out of bounds","826":"Array index out of bounds","686":"Array index out of bounds","747":"attempt to add with overflow","1058":"attempt to add with overflow","796":"attempt to add with overflow","1180":"Array index out of bounds","1235":"attempt to add with overflow","1168":"attempt to multiply with overflow","717":"attempt to add with overflow","961":"Array index out of bounds","766":"attempt to subtract with overflow","370":"Array index out of bounds","1266":"Array index out of bounds","1132":"attempt to subtract with overflow","724":"attempt to subtract with overflow","968":"Array index out of bounds","1224":"Array index out of bounds","706":"Array index out of bounds","383":"attempt to add with overflow","1261":"Index out of bounds","682":"attempt to subtract with overflow","676":"Nested call failed!","30":"Not initialized","1176":"attempt to add with overflow","914":"Array index out of bounds"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiC5MmAgBBjN11AAIKOAECAyQCAQACKggBBAAAAQIBJAMEAQQAKAQCBSQCBAAFJAIEAQYkAgAAByQCAAIIJAIAAQkkAgQECiQCAAQLJAIEAwwkAgAGDSQCAQEOJAIEAg8qCAEQJAIEAhEAEAERASQDBAEQACgQAhEqDBESKg4HEiECACUAAyACHCoIASEkAgQDIgAQASIBJAMEASEAKCECIh88AAYADwAiKg0hIgAoIgIiKg4iISoIASIAAAECASoOISIqCAEjAAABAgEqDgUjKg0hJAAoJAIkKg4kISQCBCUkKggAJSoMIiYqDCMnKgwQKAAQACQAIguYKgQAACoMJiEkAgQmJSoIACYqDAsnKgwhKAAQACUAIgvTKgQAACoMJyQkAgQmJSoIACYqDCInKgwjKCoMECkAEAAlACILmCoEAAAqDCchJAIEJSMqCAAlKgwNJioMIScAEAAjACIL0yoEAAAqDCYiKggBIQAAAQIBKg4CISoIASMAAAECASoOByMqCAElAAABAgEkAgCLJioOJiUeAgAAJioIASckAgQSKAAQASgBJAMEAScAKCcCKDMOAAAAJgAAACgqDScmACgmAiYqDiYnKggBJgAAAQIBKggBKAAAAQIBKg0nKQAoKQIpKg4pJwAoJwIqADgqBSsqDSspKg4nJioOBigKOCkHJyECASEAJyAAfCoIASkAAAECASoIASokAgQRKwAQASsBJAMEASoAKCoCKyQCBBAsADgsKywqDCstDDgtLC4WDC4uIQIAjAAuKg4HLQAoLQItIACGKg4qKSoNKisAKCsCKyoOKyokAgQQKyoMBScgAJMMOCcrLCECAQEALCAAlioNJicqDSgsADgsKy0OOCwtLiECAJwALjkBAAAqDicmKg4tKCoNKSYqDScoAigoAigqDignKg0qKAIoKAIoKg4oKgAoJgIpADgpBSoqDSooACgmAioAOCoGKyoNKykAKCYCKwA4Kw8sKg0sKgAoJgIsADgsDC0qDS0rACgmAi0AOC0KLioNLiwkAgQFLQAoJgIvADgvLTAqDTAuJAIEBi0AKCYCMAA4MC0xKg0xLyQCBActACgmAjEAODEtMioNMjAkAgQILQAoJgIyADgyLTMq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Kgw5MyoNMC8AKC8CLyoOLzAqCAEvAAABAgEqDjAvKg0xMAAoMAIwKg4wMSoIATAAAAECASoOMTAqCAExAAABAgEqDjIxKggBMgAAAQIBKg4zMiQCAAUzJAIENTQqCAA1KgwvNioMMDcqDDE4KgwyOSoMMzoAEAA0ACIMMioEAAAqDAURIATIDDgRDDMhAgmoADMgBMskAgQzESoIADMqDC80KgwwNSoMMTYqDDI3ABAAEQAiDIEqBAAAKgw0DB4CAAARMDgADAARACsKOCsCESECBNoAETkBAAAyOAAuACwAESECBN0AETkBAAAxAgAMJAIELhEqCAAuKgwoLyoMKTAqDC0xKgwJMgAQABEAIg9nKgQAACoMLwwkAgQBKCQCBAIrADgoKykqCAERABABKQEkAwQBEQAoEQIpKg4oKSQCBAIpADgRKSgqDCgpKg4qKSQCBCwrKggALCoMBS0qDCUuKgwGLyoMETAAEAArACIPeyoEAAAqDC0oKgwuKQAoKAIRKwQAKYADJQAEAAGABCIPrysIgAUAKisIgAYAKyoOJysmAgDqDQqPACckAgQrKSoIACsqDCcsABAAKQAiDA4qBAAAKgwsKBwMACgnJAIEASkkAgQCLAA4KSwrKggBKAAQASsBJAMEASgAKCgCKyoOKSskAgQCKwA4KCspKgwpKyoOJyskAgQtLCoIAC0qDAYuKgwoLyoMETAqDCoxABAALAAiD3sqBAAAKgwuKSoMLysqCAERJAIEAycAEAEnASQDBAERACgRAicqDCcoKg4jKAAoKAIoKg4jKAAoEQInACgrAiwqDSwqACgsAigqCAEsAAABAgEkAwQBLAAoLAIuNj+VACcADAAoACoALgAAAC0AEwo4LSYMIQIFOwAMOQEAACQCBC0MKggALSoMBC4AEAAMACIM5ioEAAAgBUImAgCkKZxeAAwKOAEMESECBUYAESAHeioIAREkAgQFJwAQAScBJAMEAREAKBECJx88AAYACgAnKg0RJwAoJwInKg4nESoIAScAAAECASoOEScqCAEoAAABAgEqDgUoKg0RKQAoKQIpKg4pESQCBCopKggAKioMJysqDCgsKgwQLQAQACkAIg0PKgQAACoMKxEkAgQrKioIACsqDA0sKgwRLQAQACoAIgvTKgQAACoMLCkkAgQrKioIACsqDCcsKgwoLSoMFy4AEAAqACINSioEAAAqDCwRJAIELCsqCAAsKgwnLSoMKC4qDBAvABAAKwAiDQ8qBAAAKgwtKiQCBC0sKggALSoMDS4qDCovABAALAAiC9MqBAAAKgwuKyQCBCwqKggALCoMJy0qDCguKgwXLwAQACoAIg1KKgQAACoMLQ0qCAEnAAABAgEqDgInKggBKAAAAQIBKg4HKCoIASoAAAECASQCAFAsKg4sKiQCBC0sKggALSoMJy4qDCgvKgwqMAAQACwAIgzqKgQAACoIASwAAAECASQCBC8uKggALyoMKTAAEAAuACINZSoEAAAqDDAtJAIELy4qCAAvKgwRMAAQAC4AIg1lKgQAACoMMCkkAgQwLyoIADAqDCsxABAALwAiDWUqBAAAKgwxLiQCAmkrKggBLyQCBGUwABABMAEkAwQBLwAoLwIwKgwwMSoOKzEAKDECMSQCAjIyKg4yMQAoMQIxJAICjTMqDjMxACgxAjEkAgLsNCoONDEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEAKDECMSoOITEqDi8sKgwFDCAGiQw4DBgrIQIJXgArIAaMKg0sCioNHwwAKAwCDCoODB8qCAEMAAABAgEqDh8MKg0WFAAoFAIUKg4UFioIARQAAAECASoOFhQqCAESAAABAgEqDgUSJAIEZBUqDAUDIAafCjgDBRYhAgkdABYgBqIkAgQrGCoIACsqDAosKgwVLSoMIi4AEAAYACIPySoEAAAqDCwDKgwtFioNAwoAKAoCCioOCgMqDgMMKg4WEgo4FiIKIQIGtAAKIAa2Kg4FEiAGtioNAwoAKAoCCioOCgMqDRIKJAIEQBgMOAoYGSECBr4AGTkBAAAAKAMCGAA4GAoZKg4kGSoMAxYqDhYMKg0WAwAoAwIDKg4DFioNEgMAOAMGCg44AwoYIQIGywAYOQEAACoOChIMOCAKAyECBs8AAyAG5SQCBCsKKggAKyoMFiwAEAAKACINyCoEAAAqDCwDKg0UCioIARgkAgQJGQAQARkBJAMEARgAKAMCGQAoCgIaACgYAhs9PwAbABoAGSoNGAMAKAMCAyoOAxgqDhgUKg4FEiAG5SoNEgMkAgQrEioIACsqDBYsKgwDLSoMFS4AEAASACIONSoEAAAqDCwKKg0KAwAoAwIDKg4DCioOCgwqDRQDJAIEKxIqCAArKgwKLCoMAy0AEAASACIOlioEAAAqDCwMJAIEKwoqCAArKgwMLAAQAAoAIg8XKgQAACoMLAMkAgQrDCoIACsqDCcsKgwoLSoM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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"3584":"Array index out of bounds","1725":"Array index out of bounds","3005":"Array index out of bounds","2871":"Array index out of bounds","2603":"Array index out of bounds","2469":"attempt to add with overflow","2402":"attempt to add with overflow","2658":"Array index out of bounds","1244":"Tried to consume nonexistent L1-to-L2 message","854":"Array index out of bounds","3469":"attempt to add with overflow","263":"attempt to add with overflow","2311":"Array index out of bounds","3012":"Array index out of bounds","3524":"attempt to add with overflow","2610":"Array index out of bounds","3634":"attempt to add with overflow","4012":"attempt to add with overflow","2665":"Array index out of bounds","3689":"attempt to add with overflow","4067":"attempt to add with overflow","2720":"attempt to add with overflow","4122":"attempt to add with overflow","3287":"Array index out of bounds","3799":"Array index out of bounds","2318":"Array index out of bounds","2629":"Array index out of bounds","2885":"attempt to add with overflow","3909":"Array index out of bounds","3818":"attempt to add with overflow","3940":"attempt to add with overflow","155":"attempt to add with overflow","2636":"Array index out of bounds","3660":"attempt to multiply with overflow","3837":"attempt to subtract with overflow","2746":"Array index out of bounds","3380":"Array index out of bounds","3502":"attempt to add with overflow","3624":"Array index out of bounds","3612":"attempt to multiply with overflow","1241":"L1-to-L2 message is already nullified","2966":"Stack too deep","3990":"Array index out of bounds","4179":"Array index out of bounds","2698":"attempt to add with overflow","2119":"Nested call failed!","4100":"attempt to add with overflow","449":"Initializer address is not the contract deployer","2753":"Array index out of bounds","3387":"Array index out of bounds","3576":"attempt to subtract with overflow","3253":"attempt to add with overflow","1906":"Nested call failed!","2406":"Array index out of bounds","2449":"attempt to add with overflow","3985":"Index out of bounds","267":"Array index out of bounds","2937":"attempt to add with overflow","2224":"Token address is not the same as seen in storage","2413":"Array index out of bounds","3693":"Array index out of bounds","2535":"attempt to subtract with overflow","2724":"Array index out of bounds","2523":"attempt to add with overflow","1109":"Array index out of bounds","274":"Array index out of bounds","3023":"attempt to add with overflow","3925":"attempt to subtract with overflow","2889":"Array index out of bounds","3712":"attempt to add with overflow","2621":"attempt to add with overflow","2042":"Function _call_mint_on_token can only be called internally","2676":"attempt to add with overflow","3700":"Array index out of bounds","2798":"attempt to multiply with overflow","2731":"Array index out of bounds","2920":"Array index out of bounds","2853":"attempt to add with overflow","2987":"attempt to add with overflow","3298":"attempt to add with overflow","2329":"attempt to add with overflow","1939":"Function get_token can only be called statically","2896":"Array index out of bounds","1738":"attempt to add with overflow","3719":"Array index out of bounds","3841":"Array index out of bounds","2427":"attempt to add with overflow","3829":"attempt to multiply with overflow","3506":"Array index out of bounds","2860":"attempt to add with overflow","489":"SharedImmutable already initialized","867":"attempt to add with overflow","2592":"attempt to add with overflow","3616":"attempt to subtract with overflow","3482":"attempt to subtract with overflow","2647":"attempt to add with overflow","3604":"attempt to add with overflow","2513":"attempt to multiply with overflow","2702":"Array index out of bounds","3860":"attempt to add with overflow","3336":"call to assert_max_bit_size","3848":"Array index out of bounds","4104":"Array index out of bounds","4195":"Array index out of bounds","3001":"attempt to add with overflow","3513":"Array index out of bounds","3312":"Not initialized","3245":"Array index out of bounds","4080":"attempt to subtract with overflow","2599":"attempt to add with overflow","2788":"attempt to add with overflow","2654":"attempt to add with overflow","2453":"Array index out of bounds","2709":"Array index out of bounds","4111":"Array index out of bounds","3142":"Array index out of bounds","2307":"attempt to add with overflow","3398":"attempt to add with overflow","1338":"Nested call failed!","1125":"attempt to add with overflow","3362":"attempt to add with overflow","2460":"Array index out of bounds","2905":"attempt to add with overflow","3161":"attempt to add with overflow","2771":"Array index out of bounds","2960":"attempt to add with overflow","3795":"attempt to subtract with overflow","3929":"Array index out of bounds","2503":"attempt to add with overflow","3905":"attempt to subtract with overflow","443":"Initialization hash does not match","2168":"attempt to add with overflow","2680":"Array index out of bounds","2211":"Function _assert_token_is_same can only be called internally","285":"attempt to add with overflow","2431":"Array index out of bounds","2687":"Array index out of bounds","2943":"Array index out of bounds","2486":"Array index out of bounds","2742":"attempt to add with overflow","2864":"Array index out of bounds","3053":"call to assert_max_bit_size","3376":"attempt to add with overflow","3833":"attempt to subtract with overflow","2340":"attempt to multiply with overflow","3620":"attempt to add with overflow","4211":"attempt to add with overflow","2395":"attempt to add with overflow","4187":"Array index out of bounds","3730":"attempt to add with overflow","3596":"attempt to add with overflow","2438":"Array index out of bounds"}},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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DLSxj3NEuDqbNvhxjghXZ+N8kAHngww4H2TA+SBDw531a7izfrQBkHNEuJyN80EGnA8y4HyQAeeDDDgfZOi4cyM4H2TA+SADbRTkHBEuZ+N8kAHngww4H2TA+SDjRDvrFydazo64eZARNw8yTrScHXE+yIjzQUacDzLifJAR54OMuHmQETcPMuLmQUbcPMiI80HGN/ggawuXiGpLnyNyydn1cnW0qT+KKOZ6iSjW30X0+eJsU7kEYtE+h1+PHX47dvj90OH7eDffF344dvjx2OGnY4dvxw4/Hzv8Y++68di7bjz2rhuPveumY++66di7bjr2rpuOvev6OIbfF/6xd9107F03HXvXTcfeddOxd1079q5rx9517di7rh171/XxfL8v/GPvunbsXdeOvevasXddO/aum4+96+Zj77r52LtuPvau6+Paf1/4x95187F33XzsXTcfe9fNx951y7F33XLsXbcce9ctx951fX534X3h77/rPjj4WwouooqLqOEi2n8He3D0r064iAIuooiLKOEiMtpnreJydsXl7IrL2bXhnmxczm64nN1wObvhcnbD5exmuIgyLqKCi6jiIsLl7IbL2R2XszsuZ/dIq0Z6wkWEq7M7rs7uuJzdcTm743J2p+XsNNFydppoOTtNtDo7TbQ6O020OjtNtDo7TbScnSZazk4TLWenCZezwwSrRlIIuIhodXYKtDo7BVzODricHXA5O+BydsDl7IDL2RFXZ0dcnR1xdXbE1dkRl7MjLmdHXM6OuJwdaedG0hu89Q8iSrg6O+Hq7ITL2QmXsxMuZydczk64nJ1wOTvh6uyEq7MNV2cbrs42XM42XM42XM42XM422lm/ZLSzfslwdbbh6uyMy9kZl7MzLmdnXM7OuJydcTk74+rsjKuzM67Ozrg6u+BydsHl7ILL2QWXs99gmnxQjeB8kAnng0w4H2QquJyN80EmnA8y4XyQCeeDTDgfZHqHD/JBRLg6u+Lq7Iqrs3E+yITzQSacDzLhfJCp4c76NdxZv3f4IB9EhKuzcT7IhPNBJpwPMuF8kAnng0w4H2TquDq74+rsd/ggH0SEq7NxPsiE80EmnA8y4XyQNtHO+tlEO+tnE63OtolWZ9tEy9mG80EazgdpOB+k4XyQhvNBWqDV2RZodbYFWp1tgVZnG84HaTgfpOF8kIbzQVqgnfWzQDvr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","brillig_names":["build_msg_block","attach_len_to_msg_block","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","pack_arguments_oracle_wrapper","call_private_function_internal","directive_invert","directive_integer_quotient"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"TokenBridge"}},{"name":"fields","value":{"fields":[{"name":"token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters"}}],"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::constructor_parameters"}}],"kind":"struct","path":"TokenBridge::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"TokenBridge::get_token_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::get_token_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"TokenBridge::get_portal_address_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters"}}],"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_private_parameters"}}],"kind":"struct","path":"TokenBridge::claim_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"TokenBridge::get_portal_address_public_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"TokenBridge::get_portal_address_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters"}}],"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"TokenBridge::claim_public_parameters"}}],"kind":"struct","path":"TokenBridge::claim_public_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT, utils::arr_copy_slice,\n};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"142":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize},\n};\n\n// Just like PublicImmutable but with the ability to read from private functions.\npub struct SharedImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // Intended to be only called once.\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"154":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: Header,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"180":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress}, merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"190":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"274":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"310":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"333":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot: Field,\n    value: Field,\n    next_slot: Field,\n    next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"353":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        oracle::random::random,\n        prelude::{\n            NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n            FunctionSelector,\n        },\n        encrypted_logs::{\n            encrypted_note_emission::{\n                encode_and_encrypt_note, encode_and_encrypt_note_unconstrained,\n                encrypt_and_emit_partial_log,\n            }, encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n        }, keys::getters::get_public_keys,\n        macros::{\n            storage::storage, events::event,\n            functions::{initializer, private, view, public, internal},\n        }, utils::comparison::Comparator, protocol_types::{point::Point, traits::Serialize},\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote, token_note::TokenNote, balance_set::BalanceSet,\n    };\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[event]\n    #[derive(Serialize)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<TokenNote, Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote, Context>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: SharedImmutable<FieldCompressedString, Context>,\n        name: SharedImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n    // docs:start:mint_public\n    #[public]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n    // docs:start:mint_private\n    #[public]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[private]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_public_keys(caller);\n        storage.balances.at(caller).add(caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller),\n        );\n        Token::at(context.this_address())\n            .assert_minter_and_mint(context.msg_sender(), amount)\n            .enqueue(&mut context);\n    }\n    #[public]\n    #[internal]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n    // docs:start:shield\n    #[public]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n    // docs:start:transfer_public\n    #[public]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n    // docs:start:redeem_shield\n    #[private]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options\n            .select(TransparentNote::properties().amount, Comparator.EQ, amount)\n            .select(TransparentNote::properties().secret_hash, Comparator.EQ, secret_hash)\n            .set_limit(1);\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n        storage.balances.at(to).add(to_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to),\n        );\n    }\n    // docs:end:redeem_shield\n    // docs:start:unshield\n    #[private]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                from_keys.ivpk_m,\n                from,\n            ),\n        );\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n    }\n    // docs:end:transfer\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n    // docs:start:transfer_from\n    #[private]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            from_keys.ivpk_m,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            to_keys.ivpk_m,\n            to,\n        ));\n    }\n    // docs:end:transfer_from\n    // docs:start:burn\n    #[private]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_keys = get_public_keys(fee_payer);\n        let user_keys = get_public_keys(user);\n\n        let fee_payer_npk_m_hash = fee_payer_keys.npk_m.hash();\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                user_keys.ovpk_m,\n                user_keys.ivpk_m,\n                user,\n            ),\n        );\n\n        // 4. Now we get the partial payloads\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let fee_payer_randomness = unsafe { random() };\n        let user_randomness = unsafe { random() };\n\n        let fee_payer_setup_payload = TokenNote::setup_payload().new(\n            fee_payer_npk_m_hash,\n            fee_payer_randomness,\n            storage.balances.at(fee_payer).set.storage_slot,\n        );\n\n        let user_setup_payload = TokenNote::setup_payload().new(\n            user_npk_m_hash,\n            user_randomness,\n            storage.balances.at(user).set.storage_slot,\n        );\n\n        // 5. We encrypt and emit the partial note log\n        encrypt_and_emit_partial_log(\n            &mut context,\n            fee_payer_setup_payload.log_plaintext,\n            fee_payer_keys,\n            fee_payer,\n        );\n        encrypt_and_emit_partial_log(\n            &mut context,\n            user_setup_payload.log_plaintext,\n            user_keys,\n            user,\n        );\n\n        // 6. We convert the hiding points to standard `Point` type as we cannot pass `TokenNoteHidingPoint` type\n        // as an argument to a function due to macro limitations (the `TokenNoteHidingPoint` type is macro generated\n        // and hence is not resolved soon enough by the compiler).\n        let fee_payer_point = fee_payer_setup_payload.hiding_point;\n        let user_point = user_setup_payload.hiding_point;\n\n        // 7. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime {\n                FunctionSelector::from_signature(\n                    \"complete_refund((Field,Field,bool),(Field,Field,bool),Field)\",\n                )\n            },\n            [\n                fee_payer_point.x,\n                fee_payer_point.y,\n                fee_payer_point.is_infinite as Field,\n                user_point.x,\n                user_point.y,\n                user_point.is_infinite as Field,\n                funded_amount,\n            ],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_point: Point, user_point: Point, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            TokenNote::finalization_payload().new(fee_payer_point, tx_fee);\n        let user_finalization_payload =\n            TokenNote::finalization_payload().new(user_point, refund_amount);\n\n        // 4. We emit the `tx_fee` and `refund_amount` as unencrypted event such that the `NoteProcessor` can use it\n        // to reconstruct the note.\n        context.emit_unencrypted_log(fee_payer_finalization_payload.log);\n        context.emit_unencrypted_log(user_finalization_payload.log);\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_finalization_payload.note_hash);\n        context.push_note_hash(user_finalization_payload.note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"},"355":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, note::utils::compute_note_hash_for_nullify, oracle::random::random,\n    keys::getters::get_nsk_app, macros::notes::partial_note,\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\n// docs:start:TokenNote\n#[partial_note(quote {amount})]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"357":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n};\n\nuse dep::std::mem::zeroed;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[note]\npub struct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nimpl NullifiableNote for TransparentNote {\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit.\n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier(\n        self,\n        _context: &mut PrivateContext,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // compute_nullifier ignores both of its parameters so we can reuse it here\n        self.compute_nullifier(zeroed(), zeroed())\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all\n"},"411":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr","source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes:[u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes:[u8; 32] = secret_hash_for_redeeming_minted_notes.to_be_bytes();\n    let amount_bytes:[u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n    let caller_on_l1_bytes: [u8; 32] = caller_on_l1.to_field().to_be_bytes();\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"},"453":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_bridge_contract/src/main.nr","source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract TokenBridge {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{\n        storage::storage, functions::{public, initializer, private, internal, view},\n    };\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        token: PublicMutable<AztecAddress, Context>,\n        portal_address: SharedImmutable<EthAddress, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[private]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[public]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index,\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(\n            &mut context,\n        );\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    // TODO(#8416): Consider creating a truly private claim flow.\n    #[private]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash =\n            get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private(),\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())\n            ._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes)\n            .enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n    // docs:start:get_token\n    #[public]\n    #[view]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[public]\n    #[internal]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[public]\n    #[internal]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"65":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"97":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice,\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: arr_copy_slice(\n            fields,\n            [0; PUBLIC_DATA_TREE_HEIGHT],\n            1 + LEAF_PREIMAGE_LENGTH,\n        ),\n    }\n}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
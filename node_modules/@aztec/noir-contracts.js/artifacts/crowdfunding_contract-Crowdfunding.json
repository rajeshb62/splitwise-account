{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"Crowdfunding","functions":[{"name":"_publish_donation_receipts","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMdAAWAQ4BDKwiAQwABKwiARAACIgALOACARQAAIgDQHgIAAAQeAgAABTA4AAQABQAGJAIBAQQhAgASAAY5AQAAHgIBAAQeAgAABQo4BAUGIQIAFwAGOQEAABwMAAEEKggBASQCBAQFABABBQEkAwQBAQAoAQIFKgwFBiQCAAAHKg4HBgAoBgIGKg4HBgAoBgIGKg4HBioNAQUAKAUCBSoOBQEqCAEFAAABAgEqDgEFJAIEAAYkAgQBCCQCBAIJKgwGAyAALww4AwkKIQIArQAKIAAyKg0FAyYCAJcIr/YABCsEAAOAAyUABAAEgAQiANUrCIAFAAoAKAoCCwA4CwkMKg4EDCoOCgUqDQoDACgDAgMqDgMKKg0BAwAoAwIDKg4DASoIAQMAAAECASoOAQMqCAEBJAIEAgQAEAEEASQDBAEBACgBAgQqDAQFKg4HBSoNAQQAKAQCBCoOBAEqCAEEAAABAgEqDgEEJAIEAwEqDAYCIABVDDgCAQUhAgBxAAUgAFgqDQMCKg0KAwIoAwIDKg4DCiQCBAMFBigFAgMkAgQCBwA4BQcGKggBBAAQAQYBJAMEAQQAKAQCBioOBQYkAgQCBwA4BAcGACgCAgcrBAAHgAMrBAAGgAQrBAAFgAUiAOoAKAQCBioNBgUAKAYCAjQNAAIABSMkAgQDCQw4AgkLIQIAdQALOQEAAAAoCgIJADgJAgsqDQsHKggBCSQCBAILABABCwEkAwQBCQAoCQILKgwLDCoOBwwqDQkLACgLAgsqDgsJKg4JBCoMBgUgAIUKOAUGByECAI4AByAAiAA4AggFDjgCBQchAgCMAAc5AQAAKgwFAiAAVSoNAwcAOAIFCQ44AgkLIQIAkwALOQEAACoNBAskAgQBDQw4BQ0OIQIAmAAOOQEAAAAoCwINADgNBQ4qDQ4MJAIEAw0MOAkNDiECAJ8ADjkBAAArBAAHgAMlAAQABIAEIgDVKwiABQALACgLAg0AOA0JDioODA4qDgsDADgFCAcOOAUHCSECAKsACTkBAAAqDAcFIACFKg0FCioIAQskAgQDDAAQAQwBJAMEAQsAKAsCDCoMDA0qDgINACgNAg0qDgQNJAIEAg0MOAMNDiECALsADjkBAAAAKAsCDQA4DQMOKg0ODCQCBAMNDDgDDQ4hAgDCAA45AQAAKwQACoADJQAEAASABCIA1SsIgAUACwAoCwINADgNAw4qDgwOADgDCAoOOAMKDCECAM0ADDkBAAAqDgsFKgwKAyAALyUABHgAgAQNAAAAgASAAyEAANSAAzkBAAAjKwGAA4AGCwCABgACgAchAADZgAcgANsrAIADgAUgAOkrAAABgAUBAAABgAQAASUABAAAgAkNAIAJgASAChcAgAqACiEAAOeACgEAgAOACYALKwGAC4AIAQCABYAJgAsrAoAIgAsBAIAJAAKACSAA3iUBBAABgAUgAOkjJQAEAACABw0AgAeABYAIFwCACIAIIQAA9IAIAQCAA4AHgAkrAYAJgAYBAIAEgAeACSsCgAaACQEAgAcAAoAHIADrIysAGMoYyg==","debug_symbols":"7Z3bbuIwEIbfJddc+Hzoq6xWFW1phYSgKnSlVcW7b9LFKTRTj7bAZpzxTQVlIL+/BM8f24zfmofF3evT7XL9uNk2Nz/emtXmfr5bbtbts7f9rLl7Wa5Wy6fb4383ovsj1Xv89nm+7p5ud/OXXXMjXRSzZrF+aB96IdpPeFyuFs2Njmo/G0RHaw/B0ds+VgYJxOroUrCO3hxFWyDamSAP0c5EfxL9c9ZIfb54KbRK0cKq/yrfXIB9lL16icGXysYUrU+iIfXe63CI9r77vE/q7WXV21P13RHc1Y/gr36EcP4RjOhPhBHGYRedNSnaWacHpy2eL+ii3wIl/lVQ9yb5nTep77wJ7GOM9TqdEic9wivYdEbC0Qn5qj8Sob+e1BFbJ6AzEVx/ZUgkNvh0GkIIg2Yays00fR9ttD6J7aTbcqW7cqX7cqWHcqXHYqVrUa50Wa50Va500pk3L73cbKrLzaa63Gyqy82mutxsqsvNpqbcbGrKzaaG9Ne0vds/BNtgP0u3pC8YG9N9rJNiIJ30BeNMGgtxYSidtP3KSydtv/LSTbnSSduvvHTS9isvnXS/npdO2n7lpZO2X1npjnQ29SJN83jtkdgg0uh3UPiMUPrcoAfj+I50lh4HCensPw4S0q7iWki0V2nuRXsd+2gl4jsUU6EMoZB2QmNBIe2xxoJC2r2NBYW0LxwLCmnHeT0oIY1p6XC0wuEAxbP0shgUlm4Wg8LSz2JQmDraPBRToQyhMHW0eShMHW0eClNHm4fC1NHmoVRHO4QSqqMFoFRHC0DhmZKD+oCi9AAKz442yrQGQUc9hMKzo81DiTw7WgQKz44WgTLFoQN9+tOnrplTHAwAmml4NHOK7gBo5hRvwYFmTvGmGmjmFN0b0Mwp+rFhM9vDMmnnFF0T1E4eRkgKHk5ICsOknTy8kBQ8zJAUPNyQFJOxQ1+vqwRio/bpg6MfFgERk3FPl6QiJ+O1LkplMs7solR4LvsItl9f16rffxrlk3KKbuh8KkxnmRAqPFd+YFR4Lv3AqPCcksSo8JyTRKgonpOSx1QcQIXnrCRGheeKZoxK9bYQFVOpAFSqt4WoVG8LUaneFqJSvS1EpXpbgArtIpqjUWHqV/qiWe1DP6TCMwfl1yFK2pUWR6NSl3xDVOqab4CKYXrPnO9tDc8cFJX+uFbUkIqpVAAqPO+ZMSpM/QpChalfQagw9Sv6IzObOKTC1K/kqdCufDwaFaa/UkOo8PS2GBWm3hahYioVgApTb5u/Z6ZdG3s0KnUsDqJSx+IgKnUsDqDCsw45SqVWYICoMPW2CBWm3hahYioVgEr1thCV6m0hKtXbQlSqt4WoVG8LUGFalxyjQtqvZLcglLSrQjuZZLijGadeO+2N2fLaae/MltdOe2u2vHbae7PltdPenC2rnXb9X0Q77c1O89pp73aa1057u9O89oLzKu0KzIj2gvNqKDiv0i5QjWgvOK/SLvec3UNc0q7KjGgnnVcR7bTvV/PaSedVRDvpvIpoJ51XEe2k8yqinXReRbSTzqtZ7Yp2jV9Ee7l5VdGuxYtoLzevKlFuXlW06+BmtO/bp7/mL8v53Wqxbd/Svfq6vt8tN+vD093v57+vtMF/AA==","brillig_names":["_publish_donation_receipts"],"assert_messages":{"170":"attempt to add with overflow","151":"Array index out of bounds","116":"Array index out of bounds","17":"Not initialized","158":"Array index out of bounds","139":"attempt to add with overflow","186":"Array index out of bounds","193":"Array index out of bounds","146":"attempt to add with overflow","204":"attempt to add with overflow","22":"Function _publish_donation_receipts can only be called internally","211":"Stack too deep"}},{"name":"init","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"donation_token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"operator","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"deadline","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["init"],"assert_messages":{"701":"SharedImmutable already initialized","861":"Array index out of bounds","893":"attempt to add with overflow","593":"Array index out of bounds","206":"Array index out of bounds","779":"Array index out of bounds","808":"Array index out of bounds","869":"Array index out of bounds","473":"Array index out of bounds","217":"attempt to add with overflow","86":"attempt to add with overflow","496":"Array index out of bounds","790":"attempt to add with overflow","490":"attempt to add with overflow","199":"Array index out of bounds","519":"Stack too deep","513":"attempt to add with overflow","414":"SharedImmutable already initialized","612":"attempt to add with overflow","376":"Initializer address is not the contract deployer","816":"attempt to add with overflow","370":"Initialization hash does not match","877":"Array index out of bounds","195":"attempt to add with overflow"}},{"name":"donate","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7P3fjuNat5553st37AORnKQo30qj0XB3uRoGCnah7DoyfO+V608oY+0YEYzcHCkNzfnbR58NIRb1vCPF8T6M0Pyf//rf/vP/9//+//9//st//d//23//13/8f/3Pf/0f/+3/95/+x3/5b//1x//rf/5ran/+//33//M//dc//p///X/8p//rf/zrP07b7fIf/vWf/+v/9uN/Xi+X//Uf/vW//5f/4z//6z8ut/l//YcPr56v+/XvV8/75XZ/9bRNwauXtu1/v3pZ23Tw6mm63N5ePv34v/nntcxr9Pp9395efrusP1/dwh8+3+4/+7q/f/H/+z/8a1qh+QzNBs1naK7QfIZmP49mubXp7c3ertefb3bf/vxP3H77f2K+nP9PTPPa3l497+8C3qPIbuv9Z9+2yz8vKBieaV/nt+n5kd704Q1Mr/4G5ugNzG17+4/M7d0lffJPbNnW+6svP/8RTC169b68/Ru4vb+cNfw3cNnWt3+9P/73dXrcP7B5ASYG04CJwazAxGC2R4P55/Vc/oHmjwu6VrugvdoF3Ypd0HKpdkFTtQuaq13QUu2CWrULWqtd0OM/qS/7vUHN8/rhgq7VLujxn9TXdq8H138T2cdXt/tK0Nq761iW8K1O97d6WeZ/vPqPt3ob5q22yzhvderprS4/V9r141udx3mryzhvtfX0Vt91suv24a2u47zVbZy3eu3qZvPurV4/vNWutqV9uq/Ol+nDW+1qW/ryra5dbUtfv9WutqWf/1any4f76lp9W7q9Xf12nQ/f6qWt98+ly235X1/LzuX2NgTt/cYcXcYf7+v+FqcjL9rmtxdP7d3jxH+HRF2rb3iDx9PE85149jvEeW/LAfG8RxBr9U168Hiqb/9p8fzxZp+w/8/3JWd//+rwzV7b25u9bj+Dmq9/JbW/8sXfXvjit8srX/z0yhc/v/LFL6988e2VL3595YvfXvniX/kOu73yHXZ75Tvs9ZXvsNdXvsNeX/kOe33lO+z1le+w11e+w15f+Q57feU77PWV77DXV77D7q98h91f+Q67v/Iddn/lO+z+ynfY/ZXvsPsr32H3V77D7q98h91f+Q57e+U77O2V77C3V77D3l75Dnt75Tvs7ZXvsLdXvsPeXvkOe3vlO+ztle+wP57pv/TVv/I9drq88k12urzyXXa6vPJtdrq88n12urzyjXa6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","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","pack_arguments_oracle_wrapper","call_private_function_internal","pack_arguments_oracle_wrapper","get_public_keys_and_partial_address","random","notify_created_note_oracle_wrapper","get_key_validation_request","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"withdraw","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"H4sIAAAAAAAA/+1dB5gURRPd23DkbA54Kggq4PbthT0ByTknlSBwYQ+BIx9JSQqoJAFBAREQMSMqZn/EgBgxgzkrRsw5+1cfM14z9N3t7FQdXcp83/t2dnam51VV1+swszNJvr3LexV8vldCe9eTAAHr0w9IcWyzP9X1kGa/Kppt1TTbami21dJsOwzQ0rGtrma/4zTbUjTbjtdsq6/ZdpJ1XnVJsj7t7ZFwRlpaLDM1JiIiO5yalRNND6el52RERVSkR9PzUqORSCyaFs3MysnKDGeJtEhM5KdnRfLDe5dj/MVlhT0tqbmUPI9F4xkOU/KsmzjPVOcGya0OIKhwlfH6S6kf9vqxyva61rp93HHwPQVwPOAEf/F2e/E7fBD2toj6iP48ES/uQs0tWW4KsR9U7l79UI/ID/U0fsDOifpo3EUmJc+T8HycSsmzQeI8I84NOo2pr2iJxD96o2xv4NCYhvD9ZMApgFMtjZFtMzTv/+RVaT4Je1vEIT6a9sGHw1PYK6ovGllfGvt9+zb88od3HNsaaxI1QOjEBCtpqlVJRSNE8WtM1PhjCz6mzU00ZeWEc/PSRU5GXqaIZadHc3OzIkKkZmdkZ+SkRvNjOekimh6FMnOzU6NwutTsXBELZ2fEZCJW9BUnnbpgJ2ITxFipfE/zExKWhWOXG0asDFR2q3KEVK6WK4YASK5YCWuXixkjgVzxbeGX5coRozVILpfWlEpwsXk2ROSZrPBMtZwcsT7TrM906zPD0ouG1v6Z8D0KyAKcDmgKaAZoDjgD0ELyBLQCtAa0AbQFtAO0B3QAdAR0AnQGdAF0BXQDdAf0APQE9AL0BvQB9AX0A5wJOAtwNqA/YABgIGAQ4BzAYGfvIsPqSZRnqxAhahWG+AkJDyFoFYYa3ipIu4cStArlWdnSiCpbtp+QcDZBZcsxvLJJu3OYV7Z0osqW6ycknEtQ2fIMr2zS7rxy6u+GvS1FrUSOH78fHfPzTLIMoiTL9xMSzidIsmGGJ5m0exiTJJNiECNIsnPLafDklefwxHmmOTfoppFlV9KeLk5T1jOU9eH+faeRR8D3kYACwCj//peqsGc8EVtvMQIxN0cjC54zNqOVGIxU1guU9VGO2IyB72MB4wDj/fuWh1kvpX6cS5CXExBjrUic1gdhb4tIRYy/PUlRCGVOBEwCTAZMAUwFnAc4HzANMB0wAzATMAtwAeBCwGzAHMBcwEWAiwGXAOYB5gMWABYCFgEuBSwGLAEsBVwGWAZYDrgccAVgBWAlYBXgSsBq/96JLXWeotC//+0eEzXbJmm2TdZsm6LZNlWz7TzNtvM126Zptk3XbJuh2TZTs22WZtsFmm0XarbN1mybo9k2V7PtIs22izXbLtFsm6fZNl+zbYFm20LNtkWabZdqti3WbFui2bZUs+0yzbZlmm3LNdsu12y7QrNthWbbSs22VZptV2q2rVb00F5s/W1pfYa9LftojletLUQoK5a/d5mIyOu6EE3fzBkLjzbnTcLzX9ZkvLLEFMRYXM8iFjExFc1/ueI8tLKi4nzEWNzAIhZhMQ3Lf7GwmI5VVm5YzECMxY0cYhENi5lY/oO2ZxZSWTEo6wLEWNzEIBa5YPOFSP6LQlmzkcoCk8UcxFjcbH4sYtLmuTj+y5VlXYRTVlSWdTFiLDaaHwtZtLgExX+xorLmoZSVW1TWfMRY3GJ8LKJFNi9A8V8RTbEQo6zY3rIWIcZik+mxyN1r86UY/ovuLWsxRll7TRZLEGNxq+GxyLNsXopgc45V1mUIZWVaZS1DjMVtZsfin7uWl3u3WdhlXe65rGi+XdYViLG43ehYRHNsm1d4959ts1jpuazMf8pahRiLzUbHIv0fm6/0bLP4p6zVfrw5S3U+z2ss7iinWIS9LQJx3kwgzvuIGxFjcSeTWCDODwjE8a3YiBiLu5jEAnEcJBD78eJWxFjczSQWiP09gdhfEZsRY3EPk1ggtmsCUZfFXYixuJcoFtj3GyHmr0Csf4LKf36H/0y4rmyXdRViP1SWgX0PkLzfSt6zhH0f1Bo/bqyx7ZZ/pioksHtHyGy7ZX1cQ2D3M+WkjV55rkXMR8RYi2cMrzcyX64iqDfPG253IVG+vMAkX9Yh5gtirAWm/2RsnfcuS52w71Fe54/vEUhXw/f1gGsAG/wl37sc9rYI+SfgiQR1cidxLnrlJ22+msDuXUzGWFcj9kuvRcxrxHojuMQiihiL6/w0OWxSXug09lpFS6+LU2Ovh+83AG4E3ESosfIhC5MItOZVwzVW2nw9gd2vcbnugZiLNyNqLGK9EVxikYUYi41+mhw2KS90GnuzoqUb49TYW+D7JsCtgNsINVY+xGYygda8abjGSptvIbD7LS7X0BBz8XZEjUWsN4JLLE5HjMVmP00Om5QXOo29XdHSzXFq7B3w/U7AXYC7CTVWPiRsCoHWvGu4xkqb7yCw+z0u12MRc/EeRI1FrDeCSyyaIsbiXj9NDpuUFzqNvUfR0nvj1Nj74Pv9gP8BthBqrHwI41QCrfnQcI2VNt9HYPduJnl9H2IuPoCosYj1RnCJRTPEWGz10+SwSXmh09gHFC3dGqfGPgjfHwI8DHiEUGPlQ27PI9CaTwzXWGnzgwR2f8okrx9EzMVtiBqLWG8El1g0R4zFo36aHDYpL3Qau03R0kfj1Njt8P0xwOOAJwg1Vj5E/HwCrdljuMZKm7cT2P0Fk7zejpiLTyJqLGK9EVxicQZiLJ7y0+SwSXmh09gnFS19Kk6NfRq+7wA8A3iWUGPlSxqmEWjN14ZrrLT5aQK7v2GS108j5uJziBqLWG8El1i0QIzF836aHDYpL3Qa+5yipc/HqbEvwPcXAS8BdhJqbEt/8TNS1XK9+vR7wzVW2vwCgd0/MMnrFxBzcReixiLWG8ElFi0RY/GynyaHTcoLncbuUrT05Tg19hX4/irgNcDrhBorXzI2g0BrfjZcY6XNrxDY/QuTvH4FMRffQNRYxHojuMSiFWIs3vTT5LBJeaHT2DcULX0zTo19C76/DXgH8C6hxsqXOM4k0JrfDddYafNbBHb/wSSv30LMxfcQNRax3ggusWiNGIv3/TQ5bFJe6DT2PUVL349TYz+A7x8CdgM+ItRY+ZLcWQRa87fhGitt/oDAbl8yj7z+ADEXP0bUWMR6I7jEog1iLD7x0+SwSXmh09iPFS39JE6N/RS+fwb4HLCHUGPlS8gvINCaQLLZGitt/pTA7iCTvP4UMRe/QNRYxHojuMSiLWIsvvTT5LBJeaHT2C8ULf0yTo39Cr5/DfgG8C2hxrbzF7+zTy3Xq08rGK6x0uavCOyuyCSvv0LMxe8QNRax3ggusWiHGIvv/TQ5bFJe6DT2O0VLv49TY3+A7z8CfgL8TKix7f3F70BVy/Xq0yqGa6y0+QcCu6syyesfEHPxF0SNRaw3gkss2iPG4lc/TQ6blBc6jf1F0dJf49TY3+D774A/AH8SamwHf/E7pdVyvfq0huEaK23+jcDumkzy+jfEXPwLUWMR643gEosOmHOofpocNikvdBr7l6Klf8epsfLhvUkAPyAQoNPYjnDeuQRaU8dwjZU2F/kYudxDmOS1tB3L5mAAjxdivRFcYtERURdDAZocNikvdBor66CtpaFAfBqbDPtVAFQEVCLU2E5w3osINPZwwzVW2pxMoLFHMMnrZMRcrIyosYj1RnCJRSfM8X2AJodNygudxlZWdLVKnBpbFfarBqgOqEGosZ3hvBcTaOzRhmustLkqgcYewySvqyLmYk1EjUWsN4JLLDojamytAE0Om5QXOo2tqehqrTg1tjbsVwdwCOBQQo3tAue9hEBjjzNcY6XNtQk0NoVJXtdGzMXDEDUWsd4ILrHogqixhwdoctikvNBp7GGKrh4ep8YeAfsdCTgKcDShxnaF884j0NgTDddYafMRBBpbj0leH4GYi8cgaixivRFcYtEVUWOPDdDksEl5odPYY1RdjVNj68J+xwFSAMcTamw3OO98Ao1tYLjGSpvrEmhsQyZ5XRcxF09A1FjEeiO4xKIbosaeGKDJYZPyQqexJyi6emKcGlsP9qsPOAnQgFBju8N5FxBo7KmGa6y0uR6BxjZiktf1EHOxIaLGItYbwSUW3RE19uQATQ6blBc6jW2o6OrJcWrsKbDfqYBGgMaEGtsDzruQQGNPM1xjpc2nEGhsmElen4KYi00QNRax3gguseiBqLGnBWhy2KS80GlsE0VXT4tTY8OwnwCkAiKEGtsTzruIQGMjhmustDlMoLFpTPI6jJiLaYgai1hvBJdY9ETU2PQATQ6blBc6jU1TdDU9To3NgP0yAVFAFqHG9oLzXkqgsZmGa6y0OYNAY6NM8joDMRdPR9RYxHojuMSiF6LGNg3Q5LBJeaHT2NMVXW0ap8Y2g/2aA84AtCDU2N5w3sUEGtvUcI2VNjcj0NhmTPK6GWIutkTUWMR6I7jEojeixrYK0OSwSXmh09iWiq62ilNjW8N+bQBtAe0INbYPnHcJgca2MFxjpc2tCTS2JZO8bo2Yi+0RNRax3gguseiDqLEdAjQ5bFJe6DS2vaKrHeLU2I6wXydAZ0AXQo3tC+ddSqCxbQzXWGlzRwKNbcvlP/KIudgVUWMR643gEou+iBrbLUCTwyblhU5juyq62i1Oje0O+/UA9AT0ItTYfnDeywg0toPhGitt7k6gsR253C+EmIu9ETUWsd4ILrHoh6ixfQI0OWxSXug0treiq33i1Ni+sF8/wJmAswg19kw47zICje1iuMZKm/sSaGxXLn0nxFw8G1FjEeuN4BKLMxE1tn+AJodNygudxp6t6Gr/ODV2AOw3EDAIcA6hxp4F511OoLE9DNdYafMAAo3tySSvByDm4mBEjUWsN4JLLM5C1NghAZocNikvdBo7WNHVIXFq7FDYLxuQA8gl1Niz4byXE2hsH8M1Vto8lEBj+zLJ66GIuZiHqLGI9UZwicXZiBobC9DksEl5odPYPEVXY3FqbD7sNwxwLmA4ocb2h/NeQaCxZxmusdLmfAKNPZtJXucj5uIIRI1FrDeCSyz6I2rsyABNDpuUFzqNHaHo6sg4NbYA9hsFGA0YQ6ixA+C8Kwg0dqDhGittLiDQ2EFM8roAMRfHImosYr0RXGIxAFFjxwVoctikvNBp7FhFV8fFqbHjYb8JgELAREKNHQjnXUmgsUMM11hp83gCjR3KJK/HI+biJESNRaw3gkssBiJq7OQATQ6blBc6jZ2k6OrkODV2Cuw3FXAe4HxCjR0E511FoLG5hmustHkKgcbmMcnrKYi5OA1RYxHrjeASi0GIGjs9QJPDJuWFTmOnKbo6PU6NnQH7zQTMAlxAqLHnwHmvJNDYYYZrrLR5BoHGnsskr2cg5uKFiBqLWG8El1icg6ixswM0OWxSXug09kJFV2fHqbFzYL+5gIsAFxNq7GA472oCjR1puMZKm+cQaGwBk7yeg5iLlyBqLGK9EVxiMRhRY+cFaHLYpLzQaewliq7Oi1Nj58N+CwALAYsUjbUXP3Kca/rw/Dk/QFO3Aw6bPT9b2o/nvwhinlyK6L8QlFHRV9yWqAt2e43JW+W7OEBIeHEAv9wliEJHZfeSQLGDkcotqmySq99HX9kQkzdMyTPip0mKpUq9xX+aC2KvSXILWBxt0iGrkpSHKmEGQK3Yl1kJtEzaRBGApQTKtBS5aaay209ot+e/1hD7MOxtEbJiLicYPl6O3LzboiDLnWWVi+2LZUS+uILIF1cQ+kIKIYUvxpj+SAeiOjD2wNqdWwY/sro/jmjqwjm8C3tbBGK9FIixFpj+C1l+0/W4fS79WVZ9UsukaLOwfKJ2KleU1ksOe1vEcqJGQCXtkrMo6zyS8woCUZhoyHymm86b53v6AmYKzMRkmnq5UumcJBqfsnyOGZ9VSlkiEoHcyMsU+Xn5kfTMrNQckRHJyMhPy8/MiKbl5aenZedlxkRadiQ1K5YZzhfRWCwzPZKbmZGflZebka+KtsiLRNLysnJyRXpqRnZOOJoXyQ7np2VGUsPZeZHMvLxINCMjOxLJy4jmR7OiqanZ+ZFoOD0zMyuckRrJSqWKzyorPuU5usachlEbsSut3sBqLgJOxe9KArG+iqjhuopw9CJ9sZrAF2uIfLGG0BcNiUZyk01/qAlRPkwxfCRHVfenMhnJIdZLgRhrMfXgSM65iCuJRnJrOY7k1hKP5NYSiML0/+BIbl3ATIGZTjRSWMdsJHc14khuKuJIjio+VysjuZIaBZOn4Ch5UjUw6zk2MOuJG5j1BA3MzHJqYDCv8xp0rWifBsYrr1nlNALwyvMaxAYasf6JWUQNwDVxNNBefbohgNcQ7jM9alADPZMoPhv+RVOt11rJep3uRqawt0WUdEMP5h1qnt+rgyguFIG3fYgtqlQ+9FrW9YbHQybM9QQdoxuIOok3EE5FX0fkixuJfHEj8bQ8hS9mGz4tT5UPcwyflqeq+3OZTMsj1kuBGGsx9+C0vHMparOwfKJ2dm+inDW5nqgRuIlw1kRyvolAFOYxmZa/HrEjeHPATIGZRzSqvLkcpuUx47MRcVp+LuKonyo+Gw/AqJ/q70u3WL2BTVwEnIrfLQRifStRw3Ur4ehF+mITgS9uI/LFbQHav8pQ9OwXGD6So8qHhYaP5Kjq/iImIznEeikQYy0WHRzJORdxC9FI7naOI7nbiUdytxOIwtL/4Ehuc8BMgVlKNFLYzGwkdwfiSG4R4kiOKj53HIAbrDCn4Ch5UjUwd3JsYO4kbmDuJGhgljG5wQpTwOYQ9WA930TG5AaruxAbaMT6J5YTNQB3lcMNVncj3mA1N9nMBnoZUXzu1sQHe9Sr3lDlNdbpiGXdg9iWlefz/+4h6jjcGyAkfG8Av9z7EBs2KrvvCxQ7GKnccn3+n5pwYY8LJU/MuzbVpLi/tN6010p3H2JvQFV1m/S/4bbZ/1kJtEV32yxGAO4nUKb7iS/IYdntJ7TbK8cHDL+oKSvmAwTDyq1EQ+ythBfythD54kEiXzxIfHsqhS9WGH5RkyofVhp+UZOq7q9iclETsV4KxFiLVQcvajqXojYLyydqp/IhyjnnB4gagYcI55wl54cIRGENk4uaDyB2BB8OmCkwa4jm5B4uh4uamPF5BPGi5irEOVOq+DxyAG5PxZyGURuxbVZv4FEuAk7FbxuBWG8nari2E45epC8eJfDFY0S+eIzQF+lEI7l1ho/kqPLhasNHclR1fz2TkRxivRSIsRbrD47knIvYRjSSe5zjSO5x4pHc4wSicN1/cCT3RMBMgbmOaKTwBLOR3JOII7n1iCM5qvg8eQBuT8WcgqPkSdXAPMWxgXmKuIF5iqCBuYHJ7amYAraSqAfr+TE7TG5PfRqxgUasf+JGogbg6XK4PXUH4u2pq5LNbKBvIIrPjn/RVOszVrI+q7uRKextESXd0IN5h5rXshBviiJ53pztQ2xRpfKh17KeMzweMmGeI+gYPU/USXyecCr6WSJfvEDkixeIp+UpfLHR8Gl5qny4xfBpeaq6v4nJtDxivRSIsRabDk7LO5eiNgvLJ2pn90XKWZPniBqBFwlnTSTnFwlEYTOTafnnEDuCLwXMFJjNRKPKl8phWh4zPjsRp+U3IY76qeKz8wCM+qn+vrTL6g28zEXAqfjtIhDrV4garlcIRy/SFy8T+OJVIl+8GqD9qwxFz/5Ow0dyVPlwl+EjOaq6fzeTkRxivRSIsRZ3HxzJORexi2gk9xrHkdxrxCO51whE4f7/4Eju9YCZAnM/0UjhdWYjuTcQR3J3I47kqOLzxgG4wQpzCo6SJ1UD8ybHBuZN4gbmTYIGZguTG6wwBewWoh6s55vImNxg9RZiA41Y/8QDRA3AW+Vwg9XbiDdYbUo2s4HeQhSft0uZ3cG47+W5AP5DhjD17B3DZ07zwHnD/PixeZfYbox3pl5PUHcwn4X7nuE+lHX73QD+LBZizoh3EePxvuHxkPXlfYJ+6AfE9/F55Sdn+T8gsPuhZLO1O0Jk98NEfV1srUWMj3jY8Cs6aSXEOuxtEYhllTqZ4dX+DxE1SHKr4yseJ8jv9cG/f1nrEva6PK+93sDaxz5uN/z2EeBjwCeBvdtDjrpemk/C3hbR2F8+sQt7W8RuxHYzWeH5qdXx+Mz6/Nz63GN9fmHlS0Nr/y/h+1eArwHfAL4FfAf4HvAD4EfAT4CfAb8AfgX8Bvgd8AfgT1kXAH8H9laCJIAfEAAEASFAMqACoCKgEqAyoAqgKqAaoDqgBqAmoBagNqAO4JCg5Xh74CTJp1gVqrwe/P0Z0YzhoUFCwrJw7HIPC+IpF5XdhwWLHYxUbrk+Zf5zosp2eJCQ8OEEle0IwyubtPsI5pVtD1FlOzJISPhIgsp2lOGVTdp9FEFlo+AqFfiIIH5f9+ggzyT7gijJjgkSEj6GIMmONTzJpN3HMkkyKQZHEyRZ3SBuZXUOKD9TBo6fK+tfKOvDHQPK42AlBXA84IRg8XZ7wZ5oRWwVxXGIdf5E4tjI8u0YpCjrxyvrJwT3jU09WKkPOAnQILhveZj1UuZlXYL63hDPp8I5uYGd858iNiT24P9ksP8UwKmARoDGgCaA0wBhgACkAiKANEA6IAOQCYgCsgCnA5oCmgGaA84AtJB+BbQCtAa0AbQFtAO0B3QAdAR0AnQGdAF0BXQDdAf0APQMFv8PxR7/nxwsnoyyt52i2XaqZlsjzbbGmm1NNNtO02wLa7YJzbZUzbaIZluaZlu6ZluGZlumZltUsy1Ls+10zbammm3NNNuaa7adodnWQrOtpWZbK8221pptbTTb2mq2tdNsa6/Z1kGzraNmWyfNts6abV0027pqtnXTbOuu2dZDs62noof2YutvS+sz7G3ZR3O8au3JCG1hLH/vcgpiu/qo4TeUWTbnnYrnv6xGeGWJxoix2M4iFjHRBM1/ueI0tLKiIowYi8dYxCIsBJb/YmGRilVWLlyIRozF4xxiEQ2LNCz/yQfOIJUVg7IyEGPxBINY5ILNmUj+i0JZUaSywGSRhRiLJ82PRUzafDqO/3JlWU1xyorKspohxuIp82MhixbNUfwXKyrrDJSycovKaoEYi6eNj0W0yOaWKP4roilaYZQV21tWa8RY7DA9Frl7bW6D4b/o3rLaYpS112TRDjEWzxgeizzL5vYINudYZXVAKCvTKqsjYiyeNTsWqfbf3Tt5t1nYZXX2XFY03y6rC2IsnjM6FtEc2+au3v33z2MMunkuK/OfsrojxuJ5o2OR/o/NPTzbLP4pq2cQb87yUcQ/OL5gyNMMylgE4ryZQJz3EY8jxuJFJrFAnB8QiONb8RRiLF5iEgvEcZBA7MeLZxBjsZNJLBD7ewKxvyKeR4zFLiaxQGzXBKIui5cQY/Eyk8eTIeavQKx/gsp/fof/TLiubJfVC7EfKsvAvgdI3m/VMIh/H1TvIG6sse2Wf1I6mcDuzwz/M6usj70J7P6cyYNb+iDmI2KsxeeG1xuZL70I6s2Xhtt9MlG+fMUkX/oi5gtirAWm/2RsnfcuS52w71Huq6wf6y9er+vf997lfrByJuAswNnBku9dDntbhPxz7SkEdfJbw/+cL23uR2D3d0zGWP0Q+6X9EfMasd4ILrH4CvE+1gFBmhw2KS90Gttf0dUBcWrsQFgZBDgHMJhQY+XDC04l0JofDddYafNAArt/YpLXAxFzcQiixiLWG8ElFl8jauzQIE0Om5QXOo0doujq0Dg1NhtWcgC5gDxCjZUPh2lEoDW/Gq6x0uZsArt/Y5LX2Yi5GEPUWMR6I7jE4htEjc0P0uSwSXmh09iYoqv5cWrsMFg5FzAcMIJQY+XDtxoTaM2fhmustHkYgd1/McnrYYi5OBJRYxHrjeASi28RNbYgSJPDJuWFTmNHKrpaEKfGjoKV0YAxgLGEGisfbtiEQGuSKpitsdLmUQR2+yvwyOtRiLk4DlFjEeuN4BKL7xA1dnyQJodNygudxo5TdHV8nBo7AVYKARMBkwg1Vj489jQCrQkZrrHS5gkEdiczyesJiLk4GVFjEeuN4BKL7xE1dkqQJodNygudxk5WdHVKnBo7FVbOA5wPmEaosfLh3GECralkuMZKm6cS2F2ZSV5PRczF6Ygai1hvBJdY/ICosTOCNDlsUl7oNHa6oqsz4tTYmbAyC3AB4EJCjZUvPxAEWlPNcI2VNs8ksLs6k7yeiZiLsxE1FrHeCC6x+BFRY+cEaXLYpLzQaexsRVfnxKmxc2HlIsDFgEsINVa+XCaVQGtqGa6x0ua5BHbXZpLXcxFzcR6ixiLWG8ElFj8hauz8IE0Om5QXOo2dp+jq/Dg1dgGsLAQsAlxKqLHy5V0RAq051HCNlTYvILD7MCZ5vQAxFxcjaixivRFcYvEzosYuCdLksEl5odPYxYquLolTY5fCymWAZYDlhBorX46YRqA1RxqusdLmpQR2H8Ukr5ci5uLliBqLWG8El1j8gqixVwRpctikvNBp7OWKrl4Rp8augJWVgFWAKwk1Vr58Np1Aa441XGOlzSsI7K7LJK9XIObiakSNRaw3gkssfkXU2KuCNDlsUl7oNHa1oqtXxamxa2BlLWAd4GpCjZUv984g0JrjDddYafMaArtPYJLXaxBzcT2ixiLWG8ElFr8hauw1QZocNikvdBq7XtHVa+LU2A2wci3gOsD1hBr7e6D4nX1quV59Wt9wjZU2byCw+yQmeb0BMRdvQNRYxHojuMTid0SNvTFIk8Mm5YVOY29QdPXGODX2Jli5GbARcAuhxv4RKH4Hqlqu5+eNGq6x0uabCOw+hUle34SYi5sQNRax3ggusfgDUWNvDdLksEl5odPYTYqu3hqnxt4GK7cDNgPuINTYPwPF75RWy/X8PADDNVbafBuB3U2Y5PVtiLl4J6LGItYbwSUWfyJq7F1Bmhw2KS90Gnunoqt3xamxd8PKPYB7AfcRauxfEN/TCbRGGK6x0ua7CexOZZLXdyPm4v2IGotYbwSXWPyFqLH/C9LksEl5odPY+xVd/V+cGrsFVh4AbAU8SKixf0N8mxJoTbrhGitt3kJgdwaTvN6CmIsPIWosYr0RXGLxN6LGPhykyWGT8kKnsQ8puvpwnBr7CKxsAzwK2E6osbLgZgRak2W4xkqbHyGw+3Qmef0IYi4+hqixiPVGcImFDzEWjwdpctikvNBp7GOKrj4ep8Y+AStPAp4CPE2osUlQcHMCrWluuMZKm58gsPsMJnn9BGIu7kDUWMR6I7jEIgkxFs8EaXLYpLzQaewORVefiVNjn4WV5wDPA14g1Fg/FHwGgda0Mlxjpc3PEtjdmkleP4uYiy8iaixivRFcYuFHjMVLQZocNikvdBr7oqKrL8WpsTthZRfgZcArhBobgIJbEGhNO8M1Vtq8k8Du9kzyeidiLr6KqLGI9UZwiUUAMRavBWly2KS80Gnsq4quvhanxr4OK28A3gS8RaixQRkTAq3pZLjGSptfJ7C7M5O8fh0xF99G1FjEeiO4xCKIGIt3gjQ5bFJe6DT2bUVX34lTY9+FlfcA7wM+INTYEBTcikBruhmusdLmdwns7s4kr99FzMUPETUWsd4ILrEIIcZid5Amh03KC53Gfqjo6u44NfYjWPkY8AngU0KNTYaCWxNoTS/DNVba/BGB3b2Z5PVHiLn4GaLGItYbwSUWyYix+DxIk8Mm5YVOYz9TdPXzODV2D6x8AfgS8BWhxlaAgtsQaE0/wzVW2ryHwO4zmeT1HsRc/BpRYxHrjeASiwqIsfgmSJPDJuWFTmO/VnT1mzg19ltY+Q7wPeAHQo2tCAW3JdCa/oZrrLT5WwK7BzDJ628Rc/FHRI1FrDeCSywqIsbipyBNDpuUFzqN/VHR1Z/i1NifYeUXwK+A3wg1thIU3I5Aa84xXGOlzT8T2D2Yy7P3EXPxd0SNRaw3gkssKiHG4o8gTQ6blBc6jf1d0dU/4tTYP+V+gL/lhhCdxlaGgtsTaE224Rorbf6TwO4cLs8hQczFpBAeL8R6I7jEojJiLPwhmhw2KS90GivroK2l/lB8GhuQugoIAZIJNbYKFNyBQGtihmustFn6GLvcfC73ZCLmYgVEjUWsN4JLLKogamzFEE0Om5QXOo2toOhqxTg1thLsVxlQBVCVUGOrQsEdCTR2uOEaK22uRKCxI7iMTxFzsRqixiLWG8ElFlURNbZ6iCaHTcoLncZWU3S1epwaWwP2qwmoBahNqLHVoOBOBBo7ynCNlTbXINDY0UzyugZiLtZB1FjEeiO4xKIaosYeEqLJYZPyQqexdRRdPSROjT0U9jsMcDjgCEKNrQ4FdybQ2HGGa6y0+VACjR3PJK8PRczFIxE1FrHeCC6xqI6osUeFaHLYpLzQaeyRiq4eFafGHg37HQM4FlCXUGNrQMFdCDR2ouEaK20+mkBjJzHJ66MRc/E4RI1FrDeCSyxqIGpsSogmh03KC53GHqfoakqcGns87HcC4ERAPUKNrQkFdyXQ2KmGa6y0+XgCjT2PSV4fj5iL9RE1FrHeCC6xqImosSeFaHLYpLzQaWx9RVdPilNjG8B+DQEnA04h1NhaUHA3Ao2dbrjGSpsbEGjsDCZ53QAxF09F1FjEeiO4xKIWosY2CtHksEl5odPYUxVdbRSnxjaG/ZoATgOECTW2NhTcnUBjLzBcY6XNjQk09kImed0YMRcFosYi1hvBJRa1ETU2NUSTwyblhU5jhaKrqXFqbAT2SwOkAzIINbYOFNyDQGPnGq6x0uYIgcZexCSvI4i5mImosYj1RnCJRR1EjY2GaHLYpLzQaWymoqvRODU2C/Y7HdAU0IxQYw+BgnsSaOw8wzVW2pxFoLHzmeR1FmIuNkfUWMR6I7jE4hBEjT0jRJPDJuWFTmObK7p6Rpwa20L6CtAK0FrRWHvxI8e5pg/Pny1CNHU74LDZ87M2A3j++wzx3aJtEP0HRfkq+orbEnXBbq8xeat824YICbcN4ZfbDlHoqOxuFyp2MFK5RZWt6M+sPvrKhpi8YUqenwVokqK9Um/xn+aC2GuS3AIWR5t0yKok5aFKmAFQK3YHK4E6SpsoAtCeQJnaIzfNVHb7Ce32/NcaYh+GvS1CVsxOBMPHzsjNuy0KstxZVrnYvuhI5IsuRL7oQugLKYQUvlhk+iMdiOrApQfW7twy+JHV/cVEUxfO4V3Y2yIQ66VAjLXA9F/I8puux+1z6c+y6pNaJkWbheUTtVPZtbRectjbIjoRNQIqaZecRVnnkZy7EojCMkPmM9103jzf0xcyU2CWVaCpl92Uzkmi8SnL55jx6a6UJSIRyI28TJGflx9Jz8xKzREZkYyM/LT8zIxoWl5+elp2XmZMpGVHUrNimeF8EY3FMtMjuZkZ+Vl5uRn5qmiLvEgkLS8rJ1ekp2Zk54SjeZHscH5aZiQ1nJ0XyczLi0QzMrIjkbyMaH40K5qamp0fiYbTMzOzwhmpkaxUqvh0t+JTnqPr3USj6x7W6LonFwGn4teDQKx7ETVcvQhHL9IXPQl80ZvIF70JfbGbaCR3uekPNSHKhysMH8lR1f0VTEZyiPVSIMZarDg4knMuogfRSK4Px5FcH+KRXB8CUVj9HxzJ9Q2ZKTCriUYKfZmN5PohjuRWII7kqOLTTxnJldQomDwFR8mTqoE5k2MDcyZxA3MmQQOzppwaGMzrvAZdK9qngfHKa205jQC88jwLsYFGrH9iLVEDcFYcDbRXn54dwmsI95keNaiBXkMUn7P/RVOt/a2p1gG6G5nC3hZR0g09mHeoeX6vDqK4UATe9iG2qFL50GtZAw2Ph0yYgQQdo0FEncRBhFPRA4h8cQ6RL84hnpan8MV6w6flqfLhGsOn5anq/gYm0/KI9VIgxlpsODgt71yK2iwsn6id3cGUsyYDiRqBwYSzJpLzYAJRuIHJtPxAxI7gkJCZAnMD0ahySDlMy2PGZyjitPwGxFE/VXyGHoBRP9Xfl7KtUX8OFwGn4pdNINa5RA1XLuHoRfoih8AXeUS+yCP+qwxFz/4mw0dyVPlws+EjOaq6v5HJSA6xXgrEWIuNB0dyzkVkE43kYhxHcjHikVyMQBRu+w+O5PJDZgrMbUQjhXxmI7lhiCO5jYgjOar4DDsAN1j1D9HkPZcG5lyODcy5xA3MuQQNzGYmN1hhCtg1RD1Yr7zuYHKD1XDEBhqx/ok7iBqA4eVwg9UIxBusNlQws4HeTBSfEZr4YI96dyM+s28PYlkjEdsy2cEpr+f/jSTqOBSECAkXhPDLHYXYsFHZPSpU7GCkcsv1+X97mDz/D/OuTTUpRpfWm/b8ZnTE3oCq6jbpf8Nts2OsBBqru20WIwCjCZRpNPEFOSy7/YR2e36lteEXNWXFHEcwrBxPNMQeT3ghbyyRLyYQ+WIC8e2pFL642/CLmlT5cI/hFzWp6v69TC5qItZLgRhrce/Bi5rOpajNwvKJ2qkspJxzHkfUCBQSzjlLzoUEorCFyUXNcYgdwYkhMwVmC9Gc3MRyuKiJGZ9JiBc170WcM6WKz6QDcHvqHqLR9WRrdD2Fi4BT8ZtMINZTiRquqYSjF+mLKQS+OI/IF+cR+mIP0Uhuq+EjOap8eNDwkRxV3X+IyUgOsV4KxFiLhw6O5JyLmEw0kjuf40jufOKR3PkEovDof3AkNy1kpsA8SjRSmMZsJDcdcST3EOJIjio+0w/A7aljQjR5z6WBmcGxgZlB3MDMIGhgHmNyeyqmgN1D1IP1yutxJrenzkRsoBHrn3icqAGYWQ63p85CvD313gpmNtCPEcVn1r9oqvUCa6r1Qt2NTGFviyjphh7MO9S8loV4UxTJ8+ZsH2KLKpUPvZY12/B4yISZTdAxmkPUSZxDOBV9IZEv5hL5Yi7xtDyFL54yfFqeKh+eNnxanqru72AyLY9YLwVirMWOg9PyzqWozcLyidrZvYhy1mQ2USNwEeGsieR8EYEoPM9kWn42Ykfw4pCZAvM80ajy4nKYlseMzyWI0/I7EEf9VPG55ACM+qn+vjTPGvXP5yLgVPzmEYj1AqKGawHh6EX6Yj6BLxYS+WIh8V9lKHr2Lxo+kqPKh5cMH8lR1f2dTEZyiPVSIMZa7Dw4knMuYh7RSG4Rx5HcIuKR3CICUXj1PziSuzRkpsC8SjRSuJTZSG4x4khuJ+JIjio+iw/ADVYXhGjynksDs4RjA7OEuIFZQtDAvM7kBitMAXuaqAfrldcbTG6wWorYQCPWP/EGUQOwtBxusLoM8QarHRXMbKBfJ4rPZaXM7mDc9zI7hP+QIUw9W2b4zOlRkCzHBvFjs5zYbox3pg4kqDuYz8K93HAfyrq9PIQ/i4WYM2I5YjyuMDwesr5cQdAPXUF8H59XfnKWfwWB3W9XMFu7PyOy+x2ivi621iLGR7yD3P+p4yvuh8rvx4Dxfyl1wF4/SVlvYO1jH7cSYrsKcCVgdWjv9pD1u99X8tISx47UJM15sOswYllhKo4nEXAsCqQNKuJSHD4PoFeMfZIaq+ystIzUvNTMLB+hP1Yymbmr5+fBM4BX1j73tFxlJcWakEXaHk3KH1J8+y7YrcpViD3GtYg9J9UPazV+wA7umlD5tYhqK+jzldwirgNOVwPWA675l7aIFK0Nh1Z7nwU7qdciJvUGoqTeYCW1rNDJvn17BlSBTPIZ3iuIpadGRQ5pr2Adk17BWiY8MXsF6nXHa50J4RQJjFd0YDmhgY8mWNg2IwqAaMjEZj+izSczsRkxKcUp5WRz2NsiTkX033FMhmSNfDx4NmbCswkTnqcx4RlmwlMw4ZnKhGeECc80JjzTmfDMYMIzkwnPKBOeWUx4ns6EZ1MmPJsx4dmcCc8zmPBswYRnSyY8WzHh2ZoJzzZMeLZlwrMdE57tmfDswIRnRyY8OzHh2ZkJzy5MeHZlwrMbE57dmfDswYRnTyKeJl8X7FVONoe9LaI3ov9OZHK9qI+PB8++THj2Y8LzTCY8z2LC82wmPPsz4TmACc+BTHgOYsLzHCY8BzPhOYQJz6FMeGYz4ZnDhGcuE555THjGmPDMZ8JzGBOe5zLhOZwJzxFMeI5kwrOACc9RTHiOZsJzDBOeY5nwHMeE53gmPCcw4VnIhOdEJjwnMeE5mQnPKUx4TmXC8zwmPM9nwnMaE57TmfCcwYTnTCY8ZzHheQETnhcy4TmbCc85THjOZcLzIiY8L2bC8xImPOcx4TmfCc8FTHguZMJzEROelzLhuZgJzyVMeC5lwvMyJjyXMeG5nAnPy5nwvIIJzxVMeK5kwnMVE55XMuG5mgnPq5jwXMOE51omPNcx4Xk1E57rmfC8hgnPDUx4XsuE53VMeF7PhOcNTHjeyITnTUx43syE50YmPG9hwnMTE563MuF5GxOetzPhuZkJzzuY8LyTCc+7mPC8mwnPe5jwvJcJz/uY8LyfCc//MeG5hQnPB5jw3MqE54NMeD7EhOfDTHg+woTnNiY8H2XCczsTno8x4fk4E55PMOH5JBOeTzHh+TQTnjuY8HyGCc9nmfB8jgnP55nwfIEJzxeZ8HyJCc+dTHjuYsLzZSY8X2HC81UmPF9jwvN1JjzfYMLzTSY832LC820mPN9hwvNdJjzfY8LzfSY8P2DC80MmPHcz4fkRE54fM+H5CROenzLh+RkTnp8z4bmHCc8vmPD8kgnPr5jw/JoJz2+Y8PyWCc/vmPD8ngnPH5jw/JEJz5+Y8PyZCc9fmPD8lQnP35jw/J0Jzz+Y8PyTCc+/mPD8mwlPWSAHnklMePqZ8Aww4RlkwjPEhGcyE54VmPCsyIRnJSY8KzPhWYUJz6pMeFZjwrM6E541mPCsScTT7+Bp0nvpayHbnIRs6+cBn29FCD/WtZnUyTpJ3n2ZnpOVl5oXjVLWyQCizYeUUx6GvS3i0CQ8/60M8aiPhzGJzeGIsann52HzEYg2X8WkPh7JRMePYsLzaCY8j2HC81gmPOsy4XkcE54pTHgez4TnCUx4nsiEZz0mPOsz4XkSE54NmPBsyITnyUx4nsKE56lMeDZiwrMxE55NmPA8jQnP8H9wLlv8B21OZVIfIwhzUyI7JyeWlp9GGRvMeew0JnOl6YjzhteGeNicgWjzWiZzpZlMtCLKhGcWE56nM+HZlAnPZkx4NmfC8wwmPFsw4dmSCc9WTHi2ZsKzDROebZnwbMeEZ3smPDsw4dmRCc9OTHh2ZsKzCxOeXZnw7MaEZ3cmPHsw4dmTCc9eTHj2ZsKzDxOefZnw7MeE55lMeJ7FhOfZTHj2Z8JzABOeA5nwHMSE5zlMeA5mwnMIE55DmfDMZsIzhwnPXCY885jwjDHhmc+E5zAmPM9lwnM4E54jmPAcyYRnAROeo5jwHM2E5xgmPMcy4TmOCc/xTHhOYMKzkAnPiUx4TmLCczITnlOY8JzKhOd5THiez4TnNCY8pzPhOYMJz5lMeM5iwvMCJjwvZMJzNhOec5jwnMuE50VMeF7MhOclTHjOY8JzPhOeC5jwXMiE5yImPC9lwnMxE55LmPBcyoTnZUx4LmPCczkTnpcz4XkFE54rmPBcyYTnKiY8r2TCczUTnlcR8fQ7eHp9Lkd9RJvXlJPNYW+LWJuE578NTJ5rso5J3lzNhOd6JjyvYcJzAxOe1zLheR0Tntcz4XkDE543MuF5ExOeNzPhuZEJz1uY8NzEhOetTHjexoTn7Ux4bmbC8w4mPO9kwvMuJjzvZsLzHiY872XC8z4mPO9nwvN/THhuYcLzASY8tzLh+SATng8x4fkwE56PMOG5jQnPR5nw3M6E52NMeD7OhOcTTHg+yYTnU0x4Ps2E5w4mPJ9hwvNZJjyfY8LzeSY8X2DC80UmPF9iwnMnE567mPB8mQnPV5jwfJUJz9eY8HydCc83mPB8kwnPt5jwfJsJz3eY8HyXCc/3mPB8nwnPD5jw/JAJz91MeH7EhOfHTHh+woTnp0x4fsaE5+dMeO5hwvMLJjy/ZMLzKyY8v2bC8xsmPL9lwvM7Jjy/Z8LzByY8f2TC8ycmPH9mwvMXJjx/ZcLzNyKefgdPr/+DDiLa/DsTm0OINv/BxOZkRJv/ZGJzBUSb/2Jic0VEm/9mYnMlRJslOQ42V0a0OYmJzVUQbfYzsbkqos0BJjZXQ7Q5yMTm6og2h5jYXAPR5mQmNtdEtLkCE5trIdpckYnNtRFtrsTE5jqINldmYvMhiDZXYWLzoYg2V2Vi82GINldjYvPhiDZXZ2LzEYg212Bi85GINtdkYvNRiDbXYmLz0Yg212Zi8zGINtdhYvOxiDYfwsTmuog2H8rE5uMQbT6Mic0piDYfzsTm4xFtPoKJzScg2nwkE5tPRLT5KCY210O0+WhEm+V1cXlPwI/WjQENAA0BJwNOAZwKaARoDGgCOE2eEyAAqdIvgDRAOiADkAmIArIApwOaApoBmgPOALSw/NAK0BrQBtAW0A7QHtAB0BHQCdAZ0AXQFdAN0B3QA9AT0AvQG9AH0BfQD3Am4CzA2YD+gAGAgYBBgHMAgwFDAEMB2YAcQC4gDxAD5AOGAc4FDAeMAIwEFABGAUYDxgDGAsYBxgMmAAoBEwGTAJMBUwBTAecBzgdMA0wHzADMBMwCXAC4EDAbMAcwF3AR4GLAJYB5gPmABYCFgEWASwGLAUsASwGXAZYBlgMuB1wBWAFYCVgFuBKwGnAVYA1gLWAd4GrAesA1gA2AawHXAa4H3AC4EXAT4GbARsAtgE2AWwG3AW4HbAbcAbgTcBfgbsA9gHsB9wHuB/wPsAXwAGAr4EHAQ4CHAY8AtgEeBWwHPAZ4HPAE4EnAU4CnATsAzwCeBTwHeB7wAuBFwEuAnYBdgJcBrwBeBbwGeB3wBuBNwFuAtwHvAN4FvAd4H/AB4EPAbsBHgI8BnwA+BXwG+BywB/AF4EvAV4CvAd8AvgV8B/ge8APgR8BPgJ8BvwB+BfwG+B3wB+BPwF+AvwEy4ZIAfkAAEASEAMmACoCKgEqAyoAqgKqAaoDqgBqAmoBagNqAOoBDAIcCDgMcDjgCcCTgKMDRgGMAxwLqAo4DpACOB5wAOBFQD1AfcBKgAaAh4GTAKYBTAY0AjQFNAKcBwgABSAVEAGmAdEAGIBMQBWQBTgc0BTQDNAecAWghr7UDWgFaA9oA2gLaAdoDOgA6AjoBOgO6ALoCugG6A3oAegJ6AXoD+gD6AvoBzgScBTgb0B8wADAQMAhwDmAwYAhgKCAbkAPIBeQBYoB8wDDAuYDhgBGAkYACwCjAaMAYwFjAOIB8p718X7x8F7t8z7l8h7h8P7d897V8r7R8Z7N8H7J817B8j698R658/+wsgHxvqnwnqXzfp3yXpnxPpXwHpHy/onx3oXwvoHznnnyfnXxXnHwPm3zHmXx/mHw3l3zvlXynlHxfk3wXknzPkHyHj3w/jnz3jHyvi3xninwfiXzXh3z3hXyvhHzPwtUA+X4A+ex9+Vx7+cx4+Tx2+axz+Rxx+Yxu+fxr+Wxp+dxm+Uxk+bxh+Sxf+Zxc+Qxa+XxX+exU+VxS+cxP+TxN+axK+RxI+YxF+fxC+WxA+dw9+Uw7+bw4+Sw2+ZyzhwHy+Vzy2VfyuVLymU3yeUjyWUPyOT7yGTny+TPy2S7yuSnymSTyeR/yWRryORXyGRDy+Qry2QXyuQDyP/fy/+zyv+Lyf9jyP87y/8Pyv7nyf6/yP6Xy/5ryv5Dyf4byP3zy/3Hyv2fyf13yP1Py/0jyvz7yfzTyPyry/x/yvxXyfwvyPwHyfnt5L7u8T1zegy3vb5b3Dsv7cuU9r7L9lPdqyvsg5T2G8v49eW+cvFdM3jsl7yWS99bIe01k50LeiyCvzctr1fLarbyWKa/tyWtd8tqPvBYirw3IuXI5dyznUuXcopxrk3NPci5Gzk3Isbocu8qxnBzbyL6+7PvKvqDsG8m+gn+v5PhkWy+XBr7ixaLjC1i/y3vG5D1U8p4ieY+NvOdE3oMh70mQ1+jlNWt5DVde05TX+OQ1L3kNSF4TkdcI5Jy5nEOWc6pyjlHOuck5KDknI+co5JhdjmHlmC4FcDxA9oFln1D2keT7Xk7y7b9IfbKXOsr2Y6zP7MLC2KixhSmFY1Ky8/JSJg8vPDdlzKTY+PyCMbJJLuLl9pjWyjnrW589x4+ZNHz0sJSxE3MKhuemTMoumBhLGT46t2DihOFjRqfkZw8viMn+RJFo2cvR1mdudkFB0dkmTIiNLxwyKnvKkJzhhUMmDD9Pdj+K9M3lIWe5P6S/+0MGuT9ksPtDhrk/ZLj7Q8a4P2Sc+0Mmuj9ksvtDZrk/5EL3h8x1f8jF7g9Z4v6Qy9wfstL9IVe6P+Ra94dc7/6Q29wfstn9IXe5P+Qe94c85P6QR9wf8oT7Q55yf8iz7g953v0hr7k/5A33h7zt/pB33R/yqftDPnd/yDfuD/nO/SG/KIc0sj577u0s5GUXZqcUjo/JDkNebEpK3pjYhNENClNGZRfmniu7H6NjE+R8QlHn0WsZvyGU8btSRg3rs/uYwpTs0SljxsbGZxeOGV/kmUDxbq77SfUDrl3cwP0hYfeHpLo/JN39IZnuD2np/pDW7g/p6P6Qzu4P6e7+kJ7uD+nv/pCB7g8Z7P6Qoe4PGe7+kJHuDxnn/pAJ7g+Z7v6Qme4PucT9IfPdH7LI/SGL3R+y0v0hV7o/5Gr3h1zj/pDr3R9yo/tDNrs/5E73h9zj/pD73B/yiPtDHnV/yFPuD9nh/pAXlUMS7Z+8hFDGToQyXlfKiHdy6R2Xx8iuWD17P1/ix8aUY4+0PluNH5891TJyzMTClDH5KTljJo7Om6AeWJDogZM9sJ2nHFvd+uxTmJ07Eo4ck5IXi8m5+KKLBnI52tXebZW9j9+f14SJOYXjs3ML9ydnF9DRawFdfS5dah/YJ9EDc5QD441Fp6R99y/du32svU90tXfXRF1pF9DTawF9fS5dah84MNEDRygHxhuLAa5ikesqFrleY5HrNRa5icYiN9FY5HqIxQhX3h3h1bsjvHp3RKLeHZGod0d48O54VzV9mqtYTPMai2leYzEt0VhMSzQW0zzEYrarWCx0FYuFXmOx0GssFiYai4WJxmKhh1gsc+XdZV69u8yrd5cl6t1liXp3mQfvrnPVk1zntSe5zmtPcl2iPcl1ifYk13noSa53pSMbXdX0jV5r+kavNX1jojV9Y6I1faOHmn6Hq1hscRWLLV5jscVrLLYkGosticZii4dYbHPl3W1evbvNq3e3JerdbYl6d5sH7z7tqqbvchWLXV5jsctrLHYlGotdicZil4dYvOkqFrtdxWK311js9hqL3YnGYneisdjtIRZ7XHl3j1fv7vHq3T2JendPot7d48G7f1nHZns41vVcrX1gQaIHJjJXax8b31xtijXvfbSrvRPuYdsFdPRagOsetn1gn0QPTKSHfUJg3/1L924ja+8TXe2dsALYBfT0WoBrBbAPHJjogYkoQMRVLJq5ikUzr7Fo5jUWzRKNRbNEY9HMQyzauPJuG6/ebePVu20S9W6bRL3bxoN3u7iq6f1cxaKf11j08xqLfonGol+isejnIRaDXMUi5ioWMa+xiHmNRSzRWMQSjUXMQywKXHm3wKt3C7x6tyBR7xYk6t0CD96d4qonOcVrT3KK157klER7klMS7UlO8dCTPM+VjsxxVdPneK3pc7zW9DmJ1vQ5idb0OR5q+gJXsVjuKhbLvcZiuddYLE80FssTjcVyD7FY7cq7q716d7VX765O1LurE/Xuag/e3eCqpm9yFYtNXmOxyWssNiUai02JxmKTh1jc5SoWW13FYqvXWGz1GouticZia6Kx2OohFttdeXe7V+9u9+rd7Yl6d3ui3t3uwbsvW8c28cXj3VesvVu42ruDW4PsA3slYNBbrgx619r7iDL3LnocgFyutj7t7/bjkmRxsrSW1vewt0VUUsrFLj8azkyt5Nt3QeYfqaSUSVB+ql1+kKb8olfLyKXNrH3L9znOG3DspzummrWe5Nt/H/s3v/JbW+s3+RiKw33F+8mlnVJ2kuO39spvfsdvHRyc1N86ztrfLvu3TspvId++57Z95LPKlNuSlW02BztWFX37cmhpfQ97WKLhtGy7/EoE5UNVi9q+CMwqLr+Cw09B5beKjt9Cym82R7nP+da6fKyHHdfGyu8XKeWosbHLUn0borE9luQ4n8+3bx74HOev7CPNS5HkOJ/Nx+kfu+7JR7fY8j4sVrj3Dy5tswuz+46Pxc7a+08W1Q617MYaO1U/qPuo+evcT81H534B5Xslx7HYmubWd/b+yZr9nVoglxoOW9Vjaetpcb2o4NK2ipr9Kyj7hBy2JSu/VXTYVoHGtlSbayWXtlXW7K9qZAWHbao+Vy4f2yKlcS3Ntiqa/SuXYptqd5VSjnO2Ibo6Ea9f7TKIfZhWmk9K82FVzf5VfCX7UPWTfWw13/55l1TCp30e5zZnP0G1o6X1Gfa4VPPtb7OzDa2mbEdsQ7PibUPt81d2cKXSymoOPk7/OONSncY/0SRH+Sqf6hr/2LGsofnNLqum9T2klKXuX12xUd1fXbePV7e1tz5rasqs4uBQw7e/Peo227/qqzvtclWtsGNSQ2NrVcc5dTGtpjlnTc3x9n7E+RClrU/h9GpKmapvbF93d2y3f1PrSkDjl5Bj/3OUMu3JihqOfXQ6qpbtjJ9zvKxuk0tp8VPHdc46lOT4Te2fV3b8pnKo6PhNtcvv+E3X76vm+K7ysn9T+4R2OypzqTRflpZjKv/qjv3tPE4uYX+7PGfe21cSa/v0i12nayllIeZMns2/tsJPp2u1HPzt/fPL4J/kON7ni68PUVuzv+oDm5sdS1Vn7WOJfRctzXdq7Evy3SjrsyTf6eYH1L6FXIKzSGzLkvm5QOHhzImQg5Muvro2Kd742v6r6djfGWvVJ2pZqv+dY8qyclXVbXX/KdZnSfHStbG2D+JtO+y4VphVvB/2WF0uFWcV2xhwnLNou7Xud+zvXA85ts1V7CuyR9nXPk9A2Waf0/ZTsvKbfWxpZQU1ZdXU7J/sKKuCpix1m9qHmmaty7aDMu8yo8XxsX2kxkddgsrv6v7zre8l1VG7/SuybVbxdlVj5GL7IqicX93f9k/Isf9ie1/f3kfqy8U5X6meT+63rpT9kkr4LCpDsy1oHWvHSa1DFHlUeVaxHwKOc6p8/I79neshx7Y1DtuqzNrfbjWP7HPasVVz1D62tLJCmrJqavav6ChLl5PqNjWPllvrlR3nRI6NUOuUrO9jbF4OTtjnpb22lpZx8Npa6Uu819a8XDeropQhl3bKuezy6ji228fa1wto/ZwaJp4Tz3COvdQlnjGiOh/sHOs550l9vn3jZC/ONlG1V5Z/rFKucz8nV7U+OseQai7b+3HoB9g3NpTWD9DVSXU8jVhnMnXzufaiqxe69t5edLG3ecsyYkq5zv2c51RzpKKhvvBr+FP4IknjC50euu2TOed7kx37tLQ+wx6Xmr79/eWcL8K4nqAb5yWXYiN2H8NZP3wE5dPc81B8vUTVXPtc0mdRZbv6mzq34uw/2L+r+zdXymxqrevm/eyYqvOCumtu9ny+7pqeen7791bK+YeUYFOSTz//kOzYv7JSVsCnr186Du2sz7Lm5ipr+Kgcg479q2j46OIZcuzfqQw+zut02P0im39VhZ/uWm0VB397/25l8Hf6x+fb/74Gubi9Xmpz09VP+9hKju9UvlOvWeh8p/pW3d++b7Us3+l8odNgJx91f9UHTt+pfnVe27P3Dfr0uVpF4VDSeeTirDf2rbc6LajsOKakc+ratsqO39T2qGIp5yztfo949ae0fLf3z7U+S5vfjqct0PVTScbworh9UvtVSY5z04xfU0U8/RD1/JV9+7cdFNfzgw4+Tv/YsahlIcmnb2PVslLsg3WdT7twWfnrWusHJ29KXSKkiaF0DIkqm3byxmmLz1f65I1ugqatUl6S47d2mnPVUY755+KHr/gvBqVdMLIreKAU/j7NtiRfyUnjvHlTLi2tz7C7RTg3qJzLss3ZkXEKYdBX+sU3n2Zbkk8vqD7NOQIlHKsr11+KHWUdq/pedwMCp0kgexKstEkg+wFFB/W11OXg5LiPdnI8RSlT5eO8OUo9f8ixr/3gAtl5tC+E0fpVhE2dONVNqDt1rbLG30ma85Q1yVhfKde5n5OrbsJVd3OEvZ88j9oHdNYFubS0PsPeFlHWTRp1HXxL6rOa3i7Us76XdXEgxfr+b7o4MEop17mf85z/9osDbnyRpPHFwYsD+9tx8OJA4ktZE0Itle3qb24vDrRTymxjrZfnxYFOyvmHlWBTko/24kC8k9nldXGgVxl8TL840K8M/k7/+HwHLw7Y+w+yPv+LFwdyrU+dFpTHxYGS9EculBcHRlqfiV4caGmt6/qpBy8O/EcuDoSt9YOTV6Uu1JNXEVMmrwKO/XTHlDbBRSkgEOc0Yj+lEg8w/nliQGlPelDPX5pgxitozieAUAuazjadoNV07K/64EDGQTdY0P2TzO/4LThrf587/5Gh2igb3qOU/XR5Y+9nTxDKyd/2Vlk+xVdyqTBr32NbWtvDHhe7LlH946meYnORPcq+9nm4/ePJnki3JwJP9RWXVVK9UyeB7HW7Y61qg/MCXkBTlm5AJDvMdn0cm507stX4YRNHxUYXTlAFxHkCn6Yg9eT29pIaFOcxAWV/deEw63ua9b20Wd8zrXXmHars8upQEQl8OvGjXbQdKt1f6e361XZWsS/bztqXk72PKuztS9ing7JPB2UfuSR65VHXyWjn+E0dpbR3/KaKjc1Jil5thZdc1MfZJTl+66T8pt5JYh+j3knSzLfv+dW/0ThHk5SPR1LP5/PpO1/2+Sv7SOt7qY/Z0j36r6rlX7nkZhcU9Bw/fFJ2Yaz9xNG5hcPHjFZNUIv1a0wsqZlQq4VzP2dV1PVxnU/VC2nKLel45zb73LpJaueEjDOkzm3O/qvzeLnoUjGphE/7PL4yzqPjTHEBiWh8oL2AZJ9L9wQWp191/ZzSxhW6SXzi8WO6ThLtpZqv7PqiypXbC5PquKKVUq5zPycfnc+d/UhdvdCNW8saTzn9zvGflvHGQ/03pZt4xPtvyoDjN6432bW0vpd1M4Xd7Ou0wqnvqg9Lu0BOMadgx6yki6rJyu/q/h3L8EOSb/+6XJoOOvmo+6s+sLnZvlNzsbQnZBng87ieLqrTXPUCjm5/NYbq/r2tz7KeYKPLU137V1p+23GQ9d+eJ2I+rMw6OKwsfTk4rCx7WFlL4SUX3bCyjmO7feyh1roc/th/SIiNHjcxNjG29wnU9gCoDYyJVIOdgVAXEwc6OkGx+XPoFNjBKatT4FNscd5p0xLBlrB1Ucg+J0H5Yd2dipUdtqqLXZ+CmuOSSvjud3yWtq9zu7qtmuY3db7Gua2S4/MQpTyKhutQmvK1MTpEWT/UYafq55ZIHOzy7DzS6YNz8kW9iKTyS8LnJ3yORTfZYC9qXbF//z+FZgUBPpcFAA==","debug_symbols":"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","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","pack_arguments_oracle_wrapper","call_private_function_internal","enqueue_public_function_call_internal","directive_integer_quotient","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":9,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7V3Rrhy5cf0XPfuhSVYVSf9KEATrxAkWWKwNex0gMPzvmSvdmTvaoVQaks0+1VMvgTZudh8eNc+pas0h//npv/78p3/8z3/8/Ot//+Xvn/74b//89Mtf/vOn337+y6+X//rnv/7w6U9/+/mXX37+n/+4/39/2t7+D/Hn6//+159+ffvPv//2099++/RHSX/49Odf/+vyh3IZ/d8///LnT39MNf7r3//wieTJAZKeHUBPDijPPqE8/YT8zIA/PFyZ4/uVOd+u5Pr5zmW3O9e97ly33e4cdrtz3O3Oabc702535t3uLLvdebc1WHdbg3W3NRi2bb9bh/1uHfe7ddrv1rTfrXm/W8t+t8773brsd+v9VmPYbzWG/VZj2G81hv1WY9hvNYb9VmPYbzWG/VZj2G81hv1WY9xvNcb9VmPcbzXG/VZj3G81xv1WY9xvNcb9VmPcbzXG/VZj2m81pv1WY9pvNab9VmPabzWm/VZj2m81pv1WY9pvNab9ViPttxppv9VI+61G2m810n6rkfZbjbTfaqT9ViPttxppv9XI+61G3m818n6rkfdbjbzfauT9ViPvtxp5v9XI+61G3m81yn6rUfZbjbLfapT9VqMMvteylXq99tIH3K6+fOVrXJ1KDe9XpxrS7epIX8BkJDAFCUwFApM3JDABCUxEApOQwBASGEYCg6TAGUmBM5ICZyQFLkgKXJAUuCApcFmqMxLkenH8uHMs71iWLiZJt4uJH7FUHCx1A8ISgLAMLyS5wxIVLDld391M28eds3zBkoCwEBAWBsIiQFgyEJYChKXCYInbBoRlVHfDh+7GEMawRCAsCQgLAWFhICwChCUDYSlAWCoOltGfSE7FAqS7AUh3A5DuBiDdDUC6G4B0NwDpbgDS3QCkuxFIdyOQ7kYg3Y1AuhuBdDcC6W4E0t0IpLsRSHcjkO4mIN1NQLqbgHQ3gehu4x94suT3i1N5+AeemEBE+nngIIr+PHAQ+X8eOIhXPA8cxFieBw7iQk8DJxDLeh44iL89DxzEDJ8HbtU5RzMZxwG36pxk1TnJqnOSVeckq87JVp2TrTonW3VOtuqco/mp44BbdU626pxs1TnZqnOyVecUq84pVp1TrDqnWHXO53Y0RQJu1TnFqnOKVecUq84pVp0zW3XObNU5s1XnzFadczi9exhwq86ZrTpntuqc2apzZqvOWaw6Z7HqnMWqcxarzvncGRdIwK06Z7HqnMWqcxarzlmsOme16pzVqnNWq85ZcZ2zULoB5/wAHNc5FeC4zqkAH3XOSPEGvIoCPNR6vTpuQh/3jty6eqN6fc3Dxil/df1n9Nk0+mIafTWMPg1vRXEs+mAafTSNPplGT6bRs2n0lr02bZa9Nm2WvTZtpr02mPbaYNprg2mvDaa9dngblWPRm/baYNprg2mvDaa9Npj22mjaa6Npr42mvTaa9trhrXN2Rc+3b7CXP7M8oof2WhU9tNeq6KG9VkUP7bUqemiv1dAnaK9V0UN7rYoe2mtV9NBeq6LH1vu7SkHe7vh79NCaI3yHPocH9AStOSp6aM1R0UNrjooeWnNU9GQaPXR9r6KH1nsVPXR9r6KHru9V9KNee7nR9dpU81fo3+4/vPeLdv+w8/3jzvdPO9+fdr4/73x/2ff+wxsV0G2BCVXWVu9d4c757t7NHwaypO39apa8affe8nZb6m9Yv3v1d7d+TcO7IJyTleSsNFghZ6XBCjsrDVbEWWmwkp2VBivFWWmwUp2VR1aGd/s4Jyte27ZY8dq2xYrXti1WyFlpsOK1bYsVr21brHht22LFa9sWK17bNlgpXtu2WPHatsWK17YtVry2bbFCzkqDFa9tW6x4bdtixWvbFite27ZY8dq2wUr12rbFite2LVa8tm2x4rXt4F5saXhLM6ewetU8TKGX2MMUej0+TKEX78MUeqU/SCFt3hYMU+g9xDCF3nAMU+jdyTCF5BSOUujdyTCF3p0MU+jdyTCF3p0MU+jdySiFwbuTYQq9Oxmm0LuTYQq9OxmmkJzCUQq9Oxmm0LuTYQq9Oxmm0LuTYQq9OxmlMHp3MkyhdyfDFHp3MkyhdyfDFJJTqFL43dMnKXp3MkyhdyfDFJ6nO4lM13svP4OB4nlalGN5PE+fciiP6TzNyrE8nqdjOZbH87Qtx/J4nt7lWB7JeZzC43m6mGN5PE8rcyyP3s/M4dH7mTk8ej8zhUfyfmYOj97PzOHR+5k5PHo/M4dHch6n8Oj9zBwevZ+Zw6P3M3N49H5mDo/ez0zhkb2fmcOj9zNzePR+Zg6P3s/M4ZGcxyk8ej8z49x3Yu9n5vDo/cwcHr2fmcOj9zNTeBTvZ+bw6P3MHB69n5nDo/czc3gk53EKj14//hiPd32hvN3xdzye6FzXXXkUvuMxh0ce3a/n8Oh+PYdH9+s5PLpfz+HRvz/O4dG/P87h0evHOTz698c5PPr3xyk8Yp/lm695fc5UlHvH8MFMlPrV1Z9nCt1xTJ0pdE8wdabQVfvUmdLLzBS68p06U+jadOpMoavHqTNdW9/JFq4zlVi/mulnNBUJzeKzVTU0AQpNhEKToNAQFJq1/iSpXtFkVcv037UtPtRxNvpsGn0xjb4aRs+LD/CbjT6YRh9No0+m0ZNp9Ja9ljfLXsubZa/lzbLX8mbaa4Nprw2mvTaY9tpg2msXHz00G71prw2mvTaY9tpg2muDaa+Npr02mvbaaNprI7TXKr9n58UHacxGD+21Knpor1XRQ3utih7aa1X00F6roU/QXquih/ZaFT2016rosfX++5knTtCao/zCkRO05mjoCVpzVPTQmqOih9YcFT10fa+iJ9PoofVeRQ9d36vooet7Db1go0/0gZ7SI3rsSkFDj10pKOgzdqWgoceuFDT02JWChh67UtDQk2n02JWChh67UtDQm/babNprs2mvLaa9tpj22mLaawu218aP07QlNdBje62GHttrNfTYXquhx/ZaDT2212rosb1WQV+xvVZDj+21Gnpsr9XQm/ba1anHyehNey12SlJF73vj/NjeON+v1WXzvT7n8Oh7fc7h0ff6nMOj7/U5h0dyHqfw6Ht9zuHR9/qcw6Pv9TmHR9/rcw6P3s9M4TF4PzOHR+9n5vDo/cwcHr2fmcMjOY9TePR+5sd4/P53XAnez8zh0fuZOTx6PzOHR+9npvAYvZ+Zw6P3M3N49H5mDo/ez8zhkZzHKTx6PzOHR+9n5vDo/cwcHr2fmcLj8M4yka54ZP3XquGdZY5Fn0yjJ9Po2TR6MY0+m0ZfTKOvltEP76h0LHrTXkumvZZMe+3wjkrHojfttWTaawnba5XuhLC9VkOP7bUKesb2Wg09ttdq6LG9VkOP7bUaemyv1dBje62GHttrNfSmvZZNey2b9lox7bUyqvdbuWaoJaSgoJcgt6l+3DkW+oKFlmKhcr1Y0iMWBsIiQFgyEJYChKXiYBnekXQmlrAUy21Dh8uHi0csEQhLAsJCQFgYCIsAYclAWAoQloqDpWxAWIB0twDpbgHS3QKkuwVIdwuQ7pal+pJKDe9XpxruqqkvYOqGBCYggYlIYBISGEICU2C+NuQNxyHzhuOQecNxyLzhOGQe3i1okzssUcFCcu2q6e6bYGL+gkWAsGQgLAUIS8XBMrwDyUwsAQhLBMKSgLAQEBYg3Q1Aujucrg8f3hhDGMNSgLBUHCzDSemZWAIQlgiEJQFhISAsDIRFgLAA6W4E0t0IpLsJSHcTkO4mIN1NQLqbgHQ3AeluAtLdBKS7CUh3E5DuEpDuEpDuEpDuEpDuEpDuEpDuEpDuEpDuEpDuEpDuMpDuMpDuMpDuMpDuMpDuMpDuMpDuMojuNv6RP8t1/51UHv6RPzOISD8PHETRnwYuIPL/PHAQr3geOIixPA8cxIWeBw5iWc8DB/G354GDmOHzwK06p1h1TrHqnNmqc2arzpmtOme26pzD8a7DgFt1zmzVObNV58xWnTNbdc5i1TmLVecsVp2zWHXO4YDeYcCtOmex6pzFqnMWq85ZrDpnteqc1apzVqvOWa0653Dq9DDgVp2zWnXOatU5q1XnrEads2xGnbNsRp2zbEads2xGnbNsRp2zbEads2xGnbNsRp2zbEads2xWnTNYdc5g1TmDVecMVp1zeNOCw4Bbdc5g1TlR9k54HrhV50TZleFp4ChbODwP3KpzomwO8Txwq86Jsu3E88CtOifKhhbPA7fqnChbZTwPHNc5y+1k7VQ4/x44yiYczwPHdU4FOPTRY1Svr3nYOOWvrv+MHvroMRU9mUYPffSYih766DEVPfTRYyp66KPHVPTQR49p6LGP1FbRQx/zqaI37bXYR2qr6E17LfaR2ip6016LfaS2it6012Ifqa2hxz5SW0Vv2muxj9RW0Zv2WuwjtVX0pr0W+0htFb1pr8U+UltFb9prsY/U5ts32MufWR7RQ3utih7aa1X00F6roof2WhU9tNeq6KG9VkUP7bUqemivVdFDe62GPmPr/V2lIG93/D16aM0RvkOfwyN6aM1R0UNrjooeWnNU9NCao6Ev0PW9ih66vlfRQ+u9ih66vlfRk2n0o157udH12lTzV+g/3192vn/e+f5l5/vXfe8/vC+Jdv+w8/3jzvcffX/otsCEKmurN8l19YZ7NO0fBrKk7f1qlrxp997ydlvqb1i/e/V3t6kvw7sgnJOV6qw8sFKH9284JyvBWWmwEp2VBivJWWmwQs5KgxV2VhqsiLPSYMVr2xYrXtu2WPHatsFK8Nq2xYrXti1WvLZtseK1bYsVclYarHht22LFa9sWK17btljx2rbFite2DVai17YtVry2bbHitW2LFa9tW6yQs9JgxWvbFite27ZY8dq2xYrXti1WvLZtsJK8tm2x4rVtixWvbVuseG3bYoWclQYrXtu2WPHatsWK17a/Y+Xx2u/vHVuTF8LDFHrVPEoheYk9TKHX48MUevE+TKFX+sMUklM4SqH3EMMUesMxTKF3J8MUencyTKF3J6MUsncnwxR6dzJMoXcnwxR6dzJMITmFoxR6dzJMoXcnwxR6dzJMoXcnwxR6dzJKoXh3MkyhdyfDFHp3MkyhdyfDFJJTOEqhdyfDFHp3MkyhdyfDFHp3MkyhdyejFGbvToYp9O5kmELvTnQKy+0ckFQ4P1Do3ckwheQUjlJ4nu4kMl3vvfz8vJrP06Icy+N5+pRjeTxPs3Isj+fpWA7lsZynbTmWx/P0LsfyeJ4G5lgez9PFHMsjOY9TePR+Zg6P3s/M4dH7mTk8ej8zh0fvZ6bwWL2fmcOj9zNzePR+Zg6P3s/M4ZGcxyk8ej8zh0fvZ+bw6P3MHB69n5nDo/czM3gM24kOCj6YSO9oJhHpLc0kIr2n+SEi+fZLqcufWRpEkhM5h0jvaiYR6W3NJCK9r5lEpDc2k4j0zmYOkSc6JvpgIr2zmUSkdzaTiPQ68seIvGsR5e2OD0S6a/8QkcJ3RObQINJdew6RJzoA92Ai3bUnEemuPYlI/x45iUhyIucQ6XXkJCL9e+QkIv175CQioTubLFciMxXl3jF8UBOlfnX1l6lC9x5Tp4p9hPDcqULX73OnCl1hz50qdA08d6r0OlOFriPnTnVtpUfxtj8O3YF/m+oXOBkLTsGCU6HgLD6dVIUTsOBELDhrnYr4urdV4FIUTfuBH78tPv1xOny2DV9sw8+24Rfb8Ktp+ItPuZsOP9iGH23Dt+26i081mw7ftuuybddl267Ltl2Xbbuu2HZdse26Ytt1xbbrLj6tZzp8264rtl1XbLuu2HZdse262bbrZmjXVX8Gn6FdV4cP7bo6fGjX1eFDu64OH9p1dfjQrqvDh3ZdHT6066rwC7Tr6vCxdV/LTBVo5VF/GFmglUeHD608Onxo5VHhV2jl0eFD1/s6fOh6X4cPrfs6fLINH7re1+CHgA0/0Qd8Sg342EWDCh+7aFDhYxcNKnzsokGDH7GLBhU+dtGgwscuGlT42EWDCp9sw7ftutG260bbrhttu2607brJtusmbNf9CE9cptKCj+26Knxs11XhY7uuCh/bdVX42K6rwsd2XRU+tuuq8LFdV4NP2K6rwrftumTbdbEjlzp8265LvvXOj229o5Xu5JuKTiLSNxWdQyT7pqKTiPRNRScR6ZuKTiLSNxWdRCQ5kXOI9E1FJxHpm4pOItI7m0lEemcziUjvbOYQKd7ZTCLSO5tJRHpnM4lI72x+jEjtw+7i7RFOTKR3NpOI9M5mEpHe2Uwi0jubSUR6ZzOHyOydzSQivbOZRKR3NpOI9M5mEpHkRM4h0jubSUR6ZzOJyNE6MtIVkBzw8Wp4i5qD4Qfb8KNt+Mk2fLINn23DF9vws234xTZ8265bbbtute261bbrVtuuO7w908HwsV1Xa1cqtuuq8LFdV4WP7boqfGzXVeDHDdt1VfjYrqvCx3ZdFT6266rwsV1XhW/adS83sQ3ftOvGzbTrxjCq+1up12tDCgp8CXKb68edY6F3MHEpGLpGx0VSA0xCAkNIYBgJjCCByUhgChKYuhRMul1M/AhmeC/SqWACEpiIBCYhgSEkMIwERpDAZCQwBQkMkgInJAVOSAqckBQ4ISlwQlLgtFRnUqnh/epUw115dUVToNBUJDS0QaEJUGgiFJoEhYag0DAUGoFCA6XFBKXFBKXFDKXFDKXFvFRvlC+xjNRGMVIbxUhtlCC1UcObZ2xyByYqYHK+/stGznf/DsL5HUxEApOQwBASGEYCI0hgRhU4fCzty7/yDYIpSGAqEJjhgPJUMAEJTEQCk5DAEBIYRgIjSGCQFDgjKXBGUuCCpMAFSYELkgIXJAUuSApckBS4IClwQVLggqTABUmBK5ICVxAFbnwAzHLd1SCVxgfACiLXHchBtL0DOYgRdCAHcY0O5CAW04EcxI86kIOYVwdyEKd7GnnaQGyxA7lVD02bVQ9Nm1UPTZtVD02bVQ9Nm1UPTZtVD02bVQ9Nm1kPDWY9NJj10GDWQ4NZDx3O9x2H3KyHBrMeGsx6aDDrocGsh0azHhrNemg066HRrIcOJzSPQ27WQ6NZD41mPTSa9dBo1kOTWQ9NZj00mfXQZNZDhzO2xyE366HJrIcmsx6azHpoMuuhZNZDCddDC6Ubcs6PyHE9VEOO66Ea8lEP3XVHQKrXVz1snPJX13+BD70bpg4fejdMHT70bpg6fOjdMHX40HtQq/AZeg9qHT70HtQ6fOg9qHX40HtQ6/Btuy7bdl227bps23XZtuuybdcV264rtl1XbLuu2Hbd4c1EDoZv23XFtuuKbdcV264rtl0323bdbNt1M7Tr8u0D7eXPLA340K6rw4d2XR0+tOvq8KFdV4cP7bo6fGjX1eFDu64Kv0C7rg4f2nV1+Ni6f1c0yNsdH+Bjn/TGd/BzaMDHPulNhY99vqoGH/xUcxU+9vmqKnzs81VV+Njnq6rwoXVfh499vqoKH/t8VRX+qOte7nS99nKzr+B/eUDZ+wF13wfQ8E4t6gPC3g+Iez8g7f0A2vsBo28R3VaaUGVlGceQ6LqMA8WPe7/vU0fDOxtMhhOw4EQsOAkLDmHBYSw4ggUnY8EpWHCwVDliqXLEUuWIpcoRS5UjlipHLFWOWKocsVQ5YqlyxFLlhKXKCUuVE5YqJyxVTliqnLBUOWGpcsJS5YSlyglLlQlLlQlLlQlLlQlLlQlLlQlLlQlLlQlLlQlLlQlLlRlLlRlLlRlLlRlLlRlLlRlLlRlLlRlLlRlLlRlLlQVLlQVLlQVLlQVLlQVLlQVLlQVLlQVLlQVLlQVLlTOWKmcsVc5YqpyxVDljqXLGUuWMpcoZS5UzlipnLFUuWKpcsFS5YKlywVLlgqXKBUuVC5YqFyxVLliqXLBUuWKpcsVS5YqlyhVLlSuWKlcsVa5YqlyxVLliqXKFUmXeoFSZNyhV5g1KlXmDUmXeoFSZNyhV5g1KlXmDUmXeoFSZsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsH2Nl+xgr28dY2T7GyvYxVraPsbJ9jJXtY6xsn2Bl+wQr2ydY2T7ByvbJBqXKgpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrZPsLJ9gpXtE6xsn2Bl+wQr2ydY2T7ByvYJVrYvY2X7Mla2L2Nl+zJWti9vUKqcsbJ9GSvbl7GyfRkr25exsn0ZK9uXsbJ9GSvbl7GyfRkr25exsn0ZK9uXsbJ9GSvbl7GyfRkr25exsn0ZK9uXsbJ9GSvbl7GyfRkr25exsn0ZK9uXsbJ9GSvbl7GyfRkr25exsn0ZK9uXsbJ9GSvbl7GyfRkr25exsn0ZK9uXsbJ9GSvbl7GyfRkr25exsn0ZK9uXsbJ9GSvbl7GyfRkr25exsn15dbYvhBuclL6C89zVX8Any+DJMni2DF4sg8+WwRfL4Kth8KuzlHPBB8vgLTusWHbY1RnQueAtO6xYdlix7LBi2WHFssNmyw6bLTtstuyw2bLDrs7zzgVv2WGzZYfNlh02W3bYbNlhi2WHLZYdtlh22GLZYVdns+eCB3bYt28b71eHXItyNUva3q9myZuCJGz5evXlgqhcnW8XX+qpBonATm+HROCKww6JwJWPHRKBKzAzJFbgStAOicAVqR0SgStjOyQCV+h2SCQncZxE71gmkOgdywQSvWOZQKJ3LBNI9I5lmMSyeccygUTvWCaQ6B3LBBK9Y5lAIjmJ4yR6xzKBRO9YJpDoHcsEEr1jmUCidyxDJD5em7JcGUklfMwx0hfGg7c3qxn3Xmg14944rWbcu6zVjJMzvphx799WM+7N3mrGvTNczbi3kasZ955zMePRe87VjHvPuZpx7zlXM+4952rGyRlfzLj3nKsZ955zNePec65m3HvO1Yx7z7mY8eQ952rGvedczbj3nKsZ955zNePkjC9m3HvO1Yx7zzmb8ULpxvjbFb9n3HvO1Yx7z7ma8VftOSNfT9IIsYp2da3xinuTO84jN/82qebbXyen/NX1n2mnV208D6b9VbvPg2l/1Rb0YNpftQ89mHZy2o+g/VU70oNpf9W29GDaX7U3PZj2V21QD6bdu9QjaGfvUg+h3bvUQ2j3LvUQ2r1LPYR2ctqPoN271ENo9y71ENq9Sz2Edu9SD6Hdu9QjaEc+C/vMtHuXegjt3qUeQrt3qYfQTk77EbR7l3oI7d6lHkK7d6k70M63H55e/szSoN271ENo9y71CNqzd6mH0O5d6iG0e5d6CO3epR5COzntR9DuXeohtHuXegjtXrfvQfvdxwF5u+PvaS9eyexAu/Ad7Tk0aPdK5hDayWk/gnavZA6h3SuZQ2j37+2H0O7f2w+h3ev2I2iv/r39ENr9e/shtJ+oS81ypT1TUZF8EBmlfnX1F2JO1EfOJYacmDYxJ+rF5hJzom5pLjEn6mfmEnOijmMuMSfqCWYSUzfkqr1s5UpMTVW7Wv3dYd2Qa+Xpk0WuUKdPFrnqnD5ZeqXJIleH0yeLXPFNnyxyFTd9ssiV2fTJIldbsycbXqmCCq9UQYVXqqDCK1VQgV5psq9UQYVXqqDCK1VQ4ZUqqPBKFRT0QfTTJ/tKFRT08evTJ/tKFRT0oePTJ/tKFRT0UdvTJ/tKFRT0AdPTJ3uiCkqLKlXoY5WnT/ZEFZQ+2RNVUPpkT1RB6ZOlV5rsiSoofbInqqD0yZ6ogtIne6IKSp0s9NmNz05WSR1X6DPknpys9uP1Cn1y2/TJnkiN9cmeSI31yZ5IjfXJnqifVScLfQ7W9MmeyGf1yZ6on9Une6J+Vp0s9FZoz0420cdkKTUmS6802TOVi+pkz1QuqpM9U7moTvZM5aI62TOVi9pky5nKRXWyZyoX1cmeqVxUJ/tKFRT0xmfTJ/tKFRT0Jl/TJ3umCipuH5NNrcmeqYJSJ3umCkqbLPTmTdMne6YKSp3smSoodbJnqqDUydIrTfZMFZQ62TNVUOpkX6mCgt6gZ/pkX6eCituZNtLRJ+ubxe+x6eT3m80L7eS0H0G7bxZ/CO2+WfwhtPtm8YfQ7pvFH0K7bxZ/BO3QmyadmHbfLP4Q2v1Is0No9y71ENrJaT+Cdu9SD6Hdu9RDaPcu9RDavUs9hHbvUvegXftnDuiN6U5Mu3eph9DuXeohtHuXegjt5LQfQbt3qYfQ7l3qIbR7l3oI7d6lHkK7d6lH0A69+eeJafcu9RDavUs9hPbRuj3SFZAc8AF1eEvOg+Fn2/CLbfjVNHzabMMPtuFH2/CTbfhkG75t1yXbrku2XZdsuy7Zdl227bqM7bpau8LYrqvCx3ZdFT6266rwsV1XhY/tuip8bNdV4WO7rgof23U1+ILtuip8264rtl1XbLuu2HZdGdX9rdTrtSEFBb4Euc31486x0DuYshQMXbfnEEkNMBUITN6QwAQkMBEJTEICQ0hgeCmYdLuYuAFGkMBkJDAFCUwFAlM2JDABCUxEApOQwBASGCQFLkgKXJAUuCApcEFS4IqkwO1dFlNMVzgp5o9mLraeULPcerPt44dIzU5O5IYm5/tL38CE9i6IR4EJa8HUa92ZAz2CiYvBXH/llu/72yuYhASGloLJt9/RZYmPYBgJjKwFU6+/dSxbYzXlxWCu34tKDI9gylIwJV1f4NL6a6pHgWmIXntnrZSYr2BSTfdgvowKXaPampaofndU+sao8N1R1DWKe0a1//H7Mt3rvELIdx5P76OabIT4cc52lPA4KnWNoq5R3DVKukbl9qjMt1G1wWHpGdX+d4fLX+PtkzOHR4Ttz/3qKOoaxV2jpGtUm3m5ydHlvtvjqNI1qvaMan9DVkeFrlGxa1TqGkVdo7hrlHSN6no3cte7kbvejdL1bpSud6N0vRul690oXe9G6Xo3yjfejXL9F7vLCoyPo3LXqNI1qvaMqlvXqNA1KnaNSl2j2n/LFG+jiB51vn1KiDoqd40qXaNqx6jY/oagjgpdo2LXqNQ1irpGcdco6RqVu0Z94934ODCc8vY4qvaMClvXqNA1KnaNSl2jqGsUd42SrlG5a1TXuxG63o3Y9W7Erncjdr0bsafjiJG6RnHXqJ6OI7YT6JfPVx90bJLvxr1/rIjtDPWlSr2L0TYeF7tGpa5R1DWqTX4pt688dePHUdI1KneNKl2jas+odgBRHRW6RsWuUalrFHWN6no3qOvdoK53g7reDep6N7jr3eCud4O73o32B7q37fLeR72F4x9HUdco7holPaPaP5W+1BTXj5wxlviVZLd+1kn1Q+I55UeJb/+kef5j4prHpDWPoTWP4TWPkTWPyWseU9Y8pi55TF6jAnmNCuQ1KpDXqEBeowJ5jQrkNSqQ16hAXqMCeY0KlDUqUNaoQFmjAmWNCpQ1KlDWqEBZowJljQqUNSpQpqgAf/yD/cYsj4+p25rHhDWPiWsek9Y8htY8htc8RtY8Jq95TFnzmCUqkLY5r8Cdpsnbz5ofHjOFNO0Lc9rqkseEbc1jwprHxDWPSWseQ2sew2seI2sek9c8Zs7yVHYzSnFb85iw5jFxzWPSmsfQmsfwmsfImsfkNY8pax6zRgXSGhVIa1QgrVGBtEYF0hoVSHNUQNnLJCVZ85i85jFlzWPqksfQtuYxYc1j4prHpDWPoTWPWaMCtEYFaI0K0BoVaP9II91yknT3MeFzCuvhWqnX33Nk/njAW8zr4VKS6205bveXfoGScKAQDhTGgSI4UDIOlIIDpS6EwvF6KUv+/qVhy+EmQ+Uub/v+46jU/nGUBeDBKvBoFHj735nKLQNd7sDcxrR/A7px/DBHfhwlXaNy16jSNar9G9DvB6fpG4EfbVToGhW7RqWuUdQ1irtGSdeo3DWqdI3qejdC17sRut6N0PVuhK53I3S9G+2P/9/VGvpGcGcLH59K0uOob4RptFGha1TsGpW6RlHXqB69pihdo3LXqNI1qvaM+lbcRxkVukbFrlHfeDdu20VdrDw+jqKuUdw1SrpG5a5RpWtU7RlF+rvRGtX1blDXu/GNrI82irpGdekGdekGdekGdekGdekGd+kGd70b3PVucNe7wV3vBne9G9z1t8xdf8vc9bcsT/8t/+vyX//7099+/ulPv/z575cxb//jP379z99+/suv7//52//99cv/crn4/wE=","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"1405":"Array index out of bounds","1332":"attempt to add with overflow","881":"Array index out of bounds","1262":"Array index out of bounds","875":"attempt to add with overflow","808":"attempt to add with overflow","485":"SharedImmutable already initialized","939":"attempt to add with overflow","287":"attempt to add with overflow","156":"attempt to add with overflow","796":"Array index out of bounds","1244":"attempt to add with overflow","1314":"Array index out of bounds","592":"Not initialized","269":"Array index out of bounds","784":"attempt to add with overflow","842":"attempt to add with overflow","1296":"attempt to add with overflow","961":"attempt to add with overflow","446":"Initializer address is not the contract deployer","1421":"attempt to add with overflow","440":"Initialization hash does not match","824":"Array index out of bounds","754":"Array index out of bounds","943":"Array index out of bounds","1397":"Array index out of bounds","1321":"Array index out of bounds","925":"attempt to add with overflow","858":"Array index out of bounds","1047":"Array index out of bounds","276":"Array index out of bounds","1233":"Array index out of bounds","904":"Stack too deep","898":"attempt to add with overflow","831":"Array index out of bounds","950":"Array index out of bounds","1270":"attempt to add with overflow","1389":"Array index out of bounds","1066":"attempt to add with overflow","1310":"attempt to add with overflow","789":"Array index out of bounds","597":"Function _publish_donation_receipts can only be called internally","265":"attempt to add with overflow","777":"attempt to add with overflow","1155":"SharedImmutable already initialized"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Crowdfunding"}},{"name":"fields","value":{"fields":[{"name":"donation_token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"operator","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"deadline","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"donation_receipts","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"events":[{"fields":[{"name":"who","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"Crowdfunding::WithdrawalProcessed"}],"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"donation_token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"operator","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"deadline","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"Crowdfunding::init_parameters"}}],"kind":"struct","path":"Crowdfunding::init_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"Crowdfunding::donate_parameters"}}],"kind":"struct","path":"Crowdfunding::donate_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"Crowdfunding::withdraw_parameters"}}],"kind":"struct","path":"Crowdfunding::withdraw_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Crowdfunding::_publish_donation_receipts_parameters"}}],"kind":"struct","path":"Crowdfunding::_publish_donation_receipts_abi"}]}},"file_map":{"101":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"120":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"141":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest,\n};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission,\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"142":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize},\n};\n\n// Just like PublicImmutable but with the ability to read from private functions.\npub struct SharedImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // Intended to be only called once.\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"154":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: Header,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"},"160":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/unencrypted_logs/unencrypted_event_emission.nr","source":"use crate::{context::PublicContext, event::event_interface::EventInterface};\nuse dep::protocol_types::traits::Serialize;\n\nfn emit<Event, let N: u32, let M: u32>(context: &mut PublicContext, event: Event)\nwhere\n    Event: EventInterface<N>,\n    Event: Serialize<N>,\n    [Field; N]: LensForEventSelector<N, M>,\n{\n    let selector = Event::get_event_type_id();\n\n    let serialized_event = event.serialize();\n    let mut emitted_log = [0; M];\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    for i in 0..serialized_event.len() {\n        emitted_log[i] = serialized_event[i];\n    }\n\n    emitted_log[serialized_event.len()] = selector.to_field();\n\n    context.emit_unencrypted_log(emitted_log);\n}\n\npub fn encode_event<Event, let N: u32, let M: u32>(\n    context: &mut PublicContext,\n) -> fn[(&mut PublicContext,)](Event) -> ()\nwhere\n    Event: EventInterface<N>,\n    Event: Serialize<N>,\n    [Field; N]: LensForEventSelector<N, M>,\n{\n    |e: Event| { emit(context, e); }\n}\n\ntrait LensForEventSelector<let N: u32, let M: u32> {\n    // N = event preimage input in fields\n    // M = event preimage input in fields + event selector as field\n    fn output(self: [Field; N]) -> [Field; M];\n}\n\nimpl LensForEventSelector<1, 2> for [Field; 1] {\n    fn output(self) -> [Field; 2] {\n        [self[0] as Field; 2]\n    }\n}\nimpl LensForEventSelector<2, 3> for [Field; 2] {\n    fn output(self) -> [Field; 3] {\n        [self[0] as Field; 3]\n    }\n}\nimpl LensForEventSelector<3, 4> for [Field; 3] {\n    fn output(self) -> [Field; 4] {\n        [self[0] as Field; 4]\n    }\n}\nimpl LensForEventSelector<4, 5> for [Field; 4] {\n    fn output(self) -> [Field; 5] {\n        [self[0] as Field; 5]\n    }\n}\nimpl LensForEventSelector<5, 6> for [Field; 5] {\n    fn output(self) -> [Field; 6] {\n        [self[0] as Field; 6]\n    }\n}\nimpl LensForEventSelector<6, 7> for [Field; 6] {\n    fn output(self) -> [Field; 7] {\n        [self[0] as Field; 7]\n    }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"165":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"166":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"177":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"190":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"274":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"333":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot: Field,\n    value: Field,\n    next_slot: Field,\n    next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"339":{"path":"/usr/src/noir-projects/noir-contracts/contracts/router_contract/src/utils.nr","source":"use aztec::protocol_types::constants::ROUTER_ADDRESS;\nuse aztec::context::private_context::PrivateContext;\nuse crate::Router;\n\n// docs:start:helper_router_functions\n/// Asserts that the current timestamp in the enqueued public call enqueued by `check_timestamp` satisfies\n/// the `operation` with respect to the `value. Preserves privacy by performing the check via the router contract.\n/// This conceals an address of the calling contract by setting `context.msg_sender` to the router contract address.\npub fn privately_check_timestamp(operation: u8, value: u64, context: &mut PrivateContext) {\n    Router::at(ROUTER_ADDRESS).check_timestamp(operation, value).call(context);\n}\n\n/// Asserts that the current block number in the enqueued public call enqueued by `check_block_number` satisfies\n/// the `operation` with respect to the `value. Preserves privacy by performing the check via the router contract.\n/// This conceals an address of the calling contract by setting `context.msg_sender` to the router contract address.\npub fn privately_check_block_number(operation: u8, value: Field, context: &mut PrivateContext) {\n    // docs:start:enqueueing\n    Router::at(ROUTER_ADDRESS).check_block_number(operation, value).call(context);\n    // docs:end:enqueueing\n}\n// docs:end:helper_router_functions\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"340":{"path":"/usr/src/noir-projects/noir-contracts/contracts/router_contract/src/main.nr","source":"mod test;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n/// The purpose of this contract is to perform a check in public without revealing what contract enqued the public\n/// call. This is achieved by having a private function on this contract that enques the public call and hence\n/// the `msg_sender` in the public call is the address of this contract.\n#[aztec]\ncontract Router {\n    use aztec::{macros::functions::{private, public, view, internal}, utils::comparison::compare};\n\n    // docs:start:check_timestamp\n    /// Asserts that the current timestamp in the enqueued public call satisfies the `operation` with respect\n    /// to the `value.\n    #[private]\n    fn check_timestamp(operation: u8, value: u64) {\n        Router::at(context.this_address())._check_timestamp(operation, value).enqueue_view(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    #[view]\n    fn _check_timestamp(operation: u8, value: u64) {\n        let lhs_field = context.timestamp() as Field;\n        let rhs_field = value as Field;\n        assert(compare(lhs_field, operation, rhs_field), \"Timestamp mismatch.\");\n    }\n    // docs:end:check_timestamp\n\n    /// Asserts that the current block number in the enqueued public call satisfies the `operation` with respect\n    /// to the `value.\n    #[private]\n    fn check_block_number(operation: u8, value: Field) {\n        Router::at(context.this_address())._check_block_number(operation, value).enqueue_view(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    #[view]\n    fn _check_block_number(operation: u8, value: Field) {\n        assert(compare(context.block_number(), operation, value), \"Block number mismatch.\");\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"353":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        oracle::random::random,\n        prelude::{\n            NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n            FunctionSelector,\n        },\n        encrypted_logs::{\n            encrypted_note_emission::{\n                encode_and_encrypt_note, encode_and_encrypt_note_unconstrained,\n                encrypt_and_emit_partial_log,\n            }, encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n        }, keys::getters::get_public_keys,\n        macros::{\n            storage::storage, events::event,\n            functions::{initializer, private, view, public, internal},\n        }, utils::comparison::Comparator, protocol_types::{point::Point, traits::Serialize},\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote, token_note::TokenNote, balance_set::BalanceSet,\n    };\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[event]\n    #[derive(Serialize)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<TokenNote, Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote, Context>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: SharedImmutable<FieldCompressedString, Context>,\n        name: SharedImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n    // docs:start:mint_public\n    #[public]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n    // docs:start:mint_private\n    #[public]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[private]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_public_keys(caller);\n        storage.balances.at(caller).add(caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller),\n        );\n        Token::at(context.this_address())\n            .assert_minter_and_mint(context.msg_sender(), amount)\n            .enqueue(&mut context);\n    }\n    #[public]\n    #[internal]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n    // docs:start:shield\n    #[public]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n    // docs:start:transfer_public\n    #[public]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n    // docs:start:redeem_shield\n    #[private]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options\n            .select(TransparentNote::properties().amount, Comparator.EQ, amount)\n            .select(TransparentNote::properties().secret_hash, Comparator.EQ, secret_hash)\n            .set_limit(1);\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n        storage.balances.at(to).add(to_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to),\n        );\n    }\n    // docs:end:redeem_shield\n    // docs:start:unshield\n    #[private]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                from_keys.ivpk_m,\n                from,\n            ),\n        );\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n    }\n    // docs:end:transfer\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n    // docs:start:transfer_from\n    #[private]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            from_keys.ivpk_m,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            to_keys.ivpk_m,\n            to,\n        ));\n    }\n    // docs:end:transfer_from\n    // docs:start:burn\n    #[private]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_keys = get_public_keys(fee_payer);\n        let user_keys = get_public_keys(user);\n\n        let fee_payer_npk_m_hash = fee_payer_keys.npk_m.hash();\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                user_keys.ovpk_m,\n                user_keys.ivpk_m,\n                user,\n            ),\n        );\n\n        // 4. Now we get the partial payloads\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let fee_payer_randomness = unsafe { random() };\n        let user_randomness = unsafe { random() };\n\n        let fee_payer_setup_payload = TokenNote::setup_payload().new(\n            fee_payer_npk_m_hash,\n            fee_payer_randomness,\n            storage.balances.at(fee_payer).set.storage_slot,\n        );\n\n        let user_setup_payload = TokenNote::setup_payload().new(\n            user_npk_m_hash,\n            user_randomness,\n            storage.balances.at(user).set.storage_slot,\n        );\n\n        // 5. We encrypt and emit the partial note log\n        encrypt_and_emit_partial_log(\n            &mut context,\n            fee_payer_setup_payload.log_plaintext,\n            fee_payer_keys,\n            fee_payer,\n        );\n        encrypt_and_emit_partial_log(\n            &mut context,\n            user_setup_payload.log_plaintext,\n            user_keys,\n            user,\n        );\n\n        // 6. We convert the hiding points to standard `Point` type as we cannot pass `TokenNoteHidingPoint` type\n        // as an argument to a function due to macro limitations (the `TokenNoteHidingPoint` type is macro generated\n        // and hence is not resolved soon enough by the compiler).\n        let fee_payer_point = fee_payer_setup_payload.hiding_point;\n        let user_point = user_setup_payload.hiding_point;\n\n        // 7. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime {\n                FunctionSelector::from_signature(\n                    \"complete_refund((Field,Field,bool),(Field,Field,bool),Field)\",\n                )\n            },\n            [\n                fee_payer_point.x,\n                fee_payer_point.y,\n                fee_payer_point.is_infinite as Field,\n                user_point.x,\n                user_point.y,\n                user_point.is_infinite as Field,\n                funded_amount,\n            ],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_point: Point, user_point: Point, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            TokenNote::finalization_payload().new(fee_payer_point, tx_fee);\n        let user_finalization_payload =\n            TokenNote::finalization_payload().new(user_point, refund_amount);\n\n        // 4. We emit the `tx_fee` and `refund_amount` as unencrypted event such that the `NoteProcessor` can use it\n        // to reconstruct the note.\n        context.emit_unencrypted_log(fee_payer_finalization_payload.log);\n        context.emit_unencrypted_log(user_finalization_payload.log);\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_finalization_payload.note_hash);\n        context.push_note_hash(user_finalization_payload.note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"},"355":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, note::utils::compute_note_hash_for_nullify, oracle::random::random,\n    keys::getters::get_nsk_app, macros::notes::partial_note,\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\n// docs:start:TokenNote\n#[partial_note(quote {amount})]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"357":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n};\n\nuse dep::std::mem::zeroed;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[note]\npub struct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nimpl NullifiableNote for TransparentNote {\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit.\n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier(\n        self,\n        _context: &mut PrivateContext,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // compute_nullifier ignores both of its parameters so we can reuse it here\n        self.compute_nullifier(zeroed(), zeroed())\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all\n"},"376":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n        traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    }, oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"392":{"path":"/usr/src/noir-projects/noir-contracts/contracts/crowdfunding_contract/src/main.nr","source":"// docs:start:empty-contract\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Crowdfunding {\n    // docs:end:empty-contract\n\n    // docs:start:all-deps\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys, prelude::{AztecAddress, PrivateSet, SharedImmutable},\n        utils::comparison::Comparator, unencrypted_logs::unencrypted_event_emission::encode_event,\n        macros::{\n            storage::storage, events::event, functions::{public, initializer, private, internal},\n        }, protocol_types::traits::Serialize,\n    };\n    use std::meta::derive;\n    // docs:start:import_valuenote\n    use dep::value_note::value_note::ValueNote;\n    // docs:end:import_valuenote\n    use token::Token;\n    use router::utils::privately_check_timestamp;\n    // docs:end:all-deps\n\n    #[event]\n    #[derive(Serialize)]\n    struct WithdrawalProcessed {\n        who: AztecAddress,\n        amount: u64,\n    }\n\n    // docs:start:storage\n    #[storage]\n    struct Storage<Context> {\n        // Token used for donations (e.g. DAI)\n        donation_token: SharedImmutable<AztecAddress, Context>,\n        // Crowdfunding campaign operator\n        operator: SharedImmutable<AztecAddress, Context>,\n        // End of the crowdfunding campaign after which no more donations are accepted\n        deadline: SharedImmutable<u64, Context>,\n        // Notes emitted to donors when they donate (can be used as proof to obtain rewards, eg in Claim contracts)\n        donation_receipts: PrivateSet<ValueNote, Context>,\n    }\n    // docs:end:storage\n\n    // TODO(#8367): Ensure deadline is quantized to improve privacy set.\n    // docs:start:init\n    // docs:start:init-header\n    // docs:start:init-header-error\n    #[public]\n    #[initializer]\n    // this-will-error:init-header-error\n    fn init(donation_token: AztecAddress, operator: AztecAddress, deadline: u64) {\n        // docs:end:init-header\n        // docs:end:init-header-error\n        storage.donation_token.initialize(donation_token);\n        storage.operator.initialize(operator);\n        storage.deadline.initialize(deadline);\n    }\n    // docs:end:init\n\n    // docs:start:donate\n    #[private]\n    fn donate(amount: u64) {\n        // 1) Check that the deadline has not passed --> we do that via the router contract to conceal which contract\n        // is performing the check.\n        // docs:start:call-check-deadline\n        let deadline = storage.deadline.read_private();\n        privately_check_timestamp(Comparator.LT, deadline, &mut context);\n        // docs:end:call-check-deadline\n        // docs:start:do-transfer\n        // 2) Transfer the donation tokens from donor to this contract\n        let donor = context.msg_sender();\n        Token::at(storage.donation_token.read_private())\n            .transfer_from(donor, context.this_address(), amount as Field, 0)\n            .call(&mut context);\n        // docs:end:do-transfer\n        // 3) Create a value note for the donor so that he can later on claim a rewards token in the Claim\n        // contract by proving that the hash of this note exists in the note hash tree.\n        let donor_keys = get_public_keys(donor);\n        // docs:start:valuenote_new\n        let mut note = ValueNote::new(amount as Field, donor_keys.npk_m.hash());\n        // docs:end:valuenote_new\n        storage.donation_receipts.insert(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            donor_keys.ovpk_m,\n            donor_keys.ivpk_m,\n            donor,\n        ));\n    }\n    // docs:end:donate\n\n    // docs:start:operator-withdrawals\n    // Withdraws balance to the operator. Requires that msg_sender() is the operator.\n    #[private]\n    fn withdraw(amount: u64) {\n        // 1) Check that msg_sender() is the operator\n        let operator_address = storage.operator.read_private();\n        assert(context.msg_sender() == operator_address, \"Not an operator\");\n\n        // 2) Transfer the donation tokens from this contract to the operator\n        Token::at(storage.donation_token.read_private())\n            .transfer(operator_address, amount as Field)\n            .call(&mut context);\n        // 3) Emit an unencrypted event so that anyone can audit how much the operator has withdrawn\n        Crowdfunding::at(context.this_address())\n            ._publish_donation_receipts(amount, operator_address)\n            .enqueue(&mut context);\n    }\n    // docs:end:operator-withdrawals\n\n    #[public]\n    #[internal]\n    fn _publish_donation_receipts(amount: u64, to: AztecAddress) {\n        WithdrawalProcessed { amount, who: to }.emit(encode_event(&mut context));\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"96":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"97":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice,\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: arr_copy_slice(\n            fields,\n            [0; PUBLIC_DATA_TREE_HEIGHT],\n            1 + LEAF_PREIMAGE_LENGTH,\n        ),\n    }\n}\n"},"98":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"Benchmarking","functions":[{"name":"recreate_note","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"16137133351287663689":{"error_kind":"fmtstring","item_types":[],"length":17}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7P3RjuPavp15vkte+0Iip0TJr9JoNNy9XQ0DBbvRdl0Z590r114rlLlOBkXtEyMnqf/81dVxQcit+MZYofkNisH//e0f//X//X/9f/9f/+2//x//439++8//j//97f/8H/+f//K//tv/+O/f/1//+9u5/fP/3//8//2X//7H//N//q//8v//X9/+8/l6P/2nb//1v//j+/+5nE7/9p++/R//7f/8r9/+87yc/+0//fLqabktf716up3uj1efr5+9em7X21+vni/tvPHq8/l0PX+8lfNpaT/ey3T57PVtmj5e3n761+f26T8+3R//9nL7+cX/z//07XyBZg3NFZo1NMvh0dxvj7f//WfZQnO7XT9efj9dvoTmBs0amvvX0cz39tH5+b4sP37Y2/WP/4np9Pv/J86f/k8s0wPT0qaN/4n7/IHpfvsp3un+GdPLxz88nX76d8+fhnU6tcvH2zid7vNGuPP94ydt8/Q82un2iHa6tXmjB7nSTBPcPXHPcPfE3eDuifvyddzfT13t8b8wnTeAX88fb+c6XbeCvH58Sv3tY+f7R/ofb/36vm99ed+3fnvft/75aes2P45Ct8t5663fHwen6fTz0bJ99up2Ps0fvwG+G8aPV5//+R/ffDraGzof7Q1NR3tD89HeUDvaG7oc7Q1dj/aGlqO9odvR3tDRflO3o/2mbkf7Td2O9pu6He03dTvab+p2tN/U7Wi/qdvRflO3o/2mbkf7TX052m/qy9F+U1+O9pv6crTf1Jej/aa+HO039eVov6kvR/tNfTnab+rL0X5TX4/2m/p6tN/U16P9pr72/009n5fHhn67/e0N/frqy+38MUNebtfTxqu/v9e/Xnxbrj+9j/s/f9Q2zo96GedHvY7zoy7j/Ki3cX7U+zA/6nIa50c9j/OjTuP8qOOclpY2zo86zmlpGee0tIxzWlrGOS0t45yWbuOclm7jnJZu45yWbuOclm5tnB91nNPSbZzT0m2c09JtnNPSbZzT0n2c09J9nNPSfZzT0n2c09K9jfOjjnNauo9zWrqPc1q61zot3T5uU7pflr/9qJ+863b78bcE7tMvYGqdrXJgzqdaR7EkmVontySZWge9JJla58IkmYbMCplap84kmVqH1CSZWmfaJBlH4DUyzsArZM7OwGtknIHXyDgDr5FxBl4j05BZIeMMvEbGGXiNjDPw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UydLu0+dLJssy2Rp96mTpd2nTpZ2nzpZ2n3qZGn3eaMsn17zWs52nzpZ2n3qZGn3qZOl3afM2efcZFkmS7tPnSztPnWytPvUydLuUydLu0+ZLCe7T50s7T51srT71MnS7lMnyybLMlnafepkafepk6Xd542yfH7Na7L71MnS7lMmy9nuUydLu0+Zs89s96mTpd2nTpZNlmWytPvUydLuUydLu0+dLO0+dbK0+5TJstl96mRp96mTpd2nTpZ2nzpZNlmWydLu80ZZPr/m1ew+dbK0+9TJ0u5TJ0u7T5mzz8XuUydLu0+dLO0+dbK0+9TJssmyTJZ2nzpZ2n3qZGn3qZOl3adOlnafMlle7T51srT71MnS7lMnS7vPG2X5/JrXtcmyTJZ2nzpZ2n3qZGn3qXP2sfvUydLuUybLxe5TJ0u7T50s7T51srT71MmyybJMlnafOlnafepkafepk6Xdp06Wdp8yWd7sPnWytPu8UZbPr3nd7D51srT71MmyybJMlnafOmcfu0+dLO0+dbK0+9TJ0u5TJsu73adOlnafOlnafepkafepk2WTZZks7T51srT71MnS7lMnS7tPnSztPm+U5dNrXreT3adOlnafOlnafepkafepcva5nZosy2Rp96mTpd2nTpZ2nzpZ2n3qZGn3KZPl2e5TJ0u7T50s7T51srT71MmyybJMlnafOlnafepkafd5oyyfX/M6233qZGn3KZPlZPepk6Xdp8zZZ7L71MnS7lMnyybLMlnafepkafepk6Xdp06Wdp86Wdp9ymQ5233qZGn3qZOl3adOlnafOlk2WZbJ0u7zRlk+v+Y1233qZGn3qZOl3adOlnafMmefZvepk6Xdp06Wdp86Wdp96mTZZFkmS7tPnSztPnWytPvUydLuUydLu0+ZLC92nzpZ2n3qZGn3qZOl3eeNsnx+zevSZFkmS7tPnSztPnWytPvUOfvYfepkafcpk+XV7lMnS7tPnSztPnWytPvUybLJskyWdp86Wdp96mRp96mTpd2nTpZ2nzJZLnafOlnafd4oy+fXvBa7T50s7T51smyyLJOl3afO2cfuUydLu0+dLO0+dbK0+5TJ8mb3qZOl3adOlnafOlnafepk2WRZJku7T50s7T51srT71MnS7lMnS7vPG2X5/JrX3e5TJ0u7T50s7T51srT7lDn73Jssy2Rp96mTpd2nTpZ2nzpZ2n3qZGn3qZLl/WT3qZOl3adOlnafOlnafepk2WRZJku7T50s7T51srT7vFGWT6953U92nzpZ2n3KZHm2+9TJ0u5T5uxztvvUydLuUyfLJssyWdp96mRp96mTpd2nTpZ2nzpZ2n3KZDnZfepkafepk6Xdp06Wdp86WTZZlsnS7vNGWT6/5jXZfepkafepk6Xdp06Wdp8yZ5/Z7lMnS7tPnSztPnWytPvUybLJskyWdp86Wdp96mRp96mTpd2nTpZ2nzJZNrtPnSztPnWytPvUydLu80ZZPr/m1Zosy2Rp96mTpd2nTpZ2nzpnH7tPnSztPmWyvNh96mRp96mTpd2nTpZ2nzpZNlmWydLuUydLu0+dLO0+dbK0+9TJ0u5TJsur3adOlnafN8ry+TWvq92nTpZ2nzpZNlmWydLuU+fsY/epk6Xdp06Wdp86Wdp9ymS52H3qZGn3qZOl3adOlnafOlk2WZbJ0u5TJ0u7T50s7T51srT71MnS7vNGWT6/5nWz+9TJ0u5TJ0u7T50s7T5lzj63JssyWdp96mRp96mTpd2nTpZ2nzpZ2n3KZHm3+9TJ0u5TJ0u7T50s7T51smyyLJOl3adOlnafOlnafd4oy+fXvO52nzpZ2n2KZHk9new+dbK0+xQ5+3zP0u5TJ0u7T50smyzLZGn3qZOl3adOlnafOlnafepkafcpk+XZ7lMnS7tPnSztPnWytPvUybLJskyWdp83yvL5Na+z3adOlnafOlnafepkafcpc/aZ7D51srT71MnS7lMnS7tPnSybLMtkafepk6Xdp06Wdp86Wdp96mRp9ymT5Wz3qZOl3adOlnafOlnafd4oy+fXvOYmyzJZ2n3qZGn3qZOl3afO2cfuUydLu0+ZLJvdp06Wdp86Wdp96mRp96mTZZNlmSztPnWytPvUydLuUydLu0+dLO0+ZbK82H3qZGn3eaMsn1/zuth96mRp96mTZZNlmSztPnXOPnafOlnafepkafepk6Xdp0yWV7tPnSztPnWytPvUydLuUyfLJssyWdp96mRp96mTpd2nTpZ2nzpZ2n3eKMvn17wWu0+dLO0+dbK0+9TJ0u5T5uyzNFmWydLuUydLu0+dLO0+dbK0+9TJ0u5TJsub3adOlnafOlnafepkafepk2WTZZks7T51srT71MnS7vNGWT6/5nWz+9TJ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1LnpHtS56R7Uueke1BvqO1DnpntQ56Z7UOeme1DnpntQ56Y7UL9w0z2oc9M9qHPTPahz02/9l95LQ30H6tx0D+rcdA/q3HSPT1Nuugd1broD9Ss33YP6/93eG+1IjmzZlf/iz/1AGo8ZyfkXYdASBoMLNLoHUo8AQbj/rsiqdI+oDI/wCCvS9vGdawYQ6qLd0ph7Hbr5XvSIpJsqUqebKlKnmypSD1IXpE43VaRON1WkTjdVpE43VaRONxWkvtJNFanTTS/jTe9KN1WkTjdVpB6kLkidbqo4TemmitTpporU6aaK1OmmgtQ3uqkidbqpInW6qSJ1uqki9SB1Qep0U0XqdFNF6nRTRep0U0XqdNPLeNO7000VqdNNFanTTRWp000Fp+kepC5InW6qSJ1uqkidbqpInW6qSJ1uOj71baKbKlKnmypSp5sqUqebKlIPUhekTjdVpE43VaRON70MN73bRDdVpE43FaQ+000VqdNNBafpTDdVpE43VaQepC5InW6qSJ1uqkidbqpInW6qSJ1uKki90E0VqdNNFanTTRWp000VqQepC1Knm17Gm95CN1WkTjdVpE43VaRONxWcpgvdVJE63VSROt1UkTrdVJF6kLogdbqpInW6qSJ1uqkidbqpInW6qSD1oJsqUqebKlKnmypSp5texpveCFIXpE43VaRON1WkTjdVnKZ0U0XqdFNB6pVuqkidbqpInW6qSJ1uqkg9SF2QOt1UkTrdVJE63VSROt1UkTrdVJB6o5sqUqebXsab3kY3VaRON1WkHqQuSJ1uqjhN6aaK1OmmitTpporU6aaC1Fe6qSJ1uqkidbqpInW6qSL1IHVB6nRTRep0U0XqdFNF6nRTRep008t407vRTRWp000VqdNNFanTTQWn6RakLkidbqpInW6qSJ1uqkidbqpInW4qSH2nmypSp5sqUqebKlKnmypSD1IXpE43VaRON1WkTje9jDe9O91UkTrddHzq+0Q3Hf++vk90U0XqdFNF6nRTRepB6oLU6aaK1Ommik+OdFNF6nRTRep0U8H7+kw3VaRON1WkTjdVpE43VaQepC5InW4q+OQ4000VqdNNFanTTRWp000Fp2mhmypSp5sqUqebKlKnmypSD1IXpE43VaRON1WkTjdVpE43VaRONxWkvtBNz0h9vSXy8p/L+9Tppl9LvS636a21PXp1qev11WX9S+rvX1xjaj9fXKPEe0QU2fSIaL3pEQWIsiOiT6dHRPlOj4imnh4RtT49IhxAdkSBMEiPCLuQHhF2IT0i7EJ6RAGi7IiwC+kRYRfSI8IupEeEXUiPCLuQHVHFLqRHhF1Ijwi7kB4RdiE9ogBRdkTYhfSIsAvpEWEX0iPCLqRHhF3IjqhhF9Ijwi6kR4RdSI8Iu5AeUYAoOyLsQnpE2IX0iLAL6RFhF9Ijwi5kR7RiF9Ijwi6kR4RdSI8Iu5AeUYAoOyLsQnpE2IX0iLAL6RFhF9Ijwi5kR7RhF85A9OAfzNgQBorUcQCK1Kn1itSD1M9I/fNfe7xRvhWp06cVqVORFanTehWpU2QFn2F2uqkidbqpInW6qSJ1uqngNN2D1AWp000VqdNNFanTTRWp000VqdNNh6e+TxPdVJE63VSROt1UkTrdVJF6kLogdbqpInW6qSJ1uulltOl9SZ1uqkidbipIfaabKlKnmwpO05luqkidbqpIPUhdkDrdVJE63VSROt1UkTrdVJE63VSQeqGbKlKnmypSp5sqUqebKlIPUhekTje9jDe9hW6qSJ1uqkidbqpInW4qOE0XuqkidbqpInW6qSJ1uqki9SB1Qep0U0XqdFNF6nRTRep0U0XqdFNB6kE3VaRON1WkTjdVpE43vYw3vRGkLkidbqpInW6qSJ1uqjhN6aaK1OmmgtQr3VSROt1UkTrdVJE63VSRepC6IHW6qSJ1uqkidbqpInW6qSJ1uqkg9UY3VaRON72MN72NbqpInW6qSD1IXZA63VRxmtJNFanTTRWp000VqdNNBamvdFNF6nRTRep0U0XqdFNF6kHqgtTpporU6aaK1OmmitTpporU6aaX8aZ3o5sqUqebKlKnmypSp5sKTtMtSF2QOt1UkTrdVJE63VSROt1UkTrdVJD6TjdVpE43VaRON1WkTjdVpB6kLkidbqpInW6qSJ1uehlvene6qSJ1uun41OeJbqpInW46/jSdJ7qpInW6qSL1IHVB6nRTRep0U0XqdFNF6nRTRep0U0HqM91UkTrdVJE63VSROt1UkXqQuiB1uullvOmd6aaK1OmmitTpporU6aaC07TQTRWp000VqdNNFanTTRWpB6kLUqebKlKnmypSp5sqUqebKlKnmwpSX+imitTpporU6aaK1Omml/GmdwlSF6RON1WkTjdVpE43VZymdFNF6nRTQepBN1WkTjdVpE43VaRON1WkHqQuSJ1uqkidbqpInW6qSJ1uqkidbipIvdJNFanTTS/jTW+lmypSp5sqUg9SF6RON1WcpnRTRep0U0XqdFNF6nRTQeqNbqpInW6qSJ1uqkidbqpIPUhdkDrdVJE63VSROt1UkTrdVJE63fQy3vSudFNF6nRTRep0U0XqdFPBaboGqQtSp5sqUqebKlKnmypSp5sqUqebClLf6KaK1OmmitTpporU6aaK1IPUBanTTRWp000VqdNNL+NN70Y3VaRONxWkvtNNFanTTQWn6U43VaRON1WkHqQuSJ1uqkidbqpInW6qSJ1uqkidbjo+9TLRTRWp000VqdNNFanTTRWpB6kLUqebXoab3jLRTRWp000VqdNNFanTTQWn6Uw3VaRON1WkTjdVpE43VaQepC5InW6qSJ1uqkidbqpInW6qSJ1uKki90E0VqdNNFanTTRWp000v401vCVIXpE43VaRON1WkTjdVnKZ0U0XqdFNB6gvdVJE63VSROt1UkTrdVJF6kLogdbqpInW6qSJ1uqkidbqpInW6qSD1oJsqUqebXsab3qCbKlKnmypSD1IXpE43VZymdFNF6nRTRep0U0XqdFNB6pVuqkidbqpInW6qSJ1uqkg9SF2QOt1UkTrdVJE63VSROt1UkTrd9DLe9Da6qSJ1uqkidbqpInW6qeA0bUHqgtTpporU6aaK1OmmitTpporU6aaC1Fe6qSJ1uqkidbqpInW6qSL1IHVB6nRTRep0U0XqdNPLeNO70k0VqdNNBalvdFNF6nRTwWm60U0VqdNNFakHqQtSp5sqUqebKlKnmypSp5sqUqebClLf6aaK1OmmitTpporU6aaK1IPUBanTTS/jTe9ON1WkTjdVpE43VaRONx1/mi4T3VSROt1UkTrdVJE63VSRepC6IHW6qSJ1uqkidbqpInW6qSJ1uqkg9ZluqkidbqpInW6qSJ1uehluepc5SF2QOt1UkTrdVJE63VRxmtJNFanTTQWpF7qpInW6qSJ1uqkidbqpIvUgdUHqdFNF6nRTRep0U0XqdFNF6nRTQeoL3VSROt30Mt70LnRTRep0U0XqQeqC1OmmitOUbqpInW6qSJ1uqkidbipIPeimitTpporU6aaK1OmmitSD1AWp000VqdNNFanTTRWp000VqdNNL+NNb6WbKlKnmypSp5sqUqebCk7TGqQuSJ1uqkidbqpInW6qSJ1uqkidbipIvdFNFanTTRWp000VqdNNFakHqQtSp5sqUqebKlKnm17Gm95GN1WkTjcVpL7STRWp000Fp+lKN1WkTjdVpB6kLkidbqpInW6qSJ1uqkidbqpInW4qSH2jmypSp5sqUqebKlKnmypSD1IXpE43vYw3vRvdVJE63VSROt1UkTrdVHCa7nRTRep0U0XqdFNF6nRTRepB6oLU6aaK1OmmitTpporU6aaK1Omm41OPiW6qSJ1uqkidbqpInW56GW56X/4qpC5InW6qSJ1uqkidbqo4TemmitTppoLUZ7qpInW6qSJ1uqkidbqpIvUgdUHqdFNF6nRTRep0U0XqdFNF6nRTQeqFbqpInW56GW96C91UkTrdVJF6kLogdbqp4jSlmypSp5sqUqebKlKnmwpSX+imitTpporU6aaK1OmmitSD1AWp000VqdNNFanTTRWp000VqdNNL+NNb9BNFanTTRWp000VqdNNBadpBKkLUqebKlKnmypSp5sqUqebKlKnmwpSr3RTRep0U0XqdFNF6nRTRepB6oLU6aaK1OmmitTpppfxprfSTRWp000FqTe6qSJ1uqngNG10U0XqdFNF6kHqgtTpporU6aaK1OmmitTpporU6aaC1Fe6qSJ1uqkidbqpInW6qSL1IHVB6nTTy3jTu9JNFanTTRWp000VqdNNBafpRjdVpE43VaRON1WkTjdVpB6kLkidbqpInW6qSJ1uqkidbqpInW4qSH2nmypSp5sqUqebKlKnm17Gm949SF2QOt1UkTrdVPG+TjdVpE43VaRONx2fep3oporU6aaK1Omm4z851oluqkg9SF2QOt1U8b5ON1WkTjdVpE43VaRONxWkPtNNFanTTQWfHGe6qSJ1uqki9SB1Qep0U8VpSjdVpE43VaRON1WkTjcVpF7oporU6aaK1OmmitTpporUg9QFqdNNFanTTc9Ifb0l8vKfy/vU6aZfTH1/nd6yPnp1qev11WX9S+rvX1xjaj9fXKPEe0QU2fSIaL3ZES1U5PSI6NPpEVG+0yOiqadHFCDKjggHkB4RwiA9IuxCekTYhfSIsAvZEQV2IT0i7EJ6RNiF9IiwC+kRBYiyI8IupEeEXUiPCLuQHhF2IT0i7EJ2RBW7kB4RdiE9IuxCekTYhfSIAkTZEWEX0iPCLqRHhF1Ijwi7kB4RdiE7ooZdSI8Iu5AeEXYhPSLsQnpEAaLsiLAL6RFhF9Ijwi6kR4RdSI8Iu5Ad0YpdSI8Iu5AeEXYhPSLsQnpEAaLsiLAL6RFhF85A9OAfzFgRBorUcQCK1Kn1gtQ3mvopqX/+a483yrcidfq0InUqsiL1IHVB6hRZxWcYuqkidbqpInW6qSJ1uqngNN3pporU6aaK1OmmitTpporUg9QFqdNNFanTTRWp000VqdNNFanTTcen3ia6qSJ1uqkidbqpInW66WW46X35v5K6IHW6qSJ1uqkidbqp4jSlmypSp5sKUp/pporU6aaK1OmmitTpporUg9QFqdNNFanTTRWp000VqdNNFanTTQWpF7qpInW66WW86S10U0XqdFNF6kHqgtTpporTlG6qSJ1uqkidbqpInW4qSH2hmypSp5sqUqebKlKnmypSD1IXpE43VaRON1WkTjdVpE43VaRON72MN71BN1WkTjdVpE43VaRONxWcphGkLkidbqpInW6qSJ1uqkidbqpInW4qSL3STRWp000VqdNNFanTTRWpB6kLUqebKlKnmypSp5texpveSjdVpE43FaTe6KaK1OmmgtO00U0VqdNNFakHqQtSp5sqUqebKlKnmypSp5sqUqebClJf6aaK1OmmitTpporU6aaK1IPUBanTTS/jTe9KN1WkTjdVpE43VaRONxWcphvdVJE63VSROt1UkTrdVJF6kLogdbqpInW6qSJ1uqkidbqpInW6qSD1nW6qSJ1uqkidbqpInW56GW969yB1Qep0U0XqdFNF6nRTxWlKN1WkTjcdn/o60U0VqdNNFanTTRWp000VqQepC1KnmypSp5sqUqebKlKnmypSp5sKUp/pporU6aaX4aZ3nemmitTpporUg9QFqdNNFacp3VSROt1UkTrdVJE63VSQeqGbKlKnmypSp5sqUqebKlIPUhekTjdVpE43VaRON1WkTjdVpE43vYw3vQvdVJE63VSROt1UkTrdVHCaLkHqgtTpporU6aaK1OmmitTpporU6aaC1INuqkidbqpInW6qSJ1uqkg9SF2QOt1UkTrdVJE63fQy3vQG3VSROt1UkHqlmypSp5sKTtNKN1WkTjdVpB6kLkidbqpInW6qSJ1uqkidbqpInW4qSL3RTRWp000VqdNNFanTTRWpB6kLUqebXsab3kY3VaRON1WkTjdVpE43FZymK91UkTrdVJE63VSROt1UkXqQuiB1uqkidbqpInW6qSJ1uqkidbqpIPWNbqpInW6qSJ1uqkidbnoZb3q3IHVB6nRTRep0U0XqdFPFaUo3VaRONxWkvtNNFanTTRWp000VqdNNFakHqQtSp5sqUqebKlKnmypSp5sqUqebjk99m+imitTpppfhpneb6KaK1OmmitSD1AWp000VpyndVJE63VSROt1UkTrdVJD6TDdVpE43VaRON1WkTjdVpB6kLkidbqpInW6qSJ1uqkidbqpInW56GW96C91UkTrdVJE63VSROt1UcJqWIHVB6nRTRep0U0XqdFNF6nRTRep0U0HqC91UkTrdVJE63VSROt1UkXqQuiB1uqkidbqpInW66WW86V3oporU6aaC1INuqkidbio4TYNuqkidbqpIPUhdkDrdVJE63VSROt1UkTrdVJE63VSQeqWbKlKnmypSp5sqUqebKlIPUhekTje9jDe9lW6qSJ1uqkidbqpInW4qOE0b3VSROt1UkTrdVJE63VSRepC6IHW6qSJ1uqkidbqpInW6qSJ1uqkg9ZVuqkidbqpInW6qSJ1uehlvetcgdUHqdFNF6nRTRep0U8VpSjdVpE43FaS+0U0VqdNNFanTTRWp000VqQepC1KnmypSp5sqUqebKlKnmypSp5sKUt/pporU6aaX8aZ3p5sqUqebKlIPUhekTjdVnKZ0U0XqdFNF6nRTRep00/Gp7xPdVJE63VSROt1UkTrdVJF6kLogdbqpInW6qSJ1uqkidbqpInW66WW46d1nuqkidbqpInW6qSJ1uqngNJ2D1AWp000VqdNNFanTTRWp000VqdNNBakXuqkidbqpInW6qSJ1uqki9SB1Qep0U0XqdFNF6nTTy3jTW+imitTppoLUF7qpInW6qeA0XeimitTpporUg9QFqdNNFanTTRWp000VqdNNFanTTQWpB91UkTrdVJE63VSROt1UkXqQuiB1uullvOkNuqkidbqpInW6qSJ1uqngNK10U0XqdFNF6nRTRep0U0XqQeqC1OmmitTpporU6aaK1OmmitTppoLUG91UkTrdVJE63VSROt30Mt70tiB1Qep0U0XqdFNF6nRTxWlKN1WkTjcVpL7STRWp000VqdNN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QlY4sUJWOLFCVjixQlY4sUJOOHeskBVOrJAVTqyQFU6skBXOAKcTTqyQFU6skBVOrJAVTqyQFU6skBHOmLBCVjixQlY4sUJWOLFCVjgDnE44sUJWOLFCVjixQlY4sUJWOLFCTjhnrJAVTqyQFU6skBVOrJAVzgCnE06skBVOrJAVTqyQFU6skBVOrJATzoIVssKJFbLCiRWywokVssIZ4HTCiRWywokVssKJFbLCiRWywokVcsK5YIWscGKFrHBihaxwYoWscAY4nXBihaxwYoWscGKFrHBihaxwYoWccAZWyAonVsgKJ1bICidWyApngNMJJ1bICidWyAonVsgKJ1bICidWyAlnxQpZ4cQKWeHEClnhxApZ4QxwOuHEClnhxApZ4cQKWeHEClnhxAo54WxYISucWCErnFghK5xYISucAU4nnFghK5xYISucWCErnFghK5xYISecK1bICidWyAonVsgKJ1bICmeA0wknVsgKJ1bICidWyAonVsgKJ1bICeeGFbLCiRWywokVssKJFbLCGeB0wokVssKJFbLCiRWywokVssKJFXLCuWOFrHBihaxwYoWscGKFrHAGOJ1wYoWscGKFrHBihaxwYoWscGKFjHDWCStkhRMrZIUTK2SFEytkhTPA6YQTK2SFEytkhRMrZIUTK2SFEyvkhHPGClnhxApZ4cQKWeHEClnhDHA64cQKWeHEClnhxApZ4cQKWeHECjnhLFghK5xYISucWCErnFghK5wBTiecWCErnFghK5xYISucWCErnFghJ5wLVsgKJ1bICidWyAonVsgKZ4DTCSdWyAonVsgKJ1bICidWyAonVsgJZ2CFrHBihaxwYoWscGKFrHAGOJ1wYoWscGKFrHBihcQ42377K64x3SGE6NESeol6f4363j2Eu0lOqKJjshPCsGQnhDTJTggPkp1QQCg5IWxFdkIIiOyEcArZCeEUshPCKSQn1HAK2QnhFLITwilkJ4RTyE4oIJScEE4hOyGcQnZCOIXshHAK2QnhFJITWnEK2QnhFLITwilkJ4RTyE4oIJScEE4hOyGcQnZCOIXshHAK2QnhFJIT2nAK2QnhFLITwilkJ4RTyE4oIJScEE4hOyGcQnZCOIXshHAK2QnhFJIT2nEK2QnhFLITwilkJ4RTyE4oIJScEE4hOyGcQnZCOIXshHAK2QnhFHITahNOITshnEJ2QjiF7IRwCtkJBYSSE8IpZCeEU8hOCKeQnRBOITshnEJyQjNOITshnEJ2QjiF7IRwCtkJBYS0/8paWer1r1j28vmLW9uuONtapjs4ERBWOLEVVjhRG1Y48SBWOJEmTjgLhsUKJzrGCifuxgonoscKZ4DTCSdWyAonVsgKJ1bICidWyAonVsgJ54IVssKJFbLCiRWywokVssIZ4HTCiRWywokVssKJFbLCiRWywokVcsIZWCErnFghK5xYISucWCErnAFOJ5xYISucWCErnFghK5xYISucWCEnnBUrZIUTK2SFEytkhRMrZIUzwOmEEytkhRMrZIUTK2SFEytkhRMr5ISzYYWscGKFrHBihaxwYoWscAY4nXBihaxwYoWscGKFrHBihaxwYoWccK5YISucWCErnFghK5xYISucAU4nnFghK5xYISucWCErnFghMc51Lte/4rq0z19cX6L++eI617iDEyvkhHPDClnhxApZ4cQKWeHEClnhDHA64cQKWeHEClnhxApZ4cQKWeHECjnh3LFCVjixQlY4sUJWOLFCVjgDnE44sUJWOLFCVjixQlY4sUJWOLFCRjjXCStkhRMrZIUTK2SFEytkhTPA6YQTK2SFEytkhRMrZIUTK2SFEyvkhHPGClnhxApZ4cQKWeHEClnhDHA64cQKWeHEClnhxApZ4cQKWeHECjnhLFghK5xYISucWCErnFghK5wBTiecWCErnFghK5xYISucWCErnFghJ5wLVsgKJ1bICidWyAonVsgKZ4DTCSdWyAonVsgKJ1bICidWyAonVsgJZ2CFrHBihaxwYoWscGKFrHAGOJ1wYoWscGKFrHBihaxwYoWscGKFnHBWrJAVTqyQFU6skBVOrJAVzgCnE06skBVOrJAVTqyQFU6skBVOrJATzoYVssKJFbLCiRWywokVssIZ4HTCiRWywokVssKJFbLCiRWywokVcsK5YoWscGKFrHBihaxwYoWscAY4nXBihaxwYoWscGKFrHBihaxwYoWccG5YISucWCErnFghK5xYISucAU4nnFghK5xYISucWCErnFghK5xYISecO1bICidWyAonVsgKJ1bICmeA0wknVsgKJ1bICidWyAonVsgKJ1bICOc2YYWscGKFrHBihaxwYoWscAY4nXBihaxwYoWscGKFrHBihaxwYoWccM5YISuc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+Ytb264421qmOzgREE44F2yFFU7UhhVOPIgVTqSJFc4ApxNOdIwVTtyNFU5EjxVOrJAVTqyQE87AClnhxApZ4cQKWeHEClnhDHA64cQKWeHEClnhxApZ4cQKWeHECjnhrFghK5xYISucWCErnFghK5wBTiecWCErnFghK5xYISucWCErnFghJ5wNK2SFEytkhRMrZIUTK2SFM8DphBMrZIUTK2SFEytkhRMrZIUTK+SEc8UKWeHEClnhxApZ4cQKWeEMcDrhxApZ4cQKWeHEClnhxApZ4cQKOeHcsEJWOLFCVjixQlY4sUJWOAOcTjixQlY4sUJWOLFCVjixQlY4sUJOOHeskBVOrJAVTqyQGOc6l+tfcV3a5y+uL1H/fHGda9zBiRWywhngdMKJFbLCiRWywokVssKJFbLCiRUywrlMWCErnFghK5xYISucWCErnAFOJ5xYISucWCErnFghK5xYISucWCEnnDNWyAonVsgKJ1bICidWyApngNMJJ1bICidWyAonVsgKJ1bICidWyAlnwQpZ4cQKWeHEClnhxApZ4QxwOuHEClnhxApZ4cQKWeHEClnhxAo54VywQlY4sUJWOLFCVjixQlY4A5xOOLFCVjixQlY4sUJWOLFCVjixQk44AytkhRMrZIUTK2SFEytkhTPA6YQTK2SFEytkhRMrZIUTK2SFEyvkhLNihaxwYoWscGKFrHBihaxwBjidcGKFrHBihaxwYoWscGKFrHBihZxwNqyQFU6skBVOrJAVTqyQFc4ApxNOrJAVTqyQFU6skBVOrJAVTqyQE84VK2SFEytkhRMr9H854cQKWeEMcDrhxApZ4cQKWeHEClnhxApZ4cQKOeHcsEJWOLFCVjixQlY4sUJWOAOcTjixQlY4sUJWOLFCVjixQlY4sUJOOHeskBVOrJAVTqyQFU6skBXOAKcTTqyQFU6skBVOrJAVTqyQFU6skBHOmLBCVjixQlY4sUJWOLFCVjgDnE44sUJWOLFCVjixQlY4sUJWOLFCTjhnrJAVTqyQFU6skBVOrJAVzgCnE06skBVOrJAVTqyQFU6skBVOrJATzoIVssKJFbLCiRWywokVssIZ4HTCiRWywokVssKJFbLCiRWywokVcsK5YIWscGKFrHBihaxwYoWscAY4nXBihaxwYoWscGKFrHBihaxwYoWccAZWyAonVsgKJ1bICidWyApngNMJJ1bICidWyAonVsgKJ1bICidWyAlnxQpZ4cQKWeHEClnhxApZ4QxwOuHEClnhxApZ4cQKWeHEClnhxAo54WxYISucWCErnFghK5xYISucAU4nnFghK5xYISucWCErnFghMc623/6Ka0x3CCF6tIReot5fo75zD624m+yE0DHZCWFYshNCmmQnFBBKTgi1kZ0QtiI7IQREdkI4heyEcArJCW04heyEcArZCeEUshPCKWQnFBBKTginkJ0QTiE7IZxCdkI4heyEcArJCe04heyEcArZCeEUshPCKWQnFBBKTginkJ0QTiE7IZxCdkI4heyEcAq5CdUJp5CdEE4hOyGcQnZCOIXshAJCyQnhFLITwilkJ4RTyE4Ip5CdEE4hOaEZp5CdEE4hOyGcQnZCOIXshAJCyQnhFLITwilkJ4RTyE4Ip5CdEE4hOaGCU8hOCKeQnRBOITshnEJ2QgGh5IRwCtkJ4RSyE8IpZCeEU8hOCKeQnNCCU8hOCKeQnRBOITshnEJ2QgGh5IRwClpCpSz1+lcse/n8xa1tV5xtLdMdnAgIK5zYCiucqA0rnHgQJ5yBNLHCiWGxwomOscKJu7HCGeB0wokVssKJFbLCiRWywokVssKJFXLCWbFCVjixQlY4sUJWOLFCVjgDnE44sUJWOLFCVjixQlY4sUJWOLFCTjgbVsgKJ1bICidWyAonVsgKZ4DTCSdWyAonVsgKJ1bICidWyAonVsgJ54oVssKJFbLCiRWywokVssIZ4HTCiRWywokVssKJFbLCiRWywokVcsK5YYWscGKFrHBihaxwYoWscAY4nXBihaxwYoWscGKFrHBihaxwYoWccO5YISucWCErnFghK5xYISucAU4nnFghK5xYISucWCErnFghK5xYITHOdS7Xv+K6tM9fXF+i/vniOtd4h7NNWCErnFghK5xYISucWCErnAFOJ5xYISucWCErnFghK5xYISucWCEnnDNWyAonVsgKJ1bICidWyApngNMJJ1bICidWyAonVsgKJ1bICidWyAlnwQpZ4cQKWeHEClnhxApZ4QxwOuHEClnhxApZ4cQKWeHEClnhxAo54VywQlY4sUJWOLFCVjixQlY4A5xOOLFCVjixQlY4sUJWOLFCVjixQk44AytkhRMrZIUTK2SFEytkhTPA6YQTK2SFEytkhRMr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","brillig_names":["get_notes_internal","get_collapse_hints","decompose_hint","get_key_validation_request","notify_nullified_note_oracle_wrapper","get_public_keys_and_partial_address","random","notify_created_note_oracle_wrapper","lt_32_hint","lte_16_hint","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"448":"attempt to add with overflow","756":"Array index out of bounds","820":"attempt to add with overflow","430":"Array index out of bounds","933":"attempt to add with overflow","674":"Storage slot 0 not allowed. Storage slots must start from 1.","223":"Nested call failed!","665":"Storage slot 0 not allowed. Storage slots must start from 1.","793":"Index out of bounds","464":"Array index out of bounds","909":"Array index out of bounds","513":"attempt to add with overflow","437":"Array index out of bounds","535":"attempt to add with overflow","718":"attempt to add with overflow","517":"Array index out of bounds","901":"Array index out of bounds","767":"attempt to add with overflow","700":"Array index out of bounds","956":"Array index out of bounds","499":"attempt to add with overflow","426":"attempt to add with overflow","478":"Stack too deep","798":"Array index out of bounds","472":"attempt to add with overflow","917":"Array index out of bounds","271":"attempt to add with overflow","524":"Array index out of bounds","975":"attempt to add with overflow"}},{"name":"increment_balance","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["increment_balance"],"assert_messages":{"215":"Stack too deep","404":"Array index out of bounds","500":"Array index out of bounds","165":"Nested call failed!","197":"Array index out of bounds","508":"Array index out of bounds","374":"attempt to add with overflow","179":"Array index out of bounds","208":"attempt to add with overflow","566":"attempt to add with overflow","330":"Storage slot 0 not allowed. Storage slots must start from 1.","426":"attempt to add with overflow","356":"Array index out of bounds","321":"Storage slot 0 not allowed. Storage slots must start from 1.","187":"attempt to add with overflow","399":"Index out of bounds","492":"Array index out of bounds","524":"attempt to add with overflow","547":"Array index out of bounds"}},{"name":"create_note","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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+7xQll/feZ3tPnOytPvMydLuMydLu8+YZ5+L3WdOlnafOVnafeZkafeZk2XIckyWdp85Wdp95mRp95mTpd1nTpZ2nzFZrnafOVnafeZkafeZk6Xd54Wy/PrOaw1ZjsnS7jMnS7vPnCztPnOefew+c7K0+4zJ8mr3mZOl3WdOlnafOVnafeZkGbIck6XdZ06Wdp85Wdp95mRp95mTpd1nTJY3u8+cLO0+L5Tl13deN7vPnCztPnOyDFmOydLuM+fZx+4zJ0u7z5ws7T5zsrT7TMnycrD7zMnS7jMnS7vPnCztPnOyDFmOydLuMydLu8+cLO0+c7K0+8zJ0u7zQll+eed1Odp95mRp95mTpd1nTpZ2nzHPPseQ5Zgs7T5zsrT7zMnS7jMnS7vPnCztPmOyXOw+c7K0+8zJ0u4zJ0u7z5wsQ5ZjsrT7zMnS7jMnS7vPC2X59Z3XYveZk6XdZ0yWJ7vPnCztPmOefU52nzlZ2n3mZBmyHJOl3WdOlnafOVnafeZkafeZk6XdZ0yWYfeZk6XdZ06Wdp85Wdp95mQZshyTpd3nhbL8+s4r7D5zsrT7zMnS7jMnS7vPmGefs91nTpZ2nzlZ2n3mZGn3mZNlyHJMlnafOVnafeZkafeZk6XdZ06Wdp8xWV7sPnOytPvMydLuMydLu88LZfn1ndclZDkmS7vPnCztPnOytPvMefax+8zJ0u4zJsvV7jMnS7vPnCztPnOytPvMyTJkOSZLu8+cLO0+c7K0+8zJ0u4zJ0u7z5gsr3afOVnafV4oy6/vvK52nzlZ2n3mZBmyHJOl3WfOs4/dZ06Wdp85Wdp95mRp9xmT5c3uMydLu8+cLO0+c7K0+8zJMmQ5Jku7z5ws7T5zsrT7zMnS7jMnS7vPC2X55Z3XerD7zMnS7jMnS7vPnCztPlOefdZDyHJMlnafOVnafeZkafeZk6XdZ06Wdp8xWR7tPnOytPvMydLuMydLu8+cLEOWY7K0+8zJ0u4zJ0u7zwtl+fWd19HuMydLu8+YLBe7z5ws7T5jnn0Wu8+cLO0+c7IMWY7J0u4zJ0u7z5ws7T5zsrT7zMnS7jMmy5PdZ06Wdp85Wdp95mRp95mTZchyTJZ2nxfK8us7r5PdZ06Wdp85Wdp95mRp9xnz7BN2nzlZ2n3mZGn3mZOl3WdOliHLMVnafeZkafeZk6XdZ06Wdp85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6XJ8n/9Ol8vxzqvP53d85+tPesd1/d1XXi/r+1e+Hn8p+ntC+xXRrSR0vb3TO91+k9Bpv9r6KgntV3JfJaH9KvGrJLRfgX6VhEJCG09ov3L+KgntV+VfJaH9iv+rJGRT+IaELsf3t32J5U5C1/Vj9Lmef7421r8CMik0B3T74HG7xt8C+s0SupzfB6JY1r8tob/5cxyHy/sf5Fji3/7H2TRsFbuN3giy2+itK7uN3myz2+hD9HuN3tC02+gtWLuN3jS22+htbruN3pq31+jP1rzdRm/N22301rzdRm/N2230Ifq9Rm/N22301rzdRm/N22301rzdRm/N22v0F2vebqO35u02emvebqO35u02+hD9XqO35u02emvebqO35u02emvebqO35u01+tWat9vorXm7jd6at9vorXm7jT5Ev9forXm7jd6at9vorXm7jd6at9vorXl7jf5qzdtt9Na83UZvzdtt9Na83UYfot9r9Na83UZvzdtt9Na83UZvzdtt9Na8V4r+cnh/F3FZPn8G881ANylNm9ukNM1ok9K0jL1UmufzR5rrb9IMaQ5K0341KU2T1KQ0rUyT0jQcTXqmtQWNSfNyONiCJqVpC5qUpi1ozFPQjzRtQZPSDGkOStMWNClNW9CkNG1Bk9K0BU1K0xY0KM2jLWhSmragSWnagialaQualGZIc1CatqBJadqCXirNr2/EjragSWnagialaQsalOZiCxr0FLTYgialaQualKYtaFKaIc1BadqCJqVpC5qUpi1oUpq2oElp2oIGpXmyBU1K0xY0KU1b0KQ0bUGT0gxpzrkRO9mCJqVpC5qUpi1oUpq2oElPQbagQWmGLWhSmragSWnagialaQualGZIc1CatqBJadqCJqVpC5qUpi1oUpq2oEFpnm1Bk9K0BU1K0xb0Uml+fSN2tgVNSjOkOShNW9CkNG1Bk56CbEGT0rQFTUrTFjQozYstaFKatqBJadqCJqVpC5qUZkhzUJq2oElp2oImpWkLmpSmLWhSmragQWmutqCXSvPrG7HVFjQpTVvQpDRtQZPSDGkOegqyBU1K0xY0KU1b0KQ0bUGT0rQFDUrzagualKYtaFKatqBJadqCJqUZ0hyUpi1oUpq2oElp2oImpWkLeqk0v74Ru9qCBqV5swVNStMWNClNW9Cgp6CbLWhSmiHNQWnagialaQua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XZG6ilyRutZbkboiW/AMMw2pF6Sum1akrptWpK6bVtxNddOK1HXTgtRn3bQidd20InXdtCJ13bQi9SH1gtR104rUddOK1HXTitR104rUddOC1K+6aUXquumXx5veq25akbpuWpH6kHpB6rppxd1UN61IXTetSF03rUhdNy1IfeimFanrphWp66YVqeumFakPqRekrptWpK6bVqSum1akrptWpK6bfnm86V1004rUddOK1HXTitR104K76TKkXpC6blqRum5akbpuWpG6blqRum5akPqqm1akrptWpK6bVqSum1akPqRekLpuWpG6blqRum765fGmd9VNK1LXTQtS33TTitR104K76aabVqSum1akPqRekLpuWpG6blqRum5akbpuWpG6blqQ+q6bVqSum1akrptWpK6bVqQ+pF6Qum765fGmd9dNK1LXTStS100rUtdNC+6mh25akbpuWpG6blqRum5akfqQekHqumlF6rppReq6aUXqumlF6rrp41PfLrppReq6aUXqumlF6rrpl4eb3u0ypF6Qum5akbpuWpG6blpxN9VNK1LXTQtSn3TTitR104rUddOK1HXTitSH1AtS100rUtdNK1LXTStS100rUtdNC1KfddOK1HXTL483vbNuWpG6blqR+pB6Qeq6acXdVDetSF03rUhdN61IXTctSP2qm1akrptWpK6bVqSum1akPqRekLpuWpG6blqRum5akbpuWpG6bvrl8aZ36KYVqeumFanrphWp66YFd9MxpF6Qum5akbpuWpG6blqRum5akbpuWpD6optWpK6bVqSum1akrptWpD6kXpC6blqRum5akbpu+uXxpnfRTStS100LUl9104rUddOCu+mqm1akrptWpD6kXpC6blqRum5akbpuWpG6blqRum5akPqmm1akrptWpK6bVqSum1akPqRekLpu+uXxpnfTTStS100rUtdNK1LXTQvuprtuWpG6blqRum5akbpuWpH6kHpB6rppReq6aUXqumlF6rppReq6aUHqh25akbpuWpG6blqRum765fGm9xhSL0hdN61IXTetSF03rbib6qYVqeumj099v+imFanrphWp66YVqeumFakPqRekrptWpK6bVqSum1akrptWpK6bFqQ+6aYVqeumXx5uevdJN61IXTetSH1IvSB13bTibqqbVqSum1akrptWpK6bFqQ+66YVqeumFanrphWp66YVqQ+pF6Sum1akrptWpK6bVqSum1akrpt+ebzpveqmFanrphWp66YVqeumBXfT65B6Qeq6aUXqumlF6rppReq6aUXqumlB6kM3rUhdN61IXTetSF03rUh9SL0gdd20InXdtCJ13fTL403v0E0rUtdNC1JfdNOK1HXTgrvpoptWpK6bVqQ+pF6Qum5akbpuWpG6blqRum5akbpuWpD6qptWpK6bVqSum1akrptWpD6kXpC6bvrl8aZ31U0rUtdNK1LXTStS100L7qabblqRum5akbpuWpG6blqR+pB6Qeq6aUXqumlF6rppReq6aUXqumlB6rtuWpG6blqRum5akbpu+uXxpncfUi9IXTetSF03rUhdN624m+qmFanrpgWpH7ppReq6aUXqumlF6rppRepD6gWp66YVqeumFanrphWp66YVqeumj0/9uOimFanrpl8ebnqPi25akbpuWpH6kHpB6rppxd1UN61IXTetSF03rUhdNy1IfdJNK1LXTStS100rUtdNK1IfUi9IXTetSF03rUhdN61IXTetSF03/fJ40zvrphWp66YVqeumFanrpgV303lIvSB13bQidd20InXdtCJ13bQidd20IPWrblqRum5akbpuWpG6blqR+pB6Qeq6aUXqumlF6rrpl8eb3qtuWpG6blqQ+tBNK1LXTQvupkM3rUhdN61IfUi9IHXdtCJ13bQidd20InXdtCJ13bQg9UU3rUhdN61IXTetSF03rUh9SL0gdd30y+NN76KbVqSum1akrptWpK6bFtxNV920InXdtCJ13bQidd20IvUh9YLUddOK1HXTitR104rUddOK1HXTgtQ33bQidd20InXdtCJ13fTL403vNqRekLpuWpG6blqRum5acTfVTStS100LUt9104rUddOK1HXTitR104rUh9QLUtdNK1LXTStS100rUtdNK1LXTQtSP3TTitR10y+PN72HblqRum5akfqQekHqumnF3VQ3rUhdN61IXTetSF03fXjq0+Xr/xF7RezaaUns6mlJ7PppSexD7BWxa6glsauoJbHrqCWxK6lfKmLXUr882vl+jX3SUkti11JLYtdSS2LXUituqdMQe0XsWmpJ7FpqSexaaknsWmpJ7FpqReyzlloSu5ZaEruWWhK7lloS+xB7RexaaknsWmpJ7Frq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kxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefMCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeG8skJROFmhKJysUBROVigK54AzCScrFIWTFYrCyQpF4WSFonCyQkk4BysUhZMVisLJCkXhZIWKca7H85e4jVuEBkKt/w3cY3A33QnRMd0JMSzdCZEm3QnxIM0JLdRGd0JsRXdCBER3QpxCd0IDoeaEOIXuhDiF7oQ4he6EOIXuhDiF5oRWTqE7IU6hOyFOoTshTqE7oYFQc0KcQndCnEJ3QpxCd0KcQndCnEJzQhun0J0Qp9CdEKfQnRCn0J3QQKg5IU6hOyFOoTshTqE7IU6hOyFOoTmhnVPoTohT6E6IU+hOiFPoTmgg1JwQp9CdEKfQnRCn0J0Qp9CdEKfQnNDBKXQnxCl0J8QpdCfEKXQnNBBqTohT6E6IU+hOiFPoTohT6E6IU2hNaLpcOIXuhDiF7oQ4he6EOIXuhAZCzQlxCt0JcQrdCXEK3QlxCt0JcQrNCU2cQi2he/6jeV9xEhBRONmKKJzURhTOAWcSTtIkCifDEoWTjonCyd1E4SR6knDOrFAUTlYoCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOKysUhZMVisLJCkXhZIWicA44k3CyQlE4WaEonKxQFE5WKAonK5SEc7BCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJOBdWKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefKCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeHcWKEonKxQFE5WKAonKxSFc8BZi3ObnqKet+v6+sXL16j/uniZlnEDJysUhZMVisLJCkXhZIWicLJCSTh3VigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnwQpF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCgXhnC6sUBROVigKJysUhZMVisI54EzCyQpF4WSFonCyQlE4WaEonKxQEs6JFYrCyQpF4WSFonCyQlE4B5xJOFmhKJysUBROVigKJysUhZMVSsI5s0JROFmhKJysUBROVigK54AzCScrFIWTFYrCyQpF4WSFonCyQkk4r6xQFE5WKAonKxSFkxWKwjngTMLJCkXhZIWicLJCUThZoSicrFASzsEKReFkhaJwskJROFmhKJwDziScrFAUTlYoCicrFIWTFYrCyQol4VxYoSicrFAUTlYoCicrFIVzwJmEkxWKwskKReFkhaJwskJROFmhJJwrKxSFkxWKwskKReFkhaJwDjiTcLJCUThZoSicrFAUTlYoCicrlIRzY4WicLJCUThZoSicrFAUzgFnEk5WKAonKxSFkxWKwskKReFkhZJw7qxQFE5WKAonKxSFkxWKwjngTMLJCkXhZIWicLJCUThZoSicrFASzoMVisLJCkXhZIWicLJCUTgHnEk4WaEonKxQFE5WKAonKxSFkxUKwjlfWKEonKxQFE5WKAonKxSFc8CZhJMVisLJCkXhZIWicLJCUThZoSScEysUhZMVisLJCkXhZIWicA44k3CyQlE4WaEonKxQFE5WKAonK5SEc2aFonCyQlE4WaEonKxQFM4BZxJOVigKJysUhZMVisLJCkXhZIWScF5ZoSicrFAUTlYoCicrFIVzwJmEkxWKwskKReFkhaJwskJROFmhJJyDFYrCyQpF4WSFonCyQlE4B5xJOFmhKJysUBROVigKJysUhZMVSsK5sELFONfj+UvcxuUGIaKnltB0jOPp4uO49T3E3XQnRMd0JzQQak6INOlOiAfpToja6E6IrehOiIBoTmjlFLoT4hS6E+IUuhPiFLoTGgg1J8QpdCfEKXQnxCl0J8QpdCfEKTQntHEK3QlxCt0JcQrdCXEK3QkNhJoT4hS6E+IUuhPiFLoT4hS6E+IUmhPaOYXuhDiF7oQ4he6EOIXuhAZCzQlxCt0JcQrdCXEK3QlxCt0JcQrNCR2cQndCnEJ3QpxCd0KcQndCA6HmhDiF7oQ4he6EOIXuhDiF7oQ4hd6ErhdOoTshTqE7IU6hOyFOoTuhgVBzQpxCd0KcQndCnEJ3QpxCd0KcQnNCE6fQnRCn0J0Qp9CdEKfQndBAqDkhTqE7IU6hOyFOoZbQPF+Xpy9xPubXL17X/Qnnus2XGzgJiCicbEUSzpnaiMLJg0ThJE2icDIsUTgHnEk4uZsonERPFE5WKAonKxSFkxVKwnllhaJwskJROFmhKJysUBTOAWcSTlYoCicrFIWTFYrCyQpF4WSFknAOVigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnwgpF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCiXhXFmhKJysUBROVigKJysUhXPAmYSTFYrCyQpF4WSFonCyQlE4WaEknBsrFIWTFYrCyQpF4WSFonAOOJNwskJROFmhKJysUBROVigKJyuUhHNnhaJwskLFOLfpKep5u66vX7x8jfqvi5dpGTdwskJROFmhKJwDziScrFAUTlYoCicrFIWTFYrCyQol4TxYoSicrFAUTlYoCicrFIVzwJmEkxWKwskKReFkhaJwskJROFmhIJzjwgpF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCiXhnFihKJysUBROVigKJysUhXPAmYSTFYrCyQpF4WSFonCyQlE4WaEknDMrFIWTFYrCyQpF4WSFonAOOJNwskJROFmhKJysUBROVigKJyuUhPPKCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeEcrFAUTlYoCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOhRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCubJCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJODdWKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefOCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeE8WKEonKxQFE5WKAonKxSFc8CZhJMVisLJCkXhZIWicLJCUThZoSCcy4UVisLJCkXhZIWicLJCUTgHnEk4WaEonKxQFE5WKAonKxSFkxVKwjmxQlE4WaEonKxQFE5WKArngDMJJysUhZMVisLJCkXhZIWicLJCSThnVigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnlRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCOVihKJysUBROVigKJysUhXPAmYSTFYrCyQpF4WSFonCyQlE4WaEknAsrFIWTFYrCyQpF4WSFonAOOJNwskJROFmhKJysUDHO9Xj+ErdxuUGI6KklNB3jeLr4OG59D3E3zQmtdEx3QgxLd0KkSXdCPEh3QgOh5oTYiu6ECIjuhDiF7oQ4he6EOIXmhDZOoTshTqE7IU6hOyFOoTuhgVBzQpxCd0KcQndCnEJ3QpxCd0KcQnNCO6fQnRCn0J0Qp9CdEKfQndBAqDkhTqE7IU6hOyFOoTshTqE7IU6hOaGDU+hOiFPoTohT6E6IU+hOaCDUnBCn0J0Qp9CdEKfQnRCn0J0Qp9Cb0HrhFLoT4hS6E+IUuhPiFLoTGgg1J8QpdCfEKXQnxCl0J8QpdCfEKTQnNHEK3QlxCt0JcQrdCXEK3QkNhJoT4hS6E+IUuhPiFLoT4hS6E+IUmhOaOYXuhDiF7oQ4he6EOIXuhAZCtf/K2nxdnr7E+Zhfv3hd9yec6zZfbuAkIKJwshVROKmNKJw8SBRO0iQJ55VhicJJx0Th5G6icBI9UTgHnEk4WaEonKxQFE5WKAonKxSFkxVKwjlYoSicrFAUTlYoCicrFIVzwJmEkxWKwskKReFkhaJwskJROFmhJJwLKxSFkxWKwskKReFkhaJwDjiTcLJCUThZoSicrFAUTlYoCicrlIRzZYWicLJCUThZoSicrFAUzgFnEk5WKAonKxSFkxWKwskKReFkhZJwbqxQFE5WKAonKxSFkxWKwjngTMLJCkXhZIWicLJCUThZoSicrFASzp0VisLJCkXhZIWicLJCUTgHnEk4WaEonKxQFE5WKAonK1SMc5ueop636/r6xcvXqP+6eJmWcQMnK5SE82CFonCyQlE4WaEonKxQFM4BZxJOVigKJysUhZMVisLJCkXhZIWCcG4XVigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnxApF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCiXhnFmhKJysUBROVigKJysUhXPAmYSTFYrCyQpF4WSFonCyQlE4WaEknFdWKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCedghaJwskJROFmhKJysUBTOAWcSTlYoCicrFIWTFYrCyQpF4WSFknAurFAUTlYoCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOlRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCubFCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJOHdWKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefBCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKBeHcL6xQFE5WKAonKxSFkxWKwjngTMLJCkXhZIWicLJCUThZoSicrFASzokVisLJCkXhZIWicLJCUTgHnEk4WaEonKxQFE5WKAonKxSFkxVKwjmzQlE4WaEonKxQFE5WKArngDMJJysUhZMVisLJCkXhZIWicLJCSTivrFAUTlYoCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOwQpF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCiXhXFihKJysUBROVigKJysUhXPAmYSTFYrCyQpF4WSFonCyQlE4WaEknCsrFIWTFYrCyQpF4WSFonAOOGtxrsfzl7iNyw1CRE8toekYx9PFx3Hre4i76U6IjulOiGHpTog0aU5o40G6E6I2uhNiK7oTIiC6ExoINSfEKXQnxCl0J8QpdCfEKXQnxCk0J7RzCt0JcQrdCXEK3QlxCt0JDYSaE+IUuhPiFLoT4hS6E+IUuhPiFJoTOjiF7oQ4he6EOIXuhDiF7oQGQs0JcQrdCXEK3QlxCt0JcQrdCXEKvQkdF06hOyFOoTshTqE7IU6hO6GBUHNCnEJ3QpxCd0KcQndCnEJ3QpxCc0ITp9CdEKfQnRCn0J0Qp9Cd0ECoOSFOoTshTqE7IU6hOyFOoTshTqE5oZlT6E6IU+hOiFPoTohT6E5oINScEKfQnRCn0J0Qp9CdEKfQnRCn0JzQlVPoTohTqCU0z9fl6Uucj/n1i9d1f8K5bvPlBk4CIgonWxGFc8CZhJMHicJJmkThZFiicNIxUTi5myScg+iJwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCubBCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJOFdWKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefGCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeHcWaEonKxQFE5WKAonKxSFc8CZhJMVisLJCkXhZIWicLJCUThZoSScBysUhZMVisLJCkXhZIWicA44k3CyQsU4t+kp6nm7rq9fvHyN+q+Ll2kZN3CyQlE4WaEonKxQFE5WKAfnfLmwQlE4WaEonKxQFE5WKArngDMJJysUhZMVisLJCkXhZIWicLJCSTgnVigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnzApF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCiXhvLJCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJOAcrFIWTFYrCyQpF4WSFonAOOJNwskJROFmhKJysUBROVigKJyuUhHNhhaJwskJROFmhKJysUBTOAWcSTlYoCicrFIWTFYrCyQpF4WSFknCurFAUTlYoCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOjRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCubNCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJOA9WKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCOd0YYWicLJCUThZoSicrFAUzgFnEk5WKAonKxSFkxWKwskKReFkhZJwTqxQFE5WKAonKxSFkxWKwjngTMLJCkXhZIWicLJCUThZoSicrFASzpkVisLJCkXhZIWicLJCUTgHnEk4WaEonKxQFE5WKAonKxSFkxVKwnllhaJwskJROFmhKJysUBTOAWcSTlYoCicrFIWTFYrCyQpF4WSFknAOVigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnwgpF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCiXhXFmhKJysUBROVigKJysUhXPAmYSTFYrCyQpF4WSFonCyQlE4WaEknBsrFIWTFSrGuR7PX+I2LjcIET21hKZjHE8XH8et7yHupjuhgVBzQgxLd0KkSXdCPEh3QtRGd0JsRXNCOwHRnRCn0J0Qp9CdEKfQndBAqDkhTqE7IU6hOyFOoTshTqE7IU6hOaGDU+hOiFPoTohT6E6IU+hOaCDUnBCn0J0Qp9CdEKfQnRCn0J0Qp9Cb0HzhFLoT4hS6E+IUuhPiFLoTGgg1J8QpdCfEKXQnxCl0J8QpdCfEKTQnNHEK3QlxCt0JcQrdCXEK3QkNhJoT4hS6E+IUuhPiFLoT4hS6E+IUmhOaOYXuhDiF7oQ4he6EOIXuhAZCzQlxCt0JcQrdCXEK3QlxCt0JcQrNCV05he6EOIXuhDiF7oQ4he6EBkLNCXEK3QlxCt0JcQrdCXEKtYT+uNE8fYnzMb9+8bruTzjXbb7cwElAJOEcbEUUTmojCicPEoWTNInCOeBMwknHROHkbqJwEj1ROFmhKJysUBLOhRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCubJCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJODdWKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefOCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeE8WKEonKxQFE5WKAonKxSFc8CZhJMVisLJCkXhZIWicLJCUThZoSCc1wsrFIWTFYrCyQoV49ymp6jn7bq+fvHyNeq/Ll6mZdzAyQpF4RxwJuFkhaJwskJROFmhKJysUBROVigJ58QKReFkhaJwskJROFmhKJwDziScrFAUTlYoCicrFIWTFYrCyQol4ZxZoSicrFAUTlYoCicrFIVzwJmEkxWKwskKReFkhaJwskJROFmhJJxXVigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnYIWicLJCUThZoSicrFAUzgFnEk5WKAonKxSFkxWKwskKReFkhZJwLqxQFE5WKAonKxSFkxWKwjngTMLJCkXhZIWicLJCUThZoSicrFASzpUVisLJCkXhZIWicLJCUTgHnEk4WaEonKxQFE5WKAonKxSFkxVKwrmxQlE4WaEonKxQFE5WKArngDMJJysUhZMVisLJCkXhZIWicLJCSTh3VigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnwQpF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCgXhHBdWKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefECkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeGcWaEonKxQFE5WKAonKxSFc8CZhJMVisLJCkXhZIWicLJCUThZoSScV1YoCicrFIWTFYrCyQpF4RxwJuFkhaJwskJROFmhKJysUBROVigJ52CFonCyQlE4WaEonKxQFM4BZxJOVigKJysUhZMVisLJCkXhZIWScC6sUBROVigKJysUhZMVisI54EzCyQpF4WSFonCyQlE4WaEonKxQEs6VFYrCyQpF4WSFonCyQlE4B5xJOFmhKJysUBROVigKJysUhZMVSsK5sUJROFmhKJysUBROVigK54AzCScrFIWTFYrCyQpF4WSFinGux/OXuI3LDUJETy2h6RjH08XHceN7aOduuhOiY7oTYli6EyJNuhMaCDUnRG10J8RWdCdEQHQnxCl0J8QpNCd0cArdCXEK3QlxCt0JcQrdCQ2EmhPiFLoT4hS6E+IUuhPiFLoT4hR6E1ounEJ3QpxCd0KcQndCnEJ3QgOh5oQ4he6EOIXuhDiF7oQ4he6EOIXmhCZOoTshTqE7IU6hOyFOoTuhgVBzQpxCd0KcQndCnEJ3QpxCd0KcQnNCM6fQnRCn0J0Qp9CdEKfQndBAqDkhTqE7IU6hOyFOoTshTqE7IU6hOaErp9CdEKfQnRCn0J0Qp9Cd0ECoOSFOoTshTqE7IU6hOyFOoTshTqE5ocEpdCfEKXQnxCl0J8QpdCc0EGpOiFOoJTTP1+XpS5yP+fWL13V/wrlu8+UGTgIiCidbEYWT2ojCyYMk4VxIkyicDEsUTjomCid3E4VzwJmEkxWKwskKReFkhaJwskJROFmhJJwrKxSFkxWKwskKReFkhaJwDjiTcLJCUThZoSicrFAUTlYoCicrlIRzY4WicLJCUThZoSicrFAUzgFnEk5WKAonKxSFkxWKwskKReFkhZJw7qxQFE5WKAonKxSFkxWKwjngTMLJCkXhZIWicLJCUThZoSicrFASzoMVisLJCkXhZIWicLJCUTgHnEk4WaEonKxQFE5WKAonKxSFkxUKwrleWKEonKxQFE5WKAonKxSFc8CZhJMVisLJCkXhZIWicLJCUThZoWKc2/QU9bxd19cvXr5G/dfFy7SMn3FOrFAUTlYoCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOmRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCeWWFonCyQlE4WaEonKxQFM4BZxJOVigKJysUhZMVisLJCkXhZIWScA5WKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefCCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeFcWaEonKxQFE5WKAonKxSFc8CZhJMVisLJCkXhZIWicLJCUThZoSScGysUhZMVisLJCkXhZIWicA44k3CyQlE4WaEonKxQFE5WKAonK5SEc2eFonCyQlE4WaEonKxQFM4BZxJOVigKJysUhZMVisLJCkXhZIWScB6sUBROVigKJysUhZMVisI54EzCyQpF4WSFonCyQlE4WaEonKxQEM7twgpF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCiXhnFihKJysUBROVigKJysUhXPAmYSTFYrCyQpF4WSFonCyQlE4WaEknDMrFIWTFYrCyQpF4WSFonAOOJNwskJROFmhKJysUBROVigKJyuUhPPKCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeEcrFAUTlYoCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOhRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCubJCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJODdWKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefOCkXhZIWicLJCUThZoSicA84knKxQMc71eP4St3G5QYjoqSU0HeN4uvg4bn0PcTfdCdEx3QkxLM0JHaRJd0I8SHdC1EZ3QmxFd0IDoeaEOIXuhDiF7oQ4he6EOIXuhDiF3oT2C6fQnRCn0J0Qp9CdEKfQndBAqDkhTqE7IU6hOyFOoTshTqE7IU6hOaGJU+hOiFPoTohT6E6IU+hOaCDUnBCn0J0Qp9CdEKfQnRCn0J0Qp9Cc0MwpdCfEKXQnxCl0J8QpdCc0EGpOiFPoTohT6E6IU+hOiFPoTohTaE7oyil0J8QpdCfEKXQnxCl0JzQQak6IU+hOiFPoTohT6E6IU+hOiFNoTmhwCt0JcQrdCXEK3QlxCt0JDYSaE+IUuhPiFLoT4hS6E+IUuhPiFJoTWjiF7oQ4he6EOIVaQvN8XZ6+xPmYX794XfcnnOs2X27gJCCicA44k3BSG1E4eZAonKRJFE6GJQonHZOEc+VuonASPVE4WaEonKxQFM4BZxJOVigKJysUhZMVisLJCkXhZIWScG6sUBROVigKJysUhZMVisI54EzCyQpF4WSFonCyQlE4WaEonKxQEs6dFYrCyQpF4WSFonCyQlE4B5xJOFmhKJysUBROVigKJysUhZMVSsJ5sEJROFmhKJysUBROVigK54AzCScrFIWTFYrCyQpF4WSFonCyQkE4jwsrFIWTFYrCyQpF4WSFonAOOJNwskJROFmhKJysUBROVigKJyuUhHNihaJwskJROFmhKJysUBTOAWcSTlYoCicrVIxzm56inrfr+vrFy9eo/7p4mZZxAycrFIWTFYrCyQol4ZxZoSicrFAUTlYoCicrFIVzwJmEkxWKwskKReFkhaJwskJROFmhJJxXVigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnYIWicLJCUThZoSicrFAUzgFnEk5WKAonKxSFkxWKwskKReFkhZJwLqxQFE5WKAonKxSFkxWKwjngTMLJCkXhZIWicLJCUThZoSicrFASzpUVisLJCkXhZIWicLJCUTgHnEk4WaEonKxQFE5WKAonKxSFkxVKwrmxQlE4WaEonKxQFE5WKArngDMJJysUhZMVisLJCkXhZIWicLJCSTh3VigKJysUhZMVisLJCkXhHHAm4WSFonCyQlE4WaEonKxQFE5WKAnnwQpF4WSFonCyQlE4WaEonAPOJJysUBROVigKJysUhZMVisLJCuXgvF4urFAUTlYoCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOiRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCObNCUThZoSicrFAUTlYoCueAMwknKxSFkxWKwskKReFkhaJwskJJOK+sUBROVigKJysUhZMVisI54EzCyQpF4WSFonCyQlE4WaEonKxQEs7BCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxWKwskKJeFcWKEonKxQFE5WKAonKxSFc8CZhJMVisLJCkXhZIWicLJCUThZoSScKysUhZMVisLJCkXhZIWicA44k3CyQlE4WaEonKxQFE5WKAonK5SEc2OFonCyQlE4WaEonKxQFM4BZxJOVigKJysUhZMVisLJCkXhZIWScO6sUBROVigKJysUhZMVisI54EzCyQpF4WSFonCyQlE4WaEonKxQEs6DFYrCyQpF4WSFinGux/OXuI3LDUJETy2hsSxPF491Wm4QGgg1J0THdCfEsHQnRJp0J8SDdCdEbfQmNF3Yiu6ECIjuhDiFYkLr9kxou75x8b5en170vq7TDZwERBTOAWcSTmojCicPEoWTNInCybBE4aRjknBO3E0UTqInCicrFIWTFYrCOeBMwskKReFkhaJwskJROFmhKJysUBLOmRWKwskKReFkhaJwskJROAecSThZoSicrFAUTlYoCicrFIWTFUrCeWWFonCyQlE4WaEonKxQFM4BZxJOVigKJysUhZMVisLJCkXhZIWScA5WKAonKxSFkxWKwskKReEccCbhZIWicLJCUThZoSicrFAUTlYoCefCCkXhZIWicLJCUThZoSicA84knKxQFE5WKAonKxSFkxX6lXAe21N4x+Vy3MDJCiXhXFmhKJysUDHObZmece7T6xcf87494bxOb1z81j+CPq0U0u/Lnm/6fdkP7H9b9kzW78ue9vp92XNkvy97Qu33Zc++/bbsN6ru92XP6/2+7Hm935c9r/f7sh/Y/7bseb3flz2v9/uy5/V+X/a83u/Lntf7bdnvvN7vy57X+33Z83q/FPvn8L6yv/HW252qi8I54PyFcI7picsxxvb6xfNxXZ7CO5ZvH/mPL/bnH+OXZ4bL5Ti+v/ivRaHqLMq7FoXXsyjvWhQS0KK8a1EYQ4vyrkWhFy3Kexbl4CItyrsWhbi0KO9aFJbTorxrUfhTi/KuRRkWxaK8Z1GYWYvyrkVhZi3KuxaFmbUo71oUZtaivGtRmFmL8o5FmS/MrEV516IwsxblXYvCzFqUdy0KM2tR3rUow6JYlPcsCjNrUd61KMysRXnXojCzFuVdi8LMWpR3LQoza1HesygTM2tR3rUozKxFedeiMLMW5V2LwsxalHctyrAoFuU9i8LMWpR3LQoza1HetSjMrEV516IwsxblXYvCzFqU9yzKzMxalHctCjNrUd61KMysRXnXojCzFuVdizIsikV5z6IwsxblXYvCzFqUdy0KM2tR3rUozKxFedeiMLMW5T2LcmVm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","brillig_names":["get_public_keys_and_partial_address","random","decompose_hint","notify_created_note_oracle_wrapper","get_key_validation_request","lt_32_hint","lte_16_hint","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"broadcast","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["broadcast"],"assert_messages":{"106":"Storage slot 0 not allowed. Storage slots must start from 1.","183":"Array index out of bounds","164":"attempt to add with overflow","327":"Array index out of bounds","346":"attempt to add with overflow","251":"Array index out of bounds","267":"Array index out of bounds","283":"attempt to add with overflow","207":"Stack too deep","153":"Array index out of bounds","201":"attempt to add with overflow","259":"Array index out of bounds"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Benchmarking"}},{"name":"fields","value":{"fields":[{"name":"notes","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"Benchmarking::recreate_note_parameters"}}],"kind":"struct","path":"Benchmarking::recreate_note_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"outgoing_viewer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"value","type":{"kind":"field"}}],"kind":"struct","path":"Benchmarking::create_note_parameters"}}],"kind":"struct","path":"Benchmarking::create_note_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Benchmarking::broadcast_parameters"}}],"kind":"struct","path":"Benchmarking::broadcast_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"value","type":{"kind":"field"}}],"kind":"struct","path":"Benchmarking::increment_balance_parameters"}}],"kind":"struct","path":"Benchmarking::increment_balance_abi"}]}},"file_map":{"101":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"120":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"141":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest,\n};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission,\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr","source":"// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"165":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"166":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"177":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"371":{"path":"/usr/src/noir-projects/noir-contracts/contracts/benchmarking_contract/src/main.nr","source":"// A contract used for running benchmarks.\n// We should try to change this contract as little as possible, since any modification\n// would alter the metrics we're capturing in the benchmarks, and we want to keep the\n// subject being tested as unmodified as possible so we can detect metric changes that\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Benchmarking {\n    use dep::aztec::prelude::{AztecAddress, NoteGetterOptions, Map, PublicMutable, PrivateSet};\n    use dep::value_note::{utils::increment, value_note::ValueNote};\n\n    use dep::aztec::macros::{storage::storage, functions::{private, public}};\n\n    #[storage]\n    struct Storage<Context> {\n        notes: Map<AztecAddress, PrivateSet<ValueNote, Context>, Context>,\n        balances: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n    }\n\n    // Creates a new value note for the target owner. Use this method to seed an initial set of notes.\n    #[private]\n    fn create_note(owner: AztecAddress, outgoing_viewer: AztecAddress, value: Field) {\n        // docs:start:increment_valuenote\n        increment(storage.notes.at(owner), value, owner, outgoing_viewer);\n        // docs:end:increment_valuenote\n    }\n    // Deletes a note at a specific index in the set and creates a new one with the same value.\n    // We explicitly pass in the note index so we can ensure we consume different notes when sending\n    // multiple txs that will land on the same block.\n    // See https://discourse.aztec.network/t/utxo-concurrency-issues-for-private-state/635\n    // by @rahul-kothari for a full explanation on why this is needed.\n    #[private]\n    fn recreate_note(owner: AztecAddress, outgoing_viewer: AztecAddress, index: u32) {\n        let owner_notes = storage.notes.at(owner);\n        let mut getter_options = NoteGetterOptions::new();\n        let notes = owner_notes.pop_notes(getter_options.set_limit(1).set_offset(index));\n        let note = notes.get(0);\n        increment(owner_notes, note.value, owner, outgoing_viewer);\n    }\n\n    // Reads and writes to public storage and enqueues a call to another public function.\n    #[public]\n    fn increment_balance(owner: AztecAddress, value: Field) {\n        let current = storage.balances.at(owner).read();\n        storage.balances.at(owner).write(current + value);\n        Benchmarking::at(context.this_address()).broadcast(owner).call(&mut context);\n    }\n\n    // Emits a public log.\n    #[public]\n    fn broadcast(owner: AztecAddress) {\n        context.emit_unencrypted_log(storage.balances.at(owner).read());\n    }\n}\n"},"372":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/utils.nr","source":"use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateSet, NoteGetterOptions};\nuse dep::aztec::note::note_getter_options::SortOrder;\nuse dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\nuse dep::aztec::keys::getters::get_public_keys;\nuse crate::{filter::filter_notes_min_sum, value_note::{ValueNote, VALUE_NOTE_LEN}};\n\n// Sort the note values (0th field) in descending order.\n// Pick the fewest notes whose sum is equal to or greater than `amount`.\npub fn create_note_getter_options_for_decreasing_balance(\n    amount: Field,\n) -> NoteGetterOptions<ValueNote, VALUE_NOTE_LEN, Field, Field> {\n    NoteGetterOptions::with_filter(filter_notes_min_sum, amount).sort(\n        ValueNote::properties().value,\n        SortOrder.DESC,\n    )\n}\n\n// Creates a new note for the recipient.\n// Inserts it to the recipient's set of notes.\npub fn increment(\n    // docs:start:increment_args\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    recipient: AztecAddress,\n    outgoing_viewer: AztecAddress, // docs:end:increment_args\n) {\n    let recipient_keys = get_public_keys(recipient);\n    let outgoing_viewer_ovpk_m = get_public_keys(outgoing_viewer).ovpk_m;\n\n    let mut note = ValueNote::new(amount, recipient_keys.npk_m.hash());\n    // Insert the new note to the owner's set of notes and emit the log if value is non-zero.\n    balance.insert(&mut note).emit(encode_and_encrypt_note(\n        balance.context,\n        outgoing_viewer_ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n    ));\n}\n\n// Find some of the `owner`'s notes whose values add up to the `amount`.\n// Remove those notes.\n// If the value of the removed notes exceeds the requested `amount`, create a new note containing the excess value, so that exactly `amount` is removed.\n// Fail if the sum of the selected notes is less than the amount.\npub fn decrement(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress,\n) {\n    let sum = decrement_by_at_most(balance, amount, owner, outgoing_viewer);\n    assert(sum == amount, \"Balance too low\");\n}\n\n// Similar to `decrement`, except that it doesn't fail if the decremented amount is less than max_amount.\n// The motivation behind this function is that there is an upper-bound on the number of notes a function may\n// read and nullify. The requested decrementation `amount` might be spread across too many of the `owner`'s\n// notes to 'fit' within this upper-bound, so we might have to remove an amount less than `amount`. A common\n// pattern is to repeatedly call this function across many function calls, until enough notes have been nullified to\n// equal `amount`.\n//\n// It returns the decremented amount, which should be less than or equal to max_amount.\npub fn decrement_by_at_most(\n    balance: PrivateSet<ValueNote, &mut PrivateContext>,\n    max_amount: Field,\n    owner: AztecAddress,\n    outgoing_viewer: AztecAddress,\n) -> Field {\n    let options = create_note_getter_options_for_decreasing_balance(max_amount);\n    let notes = balance.pop_notes(options);\n\n    let mut decremented = 0;\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            decremented += note.value;\n        }\n    }\n\n    // Add the change value back to the owner's balance.\n    let mut change_value = 0;\n    if max_amount.lt(decremented) {\n        change_value = decremented - max_amount;\n        decremented -= change_value;\n    }\n    increment(balance, change_value, owner, outgoing_viewer);\n\n    decremented\n}\n"},"376":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n        traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    }, oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"65":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"96":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"98":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"}}}
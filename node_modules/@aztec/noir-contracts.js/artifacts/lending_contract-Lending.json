{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"Lending","functions":[{"name":"withdraw_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAo4AIBFAAAiAIUeAgAAAx4CAAAEMDgAAwAEAAUkAgEBAyECABEABTkBAAAeAgAAAx4CAQAEJAIEAAUkAgQAByQCBAIJADgHCQgqCAEGABABCAEkAwQBBgAoBgIIKg4HCCQCBAIIADgGCAckAgQBByQCBAEJJAIEAgsAOAkLCioIAQgAEAEKASQDBAEIACgIAgoqDgkKJAIEAgoAOAgKCSoMCQoqDgQKJAIEDAsqCAAMKgwFDSoMBg4qDAcPKgwIEAAQAAsAIgCKKgQAACoMDQkqDA4KJAIEAQUkAgQCCAA4BQgGKggBBAAQAQYBJAMEAQQAKAQCBioOBQYkAgQCBgA4BAYFKgwFBioOAQYkAgQLCCoIAAsqDAkMKgwKDSoMBw4qDAQPABAACAAiAIoqBAAAKgwMBSoMDQYAKAUCASsEAAaAAyUABAABgAQiAL4rCIAFAAQrCIAGAAgqDgIIJgIA2p030QACJAIEAQYkAgQCCQA4BgkIKggBBQAQAQgBJAMEAQUAKAUCCCoOBggkAgQCCAA4BQgGKgwGCCoOAggkAgQKCSoIAAoqDAcLKgwFDCoMAQ0qDAQOABAACQAiAIoqBAAAKgwLBioMDAgqCAEBJAIEAwIAEAECASQDBAEBACgBAgIqDAIEKQIAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAABSoOBQQAKAQCBCoOBQQmAgDVRBsNAAIAKAECBAAoCAIKKg0KCQAoCgIHKggBCgAAAQIBJAMEAQoAKAoCDDY/lQAEAAMABwAJAAwAAAALAAIkAgIBAQo4CwECIQIAhAACOQEAACMlAAR4AIAEDQAAAIAEgAMhAACJgAM5AQAAIyIAhSoIAQYAAAECASoOAQYqCAEBAAABAgEqDgIBJAIEAQIkAgEBByQCBAAIKgwIBSAAlgw4BQMIIQIAngAIIACZKg0GAioNAQMqDAIBKgwDAiMMOAUDCCECAKEACDkBAAAAKAQCCSoNCQkMOAUJCiECAKYACjkBAAAkAgQCCgA4BAoJADgJBQoqDQoIKg0GCSoNAQoAKAkCCysEAAqAAyUABAABgAQiAL4rCIAFAAwrCIAGAA0qDggNKg0MCAAoCAIIKg4IDCoOCwYqDgwBADgFAggOOAUICSECALwACTkBAAAqDAgFIACWAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAA1oANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIADNAQCACoAHgAYjKwAYyhjK","debug_symbols":"1ZzdThsxEIXfZa9z4bHnx+ZVqgoFCChSFBCEShXi3bsp2SVpttp24CD7BrEwx3Nk5ptB8jov3c3q6vnucr29vX/qLr69dJv76+Vufb/tn15eF93V43qzWd9dHv+4C/svRL/jnx6W2/3j0275uOsuSEtYdKvtTf+thdCvcLverLoLJnldnEUXkUNwMRljKdNEbCo6BKdifBQ9tbJypkO0crGT6O+LjuLHzVNIcYgOEr/UfvqEvS80uqe5zacoZYhOJ9FTS5ulfIg226/3h3v+XPdy6n6fQeAZFJ7BpjII21B0wiXOZPjcosuThoSGyhBJNmOIw1gZHFjnDAkP0SqazgyV6R3SMBqiPGtIBz9EJ7F9ghjQCQidIKITJHQCRicQdAJFJzB0goxOgCY5oUlOaJITmuSEJjmhSU5okhOa5IQmOaFJTmiSGU0yo0lmNMmMJpnRJDOaZEaTzGiSGU0yo0kWNMmCJlnQJAuaZEGTLGiSBU2yoEkWNMmCJlnRJCuaZEWTrGiSFU2yoklWNMmKJlnRJCuaZEOTbGiSDU2yoUk2NMmGJtnQJBuaZEOTbGiSM5rkjCY5o0nOaJLzPMk2d0jUn4EMRzgqdnQGUqbO6aKOZ5JRj9Y+nJhkqc2Q1mbIajOUazNUKjNUQm2GqDZDsTZDqTZDtXXqUlunLrV16lJbpy61depSW6emUFurplBbr6ZQW7OmUFu3plBbu6ZQW7+mUFvDplBbx6bw9S3bwrB2zOn0Hbvz6MxxeCMvs52/SBlK2/4pNO6fGvcfG/efGvfPjfuXxv1r4/6tcf+Nz19qfP7GxudvbHz+xsbnb2x8/v7D5YK6/Tc+f2Pj8zc2Pn/j18/f9yufsejEvcxSm6MUqnNE1Tma/Kv1/96Nl0ZjeL+rmCi+XQMNLhW5VNGlSi4Ve1TTr0OTjtcrSeP7DU5923j5y0Vg1lGk4UzEHlH22CsOkXo2Qskjih5R8ojYIxKPSD0i84g8FaGeijBPRZinIiw60DAPhOaB0MQjUo/IPKLsERWHKAePiDwiT0VkT0VkT0VkT0VkT0Xk/66I1/7px/JxvbzarA4fJ3L7vL0++nSR3c+Ht9/0wb8A","brillig_names":["withdraw_public"],"assert_messages":{"16":"Not initialized","136":"Stack too deep","160":"Index out of bounds","165":"Array index out of bounds","131":"Nested call failed!","187":"attempt to add with overflow"}},{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7ZxhTyIxEIb/y37mQ6edTlv/yuVyQUVDQtAoXnIx/PfbVboUWZkQOdub9otxZdrO+4zpvrNAX7vbxfXL/a/l+u7hubv68dqtHm7mm+XDur967cC8/e35cb4eLp8386dNdwUU1KxbrG/7X51S21l3t1wtuisEu50dRZuAsIs2wbkxGjxtf846wH+/hP36Ehp02EVrsCFZAiaiQaGOc6shYhcdwls+9P35QJKPTvOZmFpBTESj9mOw0TQRjUBuF43g02j3ptVVpNVXpDXUo1WrirRCRVp1RVpNRVqxIq22Iq2ifJMJcWpEMEdaRfkmRqso38RoFeWbTms1onwTo1WUb2K0ivJNjFZRvonRihVpFeWbGK2ifBPB6BHJHHlEI8o3MVpF+SZGqyjfdForivJNjFZRvonRKso3MVpF+SZGK1akVZRvYrSK8k1+fI8UPR15RBTlmxitonwTo1WUbzqt1YryTYxWUb6J0SrKNzFaRfkmRitWpFWUb2K0fr9v0t7EuY3itBJRnJq8Y7QaGMkYbehA6xR00qNKRSZlMyUTUI9F6h/d7aNxKnjPBMD5NHig7hr1DNR9o56BemjUv586qUY9A3Vo1DNQ1416BuqmUc9AHRv1DNRto56BeutNc1BvvWkO6q03zUG99aYZqLvWm+agXnVvat2eugOOuvcxFwjKfol61b1pNuqF96ZOxWDtPTDUQcPIRfuEuvIT0XvmPmWoQmG7EbYKFV6hwnveViFXeH9cToWy3YcK76VbhVzhffd5FYKkQsExFQILGKPJGy46Y40K79JbjWadL72nNzDWKGiuRqRGLo5wHw26MOql9/Qyqeft6ZMvjb6fUeYv0u16G/PR1jH5aMLxI4iOiMs+Y6mwofkMjW1oPkNzicaqtwVRrAF7IHZY4hKdgXERkMZkL57maZSJtTLKqoPtdUjIl5ZQKCyhcAmLg2rc9jFZYjohp+Lt06VPW3fpQFnp6LLSMWWlgxf5Z6Z9OvBxRwkX2M8dRcEuAKPXehUfZFkPqYOhT+4UejQ8aZu0O/g10H+cfn91/bRcrZb3vw7O5FXDj+ljVWl0dE6rD4Zu+nDSkyPCuSOmD8o8OQLOHqHPG7Htr37Pn5bz69Vi4De8+LK+iTj7y82fx/dX+uC/","brillig_names":["get_contract_instance_internal","directive_integer_quotient","directive_invert"]},{"name":"repay_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"from","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"stable_coin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VrdbhstEH0XX+eC+YOZvMqnT5XTppUly6mStFIV9d2L3YDxmvWK7m7rtHsThWTOmeEAwwD7svpwf/fl07vN7uPD0+r2v5fV9uH9+nnzsIutlxXQ4W9Pn9e7ffPpef34vLoFb+5mdb/7EH8Nzn2/WX3cbO9Xtwzy/ebMGoOGV2tUZ9kaPFSsib2+WpMwDFgDOA8pFHCBsz1hLRZgxGTOBTtxlRwtcwctjf+/WQEv0vRJI4s0fdL4RZo+acIiTZ80ukjTJ40t0vRIg+7qpTHN4ce+DEmj6pO5ORklDSzS9EmD46Uh4zTnyUI4dlb9wQXN74LHuwAUTtaoxQBrbchMMrd5dxpQZfKASlrn8XeFsw7IW+9AtdIxhIQyVBnoALs0qxlCYRsODsLcDnRuBzaBA0qDxnzmgNzcDmBuBzjFGFByIOcOaAIHllKRIJ04qKwygxSNWRjK6+hQ0iJzcrRGq6VEpERNGHxpvO8o/z0dpWPuJ6NuR+VfGVH/r4xouOqOEueNkAy7sdc3EaJU3hn5odgl14LeHWMnobd8OiFbhKkKw+7KhflTJxOGRZi6MDgojMHQaTYeClIWQ3fcasBqnRVNNZuHY+jRdB8NTRANgs/RBBmIBuLo5NUn3nH3LMJ8fSHJ7w/JcxGSt7OQ/PWFFKYNidkNhEScZjZ5LGzdIZz6Zs6SHMQzNA2EE5ym4AM4HQznrexatkjTI424RZo+aWCRpk8avHpp/lS9I7RI0ycNTyANwFEaphGloMgU0QjlaGxooOKtNOUFq8J6UlH8wjW2+LffhfDbu2Ax++UZfZj0ZUixdfe42W43n96dfG3k9j+gnvdCXiGuePeoLqdYR6YZWTwMRdOoRf2DpsnYeTS7FUuvyy7j2dOLZUDtsvtZ2cNY9pDfskJRmL+y66zsNpo9Xz6q686Z+it9G3vKwIrQZYex7EppVPVMGcQJ2TurKTZgb1i/QI1b7LEuK2bbz32nfrd4GVO/dhvAQCsmNvCQ5aoRerI8T4qc6Xz/RLkMgXYItkOoHcLtkGr201wMablRugtP0JchoR2i7RBrhtSfci9DoB2C7RBqh3A7pD76mrK2mp1Aap/r5K91imqHnPQ/pU1HH+al17H08eI8HW/KM+4rvc1KX0+809HDvPQ4Lz3NS8/z0su89H5Cej1bVhzmpdd56Xs+LsqHPgrdJNtzUXkRAu0QbIdQO4TbIdIO8c0Q/wuQ0A6pTi7k/EmGD90J460ZElw7BNoh2A6hdgi3Q6Qd4tsh1dG/WBAEbYdYM0RdOwTaIdgOoUZIbNHhVFbVTSxdrwUpU/IeGJtf14+b9d32fn+Ftf/vl937dKMVm8/fPv/8TzT+AQ==","brillig_names":["decompose_hint","pack_arguments_oracle_wrapper","call_private_function_internal","enqueue_public_function_call_internal","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7V3bjiS3sfyXfdYDM5m8+VcODgzJlo0FhJUhyQYMQf/ump3py27XLNVsXiKr88WYtSqLwRgyIrOmkvX7h7//+MO///nXj5/+8fOvH/7yf79/+Onnv33/28efP23/+v2P7z788MvHn376+M+/Xv/fH9zL/0j4fP2v//r+08s/f/3t+19++/AXcfG7Dz9++vv2E9EW/4+PP/348nP44/+/+yDx7pDo7w+Ru0Oyuy/ku5trE79dmtL5ylA+35sG3psH3tsPvLcMvHcYeO848N5p4L3zwHuXcfcuA/dlGbgvy8B9WQbuyzJwX5aB+7IM3Jdl4L4sA/dlGbgvybmRN6eRN+eRN/cjby4jbx5G3jyOvHkaefM88uYjdyiN3KE0cofSyB1KI3cojdyhNHKH0sgdSiN3KI3coTRyh/LIHcojdyiP3KE8cofyyB3KI3coj9yhPHKH8sgdyiN3qB+5Q/3IHepH7lA/cof6kTvUj9yhfuQO9SN3qB+5Q/3IHSojd6iM3KEycofKyB0qI3eojNyhMnKHysgdKiN3qIzcoWHkDg0jd2gYuUPDyB0aRu7QMHKHhpE7NDy8zqPL5e3iuCVw56u3Rzk7V/tc6O1qX8ifr2b5DCc6LDiEBYex4HgsOIIFJ8+FE+l058j5Aia/okmTV3L054sl3KJhKDQeCo1AoQmPo4lXaLiCRmI+3bnE87U+hFc0EQpNgkKTodAUJDTZQaEhKDQMhcZDoREoNFBanKG0OENp8ePvlkW6eDgTPYamIKF5/P21rmgICg1DofFQaAQKTYBCE6HQJCg0UFpckLSYHZIWs0PSYnZIWswOSYvZIWkxOyQtZoekxeyQtJgdkhazg9JigtJigtJigtJigtJigtJigtJigtJigtJigtJigtJihtJihtJihtJihtJihtJihtJihtJihtJihtHindccUkxvF/t885oDM4xw3w3dw6j8/dBhLOF+6DD+cT90GLO5HzqMM90PHcbG7ocO43n3Q4cxyPuh63VTr9dNRa+bil43Fb1uKnrd9PF2n3XQ9bqp6HVT0eumotdNRa+bBr1uGvS6adDrpkGvmz7emrcOul43DXrdNOh106DXTYNeN4163TTqddOo102jXjft0Aa7DLpeN4163TTqddOo102jXjdNet006XXTpNdNk1437dCNvwy6XjdNet006XXTpNdNk143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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"withdraw_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VjbbtswDP0XP+dBJHUh8yvDUCRtWhgIkiJJBwxB/32yF8mKo8DIbG/J6jfLPj4kj0jqcixeVsuPt6dy87rdF/Nvx2K9fV4cyu3Gj44FUP1u/77YVMP9YbE7FHOwombFavPiH51Sn7PitVyvirkG8zm7QKNjd0IjK4losJBBk7Z8QpPR0IEGUBaCK6CcjnjCnC+gEQNcJ+yks+QokdtxCv4+K0BP0lyTxkzSXJPG3r00wtF9H0uXNMw2wEWZXtK4SZpr0nB/aUh0yHkS55pg2dYmZHQTqPqbADQ6oJGTCebclImJ3GLVuUOZ5AE2oc79M8NFAPDoAWAuAAM6JKpBxR0BaBXAGlyCdbUBGtuAHtuAGcIABQPm0oAdwIBABNOZgUwKCQRvRFxX00KFJmSQMg0aJVfvSIGa0NkUXAXq/p9AqWlsJNQOlL/KjMoXmVFSdx0o6djlSbDte3aRMn49CO6Qlg7fneKAdpBECvLQm2/CSZpr0tDdS/OvNt+kJ2muSWMGkAagkUZThzSGw37YQuO6h1be2CG8MRS9ka6J8vttigXLRnPfDTq5xw+B/3oI4rtfzOg66VOX/Gi5K9fr8u3p7G5T1Rec2SVBXKwQlZzosuVkbSgQmxx5PbQ6VNOo7Lo3uySl12Y3/dnDXYxDbrPbUdldX3YXT+nOYpudR2WX3uxx58mqnTP5O5jb2EMHZoQ2O/RlZwqzyhfKIA7I3qomP4AKmO9efolt9mVJtp3WHbn9H63+4B+49R8/wLrL5XuyhEbuTHIRpSo5/PDHYlculutV1Syrrx+b59A7/fDw8/33Fw/+BQ==","brillig_names":["decompose_hint","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert"]},{"name":"get_assets","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"array","length":2,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAA8AKAECAiUCBIBDAAMkAgQCBCsEAAKAAysEAAOABCsEAASABSIARTgAgEMAAiIAUCoIAQEAAAECASQCAQACKg4CASoIAQIAAAECASQCAAADKg4DAioIAQMAAAECASQCAAIEKg4EAx4CAAAFHgIAAAYwOAAFAAYAByQCAQEFIQIAIgAHOQEAAB4CCgAFJAIAAQYKOAUGByECACcABzkBAAAkAgQIByoIAAgqDAEJKgwCCioMAwsqDAYMABAABwAiAFUqBAAAKgwJBSQCBAgHKggACCoMAQkqDAIKKgwDCyoMBAwAEAAHACIAVSoEAAAqDAkGKggBASQCBAMCABABAgEkAwQBAQAoAQICKgwCAyoOBQMAKAMCAyoOBgMjJQAEAACABw0AgAeABYAIFwCACIAIIQAAT4AIAQCAA4AHgAkrAYAJgAYBAIAEgAeACSsCgAaACQEAgAcAAoAHIABGIyUABHgAgAQNAAAAgASAAyEAAFSAAzkBAAAjIgBQKggBBiQCBAIHABABBwEkAwQBBgAoBgIHKgwHCCQCAAAJKg4JCCoNBgcAKAcCByoOBwYqCAEHAAABAgEqDgYHJAIEAQYkAgQACCoMCAUgAGgKOAUIASECAHEAASAAayoNBwEAKAECAwA4AwgEKg0EAioMAgEjKg0HARwMAAUCADgEAgMsDAADAAIkAgQBCQw4BQkKIQIAeQAKOQEAACsEAAGAAyUABAACgAQiAIcrCIAFAAMAKAMCCQA4CQUKKg4CCgA4BQYBDjgFAQIhAgCEAAI5AQAAKg4DByoMAQUgAGgrAYADgAYLAIAGAAKAByEAAIuAByAAjSsAgAOABSAAmysAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQAAmYAKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIACQJQEEAAGABSAAmyMrABjKGMo=","debug_symbols":"zZrdbuIwEIXfJddceP5sD6+yWlXQQhUJhQroSivEu2/SkgAh26hTSucGETif8ym2T4jEvnhazF+fH8pqud4W01/7YrV+nO3KdVUf7Q+TYr4pV6vy+eH84yI0LxDf8tuXWdUcbnezza6YQtQwKRbVU/02hVCPsCxXi2LKIIffkwKSBcoWSA0QBgsEFggtEFkgtkBigSwrAi0rAj+9IiZXaRU5hjVJl4UMA1nS2IZJE5+lh0aOnOGYjqzpIt3I69flIRC26SB4T30KN7j2Cp09jF18QNE2TRfpoaFTonxMp9SM17OH29rLpX1zBvz2M9C3n4G/fgZBbqdNMI5OG4c2nZjwatosfUSWPiJLH5HlDkXDPQD1bm0pYJQ+xsGGgQ1DG0Y2jG2Y2LBow5INyzbsP6uEUU+YUB+TYMPAhqENIxvGNkxsWLRhyYZlE5aHJUPmjgp6KlUaus9K5PY3hcRII4UtlFObppz7hZ2TN6HsTUidCWnwJgTehNCbEHkTYm9C4k3IW1Ort6ZWb02t3poawv23GUM7tnDvIfzN6P6riCl0RhSvjW6yjLCbh5jyiBFQ6h6qKZ+e9wjw3Ui9GUFwZ0TeVjb8wF6L3RXllK6N7n9PY8EPjeIP7H49GY2tOg3YmmiQAX937QXZnZF6M8LgzgjcGaE7I3JnxO6MxJ1RdGfkrrPRXWeju84md51N7jqbfHX2oT78M9uUs/lqcfxXyPK1ejz7k8ju78v7N3X4Hw==","brillig_names":["get_assets"],"assert_messages":{"120":"Array index out of bounds","83":"Stack too deep","33":"Not initialized","38":"Function get_assets can only be called statically","131":"attempt to add with overflow"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiDz0mAgCXtLhdAAIKOAECAyQCAAECJAIABgQkAgEABSQCBAAGJAIAAwckAgQBCCQCAAAJJAIABAokAgUACyQCADMMJgIAO5rKAAANKggBDgAAAQIBJAMEAQ4AKA4CDyQCAAIPKggBECQCBAMRABABEQEkAwQBEAAoEAIRKgwREioOBxIAKBICEioOCRIkAgQEESUCACcQABIkAgQGEyECACoAAyABACoIARQkAgQFFQAQARUBJAMEARQAKBQCFR88AAgAEQAVKg0UFQAoFQIVKg4VFCoIARUAAAECASoOFBUqCAEUAAABAgEqDgYUJAIEGBcqCAAYKgwVGSoMFBoqDAobABAAFwAiD0IqBAAAKgwZFiQCBBkYKggAGSoMFRoqDBQbKgwEHAAQABgAIg9dKgQAACoMGhckAgQaGSoIABoqDBUbKgwUHCoMCh0AEAAZACIPQioEAAAqDBsYJAIEGxoqCAAbKgwVHCoMFB0qDAoeABAAGgAiD0IqBAAAKgwcGSoIARQAAAECASoOBRQqCAEVAAABAgEqDgkVKggBGgAAAQIBJAIAvhsqDhsaJAIEHBsqCAAcKgwUHSoMFR4qDBofABAAGwAiD3gqBAAAJAIEHRwqCAAdKgwQHgAQABwAIg+AKgQAACoMHhskAgQhICoIACEqDAwiKgwUIyoMFSQqDBolKgwbJgAQACAAIg/6KgQAACoMIhwqDCMdKgwkHioMJR8kAgQmJSoIACYqDBwnKgwdKCoMHikqDB8qABAAJQAiEC4qBAAAKgwnGyoMKCAqDCkhKgwqIioMKyMqDCwkJAIEJR4qCAAlKgwXJgAQAB4AIhCGKgQAACoMJhwqDCcdJAIEJiUqCAAmKgwSJwAQACUAIhCGKgQAACoMJxcqDCgeJAIEJyYqCAAnKgwcKCoMHSkqDBcqKgweKwAQACYAIhCVKgQAACoMKCUKOCUPFwo4FwUeIQIAsQAeOQEAAAo4IQsXIQIAtAAXOQEAACQCBCUhKggAJSoMCSYAEAAhACIQhioEAAAqDCYXKgwnHgo4GxchIQIAvwAhOQEAAAo4IB4XIQIAwgAXOQEAAB4CBwAXJAIEJSAqCAAlKgwNJgAQACAAIhCGKgQAACoMJhsqDCceHAwAFyAqDAYDIADODDgDExchAg8cABcgANEqDRQDKg0VFioNGhcqCAEbJAIEAhwAEAEcASQDBAEbACgbAhwqDBwdKg4YHSQCBB0cKggAHSoMAx4qDBYfKgwXICoMAiEqDBsiABAAHAAiELwqBAAAKg0UAyoNFRQqDRoVKggBFiQCBAIXABABFwEkAwQBFgAoFgIXKgwXGCoOGRgkAgQaFyoIABoqDAMbKgwUHCoMFR0qDA8eKgwWHwAQABcAIhC8KgQAACQCBBQDKggAFCoMDhUAEAADACIQ1SoEAAAgAQAmAgAFtNerAAMKOAEDFCECAQQAFCACsSoIARQAAAECASoOBRQqCAEVAAABAgEqDgkVKggBFgAAAQIBJAIAthcqDhcWJAIEGBcqCAAYKgwUGSoMFRoqDBYbABAAFwAiD3gqBAAAJAIEGRgqCAAZKgwQGgAQABgAIg+AKgQAACoMGhckAgQdHCoIAB0qDAweKgwUHyoMFSAqDBYhKgwXIgAQABwAIg/6KgQAACoMHhgqDB8ZKgwgGioMIRskAgQfHioIAB8qDBggKgwZISoMGiIqDBsjABAAHgAiEC4qBAAAKgwgFCoMIRUqDCIWKgwjFyoMJBwqDCUdKggBGAAAAQIBKg4UGCoIARkAAAECASoOFRkqCAEaAAABAgEqDhYaKggBHgAAAQIBKg4XHioIAR8AAAECASoOHB8qCAEgAAABAgEqDh0gHgIHACECOCEWIg44FiEjIQIBUQAjOQEAAAo4IgsWFgwWIyECAVUAIyACkiQCBCUkKggAJSoMDSYAEAAkACIQhioEAAAqDCYWKgwnIyYCAEuaHv8AJCQCBCgnKggAKCoMJCkAEAAnACIQhioEAAAqDCklKgwqJiQCBCkoKggAKSoMDSoAEAAoACIQhioEAAAqDCokKgwrJycCAA3gtrOnZAAAACgkAgQsKyoIACwqDCgtABAAKwAiEIYqBAAAKgwtKSoMLiokAgQtLCoIAC0qDCkuKgwqLyoMJDAqDCcxABAALAAiENkqBAAAKgwuKCoMLysqCAEsAAABAgEqDiQsKggBLQAAAQIBKg4nLQo4IgsuFgwuLyECAYwALyACbSQCBQEvAjgiLzAOOC8iMSECAZEAMTkBAAAkAgQzMioIADMqDDA0ABAAMgAiERQqBAAAKgw0LyoMNTEkAgUCMAw4MCIyIQIBnwAyIAGdKgwLLiABpQI4IjALDjgwIjIhAgGjADI5AQAAKgwLLiABpSQCBDMyKggAMyoMLjQAEAAyACIRFCoEAAAqDDQLKgw1MCQCBDQzKggANCoMIjUAEAAzACIRFCoEAAAqDDUuKgw2MiQCBDU0KggANSoMJTYqDCY3KgwlOCoMJjkAEAA0ACIRIyoEAAAqDDYiKgw3MyQCBDc2KggANyoMIjgqDDM5KgwpOioMKjsAEAA2ACIQ2SoEAAAqDDg0Kgw5NSQCBDc2KggANyoMNDgqDDU5KgwlOioMJjsAEAA2ACIRIyoEAAAqDDgiKgw5MyQCBDk4KggAOSoMIjoqDDM7KgwpPCoMKj0AEAA4ACIQ2SoEAAAqDDo2Kgw7NyQCBDgqKggAOCoMLjkqDDI6KgwvOyoMMTwAEAAqACIRIyoEAAAqDDkiKgw6KSQCBDgxKggAOCoMIjkqDCk6Kgw0OyoMNTwAEAAxACIRIyoEAAAqDDkqKgw6LyQCBDg0KggAOCoMDzkAEAA0ACIQhioEAAAqDDkxKgw6MyQCBDk4KggAOSoMKjoqDC87KgwxPCoMMz0AEAA4ACIQ2SoEAAAqDDo0Kgw7NSQCBDgxKggAOCoMIjkqDCk6KgwLOyoMMDwAEAAxACIRIyoEAAAqDDkqKgw6LyQCBDgpKggAOCoMKjkqDC86Kgw2OyoMNzwAEAApACIRIyoEAAAqDDkLKgw6IiQCBDYvKggANioMBDcAEAAvACIQhioEAAAqDDcpKgw4KiQCBDYxKggANioMCzcqDCI4KgwpOSoMKjoAEAAxACIQ2SoEAAAqDDcvKgw4MCQCBDYpKggANioMLjcqDDI4KgwlOSoMJjoAEAApACIRIyoEAAAqDDcLKgw4IiQCBDYpKggANioMCzcqDCI4Kgw0OSoMNToAEAApACIRPCoEAAAqDDclKgw4JiQCBDEpKggAMSoMJTIqDCYzKgwvNCoMMDUAEAApACIRPCoEAAAqDDILKgwzIiQCBC4pKggALioMCy8qDCIwKgwoMSoMKzIAEAApACIQ2SoEAAAqDC8lKgwwJiQCBC4oKggALioMJC8qDCcwKgwlMSoMJjIAEAAoACIRPCoEAAAqDC8LKgwwIioOCywqDiItIAJtKg0sIioNLSQkAgQoJyoIACgqDBQpKgwVKioMIisqDCQsABAAJwAiESMqBAAAKgwpJSoMKiYkAgQnIioIACcqDCUoKgwmKSoMFioqDCMrABAAIgAiENkqBAAAKgwoFCoMKRUqDhQYKg4VGSoOIRoqDhceKg4cHyoOHSAcDAAhFioMBgsgAo4MOAsTISECDvsAISACkSACkioNGAsqDRkTKg0aFCoNHhUqDR8WKg0gFxwMABQYKggBFCQCBAcZABABGQEkAwQBFAAoFAIZKgwZGioOCxoAKBoCGioOExoAKBoCGioOGBoAKBoCGioOFRoAKBoCGioOFhoAKBoCGioOFxokAgQaGSoIABoqDBQbABAAGQAiEUwqBAAAIAKxJgIASS41VQALCjgBCxMkAgQAFCQCBAIWADgUFhUqCAELABABFQEkAwQBCwAoCwIVKg4UFSQCBAIVADgLFRQmAgAs1qLAABQmAgC4ec7sABUhAgLBABMgA7sqCAETJAIEBRYAEAEWASQDBAETACgTAhYfPAAIABEAFioNExYAKBYCFioOFhMqCAEWAAABAgEqDhMWKggBEwAAAQIBKg4GEyQCBBkYKggAGSoMFhoqDBMbKgwEHAAQABgAIg9dKgQAACoMGhckAgQaGSoIABoqDBYbKgwTHCoMBB0AEAAZACIPXSoEAAAqDBsYJAIEGxoqCAAbKgwWHCoMEx0qDAQeABAAGgAiD10qBAAAKgwcGSQCBBwbKggAHCoMFh0qDBMeKgwKHwAQABsAIg9CKgQAACoMHRoqCAETAAABAgEqDgUTKggBFgAAAQIBKg4JFioIARsAAAECASQCALMcKg4cGyQCBB0cKggAHSoMEx4qDBYfKgwbIAAQABwAIg94KgQAAB4CAQAcHgIAAB0kAgQBHyQCBAIhADgfISAqCAEeABABIAEkAwQBHgAoHgIgKg4fICQCBAIgADgeIB8qDB8gKg4cICQCBAAgJAIEAiIAOCAiISoIAR8AEAEhASQDBAEfACgfAiEqDiAhJAIEAiEAOB8hICQCBCMiKggAIyoMBiQqDB8lKgwIJioMHicAEAAiACIRUCoEAAAqDCQgKgwlISQCBAEeJAIEAiIAOB4iHyoIARwAEAEfASQDBAEcACgcAh8qDh4fJAIEAh8AOBwfHioMHh8qDh0fJAIEIyIqCAAjKgwgJCoMISUqDAgmKgwcJwAQACIAIhFQKgQAACoMJB4qDCUfACgeAhwrBAAfgAMlAAQAAYAEIhGEKwiABQAdKwiABgAgKg4XIAAoHAIeKwQAHYADJQAEAAGABCIRhCsIgAUAHysIgAYAICoOGCAkAgQgHCoIACAqDBQhABAAHAAiEZ4qBAAAKgwhGCQCBCAdKggAICoMEyEqDBYiKgwbIyoMGiQqDBglKgweJioMHycqDAUoKgwJKSoMBSoqDAkrABAAHQAiEaMqBAAAKgwhHB4CAAAYJAIEAR4kAgQCIAA4HiAfKggBHQAQAR8BJAMEAR0AKB0CHyoOHh8kAgQCHwA4HR8eKgweHyoOGR8kAgQhICoIACEqDAYiKgwLIyoMCCQqDB0lABAAIAAiEVAqBAAAKgwiHioMIx8AKB4CGSsEAB+AAyUABAABgAQiEYQrCIAFAB0rCIAGACAqDhcgJAIEAR4kAgQCIAA4HiAfKggBFwAQAR8BJAMEARcAKBcCHyoOHh8kAgQCHwA4Fx8eKgweHyoOGh8kAgQhICoIACEqDBkiKgwdIyoMCCQqDBclABAAIAAiEVAqBAAAKgwiHioMIx8kAgQgGSoIACAqDBUhABAAGQAiEZ4qBAAAKgwhFyQCBCAaKggAICoMEyEqDBYiKgwbIyoMGCQqDBclKgweJioMHycqDAUoKgwJKSoMBSoqDAkrABAAGgAiEaMqBAAAKgwhGSQCBB0TKggAHSoMDh4AEAATACIQ1SoEAAAgA7sKOAEVEyQCBAMVJgIA1UQbDQAWJAIANRcpAgAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAAAAYJAICARkhAgPDABMgBJcqCAETJAIEBBoAEAEaASQDBAETACgTAhofPAAIABUAGioNExoAKBoCGioOGhMqCAEaAAABAgEqDhMaKggBEwAAAQIBKg4GEyQCBB0cKggAHSoMGh4qDBMfKgwKIAAQABwAIhHjKgQAACoMHhskAgQeHSoIAB4qDBofKgwTICoMBCEAEAAdACIR/ioEAAAqDB8cJAIEHx4qCAAfKgwaICoMEyEqDAoiABAAHgAiEeMqBAAAKgwgHSoIARMAAAECASoOBRMqCAEaAAABAgEqDgkaKggBHgAAAQIBJAIAsR8qDh8eJAIEIB8qCAAgKgwTISoMGiIqDB4jABAAHwAiD3gqBAAAHgIBAB8eAgAAIAo4HyAhIQIEBAAhOQEAAB4CAAAfKggBIAAAAQIBKg4GICoNCyAAKCACICoOIAsqCAEgAAABAgEqDgsgJAIEIiEqCAAiKgwDIwAQACEAIhGeKgQAACoMIyAqDQshACghAiEqDiELHAwAICEkAgQBIiQCBAIkADgiJCMqCAEgABABIwEkAwQBIAAoIAIjKg4iIyQCBAIjADggIyIqDCIjKg4hIyQCBCUkKggAJSoMCCYqDCAnKgwGKCoMCykAEAAkACIRUCoEAAAqDCYiKgwnIyoIASAkAgQDIQAQASEBJAMEASAAKCACISoMISQqDhgkACgkAiQqDhgkACggAiEAKCMCJioNJiUAKCYCJCoIASYkAgQHJwAQAScBJAMEASYAKCYCKDY/lQAhAB8AJAAlACgABgAnABYKOCcZHyECBEYAHzkBAAAkAgQnICoIACcqDBMoKgwaKSoMHioqDAIrABAAIAAiEhkqBAAAKgwoHwo4Hx0gIQIEUwAgOQEAACoIAR0kAgQDHwAQAR8BJAMEAR0AKB0CHyoMHyAqDgogACggAiAqDhsgJAIEJyAqCAAnKgwdKAAQACAAIg+AKgQAACoMKB8kAgQnIioIACcqDBcoKgwTKSoMGioqDB4rKgwfLAAQACIAIg/6KgQAACoMKBsqDCkdKgwqICoMKyEkAgQnGioIACcqDBsoKgwdKSoMICoqDCErABAAGgAiEi0qBAAAKgwoEwA4ExwaKg0bEyoNHRsqDSAcKggBHSQCBAIeABABHgEkAwQBHQAoHQIeKgweHyoOGh8kAgQnHioIACcqDBMoKgwbKSoMHCoqDCErKgwdLAAQAB4AIhC8KgQAACQCBCcTKggAJyoMDigAEAATACIQ1SoEAAAgBJcmAgAsaUhrABMKOAETGiQCBAITKggBGyQCBAIcABABHAEkAwQBGwAoGwIcKgwcHSoOCR0mAgDanTfRABwhAgSkABogBUAqCAEaJAIEAx0AEAEdASQDBAEaACgaAh0fPAAIABMAHSoNGh0AKB0CHSoOHRoqCAEdAAABAgEqDhodKggBHgAAAQIBKg4GHioNGh8AKB8CHyoOHxokAgQgHyoIACAqDB0hKgweIioMGyMAEAAfACISQSoEAAAqDCEaJAIEISAqCAAhKgwKIioMGiMAEAAgACISfCoEAAAqDCIfJAIEISAqCAAhKgwdIioMHiMqDBskABAAIAAiEkEqBAAAKgwiGiQCBCAeKggAICoMBCEqDBoiABAAHgAiEnwqBAAAKgwhHSoIARoAAAECASoOBRoqCAEeAAABAgEqDgkeKggBIAAAAQIBJAIArSEqDiEgJAIEIiEqCAAiKgwaIyoMHiQqDCAlABAAIQAiD3gqBAAAHgIAACEeAgEAIiQCBAEkJAIEAiYAOCQmJSoIASMAEAElASQDBAEjACgjAiUqDiQlJAIEAiUAOCMlJCoMJCUqDiIlJAIEJyYqCAAnKgwGKCoMCykqDAgqKgwjKwAQACYAIhFQKgQAACoMKCQqDCklJAIEASMkAgQCJwA4IycmKggBIgAQASYBJAMEASIAKCICJioOIyYkAgQCJgA4IiYjKgwjJioOHyYkAgQoJyoIACgqDCQpKgwlKioMCCsqDCIsABAAJwAiEVAqBAAAKgwpIyoMKiYAKCMCHysEACaAAyUABAABgAQiEYQrCIAFACIrCIAGACQqDh0kJAIEJCMqCAAkKgwcJQAQACMAIhGeKgQAACoMJR0kAgQlJCoIACUqDBomKgweJyoMICgqDCEpKgwdKioMHysqDCIsKgwFLSoMCS4qDAUvKgwJMAAQACQAIhGjKgQAACoMJiMkAgQkGioIACQqDA4lABAAGgAiENUqBAAAIAVACjgBHBokAgA2HCQCBAEeJAIEAiAAOB4gHyoIAR0AEAEfASQDBAEdACgdAh8qDh4fJAIEAh8AOB0fHioMHh8qDgkfJgIAKdWoLwAeJAIEBR8kAgAFICECBVMAGiAHoSoIARokAgQEIQAQASEBJAMEARoAKBoCIR88AAgAFQAhKg0aIQAoIQIhKg4hGioIASEAAAECASoOGiEqCAEaAAABAgEqDgYaJAIEJCMqCAAkKgwhJSoMGiYqDAonABAAIwAiEeMqBAAAKgwlIiQCBCUkKggAJSoMISYqDBonKgwKKAAQACQAIhHjKgQAACoMJiMkAgQmJSoIACYqDCEnKgwaKCoMBCkAEAAlACIR/ioEAAAqDCckKggBGgAAAQIBKg4FGioIASEAAAECASoOCSEqCAElAAABAgEkAgCqJioOJiUkAgQnJioIACcqDBooKgwhKSoMJSoAEAAmACIPeCoEAAAeAgEAJh4CAAAnCjgmJyghAgWUACg5AQAAHgIAACYqCAEnAAABAgEqDgYnKg0LJwAoJwInKg4nCyoIAScAAAECASoOCyckAgQpKCoIACkqDAMqABAAKAAiEZ4qBAAAKgwqJyoNCygAKCgCKCoOKAscDAAnKCQCBAEpJAIEAisAOCkrKioIAScAEAEqASQDBAEnACgnAioqDikqJAIEAioAOCcqKSoMKSoqDigqJAIELCsqCAAsKgwILSoMJy4qDAYvKgwLMAAQACsAIhFQKgQAACoMLSkqDC4qKggBJyQCBAMoABABKAEkAwQBJwAoJwIoKgwoKyoOGCsAKCsCKyoOGCsAKCcCKAAoKgItKg0tLAAoLQIrKggBLSQCBAcuABABLgEkAwQBLQAoLQIvNj+VACgAJgArACwALwAGAC4AFgo4LhkmIQIF1gAmOQEAAAAoLQInADgnBigqDSgmACgtAigAOCgIKSoNKScAKC0CKQA4KRUqKg0qKAAoLQIqADgqESsqDSspACgtAisAOCsfLCoNLCoqCAErAAABAgEqCAEsAAABAgEqDR0tACgtAi0qDi0dKg4IKyoOHSwkAgQtLCoIAC0qDB4uABAALAAiEZ4qBAAAKgwuKyoNHSwAKCwCLCoOLB0cDAArLCQCBAEtJAIEAi8AOC0vLioIASsAEAEuASQDBAErACgrAi4qDi0uJAIEAi4AOCsuLSoMLS4qDiwuJAIEMC8qCAAwKgwIMSoMKzIqDAgzKgwdNAAQAC8AIhFQKgQAACoMMS0qDDIuKggBKyQCBAMsABABLAEkAwQBKwAoKwIsKgwsLyoOGC8AKC8CLyoOGC8AKCsCLAAoLgIxKg0xMAAoMQIvKggBMSQCBAMyABABMgEkAwQBMQAoMQIzNz+VACwAKgAvADAAMwACADIAFgo4MhkqIQIGJgAqOQEAAAAoMQIrADgrBiwqDSwqACgxAiwAOCwILSoNLSsqCAEsJAIEAy0AEAEtASQDBAEsACgsAi0qDC0uKg4KLgAoLgIuKg4iLiQCBC8uKggALyoMLDAAEAAuACIPgCoEAAAqDDAtJAIEMjEqCAAyKgwXMyoMGjQqDCE1KgwlNioMLTcAEAAxACIP+ioEAAAqDDMsKgw0LioMNS8qDDYwJAIEMjEqCAAyKgwsMyoMLjQqDC81KgwwNgAQADEAIhItKgQAACoMMy0qCAExJAIEAzIAEAEyASQDBAExACgxAjIqDDIzKg4gMwAoMwIzKg4iMyQCBDQzKggANCoMMTUAEAAzACIPgCoEAAAqDDUyJAIENjUqCAA2KgwcNyoMGjgqDCE5KgwlOioMMjsAEAA1ACIP+ioEAAAqDDciKgw4MSoMOTMqDDo0JAIENjUqCAA2KgwiNyoMMTgqDDM5Kgw0OgAQADUAIhItKgQAACoMNzIkAgQ0MyoIADQqDC01ABAAMwAiEIYqBAAAKgw1IioMNjEkAgQ2NSoIADYqDAk3ABAANQAiEIYqBAAAKgw3MyoMODQkAgQ4NyoIADgqDCQ5ABAANwAiEIYqBAAAKgw5NSoMOjYkAgQ6OSoIADoqDA07ABAAOQAiEIYqBAAAKgw7NyoMPDgkAgQ8OyoIADwqDBI9ABAAOwAiEIYqBAAAKgw9OSoMPjokAgQ+PSoIAD4qDCI/KgwxQCoMM0EqDDRCABAAPQAiETwqBAAAKgw/OyoMQDwkAgQ9MyoIAD0qDDs+Kgw8PyoMNUAqDDZBABAAMwAiEpIqBAAAKgw+IioMPzEkAgQ7NSoIADsqDCI8KgwxPSoMKj4qDCs/ABAANQAiESMqBAAAKgw8MyoMPTQkAgQ7KyoIADsqDDM8Kgw0PSoMNz4qDDg/ABAAKwAiENkqBAAAKgw8IioMPSokAgQ7MyoIADsqDCI8KgwqPSoMKD4qDCk/ABAAMwAiESMqBAAAKgw8KyoMPTEkAgQ7KSoIADsqDCs8KgwxPSoMOT4qDDo/ABAAKQAiENkqBAAAKgw8IioMPSgkAgQzKyoIADMqDDI0ABAAKwAiEIYqBAAAKgw0KSoMNSokAgQzMioIADMqDAk0ABAAMgAiEIYqBAAAKgw0KyoMNTEkAgQ1NCoIADUqDAk2ABAANAAiEIYqBAAAKgw2MioMNzMkAgQ5OCoIADkqDCY6KgwnOyoMKTwqDCo9KgwrPioMMT8qDDJAKgwzQQAQADgAIhKkKgQAACoMOjQqDDs1Kgw8NioMPTckAgQ4JyoIADgqDDQ5Kgw1OioMIjsqDCg8ABAAJwAiEJUqBAAAKgw5Jgo4JgkiIQIHHAAiOQEAAAI4LSQiKg0sJioNLicqDS8oKggBKSQCBAIqABABKgEkAwQBKQAoKQIqKgwqKyoOIiskAgQ4KioIADgqDCY5KgwnOioMKDsqDDA8KgwpPQAQACoAIhC8KgQAACQCBDgmKggAOCoMGjkqDCE6KgwlOyoMAjwAEAAmACISGSoEAAAqDDkiHgIAACYkAgQBKCQCBAIqADgoKikqCAEnABABKQEkAwQBJwAoJwIpKg4oKSQCBAIpADgnKSgqDCgpKg4mKSQCBAApJAIEAisAOCkrKioIASgAEAEqASQDBAEoACgoAioqDikqJAIEAioAOCgqKSQCBDgrKggAOCoMBjkqDCg6KgwIOyoMJzwAEAArACIRUCoEAAAqDDkpKgw6KiQCBAEnJAIEAisAOCcrKCoIASYAEAEoASQDBAEmACgmAigqDicoJAIEAigAOCYoJyoMJygqDiMoJAIEOCsqCAA4KgwpOSoMKjoqDAg7KgwmPAAQACsAIhFQKgQAACoMOScqDDooACgnAiMrBAAogAMlAAQAAYAEIhGEKwiABQAmKwiABgApKg4kKQAoIwIkKwQAJoADJQAEAAGABCIRhCsIgAUAJysIgAYAKCoOCSgkAgQ4JioIADgqDBQ5ABAAJgAiEZ4qBAAAKgw5IyQCBDgmKggAOCoMGjkqDCE6KgwlOyoMIjwqDCM9KgwkPioMJz8qDAVAKgwJQSoMBUIqDAlDABAAJgAiEaMqBAAAKgw5FCQCBDgaKggAOCoMDjkAEAAaACIQ1SoEAAAgB6EmAgDxs+E5ABQKOAEUGiYCALXoQ5MAFCECB6YAGiAIQioIARokAgQDIQAQASEBJAMEARoAKBoCIR88AAgAEwAhKg0aIQAoIQIhKg4hGioIASEAAAECASoOGiEqCAEiAAABAgEqDgYiKg0aIwAoIwIjKg4jGiQCBCQjKggAJCoMISUqDCImKgwbJwAQACMAIhJBKgQAACoMJRokAgQlJCoIACUqDAomKgwaJwAQACQAIhJ8KgQAACoMJiMkAgQlJCoIACUqDCEmKgwiJyoMGygAEAAkACISQSoEAAAqDCYaJAIEJCIqCAAkKgwEJSoMGiYAEAAiACISfCoEAAAqDCUhKggBGgAAAQIBKg4FGioIASIAAAECASoOCSIqCAEkAAABAgEkAgClJSoOJSQkAgQmJSoIACYqDBonKgwiKCoMJCkAEAAlACIPeCoEAAAeAgAAJR4CAQAmJAIEASgkAgQCKgA4KCopKggBJwAQASkBJAMEAScAKCcCKSoOKCkkAgQCKQA4JykoKgwoKSoOJikkAgQrKioIACsqDAYsKgwLLSoMCC4qDCcvABAAKgAiEVAqBAAAKgwsKCoMLSkkAgQBJyQCBAIrADgnKyoqCAEmABABKgEkAwQBJgAoJgIqKg4nKiQCBAIqADgmKicqDCcqKg4jKiQCBCwrKggALCoMKC0qDCkuKgwILyoMJjAAEAArACIRUCoEAAAqDC0nKgwuKgAoJwIjKwQAKoADJQAEAAGABCIRhCsIgAUAJisIgAYAKCoOISgkAgQoJyoIACgqDBQpABAAJwAiEZ4qBAAAKgwpISQCBCkoKggAKSoMGioqDCIrKgwkLCoMJS0qDCEuKgwjLyoMJjAqDAUxKgwJMioMBTMqDAk0ABAAKAAiEaMqBAAAKgwqJyQCBCgaKggAKCoMDikAEAAaACIQ1SoEAAAgCEIKOAEUGigCAAAAAAAAAAABAAAAAAAAAAAAFCECCEYAGiAKgioIARokAgQEIQAQASEBJAMEARoAKBoCIR88AAgAFQAhKg0aIQAoIQIhKg4hGioIASEAAAECASoOGiEqCAEaAAABAgEqDgYaJAIEJCMqCAAkKgwhJSoMGiYqDAonABAAIwAiEeMqBAAAKgwlIiQCBCUkKggAJSoMISYqDBonKgwKKAAQACQAIhHjKgQAACoMJiMkAgQmJSoIACYqDCEnKgwaKCoMBCkAEAAlACIR/ioEAAAqDCckKggBGgAAAQIBKg4FGioIASEAAAECASoOCSEqCAElAAABAgEkAgCZJioOJiUkAgQnJioIACcqDBooKgwhKSoMJSoAEAAmACIPeCoEAAAeAgEAJh4CAAAnCjgmJyghAgiHACg5AQAAHgIAACYqCAEnAAABAgEqDgYnKg0LJwAoJwInKg4nCyoIAScAAAECASoOCyckAgQpKCoIACkqDAMqABAAKAAiEZ4qBAAAKgwqJyoNCygAKCgCKCoOKAscDAAnKCQCBAEpJAIEAisAOCkrKioIAScAEAEqASQDBAEnACgnAioqDikqJAIEAioAOCcqKSoMKSoqDigqJAIELCsqCAAsKgwILSoMJy4qDAYvKgwLMAAQACsAIhFQKgQAACoMLSkqDC4qKggBJyQCBAMoABABKAEkAwQBJwAoJwIoKgwoKyoOGCsAKCsCKyoOGCsAKCcCKAAoKgItKg0tLAAoLQIrKggBLSQCBAcuABABLgEkAwQBLQAoLQIvNj+VACgAJgArACwALwAGAC4AFgo4LhkmIQIIyQAmOQEAAAAoLQInADgnBigqDSgmACgtAigAOCgIKSoNKScAKC0CKQA4KRUqKg0qKAAoLQIqADgqESsqDSspACgtAisAOCsfLCoNLCoqCAEfAAABAgEqCAErAAABAgEqDR0sACgsAiwqDiwdKg4IHyoOHSskAgQsKyoIACwqDB4tABAAKwAiEZ4qBAAAKgwtHyoNHR4AKB4CHioOHh0cDAAfHiQCBAErJAIEAi0AOCstLCoIAR8AEAEsASQDBAEfACgfAiwqDissJAIEAiwAOB8sKyoMKywqDh4sJAIELi0qCAAuKgwILyoMHzAqDAgxKgwdMgAQAC0AIhFQKgQAACoMLysqDDAsKggBHSQCBAMeABABHgEkAwQBHQAoHQIeKgweHyoOGB8AKB8CHyoOGB8AKB0CHgAoLAIuKg0uLQAoLgIfKggBLiQCBAMvABABLwEkAwQBLgAoLgIwNz+VAB4AKgAfAC0AMAACAC8AFgo4LxkdIQIJGQAdOQEAAAAoLgIeADgeBh8qDR8dACguAh8AOB8IKioNKh4qCAEfJAIEAyoAEAEqASQDBAEfACgfAioqDCorKg4KKwAoKwIrKg4iKyQCBCwrKggALCoMHy0AEAArACIPgCoEAAAqDC0qJAIELy4qCAAvKgwXMCoMGjEqDCEyKgwlMyoMKjQAEAAuACIP+ioEAAAqDDAfKgwxKyoMMiwqDDMtJAIELy4qCAAvKgwfMCoMKzEqDCwyKgwtMwAQAC4AIhItKgQAACoMMCokAgQtLCoIAC0qDCouABAALAAiEIYqBAAAKgwuHyoMLysqCAEqJAIEAywAEAEsASQDBAEqACgqAiwqDCwtKg4gLQAoLQItKg4iLSQCBC4tKggALioMKi8AEAAtACIPgCoEAAAqDC8sJAIEMjEqCAAyKgwcMyoMGjQqDCE1KgwlNioMLDcAEAAxACIP+ioEAAAqDDMtKgw0LioMNS8qDDYwJAIEMjEqCAAyKgwtMyoMLjQqDC81KgwwNgAQADEAIhItKgQAACoMMywkAgQwLyoIADAqDCwxABAALwAiEIYqBAAAKgwxLSoMMi4kAgQxMCoIADEqDAkyABAAMAAiEIYqBAAAKgwyLCoMMy8kAgQzMioIADMqDAk0ABAAMgAiEIYqBAAAKgw0MCoMNTEkAgQ1NCoIADUqDA02ABAANAAiEIYqBAAAKgw2MioMNzMkAgQ3NioIADcqDBI4ABAANgAiEIYqBAAAKgw4NCoMOTUkAgQ4NyoIADgqDB85KgwrOioMLDsqDC88ABAANwAiETwqBAAAKgw5EioMOjYkAgQ3LCoIADcqDBI4Kgw2OSoMMDoqDDE7ABAALAAiEpIqBAAAKgw4HyoMOSskAgQ2LyoIADYqDB83KgwrOCoMHTkqDB46ABAALwAiESMqBAAAKgw3EioMOCwkAgQ2HyoIADYqDBI3KgwsOCoMMjkqDDM6ABAAHwAiENkqBAAAKgw3HSoMOB4kAgQ2KyoIADYqDB03KgweOCoMKDkqDCk6ABAAKwAiESMqBAAAKgw3EioMOB8kAgQ2KCoIADYqDBI3KgwfOCoMNDkqDDU6ABAAKAAiENkqBAAAKgw3HSoMOB4kAgQvKCoIAC8qDCQwABAAKAAiEIYqBAAAKgwwEioMMR8kAgQvKyoIAC8qDAkwABAAKwAiEIYqBAAAKgwwKCoMMSkkAgQyMSoIADIqDCYzKgwnNCoMLTUqDC42KgwSNyoMHzgqDCg5KgwpOgAQADEAIhKkKgQAACoMMysqDDQsKgw1LyoMNjAkAgQxHyoIADEqDCsyKgwsMyoMHTQqDB41ABAAHwAiEJUqBAAAKgwyEgo4EgkdIQIKDwAdOQEAACQCBDEdKggAMSoMKjIAEAAdACIPgCoEAAAqDDISJAIEMSYqCAAxKgwcMioMGjMqDCE0KgwlNSoMEjYAEAAmACIP+ioEAAAqDDIdKgwzHioMNB8qDDUiBDgwFBIAOC8SJioNHRIqDR4dKg0fHioIAR8kAgQCJwAQAScBJAMEAR8AKB8CJyoMJygqDiYoJAIEKCcqCAAoKgwSKSoMHSoqDB4rKgwiLCoMHy0AEAAnACIQvCoEAAAkAgQmHSoIACYqDBonKgwhKCoMJSkqDA8qABAAHQAiEhkqBAAAKgwnEiQCBAEeJAIEAiIAOB4iHyoIAR0AEAEfASQDBAEdACgdAh8qDh4fJAIEAh8AOB0fHioMHh8qDiMfJAIEJiIqCAAmKgwGJyoMCygqDAgpKgwdKgAQACIAIhFQKgQAACoMJx4qDCgfACgeAh0rBAAfgAMlAAQAAYAEIhGEKwiABQAiKwiABgAjKg4kIyYCAOoNCo8AHiQCBCYjKggAJioMHicAEAAjACIRnioEAAAqDCcfJAIEJiMqCAAmKgwaJyoMISgqDCUpKgwSKioMHysqDB0sKgwiLSoMBS4qDAkvKgwFMCoMCTEAEAAjACIRoyoEAAAqDCceJAIEIRIqCAAhKgwOIgAQABIAIhDVKgQAACAKgiYCAO1PJTUAEgo4ARIaJgIA6n2VjwASIQIKhwAaIAtgKggBGiQCBAUdABABHQEkAwQBGgAoGgIdHzwACAARAB0qDRoRACgRAhEqDhEaKggBEQAAAQIBKg4aESoIARoAAAECASoOBhokAgQhHioIACEqDBEiKgwaIyoMBCQAEAAeACIPXSoEAAAqDCIdJAIEIR8qCAAhKgwRIioMGiMqDAQkABAAHwAiD10qBAAAKgwiHiQCBCIhKggAIioMESMqDBokKgwKJQAQACEAIg9CKgQAACoMIx8kAgQjIioIACMqDBEkKgwaJSoMCiYAEAAiACIPQioEAAAqDCQhKggBEQAAAQIBKg4FESoIARoAAAECASoOCRoqCAEiAAABAgEkAgCNIyoOIyIkAgQkIyoIACQqDBElKgwaJioMIicAEAAjACIPeCoEAAAeAgEAIyQCBAElJAIEAicAOCUnJioIASQAEAEmASQDBAEkACgkAiYqDiUmJAIEAiYAOCQmJSoMJSYqDiMmJAIEKCcqCAAoKgwGKSoMCyoqDAgrKgwkLAAQACcAIhFQKgQAACoMKSUqDComACglAiMrBAAmgAMlAAQAAYAEIhGEKwiABQAkKwiABgAnKg4dJwAoIwIlKwQAJIADJQAEAAGABCIRhCsIgAUAJisIgAYAJyoOHicmAgDLlFvlAB4kAgQnJCoIACcqDB4oABAAJAAiEZ4qBAAAKgwoIyQCBCckKggAJyoMESgqDBopKgwiKioMISsqDCMsKgwlLSoMJi4qDAUvKgwJMCoMBTEqDAkyABAAJAAiEaMqBAAAKgwoHh4CAAAjJAIEASUkAgQCJwA4JScmKggBJAAQASYBJAMEASQAKCQCJioOJSYkAgQCJgA4JCYlKgwlJioOHyYkAgQoJyoIACgqDAYpKgwLKioMCCsqDCQsABAAJwAiEVAqBAAAKgwpJSoMKiYAKCUCHysEACaAAyUABAABgAQiEYQrCIAFACQrCIAGACcqDh0nJAIEASUkAgQCJwA4JScmKggBHQAQASYBJAMEAR0AKB0CJioOJSYkAgQCJgA4HSYlKgwlJioOISYkAgQoJyoIACgqDB8pKgwkKioMCCsqDB0sABAAJwAiEVAqBAAAKgwpJSoMKiYkAgQnHyoIACcqDBIoABAAHwAiEZ4qBAAAKgwoHSQCBCchKggAJyoMESgqDBopKgwiKioMIysqDB0sKgwlLSoMJi4qDAUvKgwJMCoMBTEqDAkyABAAIQAiEaMqBAAAKgwoHyQCBCERKggAISoMDiIAEAARACIQ1SoEAAAgC2AKOAESESECC2MAESAMfCoIAREkAgQEEgAQARIBJAMEAREAKBECEh88AAgAFQASKg0REgAoEgISKg4SESoIARIAAAECASoOERIqCAERAAABAgEqDgYRJAIEIRoqCAAhKgwSIioMESMqDAokABAAGgAiEeMqBAAAKgwiFSQCBCEdKggAISoMEiIqDBEjKgwEJAAQAB0AIhH+KgQAACoMIhokAgQhHioIACEqDBIiKgwRIyoMCiQAEAAeACIR4yoEAAAqDCIdKggBEQAAAQIBKg4FESoIARIAAAECASoOCRIqCAEeAAABAgEkAgBzHyoOHx4kAgQhHyoIACEqDBEiKgwSIyoMHiQAEAAfACIPeCoEAAAeAgEAHx4CAAAhCjgfISIhAgukACI5AQAAHgIAAB8qCAEhAAABAgEqDgYhKg0LIQAoIQIhKg4hCyoIASEAAAECASoOCyEkAgQjIioIACMqDAMkABAAIgAiEZ4qBAAAKgwkISoNCwMAKAMCAyoOAwscDAAhAyQCBAEiJAIEAiQAOCIkIyoIASEAEAEjASQDBAEhACghAiMqDiIjJAIEAiMAOCEjIioMIiMqDgMjJAIEJSQqCAAlKgwIJioMIScqDAYoKgwLKQAQACQAIhFQKgQAACoMJiIqDCcjKggBAyQCBAMLABABCwEkAwQBAwAoAwILKgwLISoOGCEAKCECISoOGCEAKAMCCwAoIwIlKg0lJAAoJQIhKggBJSQCBAcmABABJgEkAwQBJQAoJQInNj+VAAsAHwAhACQAJwAGACYAFgo4JhkDIQIL5gADOQEAAAAoJQILADgLBhYqDRYDACglAhYAOBYIGCoNGAskAgQhGCoIACEqDBEiKgwSIyoMHiQqDA8lABAAGAAiEhkqBAAAKgwiFgo4HRYYIQIL+QAYOQEAACoIARYkAgQDGAAQARgBJAMEARYAKBYCGCoMGBkqDiAZACgZAhkqDhUZJAIEIRkqCAAhKgwWIgAQABkAIg+AKgQAACoMIhgkAgQjIioIACMqDBwkKgwRJSoMEiYqDB4nKgwYKAAQACIAIg/6KgQAACoMJBkqDCUdKgwmHyoMJyEkAgQjIioIACMqDBkkKgwdJSoMHyYqDCEnABAAIgAiEi0qBAAAKgwkGCQCBCEfKggAISoMGCIAEAAfACIQhioEAAAqDCIZKgwjHSQCBCIhKggAIioMCSMAEAAhACIQhioEAAAqDCMYKgwkHyQCBCQjKggAJCoMGiUAEAAjACIQhioEAAAqDCUhKgwmIiQCBCcmKggAJyoMAygqDAspKgwZKioMHSsqDBgsKgwfLSoMIS4qDCIvABAAJgAiEqQqBAAAKgwoGioMKSMqDCokKgwrJSQCBCYLKggAJioMFicAEAALACIPgCoEAAAqDCcDJAIEJhkqCAAmKgwcJyoMESgqDBIpKgweKioMAysAEAAZACIP+ioEAAAqDCcLKgwoFSoMKRYqDCoYBDglFAMAOCQDESoNCwMqDRULKg0WEioIARUkAgQCFgAQARYBJAMEARUAKBUCFioMFhkqDhEZJAIEJBYqCAAkKgwDJSoMCyYqDBInKgwYKCoMFSkAEAAWACIQvCoEAAAkAgQkAyoIACQqDA4lABAAAwAiENUqBAAAIAx8JgIAtu/cpAADCjgBAwshAgyAAAsgDP8qCAEDJAIEAgsAEAELASQDBAEDACgDAgsfPAAIAAgACyoNAwsAKAsCCyoOCwMqCAELAAABAgEqDgMLKggBDgAAAQIBKg4GDioNAxEAKBECESoOEQMkAgQhESoIACEqDAsiKgwOIyoMGyQAEAARACITaCoEAAAqDCIDJAIEIQ4qCAAhKgwEIioMAyMAEAAOACISfCoEAAAqDCILKggBAwAAAQIBKg4FAyoIAQQAAAECASoOCQQqCAEOAAABAgEkAgByESoOEQ4kAgQhESoIACEqDAMiKgwEIyoMDiQAEAARACIPeCoEAAAeAgoAEQo4EQISIQIMuQASOQEAACoIAREkAgQDEgAQARIBJAMEAREAKBECEioMEhUqDgcVACgVAhUqDgsVJAIEIRUqCAAhKgwRIgAQABUAIg+AKgQAACoMIhIkAgQhGCoIACEqDAwiKgwDIyoMBCQqDA4lKgwSJgAQABgAIg/6KgQAACoMIgsqDCMRKgwkFSoMJRYkAgQhGioIACEqDAsiKgwRIyoMFSQqDBYlABAAGgAiEC4qBAAAKgwiAyoMIwQqDCQOKgwlEioMJhgqDCcZHAwADgsqCAEOJAIEBxEAEAERASQDBAEOACgOAhEqDBEVKg4DFQAoFQIVKg4EFQAoFQIVKg4LFQAoFQIVKg4SFQAoFQIVKg4YFQAoFQIVKg4ZFSQCBCERKggAISoMDiIAEAARACIRTCoEAAAgDP8mAgDtsOCJAAMKOAEDBCECDQMABCAOISoIAQskAgQCDgAQAQ4BJAMEAQsAKAsCDh88AAgACAAOKg0LDgAoDgIOKg4OCyoIAQ4AAAECASoOCw4qCAERAAABAgEqDgYRKg0LEgAoEgISKg4SCyQCBCESKggAISoMDiIqDBEjKgwbJAAQABIAIhNoKgQAACoMIgskAgQhESoIACEqDAoiKgwLIwAQABEAIhJ8KgQAACoMIg4qCAELAAABAgEqDgULKggBEQAAAQIBKg4JESoIARIAAAECASQCAEoVKg4VEiQCBCEVKggAISoMCyIqDBEjKgwSJAAQABUAIg94KgQAAB4CCgAVCjgVAhYhAg08ABY5AQAAKggBFSQCBAMWABABFgEkAwQBFQAoFQIWKgwWGCoOChgAKBgCGCoODhgkAgQhGCoIACEqDBUiABAAGAAiD4AqBAAAKgwiFiQCBCEaKggAISoMFyIqDAsjKgwRJCoMEiUqDBYmABAAGgAiD/oqBAAAKgwiCioMIxUqDCQYKgwlGSQCBCEXKggAISoMCiIqDBUjKgwYJCoMGSUAEAAXACISLSoEAAAqDCIWKggBCiQCBAMVABABFQEkAwQBCgAoCgIVKgwVFyoOIBcAKBcCFyoODhckAgQhFyoIACEqDAoiABAAFwAiD4AqBAAAKgwiFSQCBB0ZKggAHSoMHB4qDAsfKgwRICoMEiEqDBUiABAAGQAiD/oqBAAAKgweCioMHw4qDCAXKgwhGCQCBBwZKggAHCoMCh0qDA4eKgwXHyoMGCAAEAAZACISLSoEAAAqDB0VJAIEHA4qCAAcKgwQHQAQAA4AIg+AKgQAACoMHQokAgQcGCoIABwqDAwdKgwLHioMER8qDBIgKgwKIQAQABgAIg/6KgQAACoMHQcqDB4OKgwfECoMIBckAgQcGSoIABwqDAcdKgwOHioMEB8qDBcgABAAGQAiEC4qBAAAKgwdCioMHgsqDB8MKgwgESoMIRIqDCIYJAIEHBAqCAAcKgwVHQAQABAAIhCGKgQAACoMHQcqDB4OJAIEHBAqCAAcKgwKHQAQABAAIhOjKgQAABwMBQoXHAwAFxACOAoQFwg4FxQKJAIEHBoqCAAcKgwNHQAQABoAIhCGKgQAACoMHRcqDB4ZJAIEHRwqCAAdKgwHHioMDh8qDBAgKgwKIQAQABwAIhEjKgQAACoMHg0qDB8aJAIEHA4qCAAcKgwNHSoMGh4qDBcfKgwZIAAQAA4AIhDZKgQAACoMHQcqDB4KJAIEHRwqCAAdKgwHHioMCh8qDBcgKgwZIQAQABwAIhEjKgQAACoMHg4qDB8QJAIEHBkqCAAcKgwOHSoMEB4qDA0fKgwaIAAQABkAIhCVKgQAACoMHRcKOBcJDSECDfsADSAN+CoMBwMqDAoEIA4RJAIEHA0qCAAcKgwCHQAQAA0AIhCGKgQAACoMHQsqDB4MJAIEHBAqCAAcKgwHHSoMCh4qDAsfKgwMIAAQABAAIhE8KgQAACoMHQ0qDB4OKgwNAyoMDgQgDhEEOAQUBwA4AwcEKggBAyQCBAQHABABBwEkAwQBAwAoAwIHKgwHCioOFgoAKAoCCioOFQoAKAoCCioOBAoAKAMCBzgDAAcAAyAOISYCAJFN1fIAAwo4AQMEIQIOJQAEIA55KggBAwAAAQIBKg4FAyoIAQQAAAECASoOCQQqCAEHAAABAgEkAgApCioOCgckAgQcCioIABwqDAMdKgwEHioMBx8AEAAKACIPeCoEAAAeAgoACgo4CgILIQIOOwALOQEAACQCBBwLKggAHCoMAx0qDAQeKgwHHyoMAiAAEAALACISGSoEAAAqDB0KJAIEHAsqCAAcKgwDHSoMBB4qDAcfKgwPIAAQAAsAIhIZKgQAACoMHQIqCAEDJAIEAwQAEAEEASQDBAEDACgDAgQqDAQHKg4JBwAoBwIHKg4JByoNAwQAKAQCBCoOBAMqCAEEAAABAgEqDgMEKg0bAwAoAwIDKg4DGyoIAQMAAAECASoOGwMqDAYBIA5mDDgBEwcqCAEJJAIEAwsAEAELASQDBAEJACgJAgsqDAsMKg4KDAAoDAIMKg4CDCECDr8AByAOcioNBAEqDQkDAigDAgMqDgMJACgBAgI4AwACAAIgDnkkAgJVASQCAmwCJAICZQMkAgIgBCQCAmMHJAICcggkAgJuCSQCAmsKJAICdAskAgJvDCQCAncNJAIBAQ4qCAEPJAIEERAAEAEQASQDBAEPACgPAhAqDBARKg4BEQAoEQIRKg4JEQAoEQIRKg4KEQAoEQIRKg4JEQAoEQIRKg4MEQAoEQIRKg4NEQAoEQIRKg4JEQAoEQIRKg4EEQAoEQIRJAICcxIqDhIRACgRAhEqDgMRACgRAhEqDgIRACgRAhEqDgMRACgRAhEqDgcRACgRAhEqDgsRACgRAhEqDgwRACgRAhEqDggRCjgFDhAhAg6+ABAqCAERJAIEEhMAEAETASoMERMnAwXG8730236AAAATACgTAhMAKA8CFCQCBBAVKwQAFIADKwQAE4AEKwQAFYAFIhOqJAIEEBQAOBMUEyoOBhMAKBMCEzkDERIjJAIEAgwMOAEMDSECDsMADTkBAAAAKAkCDAA4DAENKg0NCyoIAQkkAgQCDAAQAQwBJAMEAQkAKAkCDCoMDA0qDgsNKg0JDAAoDAIMKg4MCSoOCQMqDAYHIA7TCjgHBgkhAg7cAAkgDtYAOAEIBw44AQcJIQIO2gAJOQEAACoMBwEgDmYqDQQJADgBBwsOOAELDCECDuEADDkBAAAqDQMMJAIEAQ4MOAcODyECDuYADzkBAAAAKAwCDgA4DgcPKg0PDSQCBAIODDgLDg8hAg7tAA85AQAAKwQACYADJQAEAAOABCITtSsIgAUADAAoDAIOADgOCw8qDg0PKg4MBAA4BwgJDjgHCQshAg75AAs5AQAAKgwJByAO0xwMAAshADgbISIqCAEhJAIEByMAEAEjASQDBAEhACghAiMqDCMkKg4UJAAoJAIkKg4VJAAoJAIkKg4WJAAoJAIkKg4XJAAoJAIkKg4cJAAoJAIkKg4dJCQCBAYkDDgLJCUhAg8SACU5AQAAACghAiQAOCQLJSoNJSMtDAAjACIAOAsIIQ44CyEiIQIPGgAiOQEAACoMIQsgAo4cDAADFwA4HxchKggBFyQCBAciABABIgEkAwQBFwAoFwIiKgwiIyoOGyMAKCMCIyoOHiMAKCMCIyoOICMAKCMCIyoOHCMAKCMCIyoOHSMAKCMCIyoOFiMkAgQGIww4AyMkIQIPMwAkOQEAAAAoFwIjADgjAyQqDSQiLQwAIgAhADgDCBcOOAMXISECDzsAITkBAAAqDBcDIADOJQAEeACABA0AAACABIADIQAPQYADOQEAACMiDz0kAgAABCoIAQUkAgQCBgAQAQYBJAMEAQUAKAUCBioMBgcqDgQHJAIECAcqCAAIKgwBCSoMAgoqDAULABAABwAiE8oqBAAAKgwJBiQCBAcCKggAByoMAwgqDAYJABAAAgAiEnwqBAAAKgwIASMiDz0kAgAABCoIAQUkAgQCBgAQAQYBJAMEAQUAKAUCBioMBgcqDgQHJAIECAcqCAAIKgwBCSoMAgoqDAULABAABwAiE8oqBAAAKgwJBiQCBAcCKggAByoMAwgqDAYJABAAAgAiEnwqBAAAKgwIASMiDz0eAgAABB4CAAAFMDgABAAFAAYkAgEBBCECD38ABjkBAAAjIg89JAIAAAMqCAEEJAIEBAUAEAEFASQDBAEEACgEAgUqDAUGKg4DBgAoBgIGKg4DBgAoBgIGKg4DBioNBAUAKAUCBSoOBQQqDQQFACgFAgUqDgUEKg0EBQAoBQIFKg4FBCoNBAUAKAUCBSoOBQQqCAEFAAABAgEqDgQFKggBBCQCBAUGABABBgEkAwQBBAAoBAIGKgwGByoOAwcAKAcCByoOAwcAKAcCByoOAwcAKAcCBygCAAAAAAAAAAACAAAAAAAAAAAACCoOCAcqDQQGACgGAgYqDgYEKggBBgAAAQIBKg4EBioIAQMAAAECASQCBAAEKg4EAyoIAQcAAAECASQCAQAIKg4IByQCBAEJJAIEAgoqDAQCIA+8DDgCCgshAg/fAAsgD78qDQcBCjgBCAIhAg/DAAI5AQAAJAIECAEqCAAIKgwFCSoMBgoqDAMLKgwHDAAQAAEAIhQFKgQAACoNBQEqDQYCKg0DCCoOAQUqDgIGKg4IAyQCAQEDKg4DBwAoAgIFADgFBAYqDQYDKg0BBAIoBAIEKg4EASoNAgECKAECASoOAQIqDAMBIww4AgoLIQIP4gALIA/0JAIEAgwMOAIMDSECD+YADTkBAAAAKAECDAA4DAINKg0NCyQCBA0MKggADSoMBQ4qDAYPKgwDECoMBxEqDAsSABAADAAiFFIqBAAAIA/0ADgCCQsOOAILDCECD/gADDkBAAAqDAsCIA+8Ig89JAIAMwoKOAEKCyQCAQAKJAIAAAwhAhAgAAsgEAEkAgA1EAo4ARARIQIQEgARIBAFJAIANhAKOAEQESECEAkAETkBAAAKOAUMAQo4AQoMIQIQDQAMOQEAACoMAgsqDAMNKgwEDioMBQ8gEBsKOAUMAQo4AQoMIQIQFgAMOQEAACoMAgsqDAMNKgwEDioMBQ8gEBsqDAsGKgwNByoMDggqDA8JIBApCjgFDAEKOAEKCyECECQACzkBAAAqDAIGKgwDByoMBAgqDAUJIBApKgwHAioMCAMqDAYBKgwJBCMiDz0kAgAABioIAQckAgQHCAAQAQgBJAMEAQcAKAcCCCoMCAkqDgYJACgJAgkqDgYJACgJAgkqDgYJACgJAgkqDgYJACgJAgkqDgYJACgJAgkqDgYJKg0HCAAoCAIIKg4IByoIAQgAAAECASoOBwgkAgQBBiQCBAAHJAIEBgkqDAcFIBBMDDgFCQEhAhBwAAEgEE8qDQgBACgBAgMAOAMHBCoNBAIAKAECBAA4BAYFKg0FAyQCBAIEACgBAgYAOAYEByoNBwUcDAUFBhwMAAYEHAwFBAUkAgQDBAAoAQIHADgHBAgqDQgGJAIEBAQAKAECCAA4CAQJKg0JByQCBAUEACgBAgkAOAkECioNCggqDAIBKgwDAioMBQMqDAcFKgwGBCoMCAYjKg0IARwMAAUCADgEAgMsDAADAAIkAgQGCgw4BQoLIQIQeAALOQEAACsEAAGAAyUABAAHgAQiE7UrCIAFAAMAKAMCCgA4CgULKg4CCwA4BQYBDjgFAQIhAhCDAAI5AQAAKg4DCCoMAQUgEEwiDz0kAgQDAioIAAMqDAEEABAAAgAiE6MqBAAAHAwFAQMcDAADAgI4AQIDKAIAAAAAAAAAAAEAAAAAAAAAAAABCDgDAQQqDAIBKgwEAiMiDz0cDAUCBxwMAAcGHAwFBgIcDAUEBxwMAAcGHAwFBgQkAgQIByoIAAgqDAIJKgwECgAQAAcAIhShKgQAACoMCQYcDAUBBBwMAAQCHAwFAgEcDAUDBBwMAAQCHAwFAgMkAgQHBCoIAAcqDAEIKgwDCQAQAAQAIhShKgQAACoMCAIkAgABAQo4BgEDIQIQuAADIBC2KgwGBSAQuioMAgUgELoqDAUBIyIPPSQCBAEHJAIEAAgqDAgGIBDBCjgGCAEhAhDFAAEgEMQjHAwABgEAOAQBAiQCBAEDDDgGAwkhAhDLAAk5AQAAACgFAgMAOAMGCSoNCQEtDAABAAIAOAYHAQ44BgECIQIQ0wACOQEAACoMAQYgEMEiDz0AKAECAjgDAAIAACMiDz0kAgQKCSoIAAoqDAELKgwCDCoMAw0qDAQOABAACQAiFLUqBAAAKgwLBSoMDAYqDA0HKgwOCCQCBAwLKggADCoMAw0qDAQOKgwFDyoMBhAAEAALACIRIyoEAAAqDA0JKgwOCiQCBA4NKggADioMCQ8qDAoQKgwHESoMCBIAEAANACIRPCoEAAAqDA8LKgwQDAo4AQsJIQIRAAAJOQEAAAo4AgwBIQIRAwABOQEAACQCBAkCKggACSoMBwoqDAgLKgwDDCoMBA0AEAACACIQlSoEAAAqDAoBJAIAAAIKOAECAyECEREAAzkBAAAqDAYCKgwFASMiDz0cDAABAiQCBAMBKggAAyoMAgQAEAABACIToyoEAAAcDAUCAxwMAAMBAjgCAQMoAgAAAAAAAAAAAQAAAAAAAAAAAAIIOAMCBCoMBAIjIg89BDgCBAUkAgAABgo4BQYHIQIRKQAHOQEAAAQ4AQMFHAwFBQccDAAHBgI4BQYHKAIAAAAAAAAAAAEAAAAAAAAAAAAICDgHCAkAOAECBwA4AwQBBDgHAQICOAIFAQA4AQkCHAwFAgMcDAADAQo4AQIDIQIROQADOQEAACoMAQIqDAYBIyIPPQA4AQMFHAwFBQMcDAADAQI4BQEDKAIAAAAAAAAAAAEAAAAAAAAAAAAFCDgDBQYAOAIEAwA4AwYCHAwFAgQcDAAEAwo4AwIEIQIRSgAEOQEAACoMAwIjIg89ACgBAgI4AwACAAYjIg89KggBBgAAAQIBKg4BBioIAQEAAAECASoOAgEkAgQBAiQCAQEHJAIEAAgqDAgFIBFcDDgFAwghAhFkAAggEV8qDQYCKg0BAyoMAgEqDAMCIww4BQMIIQIRZwAIOQEAAAAoBAIJKg0JCQw4BQkKIQIRbAAKOQEAACQCBAIKADgECgkAOAkFCioNCggqDQYJKg0BCgAoCQILKwQACoADJQAEAAGABCIRhCsIgAUADCsIgAYADSoOCA0qDQwIACgIAggqDggMKg4LBioODAEAOAUCCA44BQgJIQIRggAJOQEAACoMCAUgEVwBAIADAAKABysBgAeABwEAgAeABIAIJQAEAAKACgEAgAiACoAJKwAAAYAFAQAAAYAJAAElAQQAAYAFAQCABQACgAkrAoAIgAklAAQAAoAKAQCAA4AKgAklAAQAAoALAQCABYALgAolAAQAAIAMDQCADIAHgA0XAIANgA0hABGcgA0BAIAJgAyADisBgA6ACwEAgAqADIAOKwKAC4AOAQCADAACgAwgEZMBAIAKgAeABiMiDz0cDAQBAxwMAAMCHAwEAgEjIg89HAwABQ0kAgQBBSQCBAEPJAIEAhEAOA8RECoIAQ4AEAEQASQDBAEOACgOAhAqDg8QJAIEAhAAOA4QDyoMDxAqDg0QJAIEEhEqCAASKgwFEyoMDhQqDAYVKgwHFgAQABEAIhFQKgQAACoMEw8qDBQQKQIAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAABSECEcIACCARwCoMBQwgEcQqDAkMIBHEIQIRyAAKIBHGKgwFASARyioMCwEgEcoqCAECJAIEAwMAEAEDASQDBAECACgCAgMqDAMFKg4MBQAoBQIFKg4BBSYCANVEGw0AAwAoAgIFACgQAggqDQgHACgIAgYqCAEIAAABAgEkAwQBCAAoCAIKNj+VAAUABAAGAAcACgAAAAkAAyQCAgEBCjgJAQIhAhHhAAI5AQAAKgwIASMiDz0kAgAABCoIAQUkAgQCBgAQAQYBJAMEAQUAKAUCBioMBgcqDgQHJAIECAcqCAAIKgwBCSoMAgoqDAULABAABwAiFVUqBAAAKgwJBiQCBAcCKggAByoMAwgqDAYJABAAAgAiEnwqBAAAKgwIASMiDz0kAgAABCoIAQUkAgQCBgAQAQYBJAMEAQUAKAUCBioMBgcqDgQHJAIECAcqCAAIKgwBCSoMAgoqDAULABAABwAiFVUqBAAAKgwJBiQCBAcCKggAByoMAwgqDAYJABAAAgAiEnwqBAAAKgwIASMiDz0qDQEFKg0CASoNAwIkAgQHBioIAAcqDAUIKgwBCSoMAgoqDAQLABAABgAiFZAqBAAAKgwIAyQCBAABACgDAgQAOAQBBSoNBQIqDAIBIyIPPSoNAQUqDQIBKg0DAiQCBAcGKggAByoMBQgqDAEJKgwCCioMBAsAEAAGACIVkCoEAAAqDAgDJAIEAAEAKAMCBAA4BAEFKg0FAioMAgEjIg89KggBBQAAAQIBKg4DBSoNAwYAKAYCBioOBgMkAgQBBiQCBAAHKgwHBCASTAo4BAcIIQISXAAIIBJPKg0BBCoNAgcAOAcGCA44BwgJIQISVQAJOQEAACoOBAEqDggCKg0FASoNAwICKAICAioOAgMjKg0FCCoNAQkqDQIKADgKBAsOOAoLDCECEmMADDkBAAAkAgQCDAw4CwwNIQISZwANOQEAAAAoCQIMADgMCw0qDQ0KJAIEAQsMOAQLDCECEm4ADDkBAAArBAAIgAMlAAQAAoAEIhO1KwiABQAJACgJAgsAOAsEDCoOCgwAOAQGCA44BAgKIQISeQAKOQEAACoOCQUqDAgEIBJMIg89JAIABAQKOAEEBSQCBAAEIQISiwAFIBKCJAIABgUKOAEFBiECEoYABjkBAAAAKAICBQA4BQQGKg0GASoMAQMgEpAAKAICBQA4BQQGKg0GASoMAQMgEpAqDAMBIyIPPSgCAAAAAAAAAAABAAAAAAAAAAAABQA4BQEGAjgGAwEcDAUBBRwMAAUDCjgBAwUcDAAFAQI4AgQFAjgFAQIcDAUCBBwMAAQBCjgBAgQhAhKhAAQ5AQAAKgwBAioMAwEjIg89JAIAAAskAgQPDioIAA8qDAsQABAADgAiEIYqBAAAKgwQDCoMEQ0kAgQQDyoIABAqDAERKgwCEioMDBMqDA0UABAADwAiEJUqBAAAKgwRDiQCAAIMCjgODA0hAhK8AA05AQAAJgIAO5rKAAAMJAIEEA8qCAAQKgwMEQAQAA8AIhCGKgQAACoMEQ0qDBIOJAIEERAqCAARKgwDEioMBBMqDAEUKgwCFQAQABAAIhEjKgQAACoMEgwqDBMPJAIEExIqCAATKgwMFCoMDxUqDA0WKgwOFwAQABIAIhDZKgQAACoMFBAqDBURJAIEExIqCAATKgwQFCoMERUqDAUWKgwGFwAQABIAIhE8KgQAACoMFAwqDBUPJAIEExIqCAATKgwMFCoMDxUqDAcWKgwIFwAQABIAIhKSKgQAACoMFBAqDBURJAIEExIqCAATKgwFFCoMBhUqDA0WKgwOFwAQABIAIhEjKgQAACoMFAwqDBUPJAIEExIqCAATKgwMFCoMDxUqDAEWKgwCFwAQABIAIhDZKgQAACoMFAUqDBUGJAIEFRQqCAAVKgwFFioMBhcqDAEYKgwCGQAQABQAIhEjKgQAACoMFhIqDBcTJAIEFhUqCAAWKgwSFyoMExgqDAwZKgwPGgAQABUAIhCVKgQAACoMFxQKOBQLDCECEyIADCATHyoMBQkqDAYKIBM5JAIAAQskAgQTEioIABMqDAsUABAAEgAiEIYqBAAAKgwUDCoMFQ8kAgQUEyoIABQqDAUVKgwGFioMDBcqDA8YABAAEwAiETwqBAAAKgwVCyoMFhIqDAsJKgwSCiATOSQCBBILKggAEioMBxMqDAgUKgwNFSoMDhYAEAALACIRIyoEAAAqDBMFKgwUBiQCBBILKggAEioMBRMqDAYUKgwBFSoMAhYAEAALACIQ2SoEAAAqDBMHKgwUCCQCBBIFKggAEioMAxMqDAQUKgwJFSoMChYAEAAFACIRPCoEAAAqDBMBKgwUAiQCBBIFKggAEioMARMqDAIUKgwHFSoMCBYAEAAFACISkioEAAAqDBMDKgwUBCoMEAEqDBECIyIPPSoIAQUAAAECASoOAwUqDQMGACgGAgYqDgYDJAIEAQYkAgQAByoMBwQgE3MKOAQHCCECE4MACCATdioNAQQqDQIHADgHBggOOAcICSECE3wACTkBAAAqDgQBKg4IAioNBQEqDQMCAigCAgIqDgIDIyoNBQgqDQEJKg0CCgA4CgQLDjgKCwwhAhOKAAw5AQAAJAIEAQwMOAsMDSECE44ADTkBAAAAKAkCDAA4DAsNKg0NCiQCBAELDDgECwwhAhOVAAw5AQAAKwQACIADJQAEAAKABCITtSsIgAUACQAoCQILADgLBAwqDgoMADgEBggOOAQICiECE6AACjkBAAAqDgkFKgwIBCATcyIPPRwMAAECKAIA/////////////////////wADDjgCAwQhAhOpAAQ5AQAAIyUABAAAgAcNAIAHgAWACBcAgAiACCEAE7SACAEAgAOAB4AJKwGACYAGAQCABIAHgAkrAoAGgAkBAIAHAAKAByATqyMrAYADgAYLAIAGAAKAByEAE7mAByATuysAgAOABSATySsAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQATx4AKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIBO+JQEEAAGABSATySMiDz0qCAEFAAABAgEqDgMFKg0DBgAoBgIGKg4GAyQCBAEGJAIEAAcqDAcEIBPVCjgEBwghAhPlAAggE9gqDQEE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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"5498":"Array index out of bounds","5175":"Array index out of bounds","5480":"attempt to add with overflow","1573":"Nested static call failed!","4706":"attempt to add with overflow","5023":"attempt to add with overflow","3865":"attempt to add with overflow","1427":"Function _withdraw can only be called internally","336":"attempt to subtract with overflow","5005":"Array index out of bounds","4298":"Array index out of bounds","4481":"attempt to add with overflow","5121":"attempt to add with overflow","4987":"attempt to add with overflow","3256":"Function get_asset can only be called statically","4408":"attempt to multiply with overflow","3890":"Array index out of bounds","5103":"Array index out of bounds","5505":"Array index out of bounds","4768":"attempt to subtract with underflow","5085":"attempt to add with overflow","5012":"Array index out of bounds","1093":"Nested call failed!","4226":"attempt to add with overflow","5183":"Array index out of bounds","5110":"Array index out of bounds","5494":"attempt to add with overflow","4117":"Storage slot 0 not allowed. Storage slots must start from 1.","4306":"attempt to add with overflow","5001":"attempt to add with overflow","1027":"Function _deposit can only be called internally","3904":"Stack too deep","3642":"Function get_assets can only be called statically","3898":"attempt to add with overflow","4087":"attempt to add with overflow","4215":"Array index out of bounds","5562":"attempt to add with overflow","4459":"Array index out of bounds","4392":"attempt to multiply with overflow","3045":"Nested call failed!","418":"attempt to subtract with overflow","3813":"Array index out of bounds","4069":"Array index out of bounds","3801":"attempt to add with overflow","5032":"call to assert_max_bit_size","5099":"attempt to add with overflow","400":"attempt to subtract with overflow","3966":"Not initialized","3387":"Function get_position can only be called statically","3832":"attempt to add with overflow","4728":"attempt to add with overflow","5167":"Array index out of bounds","3820":"Array index out of bounds","5551":"Array index out of bounds","4454":"Index out of bounds","2979":"Function _repay can only be called internally","3808":"attempt to add with overflow","4131":"Storage slot 0 not allowed. Storage slots must start from 1.","4576":"Nested call failed!","4710":"Array index out of bounds","4692":"attempt to add with overflow","3857":"Array index out of bounds","5222":"Array index out of bounds","2248":"Nested call failed!","3778":"Array index out of bounds","5241":"attempt to add with overflow","4717":"Array index out of bounds","2328":"Nested static call failed!","1493":"Nested call failed!","5199":"attempt to add with overflow","4108":"Storage slot 0 not allowed. Storage slots must start from 1.","4425":"attempt to add with overflow","2182":"Function _borrow can only be called internally","5516":"attempt to add with overflow"}},{"name":"_borrow","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["_borrow"],"assert_messages":{"960":"attempt to add with overflow","893":"Storage slot 0 not allowed. Storage slots must start from 1.","698":"Nested call failed!","1280":"attempt to add with overflow","942":"Array index out of bounds","104":"Nested call failed!","1256":"Array index out of bounds","34":"Function _borrow can only be called internally","994":"Array index out of bounds","726":"Stack too deep","720":"attempt to add with overflow","760":"Array index out of bounds","1062":"attempt to multiply with overflow","1248":"Array index out of bounds","29":"Not initialized","1053":"attempt to subtract with underflow","1303":"Array index out of bounds","916":"Storage slot 0 not allowed. Storage slots must start from 1.","782":"attempt to add with overflow","712":"Array index out of bounds","1014":"call to assert_max_bit_size","755":"Index out of bounds","179":"Nested static call failed!","1005":"attempt to add with overflow","1078":"attempt to multiply with overflow","1264":"Array index out of bounds","1322":"attempt to add with overflow","1036":"attempt to add with overflow","902":"Storage slot 0 not allowed. Storage slots must start from 1."}},{"name":"update_accumulator","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"interest_accumulator","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"loan_to_value","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"oracle","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"asset::Asset"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["update_accumulator"],"assert_messages":{"32":"Not initialized","608":"Array index out of bounds","212":"attempt to subtract with overflow","692":"Array index out of bounds","587":"Array index out of bounds","296":"attempt to subtract with overflow","805":"attempt to multiply with overflow","901":"attempt to add with overflow","569":"Array index out of bounds","278":"attempt to subtract with overflow","598":"attempt to add with overflow","135":"Storage slot 0 not allowed. Storage slots must start from 1.","676":"Array index out of bounds","577":"attempt to add with overflow","708":"attempt to add with overflow","632":"Stack too deep","821":"attempt to multiply with overflow","626":"attempt to add with overflow","882":"Array index out of bounds","684":"Array index out of bounds","946":"call to assert_max_bit_size","838":"attempt to add with overflow","1065":"attempt to subtract with underflow"}},{"name":"init","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"oracle","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"loan_to_value","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"stable_coin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["init"],"assert_messages":{"349":"Array index out of bounds","433":"Array index out of bounds","328":"Array index out of bounds","133":"Storage slot 0 not allowed. Storage slots must start from 1.","578":"attempt to add with overflow","310":"Array index out of bounds","339":"attempt to add with overflow","449":"attempt to add with overflow","417":"Array index out of bounds","318":"attempt to add with overflow","30":"Not initialized","373":"Stack too deep","507":"Array index out of bounds","367":"attempt to add with overflow","559":"Array index out of bounds","457":"call to assert_max_bit_size","425":"Array index out of bounds","515":"attempt to add with overflow"}},{"name":"_repay","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"stable_coin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["_repay"],"assert_messages":{"29":"Not initialized","381":"Array index out of bounds","439":"attempt to add with overflow","695":"attempt to multiply with overflow","788":"attempt to subtract with underflow","855":"Array index out of bounds","395":"Stack too deep","887":"attempt to add with overflow","389":"attempt to add with overflow","34":"Function _repay can only be called internally","863":"Array index out of bounds","910":"Array index out of bounds","560":"Storage slot 0 not allowed. Storage slots must start from 1.","74":"Nested call failed!","551":"Storage slot 0 not allowed. Storage slots must start from 1.","618":"attempt to add with overflow","679":"attempt to multiply with overflow","574":"Storage slot 0 not allowed. Storage slots must start from 1.","871":"Array index out of bounds","600":"Array index out of bounds","929":"attempt to add with overflow","626":"call to assert_max_bit_size","428":"Array index out of bounds","771":"attempt to add with overflow"}},{"name":"deposit_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"from","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7Vrdbts8DH0XX/dC/JFI9lU+fBjSrRsCBOnQdgOGYu8+Jatkx5FjaLa3dPNNUbU8h9SRRFGSX5oP93dfPr3b7j8+PDW3/700u4f3m+ftwz62Xhqg49+ePm/2h+bT8+bxubmFYO6mud9/iL+Kc99vmo/b3X1zy+C/35xZo6i8WqM6y9YQoGBNHPTVmjzDiDWAC5BCASec7QlLsQAjJnPusBMXydEyt2jX+P+bBniVZkgav0ozJE1YpRmSRlZphqTRVZohaWyVZkAadFcvjWkOP/ZlTBrVkMzN+UnSwCrNkDQ4XRoyTnOeTKTtrIajC1reBU93Aeg5WaN2BlhLQ2Y+c1twpwEVJg+oT+s8/q5w1gH/1jtQrHTIq0/DFryOdIBdmtUM0rGVowNZ2oEu7cBmcEBp0JjPHJBb2gEs7QDnGANKDvy5A5rBgaVU5JFOHBRWmUGKxkzG8jo6THGg8601WiklIiVqQgld40NH+e/pKLW5n4z6HfX/yoiGf2VE5ao7Spw3QjLsx17eRIKkEowEx2L3uRYMro2dPL3l0wnZKkxRGHZXLsyfOpkwrMKUhcFVmLIwNCqMwdgxP56WUnpH1+7BYKXOek3FbIA29Gh6iIZniAYh5GjEj0QDcXRyWvLBcf+Qxv76Qgq/P6TAnZCCnYUk1xeSzhsSsxsJidjlags7tu4YTnkzb68IyCyMhCNOU5oQcDoazhvZzr1bpRmSBlZphqTBVZohaWiVZkgavnpp/lQp6P0qzZA0YQZpAFppmCZUyV7miMZTjsbGBiq+ZFBesOpZT4qtX3j68Pr2u2C/vQsWs1+e0cdJ3w0ptu4et7vd9tO7ky/U3OEHFHdLk7xCXOetrLicYomdZmTnMTGaRi3KH8HNxs6T2a2z9Prsfjp7euXuXiK8sodF2WUqu+T3T+mcWV7ZdVF2m8yeL6zV9edM+cuOOvaUgRWhzw5T2ZXSqOqZMogzsvdWU2zAwbB86R632LYu68y2n/tO+T76MqZ8VTuCgVpMbOAxyxUjDGR5nnRypgvDE+UyBOohWA+hegjXQ4rZT3MxpN2N0l34bOEyROohWg+xakj5+f8yBOohWA+hegjXQ8qjrylrq9kJpFAmSf7Cq/MoSc4PP7/ORy/L0utU+vjomu8a+YzeFqUvJ9756GFZelyWnpal52Xp/bL0YUZ6PVtWLMvS67L05aoVU21mJP0kW77evgyBegjWQ6gewvUQXw8J1ZDwCxCphxQnF3L+jCdIf8IEq4aIq4dAPQTrIVQP4XqIr4eEekhx9C8WBKL1EKuGqKuHQD0E6yFUCYkt+ivPmnw8axZ75S1d/4nvbjQHOWLz6+Zxu7nb3R8u5g7//bJ/n+7pYvP52+ef/4nGPwA=","brillig_names":["decompose_hint","pack_arguments_oracle_wrapper","call_private_function_internal","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert"]},{"name":"_deposit","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3Rbty2EobfZa9zwSGHHDKvcnBQOG1aGDCcInEPcBDk3at1La0cjZbwz21CQnMT2DH/3V+fZjkzXEr6evrt44e//vjl/vH3T19O7//z9fTw6de7p/tPj9NvX7+9O334fP/wcP/HL+v/PrnzP+Sfx3/58+7x/OuXp7vPT6f3lIp7d/r4+Nv0ozg3vcLv9w8fT++Z4rd3m9ElxpfBReIyljIpY0NJ8+BQhFejtVdOnOlldOIir0b/992JQrt5csHPo130P9Q+34B9ocU91eCTj2UeHV6N1l5aJOSX0SLn1/vOfbyt+/ja/fkd0r/+DvKvv0Nufwd2y4lgx6kWdJHn0SmmsDltpd3QTT8F3r3V0FlEiMgjInWOYXHzJ4nFlx/KS501OBVZDMVci6js5rfgvLJPRZs2/ITlZbTPQSr2M/v5tTPLZtrwcWz7aWz7Mrb9PLb9MrT94Ma2T2Pb92PbD2PbHzvrhrGzbhg764axs24YO+uGsbMuj511eeysy2NnXR476/LYWZfHzro8dtblsbMuj511eeysG8fOunHsrBvHzrpx7Kwbx866ceysG8fOunHsrBvHzrrxx2fdy7f/vqTNt1XJ9WaIejPkezOkZ6+8hOmrt9jbVZH5ZTSRWxkKmqGYeN6DEdP2K+vEvRmKvRlKvRmS3gzl3gyVzgyJ680Q9WbI92aot5laepuppbeZWnqbqeUnzNReFkOSKwUvBVn214V82Z4VyD/bz2PbL0Pbz25s+zsZZtlAyVle2z+LPCIKiEifTYtLs6h4qdAtYd6nWPKK7fmsbGnF+YW98ytW+llzPDcR08/lMq8Er2+BXBqUsHpt1tqT4OaA8MFXBqcwe06r3nkaeuYXjV8Tv2T8mviJ8Wvil41fE79i/Fr4FWf8mviR8Wvi541fE79g/Jr4sfFr4mf9Rxs/6z/a+Fn/0cbP+o86P5mX+tJqN8ILP+s/mvhNvgxgG0DrQBoBWgvSCNB6kEaAbABfA3ymYq2FRsUaBo2KtQEaFSvuNSpWsitUyOpwjYoV1xoVq5g1KlYGa1TYqChUrLbVqFhtq1Gx2lajYrWtRsVqW4WKt9pWo2K1rUbFaluNitW2GhU2KgoVq201KlbbalSsttWoWG2rUbHaVqESrLbVqFhtq1Gx2lajYrWtRoWNikLFaluFCh81B/GFyuqxODOVg84r2c+efeYAD35GeNBJ6C0ISSTMNqRs9pbxQWesWyI8aOt+S4QH7fPfhDDn2TQVt00nB10UuCXCg64g3BBhPGipd0uEB12buCXCgy5k3BKhdSfNCNkQtiK07qQZoXUnzQitO2lGaN1JM0LrTloRJutOmhFad9KM0LqTZoTWndS/O3HeL6bDFiEbwlaE1p00I7TupBmhdSfNCK07aUZo3UkrQrHupBmhdSfNCG/QnZBLl+dZeKpALEupX1ZQ9FdOy8MsUl49+SLQP97DwN55YO9xYO87FWhaPn1FuOr9hk8jop3HEf1MR7k7R6U3RzvPAfqZjqg7R747R6E7R9ydo9ido58wZ7/lmVueaSmxeJXL/PQ+z/5lcP95cP9q9ohueYJwdN698n9W7T2LYilFphdwtaP2aX7c2VTYcOWok3PzUSe3fqaxetRRytwFxLxyMn9q9u4l343/vFwvEXPkrX/p3b8vV/3n3v0v3WzMKW79l6H9+71biQ/jnwb33/v8WfMfBvfPg/uPg/vvPv9W/Heffyv+x86/3g2ef2nw/EuD51/qPv9SvPhPldGFwnxFYSHh7dF2n633j/bZf/fZuuK/+2xd8d99tq74P+rtkJYLjX3I398xwB/19o1M6bIgxhsqB91OWaHCRkWhctBNjxUqB93HWKFy0K2JFSoH3W1YoXLQeuU6laPevrFC5aDb/CpUrLbVqFhtq1Fho6JQsdpWo2K1rUbFaluNylFrW3fZcERxQ+Wote1VKke9LWyFylFr2+tUjlrbXqdy1Nr2OhU2KgqVo9a216kctba9TuWote11KlbFKVSOesfXChWr4jQqVsUpVPRbasWQlyteQn59xcuzykOqAKkYUkVIlSCVQKoMqQqi0u/uUFVBsSFQbAgUGwLFhn79bmRargBaf1BmlX79aOTgFlXY7oTSr6isvpcevZyW42KRrUqPXo7+qkp2jqtcVLVr3orz8/EUF5X3yBC7gqiKg1QEqaCYKAFSMaSKkCpBKoFUUGwUJDaCc5CKIJWHVEhsBH13deb5I5zj95sRg75FltwyWZBLcSNKiEgQUUZEalAQLZdGEq2msheR/gD2mogQkUdEARExIoqIKCEiQUQZESEREZCICEhEBCQiAhIRAYkI/cvXq9NK2PmwL/UOubAR6V/G1ESEiDwiCoiIEREyKTMyKTMyKTMyKesrVxVRdIiIEJFHRDsRkZZPk8t+I2JEFBFRQkSCiDIiKoAo1SNCESERkZCISAERMSJC5oiEzBEJmSMSMkckZI4QZI4QJCIEiQhBIkKQiBAkIgQ5uYKcXEFObkZObkaKHH2thabvt2fRtEi6ESVEJIgoI6ICiPSFE/KyrExPvfpGRIhIRx5pbnKnH7f2EiISRJQRUXm7iPX1CErL1cWUktuICBF5RBQQESOiiIgSIhJElBFRAUSERAQhEUFIRBASEYREBCERQUhEEBIRhETEzvpUyktSE/d9Dcs761MVESEij4gCImJEFBFRQkT6yeXl3tXEvJnLd5aarot2lpoqIkJEHhEFRMSIKCKihIgEESEREZCIYCQidtbCOMoiks1stLMWVhEFRMSIKCKihIgEEWVEVADRzlpYRYREREQiIiIREZGIiEhERKBt4CiIKCOiN7cN36bf/nf3+f7uw8PHL5Pm/Me/Hn99uv/0+PLr0////Ocv0+C/AQ==","brillig_names":["_deposit"],"assert_messages":{"17":"Not initialized","302":"attempt to add with overflow","258":"Stack too deep","252":"attempt to add with overflow","348":"Array index out of bounds","22":"Function _deposit can only be called internally","380":"attempt to add with overflow","208":"Array index out of bounds","403":"Array index out of bounds","234":"Array index out of bounds","356":"Array index out of bounds","62":"Nested call failed!","216":"attempt to add with overflow","175":"Storage slot 0 not allowed. Storage slots must start from 1.","364":"Array index out of bounds","422":"attempt to add with overflow","291":"Array index out of bounds"}},{"name":"borrow_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VjhjtowDH6X/uZHbCexzatM0wnuuFMlBCfgJk3o3n1pR9JSgipWusGOf4R+/Wx/sV0n++JlMf94eypXr+ttMf22L5br59muXK/Cal8A1f9t32erarndzTa7YgpezaRYrF7CTzbmc1K8lstFMbXgPicnaGThAxrFaEKDhwyarJcDmpyFHjSA8RBdAcM24QlzvoBFjHDbYiebJUdN3Cxt8PdJAfYhzTlp3EOac9L4m5dGJbkfYumTRsRHuBo3SBp+SHNOGhkuDamNOU/K3AQrvjaho5tAM9wEoLMRjdLaYMltmbrErd4cO5RJHhAX6zz8FjgJAO49AMwFwIgxURlFegKwJoItcAvLtQEa24Ad24C7hgGKBtypAX8FAxrrzCEdGcikkEL0RpX7mhYadDGDjGvQqLl6R4rUhOzb4CpQ/n8CpaaxkVI3UPkqO6pfZEfJ3HSgZFOXJ8Wu79mPFFNqemzJ9fjORuKkw2CaSEHvevgmfEhzThq6eWn+1fBN9iHNOWncFaQBaKSx1CONkzgPe2iYA7Tyxl/DG0fJG+3bqDBvUypYcVaGDujE9x+C/PUQNHS/lNF10rddCqv5plwuy7eno7tNU19wZj8JyqlCTOtEly0n72OB+NaRN0CrQzWNym4Hs2ur9Lrsbjg7N+NSl92Pys5D2Tmd0tljl11GZdfB7GnyFNPNmfwdzGXssQMLQpcdhrILxV2VE2UQr8jeqaawgAqY717hE9vMZa1sO3x39PJ3rPmDd+DSd8IC6y6XjcppbOTsWhdRppIjLH/MNuVsvlxUzbJ6+rF6jr0zLHc/338/CeBf","brillig_names":["decompose_hint","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert"]},{"name":"borrow_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAo4AIBFAAAiAIUeAgAAAx4CAAAEMDgAAwAEAAUkAgEBAyECABEABTkBAAAeAgAAAx4CAQAEJAIEAAUkAgQAByQCBAIJADgHCQgqCAEGABABCAEkAwQBBgAoBgIIKg4HCCQCBAIIADgGCAckAgQBByQCBAEJJAIEAgsAOAkLCioIAQgAEAEKASQDBAEIACgIAgoqDgkKJAIEAgoAOAgKCSoMCQoqDgQKJAIEDAsqCAAMKgwFDSoMBg4qDAcPKgwIEAAQAAsAIgCKKgQAACoMDQkqDA4KJAIEAQUkAgQCCAA4BQgGKggBBAAQAQYBJAMEAQQAKAQCBioOBQYkAgQCBgA4BAYFKgwFBioOAQYkAgQLCCoIAAsqDAkMKgwKDSoMBw4qDAQPABAACAAiAIoqBAAAKgwMBSoMDQYAKAUCASsEAAaAAyUABAABgAQiAL4rCIAFAAQrCIAGAAgqDgIIJgIAtehDkwACJAIEAQYkAgQCCQA4BgkIKggBBQAQAQgBJAMEAQUAKAUCCCoOBggkAgQCCAA4BQgGKgwGCCoOAggkAgQKCSoIAAoqDAcLKgwFDCoMAQ0qDAQOABAACQAiAIoqBAAAKgwLBioMDAgqCAEBJAIEAwIAEAECASQDBAEBACgBAgIqDAIEKQIAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAABSoOBQQAKAQCBCoOBQQmAgDVRBsNAAIAKAECBAAoCAIKKg0KCQAoCgIHKggBCgAAAQIBJAMEAQoAKAoCDDY/lQAEAAMABwAJAAwAAAALAAIkAgIBAQo4CwECIQIAhAACOQEAACMlAAR4AIAEDQAAAIAEgAMhAACJgAM5AQAAIyIAhSoIAQYAAAECASoOAQYqCAEBAAABAgEqDgIBJAIEAQIkAgEBByQCBAAIKgwIBSAAlgw4BQMIIQIAngAIIACZKg0GAioNAQMqDAIBKgwDAiMMOAUDCCECAKEACDkBAAAAKAQCCSoNCQkMOAUJCiECAKYACjkBAAAkAgQCCgA4BAoJADgJBQoqDQoIKg0GCSoNAQoAKAkCCysEAAqAAyUABAABgAQiAL4rCIAFAAwrCIAGAA0qDggNKg0MCAAoCAIIKg4IDCoOCwYqDgwBADgFAggOOAUICSECALwACTkBAAAqDAgFIACWAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAA1oANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIADNAQCACoAHgAYjKwAYyhjK","debug_symbols":"1ZzdThsxEIXfZa9z4bHnx+ZVqgoFCChSFBCEShXi3bsp2U3SbLXqlIPsG8Qmc3aOnPlmInmdt+5udfP6cL3e3j++dFff3rrN4+1yt37c9ldv74vu5nm92awfrk9f7sL+D9Hv+Jen5XZ/+bJbPu+6K9ISFt1qe9f/ayH0d7hfb1bdFZO8Ly6ii8ghuJiMsZRpIjYVHYJTMT6JnrqzcqZDtHKxs+jvi47i/5unkOIQHSR+qf30CWtfaHRPc4tPUcoQnc6ip25tlvIh2mx/vz/c8+e6l3P3+wwCz6DwDDaVwUR0WFoxncnwuUWXpw3l8bPWMGeIw1gZHFjnDAkP0SqaLgyVaUPM4wplmzU0LCcTncX2CWJAJyB0gohOkNAJGJ1A0AkUncDQCTI6AZrkhCY5oUlOaJITmuSEJjmhSU5okhOa5IQmOaFJZjTJjCaZ0SQzmmRGk8xokhlNMqNJZjTJjCZZ0CQLmmRBkyxokgVNsqBJFjTJgiZZ0CQLmmRFk6xokhVNsqJJVjTJiiZZ0SQrmmRFk6xokg1NsqFJNjTJhibZ0CQbmmRDk2xokg1NsqFJzmiSM5rkjCY5o0nOsyRrnNsx6fdAhi0cFTvZAylT+3RRxz3JqHbcgDrsmGSpzZDWZshqM5RrM1QqM1RCbYaoNkOxNkOpNkO1depSW6cutXXqUlunLrV16lJbp6ZQW6umUFuvplBbs6ZQW7emUFu7plBbv6ZQW8OmUFvHpvD1LdvC8IRgzOn8GbvL6MxxeCIvs10+SBlK2/4pNO6fGvcfG/efGvfPjfuXxv1r4/6tcf+Nz19qfP7GxudvbHz+xsbnb2x8/s4fLqjcf+PzNzY+f2Pj8zd+/fw9HvmMRSfOZZbaHKVQnSOqztHkp9Z/vRsPjcZwPCCbKH4cAw0uFblU0aVKLhV7VNOPQ5PSqNJ4PMGpHwsvfzkIzDqKNFyI2CPKHnvFIVLPQih5RNEjSh4Re0TiEalHZB6RpyLUUxHmqQjzVIRFBxrmgdA8EJp4ROoRmUeUPaLiEOXgEZFH5KmI7KmI7KmI7KmI7KmI/M8V8d5f/Vg+r5c3m9Xh50TuX7e3J78usvv59PFOH/wL","brillig_names":["borrow_public"],"assert_messages":{"16":"Not initialized","136":"Stack too deep","160":"Index out of bounds","165":"Array index out of bounds","131":"Nested call failed!","187":"attempt to add with overflow"}},{"name":"_withdraw","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["_withdraw"],"assert_messages":{"1076":"attempt to multiply with overflow","1262":"Array index out of bounds","1067":"attempt to subtract with underflow","104":"Nested call failed!","1317":"Array index out of bounds","34":"Function _withdraw can only be called internally","930":"Storage slot 0 not allowed. Storage slots must start from 1.","796":"attempt to add with overflow","726":"Array index out of bounds","1028":"call to assert_max_bit_size","769":"Index out of bounds","1092":"attempt to multiply with overflow","1019":"attempt to add with overflow","1278":"Array index out of bounds","1336":"attempt to add with overflow","29":"Not initialized","1050":"attempt to add with overflow","916":"Storage slot 0 not allowed. Storage slots must start from 1.","974":"attempt to add with overflow","907":"Storage slot 0 not allowed. Storage slots must start from 1.","712":"Nested call failed!","1294":"attempt to add with overflow","956":"Array index out of bounds","1270":"Array index out of bounds","179":"Nested static call failed!","1008":"Array index out of bounds","740":"Stack too deep","734":"attempt to add with overflow","774":"Array index out of bounds"}},{"name":"repay_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"stable_coin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"1Z3dThtJEIXfxddcdNXUTxevslpFkEBkCUEEZKUV4t3XBnuMwVkrFY5VfYMYqDN1NO7vlNSe0Twtvl1d/vz+ZXl7ffewOP/raXFz9/XicXl3uzp6ej5bXN4vb26W37+8/fOirX/Q9FL/8OPidn348Hhx/7g4J4t2tri6/bb61VtbneF6eXO1OBfS57/PFiQZkWZElhF5RtQzokiIuGVElBFxRpRZEZxZEfzbK+LsQ3WoborDda6lTgdqp7Bt8RQub6oPndmk06baJHyvem3e/tw8tYm31U35pPb9E6590Oyejl18Yo1t9bRXfejU7lPfVLuvz/fOff9c97rvft0h0B2mBu9wMDPCe5uRiX6kg7T5g5AmdmzRqWyrTW16/7FNfNiQ7Bj2OGJIY+7Qdg0mnV4aTOgGgm6g6AaGbuDoBh3dIMANpKEbELoBmmRBkyxokgVNsqBJFjTJgiZZ0CQrmmRFk6xokhVNsqJJVjTJiiZZ0SQrmmRFk2xokg1NsqFJNjTJhibZ0CQbmmRDk2xokg1NsqNJdjTJjibZ0SQ7mmRHk+xokh1NsqNJdjTJHU1yP0pyZzrSYLXnpfOel7/Z84pD26Bs85Yvm+/29zY7ZJ2rGZqqGZJqhrSaIatmyKsZ6tUMRTFD0aoZqpbUUS2po1pSR7WkjmpJHdWSOqoldVRL6qiW1NSqRTW1allNrVpYU6uW1tSqxTW10+e1t+29Edyn/ZtmPlZ34e3tF12cPvq3wf374P774P5jbP/UBvdPg/vnwf1Pg/uXwf0PPn9p8PlLg89fGnz+0uDzlwefvzz4/OXB5y8PPn958PnLp5+/u8dpOMw/OrJyjryco17O0eE51vv2m/GIduw5kE99+IgOP/sS3W12RMefTNkWC+1fz5cOBO/A8A4TvIPAOyi8g8E7OLxDh3cIdAeBMy1wpgXOtMCZFjjTAmda4EwLnGmBMy1wphXOtMKZVjjTCmda4UwrnGmFM61wphXOtMKZNjjTBmfa4EwbnGmDM21wpg3OtMGZNjjTBmfa4Uw7nGmHM+1wph3OtMOZdjjTDmfa4Uw7nOkOZ7rDme5wpvtxpvW0d611KedIyzmyco68nKNezlFUcxStnCMq54jLOSqX2VEus6NcZke5zI5ymR3lMjuqZTa3apnNrVpmc6uW2dyqZTa3apnNrVpmc6uW2dxOn9mfeU8Wtz64/xjbP7XB/dPg/nlw/9Pg/mVw/zq4fxvc/+DzlwafvzT4/OXB5y8PPn958PnLg89fHnz+8unn7/8/ncBs5Rx5NUeH76Kn1TcyGxWttoxm1UT8qrKUylOqnlJFRnX4TvOjql+8sIdmlfHuuRZ7vfDyi9fAiM0ia+9F2jIiSdhTzYgyF0I9I+oZUSRE1jIiyog4I5oyosyKsMyKsMyKsMyKsJ5AwzIQegZCp4yIM6IpI5KMSDMiy4g8I8qsCM+siJ5ZET2zInpmRfTfXhHPq6N/Lu6XF5c3V5sXPV7/vP365r2Pj//+eP3Pqvg/","brillig_names":["repay_public"],"assert_messages":{"128":"Nested call failed!","232":"Stack too deep","256":"Index out of bounds","261":"Array index out of bounds","227":"Nested call failed!","30":"Not initialized","283":"attempt to add with overflow"}},{"name":"get_asset","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"asset_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"interest_accumulator","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"loan_to_value","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"oracle","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"asset::Asset"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3dbts4EIXfxde54JDDv77KYrFI27QwECRFky6wKPruK7eW7EQj0zlSd0lwboq44ZF5Po00M5JCfd99vHv/7fNf+4dPj0+7d398390/frh93j8+DJ++/7jZvf+6v7/ff/7r/L935vAPhZ/jn77cPhw+Pj3ffn3evaOQzc3u7uHj8GM0ZtjCp/393e4dk/9xMxudvT8OztFPYymRMNblMA52OfLZaGnLgRMdRwfO8cXoP292FNdPnoyz42jj7X86/bQB+0zT7KkEn6zP42j3YrS06RhdOo6O8bC9V7PP287ev5z98A3W/PZvoN/+DXb9N3jL427zNhR3G5txdGRnX+826946oYOIEZFHRAERyecBEyNPuyZmKu1IN3LLKZ+w2SwdST4cx1pzQuwWzjCG/TQPk91pvPXiOWYMqPPd51gYap0ZHVpnC4ODG+ccXDwfeiCYlOBKglkJriPojBJcSZCU4EqCVgmuJOiU4EqCrARXEvRKcCXBoARXEtSeZC1B7UnWEtSeZCVB1p5kLUHtSdYS1J7kGoJxvEIYIr0mqD3JWoKsBFcS1J5kLUHtSdYS1J5kLUHtSWYED1i00ZCweO0eRCzaEohYtM4XsWjxLmJhxSJh0TJbxKK1s4hFC2IRi1a5IhatciUsQatcEYtWuSIWrXJFLFrlilhYsUhYtMoVsWiVK2LRKlfEolWuiEWrXAlL1CpXxKJVrohFq1wRi1a5IhZWLBIWrXJFLFrlili0yhWxaJUrYtEqV8KStMoVsWiVK2Lp95TLJyxniz78wpK7PYiSHedsEzt48IFht0fcWxhSjG6cxjmNI8Num9ANGXbbsW7IkJXhFQxTGidN2cxySre98IYMu22cN2TYbcm3IcNuW/INGXbbv2/HcJiZQlwPUTuVDSBqq7IBRO1VNoDICnE9RO1WNoCo7coGELVf2QCiNiwbQNSOZT1E0o7lmlsrxtpp0m4OUTuWDSBqx7IBRO1YNoDICnE9RO1YNoCoHcsGELVj2QCidiwbQNykYxmuY0zDyVIBY57K/3yGRd5yiNPblVI6bdf9fPEOWdP07Knp2dumZ39FVZpMKM4+nWZv8otvmY/2gcdD0Ydwmr/8jifvUhxHu3MHx1dzWW7egW/eQWjeQWzeQWreQW7dwTWvdarcATXvwDbvoPmcfM1rfSp30HxOds3nZNd8TnbN52TXfE7m5nMyN5+TufmczM3n5Gtea1G5g+ZzMtd/NmUat+1/fvsrB77+I5mdmRy4MHfwvxzJdoqLEFPBwbCN0e/QzZxfOQy/HHDzDnzzDkL9DqbRQ0cZ5g5i8w5S8w5y/Q6mN8QMP+aZg2Cad0DNO7BNOUjz4yA0kJMLDhrIyQUH9edkPp1NWTibhvpzcslB/Tm55KD+nFxyUH9O5qkfGnrieW0a68/JJQf15+SSg/pzcslB/TnZm/HRFvJk5g7qz8klB/Xn5JKD+nNywUHi1q/Zpfqvm3KY9hjHOHdQ/71M9vaig/rvZfL0BPDgoHTUZGPHmWTjBb/13/ksXCdODVyrv+wg13/ns+Sg/jufJQfN3y/J9d/5LDloIIMXHDSQwQsOGsjgBQctZPDLDprPybn1nGxN6znZmtZzsjWt52RrWs/Jtt8Ff9y0fLB16fVS4LbflVOG6y3jPNjyay79LoZS4NLt+iYFLt0uWVLg0u0qJAUurFxELt2uFVLg0m39UuDS7YoeBS7dLtJR4KL1rsjFar0rc9F6V+ai9a7MRetdmQsrF5FLv/WumdbHOn+IZOTSb717mUu/9e5lLv3Wu5e59FvvXuTi+q13L3Ppt969zKXfevcyl37r3ctcWLmIXLSuk7loXSdz0bpO5qJ1nchFXm0j8egz+dkjEEtLK0wP2JMJ8++JiCghogyIFv5MnqYFrInOHrkfRYSILCJyiIgRkUdEARFFRJQQUQZEEYmIiERERCIiIhERkYiISETE+ObTSlw42Ol0gnYzUSJEZBGRQ0SMiDwiQk7KCTkpJ+SknJCT8tLfx1wWESKyiMghooWICNPRZJKdiTwiCogoIqKEiPLbRW7p6ezLonJECCIgIpxxiIgRkUdEARFFRJQQEXCOcGQQESEiJCIIiQhCIoKQiCAkIgjZuYTsXIvsXIvsXAYqWMfyoWF5fICchhZhJkqIKAMibxARISL50BhKx0mUZ/QW1nksiGTknqalkzzNp5cQUQZEC21kQUSISEYe3LSfQjAzkUNEjIg8IgqIKCKihIgyIFpoIwsiQkRIREQkIiISERGJiIhEREQiIiIREZGISEhELPS5IU1JLZpZDbvQ5xZEDhExIvKIKCCiiIgSIFpoWdmelnLi2bl8oWUtiCwicoiIEZFHRAERRUSUEFF+u4iNQUSEiCwiWogIf1qDL5qZiBGRR0QBEUVElBBRBkQLLWtBRIjIIiIkIgiJCEIigpCIICQiCGgbmIC2ga1BRG9uG34Mn/6+/bq/fX9/9zRoDr/89vDhef/4cPz4/M+XX78ZBv8L","brillig_names":["get_asset"],"assert_messages":{"384":"attempt to add with overflow","221":"Array index out of bounds","26":"Function get_asset can only be called statically","122":"Storage slot 0 not allowed. Storage slots must start from 1.","202":"attempt to add with overflow","289":"Array index out of bounds","305":"Array index out of bounds","321":"attempt to add with overflow","365":"Array index out of bounds","21":"Not initialized","245":"Stack too deep","191":"Array index out of bounds","239":"attempt to add with overflow","297":"Array index out of bounds"}},{"name":"get_position","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"collateral","type":{"kind":"field"}},{"name":"static_debt","type":{"kind":"field"}},{"name":"debt","type":{"kind":"field"}}],"kind":"struct","path":"position::Position"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_position"],"assert_messages":{"582":"attempt to add with overflow","35":"Function get_position can only be called statically","922":"Array index out of bounds","750":"attempt to subtract with underflow","360":"Stack too deep","613":"attempt to multiply with overflow","930":"Array index out of bounds","511":"Storage slot 0 not allowed. Storage slots must start from 1.","988":"attempt to add with overflow","502":"Storage slot 0 not allowed. Storage slots must start from 1.","342":"Array index out of bounds","525":"Storage slot 0 not allowed. Storage slots must start from 1.","481":"attempt to add with overflow","353":"attempt to add with overflow","30":"Not initialized","571":"Array index out of bounds","606":"call to assert_max_bit_size","946":"attempt to add with overflow","629":"attempt to multiply with overflow","463":"Array index out of bounds","969":"Array index out of bounds","914":"Array index out of bounds","809":"attempt to add with overflow"}},{"name":"deposit_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"on_behalf_of","type":{"kind":"field"},"visibility":"private"},{"name":"collateral_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"1Z3dThtJEIXfxddcdFdX1w+vslpFkEBkCUEEZKUV4t3XEHtsxyYjan2s6huEoY7PYeivSnJPa14W326uf37/sry/fXhaXP71srh7+Hr1vHy4X716eb1YXD8u7+6W37/s/nhR3r7U9l7/9OPq/u3l0/PV4/PisoqXi8XN/bfVt1rK6h1ul3c3i0uu/fXvi0XliKhHRBIRaURkEZEHRFQiohoRUUQUWREUWRH06RVxcVDtva+LXftUW60eqW0um+LmyjvVx95Z2Oq6Wth1r/otvPz/8LU02lSXTmeNrye49l6n9HXu4lfqvqlue9XH3lq12bpa9e39fktvp03f99O/OTjaoRW4w9GewWSyFnErPOPAZfpHcGGZW3SdN9XSpf3+b2tH+9EqxWTRyGYCnZSC1o5fIdos1dXF6jOBuk9/ctn+xa23dwNGG3S0gaANFG1gaAMHG3BBG1S0AaEN0CQzmmRGk8xokhlNMqNJZjTJHU1yR5Pc0SR3NMkdTXJHk9zRJHc0yR1NckeTLGiSBU2yoEkWNMmCJlnQJAuaZEGTLGiSBU2yoklWNMmKJlnRJCuaZEWTrGiSFU2yoklWNMmGJtnQJBuaZEOTbGiSDU2yoUk2NMmGJtnQJDuaZEeT7GiSHU2yo0l2NMmOJtnRJDuaZEeTXEuBO1S4A8EdGtyB4Q6zPDeZ229c7SButvek684Ooh/bVCaZNtBJdLtbut7eq0XSJdJ0iSxdIs+WqJZ0iWq6RJQuUUuXiNMlSteza7qeXdP17JquZ9d0PZvS9WxK17MpXc+mdD2b0vVsStezKV3PpnQ9m9L1bDp/z9ayubuVrO3fjnlYbUybmzeN9eAm4NrK4Pnr4Plp8Pxt8Pw8eP4+eH4ZPL8Ont8Gzz/4/OXB5y8PPn958PnLg8/f+SMByfMPPn958PnLg89fHnz+8vnn7/a4MrkcHEesvaRLVNMlonSJjs8x3h5r5fMea60fHHFZmUyJeptJxGUqrnWv9t2hwx0E7qBwB4M7ONrhg4Mup3SocAeCOzS4A5xpgTMtcKYFzrTAmRY40wpnWuFMK5xphTOtcKYVzrTCmVY40wpnWuFMG5xpgzNtcKYNzrTBmTY40wZn2uBMG5xpgzPtcKYdzrTDmXY40w5n2uFMO5xphzPtcKYdzTSVAneocAeCOzS4A8MdOtxB4A6zTPedz+FP8mnrn+9ao2LpEnm2RLWkS1TTJaJ0iVq6RJwuUU+XSNIlSteza7qeXdP1bErXsyldz6Z0PZvS9WxK17MpXc+mdD2b0vVsStezKV3Pbul6djt/zz7lPVnUaPD8bfD8PHj+Pnh+GTy/Dp7fBs/vY+fnMnj+wecvDz5/efD5y4PPXx58/vLg85cHn788+Pzl88/fP59OoF7SJarpEh1/2lu16ZF1qy3vSdUqvauO3xk/q6ohFYVULaTiiEo/eJ5dnVRC23Mt8uvC6wcPm2SZRFIORBwRWSSeB0QWuRBWIyKKiFpExBFRj4gkItKIKLIiLLIiPLIiPLIinAJoeARCj0DoPSKSiEgjIouI/POiVkpEVCMiiohaRMQRUY+IJCL69Ip4Xb365+pxeXV9d7N+kPbtz/uvO8/Vfv73x6/frIr/Aw==","brillig_names":["deposit_public"],"assert_messages":{"152":"Nested call failed!","256":"Stack too deep","280":"Index out of bounds","285":"Array index out of bounds","251":"Nested call failed!","30":"Not initialized","307":"attempt to add with overflow"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"PriceFeed"}},{"name":"fields","value":{"fields":[{"name":"assets","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Lending"}},{"name":"fields","value":{"fields":[{"name":"collateral_asset","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"stable_coin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"assets","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"collateral","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"static_debt","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Lending::get_position_parameters"}},{"name":"return_type","type":{"fields":[{"name":"collateral","type":{"kind":"field"}},{"name":"static_debt","type":{"kind":"field"}},{"name":"debt","type":{"kind":"field"}}],"kind":"struct","path":"position::Position"}}],"kind":"struct","path":"Lending::get_position_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"stable_coin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Lending::repay_public_parameters"}}],"kind":"struct","path":"Lending::repay_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Lending::_withdraw_parameters"}}],"kind":"struct","path":"Lending::_withdraw_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Lending::_borrow_parameters"}}],"kind":"struct","path":"Lending::_borrow_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"from","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"stable_coin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Lending::repay_private_parameters"}}],"kind":"struct","path":"Lending::repay_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Lending::borrow_private_parameters"}}],"kind":"struct","path":"Lending::borrow_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Lending::get_assets_parameters"}},{"name":"return_type","type":{"kind":"array","length":2,"type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}}],"kind":"struct","path":"Lending::get_assets_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"collateral_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Lending::_deposit_parameters"}}],"kind":"struct","path":"Lending::_deposit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"asset_id","type":{"kind":"field"}}],"kind":"struct","path":"Lending::get_asset_parameters"}},{"name":"return_type","type":{"fields":[{"name":"interest_accumulator","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"loan_to_value","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"oracle","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"asset::Asset"}}],"kind":"struct","path":"Lending::get_asset_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"oracle","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"loan_to_value","type":{"kind":"field"}},{"name":"collateral_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"stable_coin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Lending::init_parameters"}}],"kind":"struct","path":"Lending::init_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Lending::update_accumulator_parameters"}},{"name":"return_type","type":{"fields":[{"name":"interest_accumulator","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"last_updated_ts","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"loan_to_value","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"oracle","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"asset::Asset"}}],"kind":"struct","path":"Lending::update_accumulator_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"secret","type":{"kind":"field"}},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Lending::withdraw_private_parameters"}}],"kind":"struct","path":"Lending::withdraw_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"from","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"collateral_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Lending::deposit_private_parameters"}}],"kind":"struct","path":"Lending::deposit_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Lending::withdraw_public_parameters"}}],"kind":"struct","path":"Lending::withdraw_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Lending::borrow_public_parameters"}}],"kind":"struct","path":"Lending::borrow_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Lending::constructor_parameters"}}],"kind":"struct","path":"Lending::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"stable_coin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Lending::_repay_parameters"}}],"kind":"struct","path":"Lending::_repay_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"nonce","type":{"kind":"field"}},{"name":"on_behalf_of","type":{"kind":"field"}},{"name":"collateral_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Lending::deposit_public_parameters"}}],"kind":"struct","path":"Lending::deposit_public_abi"}]}},"file_map":{"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"190":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"308":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"309":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"353":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        oracle::random::random,\n        prelude::{\n            NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n            FunctionSelector,\n        },\n        encrypted_logs::{\n            encrypted_note_emission::{\n                encode_and_encrypt_note, encode_and_encrypt_note_unconstrained,\n                encrypt_and_emit_partial_log,\n            }, encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n        }, keys::getters::get_public_keys,\n        macros::{\n            storage::storage, events::event,\n            functions::{initializer, private, view, public, internal},\n        }, utils::comparison::Comparator, protocol_types::{point::Point, traits::Serialize},\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote, token_note::TokenNote, balance_set::BalanceSet,\n    };\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[event]\n    #[derive(Serialize)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<TokenNote, Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote, Context>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: SharedImmutable<FieldCompressedString, Context>,\n        name: SharedImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n    // docs:start:mint_public\n    #[public]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n    // docs:start:mint_private\n    #[public]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[private]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_public_keys(caller);\n        storage.balances.at(caller).add(caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller),\n        );\n        Token::at(context.this_address())\n            .assert_minter_and_mint(context.msg_sender(), amount)\n            .enqueue(&mut context);\n    }\n    #[public]\n    #[internal]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n    // docs:start:shield\n    #[public]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n    // docs:start:transfer_public\n    #[public]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n    // docs:start:redeem_shield\n    #[private]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options\n            .select(TransparentNote::properties().amount, Comparator.EQ, amount)\n            .select(TransparentNote::properties().secret_hash, Comparator.EQ, secret_hash)\n            .set_limit(1);\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n        storage.balances.at(to).add(to_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to),\n        );\n    }\n    // docs:end:redeem_shield\n    // docs:start:unshield\n    #[private]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                from_keys.ivpk_m,\n                from,\n            ),\n        );\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n    }\n    // docs:end:transfer\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n    // docs:start:transfer_from\n    #[private]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            from_keys.ivpk_m,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            to_keys.ivpk_m,\n            to,\n        ));\n    }\n    // docs:end:transfer_from\n    // docs:start:burn\n    #[private]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_keys = get_public_keys(fee_payer);\n        let user_keys = get_public_keys(user);\n\n        let fee_payer_npk_m_hash = fee_payer_keys.npk_m.hash();\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                user_keys.ovpk_m,\n                user_keys.ivpk_m,\n                user,\n            ),\n        );\n\n        // 4. Now we get the partial payloads\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let fee_payer_randomness = unsafe { random() };\n        let user_randomness = unsafe { random() };\n\n        let fee_payer_setup_payload = TokenNote::setup_payload().new(\n            fee_payer_npk_m_hash,\n            fee_payer_randomness,\n            storage.balances.at(fee_payer).set.storage_slot,\n        );\n\n        let user_setup_payload = TokenNote::setup_payload().new(\n            user_npk_m_hash,\n            user_randomness,\n            storage.balances.at(user).set.storage_slot,\n        );\n\n        // 5. We encrypt and emit the partial note log\n        encrypt_and_emit_partial_log(\n            &mut context,\n            fee_payer_setup_payload.log_plaintext,\n            fee_payer_keys,\n            fee_payer,\n        );\n        encrypt_and_emit_partial_log(\n            &mut context,\n            user_setup_payload.log_plaintext,\n            user_keys,\n            user,\n        );\n\n        // 6. We convert the hiding points to standard `Point` type as we cannot pass `TokenNoteHidingPoint` type\n        // as an argument to a function due to macro limitations (the `TokenNoteHidingPoint` type is macro generated\n        // and hence is not resolved soon enough by the compiler).\n        let fee_payer_point = fee_payer_setup_payload.hiding_point;\n        let user_point = user_setup_payload.hiding_point;\n\n        // 7. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime {\n                FunctionSelector::from_signature(\n                    \"complete_refund((Field,Field,bool),(Field,Field,bool),Field)\",\n                )\n            },\n            [\n                fee_payer_point.x,\n                fee_payer_point.y,\n                fee_payer_point.is_infinite as Field,\n                user_point.x,\n                user_point.y,\n                user_point.is_infinite as Field,\n                funded_amount,\n            ],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_point: Point, user_point: Point, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            TokenNote::finalization_payload().new(fee_payer_point, tx_fee);\n        let user_finalization_payload =\n            TokenNote::finalization_payload().new(user_point, refund_amount);\n\n        // 4. We emit the `tx_fee` and `refund_amount` as unencrypted event such that the `NoteProcessor` can use it\n        // to reconstruct the note.\n        context.emit_unencrypted_log(fee_payer_finalization_payload.log);\n        context.emit_unencrypted_log(user_finalization_payload.log);\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_finalization_payload.note_hash);\n        context.push_note_hash(user_finalization_payload.note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"},"355":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, note::utils::compute_note_hash_for_nullify, oracle::random::random,\n    keys::getters::get_nsk_app, macros::notes::partial_note,\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\n// docs:start:TokenNote\n#[partial_note(quote {amount})]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"357":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n};\n\nuse dep::std::mem::zeroed;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[note]\npub struct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nimpl NullifiableNote for TransparentNote {\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit.\n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier(\n        self,\n        _context: &mut PrivateContext,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // compute_nullifier ignores both of its parameters so we can reuse it here\n        self.compute_nullifier(zeroed(), zeroed())\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all\n"},"413":{"path":"/usr/src/noir-projects/noir-contracts/contracts/lending_contract/src/position.nr","source":"use dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\npub struct Position {\n    collateral: Field,\n    static_debt: Field,\n    debt: Field,\n}\n\nglobal POSITION_SERIALIZED_LEN: u32 = 3;\n\nimpl Serialize<POSITION_SERIALIZED_LEN> for Position {\n    fn serialize(position: Position) -> [Field; POSITION_SERIALIZED_LEN] {\n        [position.collateral.to_field(), position.static_debt.to_field(), position.debt.to_field()]\n    }\n}\n\nimpl Deserialize<POSITION_SERIALIZED_LEN> for Position {\n    fn deserialize(fields: [Field; POSITION_SERIALIZED_LEN]) -> Position {\n        Position { collateral: fields[0], static_debt: fields[1], debt: fields[2] }\n    }\n}\n"},"414":{"path":"/usr/src/noir-projects/noir-contracts/contracts/lending_contract/src/interest_math.nr","source":"// Binomial approximation of exponential\n// using lower than desired precisions for everything due to u128 limit\n// (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3]...\n// we are loosing around almost 8 digits of precision from yearly -> daily interest\n// dividing with 31536000 (seconds per year).\n// rate must be measured with higher precision than 10^9.\n// we use e18, and rates >= 4% yearly. Otherwise need more precision\npub fn compute_multiplier(rate_per_second: U128, dt: u64) -> U128 {\n    let base = U128::from_integer(1000000000); // 1e9\n    let WAD = U128::from_integer(1000000000000000000); // 1e18\n    let diff = WAD.div(base);\n    let mut res = base;\n    if dt != 0 {\n        let exp_minus_one = U128::from_integer(dt - 1);\n        let exp_minus_two = U128::from_integer(if (dt > 2) { dt - 2 } else { 0 });\n        let dt = U128::from_integer(dt);\n\n        // if rate_per_second < sqrt(WAD), then base_power_two and base_power_three = 0\n        let rate = rate_per_second;\n        let base_power_two = (rate * rate) / WAD;\n        let base_power_three = (base_power_two * rate) / WAD;\n\n        let temp = dt.mul(exp_minus_one);\n        let second_term = temp.mul(base_power_two).div(U128::from_integer(2));\n        let third_term = temp.mul(exp_minus_two).mul(base_power_three).div(U128::from_integer(6));\n\n        // throwing away precision to keep us under u128 :sob:\n        let offset = dt.mul(rate).add(second_term).add(third_term).div(diff);\n\n        res = base.add(offset);\n    }\n    res\n}\n"},"415":{"path":"/usr/src/noir-projects/noir-contracts/contracts/lending_contract/src/main.nr","source":"mod asset;\nmod position;\nmod interest_math;\nmod helpers;\n\n// Single asset CDP contract.\n// Shoving re-entries up the ass.\n// TODO's:\n// - Use asset address instead of 0. We only use 0, as there is only one collateral asset :shrug:.\n// - Update accumulator should be for specific asset, just abusing only 1 asset atm.\n// - A way to repay all debt at once\n// - Liquidations\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Lending {\n    use dep::aztec::prelude::{AztecAddress, Map, PublicMutable};\n\n    use crate::asset::Asset;\n    use crate::position::Position;\n    use crate::interest_math::compute_multiplier;\n    use crate::helpers::{covered_by_collateral, debt_updates, debt_value, compute_identifier};\n    use dep::token::Token;\n    use dep::price_feed::PriceFeed;\n\n    use dep::aztec::macros::{\n        storage::storage, functions::{private, public, initializer, internal, view},\n    };\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        collateral_asset: PublicMutable<AztecAddress, Context>,\n        stable_coin: PublicMutable<AztecAddress, Context>,\n        assets: Map<Field, PublicMutable<Asset, Context>, Context>,\n        collateral: Map<AztecAddress, PublicMutable<Field, Context>, Context>,\n        static_debt: Map<AztecAddress, PublicMutable<Field, Context>, Context>, // abusing keys very heavily\n    }\n\n    // Constructs the contract.\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[public]\n    fn init(\n        oracle: AztecAddress,\n        loan_to_value: Field,\n        collateral_asset: AztecAddress,\n        stable_coin: AztecAddress,\n    ) {\n        let asset_loc = storage.assets.at(0);\n        let asset: Asset = asset_loc.read();\n\n        let loan_to_value = U128::from_integer(loan_to_value);\n\n        assert(loan_to_value <= U128::from_integer(10000));\n        assert(asset.last_updated_ts == 0);\n        assert(asset.interest_accumulator == U128::from_integer(0));\n\n        let last_updated_ts = context.timestamp();\n\n        asset_loc.write(\n            Asset {\n                interest_accumulator: U128::from_integer(1000000000),\n                last_updated_ts,\n                loan_to_value,\n                oracle,\n            },\n        );\n\n        storage.collateral_asset.write(collateral_asset);\n        storage.stable_coin.write(stable_coin);\n    }\n\n    // Create a position.\n    #[public]\n    fn update_accumulator() -> Asset {\n        let asset_loc = storage.assets.at(0);\n        let mut asset: Asset = asset_loc.read();\n\n        let timestamp = context.timestamp();\n        let dt = timestamp - asset.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(dt == 0) {\n            let precision = U128::from_integer(1000000000);\n            let rate_per_second = U128::from_integer(1268391679); // 4% yearly rate / (60 * 60 * 24 * 365)\n            // if rate_per_second < sqrt(WAD) our approx is eq precision + rate * dt\n            let multiplier = compute_multiplier(rate_per_second, dt);\n\n            // accumulator *= multiplier, and multiplier >= 1\n            asset.interest_accumulator = (asset.interest_accumulator * multiplier) / precision;\n            asset.last_updated_ts = timestamp;\n\n            asset_loc.write(asset);\n        }\n\n        asset\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: Field,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        let _res = Token::at(collateral_asset)\n            .unshield(from, context.this_address(), amount, nonce)\n            .call(&mut context);\n        // docs:start:enqueue_public\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, collateral_asset)\n            .enqueue(&mut context);\n        // docs:end:enqueue_public\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: Field,\n        nonce: Field,\n        on_behalf_of: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let _ = Token::at(collateral_asset)\n            .transfer_public(context.msg_sender(), context.this_address(), amount, nonce)\n            .call(&mut context);\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: Field, collateral_asset: AztecAddress) {\n        let _asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n\n        let coll_asset = storage.collateral_asset.read();\n        assert(coll_asset.eq(collateral_asset));\n\n        let coll_loc = storage.collateral.at(owner);\n        let collateral = coll_loc.read();\n        coll_loc.write(collateral + amount);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: Field) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: Field) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, recipient: AztecAddress, amount: Field) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n        let price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n\n        let coll_loc = storage.collateral.at(owner);\n        let collateral: Field = coll_loc.read();\n\n        let debt_loc = storage.static_debt.at(owner);\n        let static_debt: Field = debt_loc.read();\n\n        // debt_covered will revert if decrease would leave insufficient collateral to cover debt.\n        // or trying to remove more collateral than available\n        let debt_covered = covered_by_collateral(\n            price,\n            asset.loan_to_value,\n            U128::from_integer(collateral),\n            U128::from_integer(0),\n            U128::from_integer(amount),\n        );\n        let debt_returns = debt_updates(\n            asset.interest_accumulator,\n            U128::from_integer(static_debt),\n            U128::from_integer(0),\n            U128::from_integer(0),\n        );\n\n        assert(debt_returns.debt_value < debt_covered);\n\n        coll_loc.write(collateral - amount);\n\n        // @todo @LHerskind Support both shielding and transfers (for now just transfer)\n        let collateral_asset = storage.collateral_asset.read();\n        let _ = Token::at(collateral_asset)\n            .transfer_public(context.this_address(), recipient, amount, 0)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: Field) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), to, amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: Field) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), to, amount).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, to: AztecAddress, amount: Field) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n        let price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n\n        // Fetch collateral and static_debt, compute health of current position\n        let collateral = U128::from_integer(storage.collateral.at(owner).read());\n        let static_debt = U128::from_integer(storage.static_debt.at(owner).read());\n\n        let debt_covered = covered_by_collateral(\n            price,\n            asset.loan_to_value,\n            collateral,\n            U128::from_integer(0),\n            U128::from_integer(0),\n        );\n        let debt_returns = debt_updates(\n            asset.interest_accumulator,\n            static_debt,\n            U128::from_integer(amount),\n            U128::from_integer(0),\n        );\n\n        assert(debt_returns.debt_value < debt_covered);\n\n        storage.static_debt.at(owner).write(debt_returns.static_debt.to_integer());\n\n        // @todo @LHerskind Need to support both private and public minting.\n        let stable_coin = storage.stable_coin.read();\n        let _ = Token::at(stable_coin).mint_public(to, amount).call(&mut context);\n    }\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: Field,\n        nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        stable_coin: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        // docs:start:private_call\n        let _ = Token::at(stable_coin).burn(from, amount, nonce).call(&mut context);\n        // docs:end:private_call\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, stable_coin)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(amount: Field, nonce: Field, owner: AztecAddress, stable_coin: AztecAddress) {\n        let _ = Token::at(stable_coin).burn_public(context.msg_sender(), amount, nonce).call(\n            &mut context,\n        );\n        let _ = Lending::at(context.this_address())._repay(owner, amount, stable_coin).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: Field, stable_coin: AztecAddress) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n\n        // To ensure that private is using the correct token.\n        assert(stable_coin.eq(storage.stable_coin.read()));\n\n        let static_debt = U128::from_integer(storage.static_debt.at(owner).read());\n        let debt_returns = debt_updates(\n            asset.interest_accumulator,\n            static_debt,\n            U128::from_integer(0),\n            U128::from_integer(amount),\n        );\n\n        storage.static_debt.at(owner).write(debt_returns.static_debt.to_integer());\n    }\n\n    #[public]\n    #[view]\n    fn get_asset(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_position(owner: AztecAddress) -> pub Position {\n        let collateral = storage.collateral.at(owner).read();\n        let static_debt = storage.static_debt.at(owner).read();\n        let asset: Asset = storage.assets.at(0).read();\n        let debt = debt_value(\n            U128::from_integer(static_debt),\n            U128::from_integer(asset.interest_accumulator),\n        )\n            .to_integer();\n        Position { collateral, static_debt, debt }\n    }\n\n    #[public]\n    #[view]\n    fn get_assets() -> pub [AztecAddress; 2] {\n        [storage.collateral_asset.read(), storage.stable_coin.read()]\n    }\n}\n"},"416":{"path":"/usr/src/noir-projects/noir-contracts/contracts/lending_contract/src/asset.nr","source":"use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\n// Struct to be used to represent \"totals\". Generally, there should be one per Asset.\n// It stores the global values that are shared among all users, such as an accumulator\n// and last time it was updated.\n// In practice, it should also point to an oracle and have more fields related to\n// loan to value ratios and other things, but we did not have enough reads/writes for this.\npub struct Asset {\n    interest_accumulator: U128,\n    last_updated_ts: u64,\n    loan_to_value: U128,\n    oracle: AztecAddress,\n}\n\nglobal SERIALIZED_LEN: u32 = 6;\n\nimpl Serialize<SERIALIZED_LEN> for Asset {\n    fn serialize(Asset: Asset) -> [Field; SERIALIZED_LEN] {\n        [\n            Asset.interest_accumulator.lo,\n            Asset.interest_accumulator.hi,\n            Asset.last_updated_ts as Field,\n            Asset.loan_to_value.lo,\n            Asset.loan_to_value.hi,\n            Asset.oracle.to_field(),\n        ]\n    }\n}\n\nimpl Deserialize<SERIALIZED_LEN> for Asset {\n    // Right now we are wasting so many writes. If changing last_updated_ts\n    // we will end up rewriting all of them, wasting writes.\n    fn deserialize(fields: [Field; SERIALIZED_LEN]) -> Asset {\n        let interest_accumulator = U128 { lo: fields[0], hi: fields[1] };\n        let last_updated_ts = fields[2] as u64;\n        let loan_to_value = U128 { lo: fields[3], hi: fields[4] };\n        let oracle = AztecAddress::from_field(fields[5]);\n\n        Asset { interest_accumulator, last_updated_ts, loan_to_value, oracle }\n    }\n}\n"},"417":{"path":"/usr/src/noir-projects/noir-contracts/contracts/lending_contract/src/helpers.nr","source":"use dep::aztec::hash::pedersen_hash;\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, self: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([self, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    price: U128,\n    loan_to_value: U128,\n    collateral: U128,\n    increase: U128,\n    decrease: U128,\n) -> U128 {\n    let price_precision = U128::from_integer(1000000000);\n    let ltv_precision = U128::from_integer(10000);\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value) / ltv_precision;\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    debt_value: U128,\n    static_debt: U128,\n}\n\nfn div_up(a: U128, b: U128) -> U128 {\n    let div = a / b;\n    if div * b < a {\n        div + U128::from_integer(1)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: U128,\n    static_debt: U128,\n    increase: U128,\n    decrease: U128,\n) -> DebtReturn {\n    assert(interest_accumulator > U128::from_integer(0));\n    let accumulator_precision = U128::from_integer(1000000000);\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: U128, interest_accumulator: U128) -> U128 {\n    let accumulator_precision = U128::from_integer(1000000000);\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n"},"418":{"path":"/usr/src/noir-projects/noir-contracts/contracts/price_feed_contract/src/main.nr","source":"mod asset;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PriceFeed {\n    use dep::aztec::prelude::{Map, PublicMutable};\n    use crate::asset::Asset;\n\n    use dep::aztec::macros::{storage::storage, functions::{public, view}};\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        assets: Map<Field, PublicMutable<Asset, Context>, Context>,\n    }\n\n    #[public]\n    fn set_price(asset_id: Field, price: Field) {\n        let asset = storage.assets.at(asset_id);\n        asset.write(Asset { price: U128::from_integer(price) });\n    }\n\n    #[public]\n    #[view]\n    fn get_price(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n}\n"},"419":{"path":"/usr/src/noir-projects/noir-contracts/contracts/price_feed_contract/src/asset.nr","source":"use dep::aztec::protocol_types::traits::{Serialize, Deserialize};\n\npub struct Asset {\n    price: U128,\n}\n\nglobal ASSET_SERIALIZED_LEN: u32 = 2;\n\nimpl Serialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn serialize(asset: Asset) -> [Field; ASSET_SERIALIZED_LEN] {\n        [asset.price.lo, asset.price.hi]\n    }\n}\n\nimpl Deserialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn deserialize(fields: [Field; ASSET_SERIALIZED_LEN]) -> Asset {\n        let price = U128 { lo: fields[0], hi: fields[1] };\n        Asset { price }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"65":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
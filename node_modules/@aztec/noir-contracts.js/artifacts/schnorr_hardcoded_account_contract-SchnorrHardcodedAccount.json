{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"SchnorrHardcodedAccount","functions":[{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","view"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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3qgh7Y0a0t6oIe2NGnhv1HRCxnuj5uml91q8N2qaXtobNaS9UUPaGzWkvVFD2hs1pL1RA++NmqeX3mvx3qh5eum9VtobNaS9UUPaGzWkvVED742aTsh4b9Q8vfRei/dGzdNL91ppb5Rt0uKoI75ytz3iK7fbI75yvz3i0xvuIr7ydnvEV15vj/jK++0RX7npHvG1u660QuqIr9118RKp2bh8xFcmgI749K67iK+85x7xtbuutEnqiK/ddaVdUrZJy6SO+NpdF6+TWsTX3nXxQqlFfO1dV1opdcTX7rrSUqkjvnbXxWul5gMz3iu1iK+96+LNUov42l1X2i11xNfuutJ2qSO+dteV9kvZhhdMLeJr77p4xdQivvauKy2ZOuJrd11pzdQRX7vr4kVT84EZb5qax8erphbxtXddadnUEV+760rrpo742l1XWjh1xNfuunjl1CK+9q6Ll04t4mvvutLaqSO+dteVFk8d8bW7Ll49NR+Y8e6pRXztXRdvn5rHl9ZPHfG1u660gOqIr911pRVUR3ztrouXUC3ia++6eA3VIr72ristojria3ddaRXVEV+76+JlVPOBGW+jWsTX3nXxPqpFfO2uK22ksk1aSXXE1+660lKqI75218VrqRbxtXddvJhqEV9715VWUx3xpbuuabupTNtNZXg31XRgNrybahGf3nUX8aV3XdN2U5m2m8q03VSm7aYybTeVabupDO+mWsSX3nUN76ZaxJfedU3bTWXabirTdlOZtpvK8G6q+cCMd1Mt4mvvung31SK+dtfVdlOZtpvKtN1Upu2mMm03leHdVIv42rsu3k21iK+962q7qUzbTWXabirTdlMZ3k01H5jxbqp5fLybahFfe9fVdlOZtpvKtN1Upu2mMm03lWm7qQzvplrE19518W6qRXztXVfbTWXabirTdlOZtpvK8G6q+cCMd1Mt4mvvung31Ty+tpvKtN1Upu2mMm03lWm7qUzbTWV4N9Uivvaui3dTLeJr77rabirTdlOZtpvKtN1UhndTzQdmvJtqEV9718W7qRbxtbuutpvKtN1Upu2mMm03lWm7qQzvplrE19518W6qRXztXVfbTWXabirTdlOZtpvK8G6q+cCMd1Mt4tO77iK+9q6r7aYybTeVabupTNtN5dpuKtd2UzneTbWIL73r+kbvuov40ruua7upXNtN5dpuKtd2UzneTTUdmB3vplrEl951He+mWsTX7rrabirXdlO5tpvKtd1Uru2mcrybahFfe9fFu6kW8bV3XW03lWu7qVzbTeXabirHu6nmAzPeTTWPj3dTLeJrd11tN5Vru6lc203l2m4q13ZTOd5NtSic2l1X203leDfV/LOPd1Mt4mt3XW03lWu7qVzbTeV4N9WicGp3XbybahFfu+tqu6lc203l2m4q13ZTubabyrXdVI53Uy3ia/+EGe+mWsTX/v+62m4qp7up9m538fcen8d/9K7bhl3il/3lpT8kClyixCX6yu3ON/s00Yf3uN6T2ri8x76t3qO1Pj5e3XbPy9XWrz12jX53cXxy7XY89PHVD7+9fPXq5S/fv3rz4/N3L9+8fnt753b7t+u/rSj39vHVyj4573r/dP2L7xhfesf1368yvcO++A7/sjuOL+z2wus/3d3dP9631/bX8392c/0nqtNbrv8Uc36LfeEtfx5f/uv5by+f//Dqxe0n4vZXf3/9490H5Pjy3b9//fArx8X/AQ==","brillig_names":["get_auth_witness","pack_returns_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7d3fbiRbct/7d5lrXeSKPysi9CoHB4Yky8YAg5EhyQc4EPzuXnu6WWRPV1cOZxeL31XBG2OPVWRFZDd/GZXsT6z/+sN//9d//t//87/98c//49/+4w//+P/81x/+9G//8k//+cd/+/P6X//1B9W//P/9x//6pz//9j//4z//6d//8w//OGYd//CHf/3zf1//Gcfxf/7hD//jj3/61z/8o2n8n3/46dUSGd9fLXnU5dVjjiuvVpv5/dXqNk5ePcYxx0sp4wi7vF7Fr73eRF5ebm++u9rVby51+d6Rb1/8//7DH9S+Ls2vLo1/XZpfXZr5dWl+dWni69L86tLk16X51aWpr0vzi0tjx9el+dWlGV+X5leXRr4uza8uzdc0/MtLY1+X5leX5msa/uWl+ZqGf3lpvqbhX16ar2n4l5fmaxr+1aXxr2n4l5fmaxr+5aX5moZ/eWm+puFfXhr7ujS/ujRf0/AvL83XNPzLS/M1Df/y0nxNw7+8NF/T8K8uzfyahn95ab6m4V9emq9p+JeX5msa/uWlsa9L86tL8zUN//LSfE3Dv7w0X9PwLy/N1zT8y0vzNQ3/6tLE1zT8y0vzNQ3/8tJ8TcO/vDRf0/AvL419XZpfXZqvafiXl4Y/DVdeyl+9nF2azPny8jr8d10a/jT8aZeGPw1/2qW5wzSsZS9xoBXx2mzO394ij49/i6vTWdnLVappJ28w3PWlHJ+vf7wxr17SvOSfvPnWeVx78THl0ukxVR+Xlilfl+XaZdGvy3LtstjXZbl2Wfzrsly7LPPrsly7LPF1Wa5dlvy6LNcuS31dliuXpY6vy3LtsnxNuVcvy9eUe/WyfE25Vy+LfV2Wa5fla8q9elm+ptyrl+Vryr16Wb6m3KuX5WvKvXZZxvE15l6/Ll9z7vXr8jXoXr8uX5Pu9etiX9fl6nX5mnWvX5evYff6dfmadq9fF/a46/F6XWKcXZf7/Up9/TL/67pcuy7jDvNuvF6XPL0u8Xpd7LWaKNjP0Rhf1+XqdZGv63L1uujXdbl6Xezruly9Lv51Xa5el/l1Xa5el/i6LlevS35dl6vXpb6uy7XrIl/z7vXr8jXvXr8uX/Pu9evyNe9evy72dV2uXhf2vPtpz1+EPe9+3nW5w7x7XN5g+nFyXT6z1ezTarVpVX//oDnnpfh448+ut/qK24bV/OFb/6Wc8dhyvF7/mIb/XI6wylFWOcYqx1nlTFY5wSonWeUUqhw7WOWwUtlYqWysVDZWKhsrlY2VysZKZWOlsrFS2Vmp7KxUdlYqOyuVnZXKzkplZ6Wys1LZWansrFSerFSerFSerFSerFSerFSerFSerFSerFSerFSerFQOVioHK5WDlcrBSuVgpXKwUjlYqRysVA5WKgcrlZOVyslK5WSlcrJSOVmpnKxUTlYqJyuVk5XKyUrlYqVysVK5WKlcrFQuVioXK5WLlcrFSuVipXKhUlkOVCrLgUplOVCpLAcqleVApbIcqFSWA5XKcqBSWQ5UKsvBSuXBSuXBSuXBSuXBSuXBSuXBSuXBSuXBSuXBSuXBSmVhpbKwUllYqSysVBZWKgsrlYWVysJKZWGlsrBSWVmpzLJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9wrJ9yrJ9yrJ9yrJ9yrJ9eqBSWVm2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2z1i2z1i2z1i2z1i2zw5UKhvL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9jnL9jnL9jnL9jnL9vmBSmVn2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2b7Jsn2TZfsmy/ZNlu2bByqVJ8v2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9wbJ9wbJ9wbJ9wbJ9caBSOVi2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2L1i2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GyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlGyzlmyzlmyzlmyzlmyzlmwcqlZOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJOlfJN1+meyTv9M1umfqaxUVlYqKyuVlZXKykplZaWyslJZWanMsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Jsn3Fsn3Fsn3Fsn3Fsn11oFK5WLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavWLavULZPDpTtW+WQUnmVQ0rlVQ4plVc5pFRe5ZBSeZVDSuVVDimVVzmkVF7lsFIZZftWOaxURtm+VQ4rlVG2b5XDSmWU7VvlsFIZZftWOaxURtm+VQ4rlVG2b5XDSmWU7VvlsFIZZftWOaxURtm+VQ4rlVG2b5XDSmWU7VvlsFIZZftWOaxURtm+VQ4rlVG2b5XDSmWU7VvlPDiV6zheXlzmb8u59uIIv7w6j9eXj7z2zWcdL73OGm+++fdWpU+r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YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+ZNm+ZNm+ZNm+ZNm+PFCpnCzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblw+2fXJofn+xHKlvy7lWe4Rfis/DLy8fee2bzzrk+8tnjddXx/dWvU+rs0+r0afV7NNqdWm1OAb05xfroS+d6uHH5cU65HvxmHv931M8ZjL4e4pX8E/I+u35uHxrtzz5CZH1opcfkfXfOX54/bd2rVe75FnlA9olzysf0C56Zhlml5hS8SvlP9MckuNyc06pn27OzzSH3G71wer5U1sdfVqVPq2SJ6J3tzr10mr+9Jnhwcr8U1t9pqc2J60+01Obk1af6anNSatPNS3dbvWppqWbrcpTTUu3W32qael2q081Ld1utc+09ODtD5/aap9pSfpMS9JnWpI+05L0mZa0z7SkfaYl7TMtaZ9p6cFbWT611T7TkvaZlrTPtKR9piXtMy1Zn2nJ+kxL1mdasj7T0oO3JX1qq32mJeszLVmfacn6TEvWZ1ryPtOS95mWvM+05H2mpQdvMfvUVvtMS95nWvI+05L3mZa8z7Q0+0xLs8+0NPtMS7PPtPTg7YKf2mqfaWn2mZZmn2lp9pmWZp9pKfpMS9FnWoo+01L0mZYevPXzU1vtMy1Fn2kp+kxL0Wdaij7TUvaZlrLPtJR9pqXsMy09eBvvp7baZ1rKPtNS9pmWss+0lH2mpeozLVWfaan6TEvVZ1p6qi3ZJ632mZaeakv2Sat9pqWn2pJ90mqXacmOo8u0tFrtMi2tVrtMS6vVLtPSatX6tNplWlqtdpmWVqtdpqXVapdpabXaZ1p6rl3et1vtMy091y7v2632mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerfaZltrs8l6t9pmW2uzyXq32mZba7PJerbaZlkafXd6jzy7v0WeX9+izy3sc1qfVZ5qW6pCXVmv83OozTUsnrT54WlI7XlrV3+q92arbeKl9+Dzsh1a/lZ97l1/k8qe9KX/Wz+U/eo/2vcsfe5cve5ev4PKnj8u3nm55euu8/KTPlPrrkH30DuvPbNX7tDr7tEqeEu7cKnmieHerNyf6QZ4+7tuqkCeVO7dKnmru3Cp5Arpzq081Ld1u1fq0+lTT0u1Wn2paut3qU01Lt1vtMy1Jn2lJ+0xL2mda0j7TkvaZlh69w/ozW+0zLWmfaUn7TEvaZ1rSPtOS9ZmWrM+0ZH2mJeszLT16h/VnttpnWrI+05L1mZasz7RkfaYl7zMteZ9pyftMS95nWnr0DuvPbLXPtOR9piXvMy15n2nJ+0xLs8+0NPtMS7PPtDT7TEuP3mH9ma32mZZmn2lp9pmWZp9pafaZlqLPtBR9pqXoMy1Fn2np0TusP7PVPtNS9JmWos+0FH2mpegzLWWfaSn7TEvZZ1rKPtPSo3dYf2arfaal7DMtZZ9pKftMS9lnWqo+01L1mZaqz7RUfaalR++w/sxW+0xL1Wdaqj7TUvWZlqrNtCRHm2lJjjbTkhxtpiU52kxLclifVttMS3K0mZYEvcP6zq22mZYEvRv7vq2i92jfudU+0xJ6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YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+ZNm+ZNm+ZNm+ZNm+PFCpnCzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzbVyzbVyzbVyzbVyzbVwcqlYtl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+wpl+/xA2b5VDimVVzmkVF7lkFJ5lUNK5VUOKZVXOaRUXuWQUnmVQ0rlVQ4rlVG2b5XDSmWU7VvlsFIZZftWOaxURtm+VQ4rlVG2b5XDSmWU7VvlsFIZZftWOaxURtm+VQ4rlVG2b5XDSmWU7VvlsFL5wbZPDs3vL5Yj9W0512qP8Evxefjl5SOvffNZh3x/+azx+ur43uro06r0aVX7tGp9WvU+rc4+rUafVrNPq9WmVSNPS+k6Lt/aLU9alfWil17Xf+f44fXf2iVPTB/QLnlq+oB2yZPTB7RrvdolT1Af0O7vn6JC7KWmsDr5WJ1DXq/NmxfX93KCVU6yyqnHlhPx+uLSn8q5g9m+azmDVY6wylFWOcYqx1nlTFY5wSrnsakscvlsI/LmnrvKufKdXfTyrV3q+PmW67V1+fPYu/yxd/msu8pk3VXuYM7vWo6T/67Z67Dp87Arf9fm3uXH3uVfvcuN9aTtUtJxnDSgZS+fF/XtbzFf36Qe8CbXvfq932Q84k3kEW+ij3gT2/qHI/ZO1tg7WWPvZA3054fz8tGfH07LzwP1TC0HqxxhlaOscoxVjrPKYT3LT9az/GQ9y89ClVOsVC5WKhcrlYuVysVK5WKlcrFSuVipXKxULlQqjwOVyuNApfI4UKk8DlQqjwOVyuNApfI4UKk8DlQqjwOVyuNgpfJgpfJgpfJgpfJgpfJgpfJgpfJgpfJgpfJgpfJgpbKwUllYqSysVBZWKgsrlYWVysJKZWGlsrBSWViprKxUVlYqKyuVlZXKykplZaWyslJZWamsrFRWViobK5WNlcrGSmVjpbKxUtlYqczylIPlKQfLUw5jpbKzUtlZqeysVHZWKjsrlZ2Vys5KZWelsrNS2VmpPFmpPFmpPFmpPFmpPFmpPFmpPFmpPFmpPFmpPFmpHKxUDlYqByuVg5XKwUrlYKVysFI5WKkcrFQOViqzbN9g2b6RT7Qn0WO87Af10B/Xg35r9om2JJ43a52afaINiefNkrdM371Z8p7puzeLOt9ioM5N9oE6N3mVgzp1aKDOTV7loE4dGqhzk1c5qFOHBurc5FUO6tShgTo3eZWDSmVhnZssrHOThXVusrDOTZYDlcrCOjdZWOcmC+vcZGGdmyysc5OFdW6ysM5NFta5ycI6N1lY5yYL69xkYZ2bLKxzk4V1brKwzk0W1rnJwjo3WVjnJgvr3GRhnZssrHOThXVusrDOTRbWucnCOjdZlJXKykplZaWyslJZWamsrFRWViorK5WVlcrKSmVjpbKxUtlYqWysVDZWKhsrlY2VysZKZWOlsrFS2Vmp7KxUdlYqOyuVnZXKzkplZ6Wys1LZWansrFSerFSerFSerFSerFSerFSerFSerFSerFSerFSerFQOVioHK5WDlcrBSuVgpXKwUjlYqRysVA5WKgcrlZOVyslK5WSlcrJSOVmpnKxUTlYqJyuVWbZPWLZPWLZPWLZPWLZPWLZPWLZPWLZPWLZPWLZPWLZPWLZPWbZPWbZPWbZPWbZPD1QqK8v2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Kcv2Gcv2Gcv2Gcv2Gcv22YFKZWPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmPZPmfZPmfZPmfZPmfZPj9Qqews2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs2+cs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KhcrlYuVyoVKZTlQqSysMzaFdcamsByuHKhUlgOVynKgUlkOVCoL64xNYZ2xKSyHKyyHKyyHKyyHKyyHKyyHK4OVyoOVyoOVyoOVysJKZWGlsrBSWVipzDpjU1hnbArL4QrL4YqwUllYqaysVFZWKisrlZWVyspKZWWlMuuMTWGdsSmsMzaFdcamsM7YFNYZm2KsVDZWKhsrlY2VysZKZWOlMsv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Ccv2Kcv2Kcv2Kcv2Kcv26YFKZWXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmXZPmPZPmPZPmPZPmPZPjtQqWws22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs22cs2+cs2+cs2+cs2+cs2+cHKpWdZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfucZfsmy/ZNlu2bLNs3WbZvHqhUnizbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2Bcv2Bcv2Bcv2Bcv2xYFK5WDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvmDZvniw7ZND8/uL5Uh9W8612iP8Unwefnn5yGvffD3Kk+8vX4/RXl8d31v1Pq3OPq1Gn1azT6vVptUHG9BPbXX0aVX6tKp9WjVwq+k6Lt/aLU9alfWil17Xf+f44fXf2iVPTB/QLnlq+oB2yZPTB7RLnp4+oF3yBHX/du9gttdn4ZeawurkY3UOeb02b15c38sZrHKEVY4+tpyI1xeX/lyOscpxVjmTVU6wyklWOYUqxw9WOYNVzmNTWeTy2UbkzT13lXPl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n1+sh750qocflxfrkO/FY+71f0fxHF/69xQ/wD8h6Tou39otT35CZL3o5Udk/XeOH17/rV3ynPIB7ZJnlQ9o13q1i55ZhtklplT8SvnPNIfkuNycU+qvb871THPISavZp9Xq0qo+WGt/aqvkiejdrU69tJr+U6vP9NTmpNVnempz0qr1afWZntqctPpU09LtVp9qWrrd6lNNS7dbfapp6War46mmpdut9pmWRp9pafSZlh68teJTW+0zLY0+09LoMy2NPtPS6DMtSZ9pSfpMS9JnWpI+09KDt8l8aqt9piXpMy1Jn2lJ+kxL0mda0j7TkvaZlrTPtKR9pqUHb3n61Fb7TEvaZ1rSPtOS9pmWtM+0ZH2mJeszLVmfacn6TEsP3r72qa32mZasz7RkfaYl6zMtWZ9pyftMS95nWvI+05L3mZYevBXxU1vtMy15n2nJ+0xL3mda8j7T0uwzLc0+09LsMy3NPtPSg7eVfmqrfaal2Wdamn2mpdlnWpp9pqXoMy1Fn2kp+kxL0WdaevAW4U9ttc+0FH2mpegzLUWfaSn6TEvZZ1rKPtPSU23JPmm1z7T0VFuyT1rtMy091Zbsk1b7TEvZZ1rKPtNS9ZmW0Pu679xqn2kJvaf7zq1an1b7TEvPtcv7dqt9pqXn2uV9u9U205I91y7v2622mZaszy5v67PL2w7r02qbacn67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub+uzy9v67PK2Pru8rc8ub3v0Lm+146VV/a3em626DXn51j4P+6HVb+Xb3uU7ufxpb8qfdaX8uXf5sXf5uXf5BS5/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WKksrFRWViorK5WVlcrKSmVlpbKyUllZqaysVFZWKisrlY2VysZKZWOlsrFSmWX7nGX7nHXWprPO2nTWWZvOOmvTWWdtOuusTWedtemsszadddams87adNZZm846a9NZZ20666xNZ5216ayzNp111qazztp01lmbzjpr01lnbTrrrE1nnbXprLM2nXXWprPO2nTWWZvOOmvTWWdtOuusTWedtemsszadddams87adNZZm846a9NZZ20666xNZ5216ayzNp111qazztp01lmbzjpr01lnbTrrrE1nnbXprLM2nXXWprPO2nTWWZvOOmvTWWdtOuuszck6a3OyztqcrLM2J+uszXmgUnkeqFSeByqV54FK5XmgUnkerFQerFQerFQerFQerFQerFQerFQerFQerFQerFQerFQWVioLK5WFlcrCSmVhpbKwUllYqSysVBZWKgsrlZWVyspKZWWlsrJSWVmprKxUVlYqKyuVlZXKykplY6WysVLZWKlsrFQ2ViobK5VZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/ZNlu2bLNs3WbZvsmzfZNm+ybJ9k2X7Jsv2TZbtmyzbN1m2b7Js32TZvsmyfZNl+ybL9k2W7Zss2zdZtm+ybN9k2b7Jsn2TZfsmy/YFy/YFy/YFy/YFy/bFgUrlYNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+YNm+ZNm+ZNm+ZNm+ZNm+PFCpnCzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzblyzbVyzbVyzbVyzbVyzbVwcqlYtl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl+4pl++oOtm99kv3+YjmOcVLOMf1S/DHj9eUqfrXXnJfyD399tV178ZB6efGIfPvib71Go16zUa+/+2Ylx/BLr3byI+V5yPcXe466vHjktVfLSH95+frvHD+8/i/1/34j+cn1j83rl83r183rt83r983rn5vX/9iPcnJoXppNfTtSXfvOruPyrd3yDu1mm3bX//rnf//jn/70x//53/70b//yT//5x3/783/89tXHb//P9d92WbxcBx+vxYb/du2u/0Lq5lfUe7/i+q91bn7FePdXyPu+Yv2P8ZcrdrV/r5c/gfA3P43Hty+Uv3zh1csw9WUsyzcj3Br/fn0dbn/JeP+XyPu/RN//Jfb+L7l6T8jLIJtvfzS+f8l8/5fE+78k3/8l9e4vuf4Y/faXjPd/ibz/S/T9X2Lv/5Lrf/ppL19S9cOXXAnGeEloqdcfZj3+8vN//VHq/b59fOy3z9/77XW+TBsa9tO3rw/99tcfRd7v24+P/fbysd9eP/bb28d+e//Ybz/v+O3zpx8ri4/99vmx3/76Mxy5DLUafx2yv3hscvNLxvu/RN7/Jfr+L7H3f4m//0vmu79k/h1fEu//kqt/ucQuHypn/PVfmOu7G25+yfX9Cre/ZLz/S+T9X6Lv/xJ7/5f4+79kvv9Lrv7p3xwIrvvz219S7/6S64779peM93+JvP9L9J1fsv6X/vbKX2xTiZcP4JVv7kHrI+Evf2pufskvtpLc/JLx/i+R93+Jvv9L7P1f4u//kvn+L4n3f8n7//Tj/X/6+f4//Xz/n36+/08/3/+n/yuNX5cviZ++xN//JfP9XxLv/5J8/5fUO79k/S/7y9Ofq3+gI8blSV+EvLml/xZR63/+f//073/8p3/+07/+9sTut//r//7zv7w8wFv/8z/////17f+yXvx/AQ==","brillig_names":["get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnBaoNAEIDhd9mzB1fdmR1fpZSgiYYF0aCmUMR3r2lDCeT8X8TR2f/2nXZzl669X09p7KfF1R+bG6Zzs6ZpPKZtz1w7p2FI19PrZ5c/HlX1u7/cmvExLmszr672IWSuGy/Hm+TH+T4NnaurUvfsbVeL56rq/2aw/TNzVQDbArYVbEewbVw75GDbg+0CbJdgG3QZQJcBdBlAlwF0GUCXAroU0KWALgV0KaBLAV0K6FJAlwK6FNClgi4VdKmgSwVdKuhSQZcKulTQpYIuFXQZQZcRdBlBlxF0GUGXEXQZQZcRdBlBlxF0aaBLA10a6NJAlwa6NNClgS4NdGmgSwNd+jwn456MF2S8JOMVGQ9kXMi4kvFIxkmhnhTqSaEeE7of01czp6YduucdSH8fzy9XIuv37e/PsfwD","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"SchnorrHardcodedAccount::entrypoint_parameters"}}],"kind":"struct","path":"SchnorrHardcodedAccount::entrypoint_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrHardcodedAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrHardcodedAccount::verify_private_authwit_abi"}]}},"file_map":{"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"313":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"437":{"path":"/usr/src/noir-projects/noir-contracts/contracts/schnorr_hardcoded_account_contract/src/main.nr","source":"// docs:start:contract\n// Account contract that uses Schnorr signatures for authentication using a hardcoded public key.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract SchnorrHardcodedAccount {\n    use dep::aztec::prelude::PrivateContext;\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness,\n    };\n\n    use dep::aztec::macros::functions::{private, view};\n\n    global public_key_x: Field = 0x16b93f4afae55cab8507baeb8e7ab4de80f5ab1e9e1f5149bf8cd0d375451d90;\n    global public_key_y: Field = 0x208d44b36eb6e73b254921134d002da1a90b41131024e3b1d721259182106205;\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[private]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    // docs:start:is-valid\n    #[contract_library_method]\n    fn is_valid_impl(_context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Load auth witness and format as an u8 array\n        let witness: [Field; 64] = unsafe { get_auth_witness(outer_hash) };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify signature using hardcoded public key\n        std::schnorr::verify_signature(\n            public_key_x,\n            public_key_y,\n            signature,\n            outer_hash.to_be_bytes::<32>(),\n        )\n    }\n    // docs:end:is-valid\n}\n// docs:end:contract\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"73":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, CANONICAL_AUTH_REGISTRY_ADDRESS,\n    }, hash::poseidon2_hash_with_separator,\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let result: Field = context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n            [on_behalf_of.to_field(), inner_hash].as_slice(),\n            GasOpts::default(),\n        )\n        .deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n            [message_hash, authorize as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n            [context.this_address().to_field(), reject as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n"},"75":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"76":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator,\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"79":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: u32 = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            fields.extend_from_array(self.function_calls[i].serialize());\n        }\n        fields.push(self.nonce);\n        fields.push(self.is_fee_payer as Field);\n        fields.storage\n    }\n}\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"}}}
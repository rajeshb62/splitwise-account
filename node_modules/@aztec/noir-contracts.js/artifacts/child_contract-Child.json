{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"Child","functions":[{"name":"private_set_value","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"new_value","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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WS6aszXN2S6aczTNOS6aczXNuS6a8zTNeS6a8zXN+S6aCzTNBS6acpqmnIumvKYp76KpoGkquGj8msbvoqmoaSq6aCppmkoumsqaprKLpoqmqeKiqappqrpoLtQ0F7poLtI0F7loLtY0F7toqmmaai6a6pqmuovmEk1ziYvmUk1zqYvmMk1zmYvmck1zuYvmCk1zhYsmXtPEu2gCmibgoknQNAkumkRNk+iiSdI0SS6aZE2T7KJJ0TQpLppUTZPqoknTNGkumnRNk+6iqaFparhoamqami6aWpqmloumtqap7aKpo2nquGjqapq6Lpp6mqaei6a+pqnvommgaRq4aBpqmoYumkaappGLprGmaeyiaaJpmrhommqapi6aZpqmmYumuaZp7qJpoWlauGhaapqWLppWmqaVi6a1pmntommjadq4aNpqmrYumnaapp2L5kpNc6WLpr2mae+i6aBpOrhortI0V7loOmqaji6aqzXN1S6aTpqmk4vmGk1zjYums6bp7KLpomm6uGi6apquLppumqabi6a7punuoumhaXq4aHpqmp4uml6appeLJkPTZLhoMjVNpoumt6bp7aLpo2n6uGiyNE2Wi6avpunrorlW01zrovmPpvmPi+Y6TXOdi+Z6TXO9i+YGTXODi+ZGTXOji+YmTXOTi+ZmTXOzi6afpunnorlF09ziorlV09zqorlN09zmorld09zuoumvafq7aO7QNHe4aO7UNHe6aO7SNHe5aO7WNHe7aO7RNPe4aO7VNPe6aO7TNPe5aO7XNPe7aB7QNA+4aP6raf7ronlQ0zzoohmgaQa4aAZqmoEumoc0zUMumoc1zcMumkc0zSMumkc1zaMumsc0zWMumsc1zeMumic0zRMumic1zZMumqc0zVMumqc1zdMummc0zTMummc1zbMumuc0zXMumuc1zfMumhc0zQsumhc1zYsumpc0zUsumpc1zcsumlc0zSsumlc1zasumtc0zWsumtc1zesumjc0zRsumjc1zZsumrc0zVsumrc1zdsumnc0zTsumnc1zbsumvc0zXsumkGaZpCL5n1N876L5gNN84GL5kNN86GL5iNN85GL5mNN87GL5hNN84mL5lNN86mL5jNN85mL5nNN87mL5gtN84WL5ktN86WL5itN85WL5mtN87WL5htN842L5ltN862L5jtN852L5ntN872L5gdN84OL5kdN86OLZrCmGeyi+UnT/OSiGaJphrhohmqaoS6aYZpmmIvmZ03zs4tmuKYZ7qL5RdP84qIZoWlGuGhGapqRLppRmmaUi2a0phntohmjaca4aMZqmrEumnGaZpyLZrymGe+imaBpJrhoJmqaiS6aSZpmkotmsqaZ7KKZommmuGimapqpLpppmmaai2a6ppnuopmhaWa4aGZqmpkumlmaZpaLZramme2imaNp5rho5mqauS6aeZpmnotmvqaZ76JZoGkWuGgWapqFLppFmmaRi2axplnsolmiaZa4aJZqmqUummWaZpmLZrmmWe6iWaFpVrhoVmqalS6aVZpmlYtmtaZZ7aJZo2nWuGjWapq1Lpp1mmadi2a9plnvotmgaTa4aDZqmo0umk2aZpOLZrOm2eyi2aJptrhotmqarS6abZpmm4tmu6bZ7qLZoWl2uGh+1TS/umh2apqdLprfNM1vLppdmmaXi2a3ptntotmjafa4aPZqmr0umn2aZp+LZr+m2e+iOaBpDrhoDmqagy6aQ5rmkIvmd03zu4vmsKY57KL5Q9P84aI5ommOuGj+1DR/umiOapqjLpq/NM1fLppjmuaYi+afq2Jq2+GaPJomj4smTtPEuWjyapq8Lpp8miafiya/psnvoimgaQq4aApqmoIumkKappCLprCmKeyiKaJpirhoimqaoi6aYpqmmIumuKYp7qIpoWlKuGhKapqSLpozNM0ZLppSmqaUi+ZMTXOmi6a0pintoimjacq4aMpqmrIumrM0zVkumrM1zdkumnM0zTkumnM1zbkumvM0zXkumvM1zfkumgs0zQUumnKappyLprymKe+iqaBpKrho/JrG76KpqGkqumgqaZpKLprKmqayi6aKpqnioqmqaaq6aC7UNBe6aC7SNBe5aC7WNBe7aKppmmoumuqaprqL5hJNc4mL5lJNc6mL5jJNc5mL5nJNc7mL5gpNc4WLJl7TxLtoApom4KJJ0DQJLppETZPooknSNEkummRNk+yiSdE0KS6aVE2T6qJJ0zRpLpp0TZPuoqmhaWq4aGpqmpoumlqappaLpramqe2iqaNp6rho6mqaui6aepqmnoumvqap76JpoGkauGgaapqGmiavpmmkaRqFadA/UJMQf/p+oCYhPvYDNdpj+g/U+ONO6MKPrex+oCZ0/Jp+oCZ03Dr9XxJ3Mq+uyxv2nD7f//5AjRfjn5aQlJwTP8b0d40DTu4/NGbOLd8A81g7t1PZX87tUe0cERo758drGgfb62vj6dwKDvCiXu9/vKa6dhz9XY+m/efvS60t9Jy5+cdrKgb/EfrxmgFhc9H04zW59Ye8PLrGXrbnSX18ws8bzB+yOXFd7UKGegsZxj/8+tThx0Ye38nX4M5r0BfSxlDX69uhfL2tZnDQzzD0GT7+hQ31mK6R7bAnB/9h+nGl8N9eiPTHlfT88DHU8/K43IeeJ7wt/HlMzF6vOaExMf0eRV4DT/ixVsBFH/57FCF9k2DR//Z7DoW0/FD/cYb+Pf2BHXUL528Vd6LuFmHnXtN1PB1d57jIasvrM49dR+2527r0medf+gyfW277Ly6MIaTv8C/7L3wdCj9WOsW56wpmo/u3sfX4uq0B0+8r6LzdwvaHfvyb9kf4b96E9JnaPu4Zdk4zraXFs+lb/y2agobc7NYN07FwqsdOobDaQvpr/+XY8fT3JxLis/39CX3+uP3+xA2neO4y/bZDHq0tfDz/7bcdQmyhffn/2jt73qahMArf2IkQapmaSnxsfIgBJNyqA2MH0i6IgX+ASoQQoq1CGBiQMsCAkFhR/y3E8XXec/LaCSJu4+pcqfJx/Pja1583qXQf+86M616lu8O2p+rYjVZ4buTtn8zrss/4aelOGmlb7u74Ts8be0/0zHarzq/l//X8cj/AujtuUl3ee9puj9/T3r3qPcP4Xv265Hx5fZZ4DFZ9Vm66u+PbkmPQtKfgh3kX/KTv8D1ne1PuoobrVEzzOpzPusW6bfcU/KbfAa6Dp+BXMXMZnoIL85vDU7p3uY+5ru026ymY/ZZny5r3X54Cs0/l/ykM88IwHcMMDDOoYI4Mc1TBHBvmuIKRpwAzM/IUYGZGngLMzMhTgJkZeQowMyNPAWZm5CnAzIw8BZiZkacAMzPyFGBmRp4CzMzIU4CZGXkKMDMjTwFmZuQpwMyMPAWYmZGnADMz8hRgZkaeAszMyFOAmRl5CjAzI08BZmbkKcDMjDwFmJmRpwAzM/IUYGZGngLMzMhTgJkZeQowMyNPAWZm5CnAzIw8BZiZkacAMzPyFGBmRp4CzMzIU4CZGXkKMDMjTwFmZuQpwMyMPAWYmZGnADMz8hRgZkaeAszMyFOAmRl5CjAzI08BZmbkKcDMjDwFmJmRpwAzM/IUYGZGngLMzMhTgJkZeQowMyNPAWZm5CnAzIw8BZiZkacAMzPyFGBmRp4CzMzIU4CZGXkKMDMjTwFmZuQpwMzMJngKLFPnKeCx5PN6JrNpHOsoCbjOYTGf/Ud5nh0cyGHQLocBL+tOFtuxbEz828mc42uLHQbl94mAnoIHxUp27PxY2j52/v1kvt95ewxbfucxn8VtbvLY+XeKmTh2/mPTRr7+4jWZhMW6tv/+9Ys8/Ph+PDg9GX05Hw/fvjobD1+evQtU7PVjn3EL202QSyvWT8Pis7Kcd+qYtnfTx9qMzo+6sTazIrd67MHs8sYeTJupf7/RsQ0zf+xB25a43ZQ4b51N6Fc09S5t1uuR7cfjZp0ZqdMmHoucn1feNAS/H1KO3RoavYb36tpm9z9eG54LIh6DqzwP9vhw32fVPlOPltk+U2zj9H1513DefRO5R0XO+0VFXcEcq2lpa7/ooWlz3h7DtrVfdK/IsV/0JMzrqrruvH5RHJ/eGyeWvwvaujwnz3aYj4N+/ubkw+vh+PPo9BN3eWz1wanGbjp+XvU64XVSw9vShu7Us2K+rjtVDutdTPth/W3JTHdqt5n6sxtO+/om71I77Xk+XNM+xPriOeqFxZLQMvvItPvXWf/+7QUqqbOtWHZMLh+ntI/NaCZmXctp2WqmfvdasTqHLVoWz1nXWa9TMZ/QtI7t1NR7y1kW69xxPvsD99xqAT9/OQA=","debug_symbols":"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lltiseWWWAYsFRZbbomFyy2xcLklFi63xMLlVlicfVZjseWWWGy5JRZbbollEAuFWJj37LPnWLjcEguXW2Kx5ZaXXFtuhcXZZzUWW26JxZZbYrHlllgGLBUWLrfEwuWWWLjcEostt8Riy62wOPusxmLLLbF4k1glFuY9++w5lgFLhYXLLbHYcstLri23xGLLLbHYcisszj6rsdhySyxcbomFyy2xDFgqLFxuicWWW2Kx5ZZYbLklFltuhWXes8+eioV5zz57joXLLbFwuSWW4ZJbXXJtuSUWW26JxZZbYrHlllhsuRWWec8+e46Fyy2xcLklFi63xDJgqbDYckssttwSiy23xOJNYpVYmPfss2dYzvOeffYcC5dbYrHlFpfcs7PPaiwDlgqLLbfEYsstsdhySyxcbomFy62wzHv22XMsXG6JxZZbYrHlllgGLBUWW26JxZvEKrEw79lnz7FwuSUWLrfC4uyz8pLr7LMaiy23xGLLLbEMWCosttwSC5dbYuFySyxcbomFy62wOPusxmLLLbHYckssttwSyyAWCrEw79lnz7FwuSUWLrfEYsstL7m23AqLs89qLLbcEostt8Riyy2xDFgqLFxuiYXLLbFwuSUWW26JxZZbYXH2WY3Fllti8SaxSizMe/bZcywDlgoLl1tiseWWl1xbbonFlltiseVWWJx9VmOx5ZZYuNwSC5dbYhmwVFi43BKLLbfEYsstsdhySyy23ArLvGefPRUL85599hwLl1ti4XJLLMMlt7rk2nJLLLbcEostt8Riyy2x2HIrLPOeffYcC5dbYuFySyxcbollwFJhseWWWGy5JRZbbonFm8QqsTDv2WdPscx79tlzLFxuicWWW11ynX1WYxmwVFhsuSUWW26JxZZbYuFySyxcboFlzHv22XMsXG6JxZZbYrHlllgGLBUWW26JxZvECrEw5j377DkWLrfEwuVWWJx9Vl5ynX1WY7HlllhsuSWWAUuFxZZbYuFySyxcbomFyy2xcLkVFmef1VhsuSUWW26JxZZbYhnEQiEW5j377DkWLrfEwuWWWGy55SXXllthcfZZjcWWW2Kx5ZZYbLkllgFLhYXLLbFwuSUWLrfEYsstsdhyKyzOPqux2HJLLN4kVomFec8+e45lwFJh4XJLLLbc8pJryy2x2HJLLLbcCouzz2osttwSC5dbYuFySywDlgoLl1tiseWWWGy5JRZbbonFllthmffss6diYd6zz55j4XJLLFxuiWW45FaXXFtuicWWW2Kx5ZZYbLklFltuhWXes8+eY+FySyxcbomFyy2xDFgqLLbcEostt8Riyy2xeJNYJRbmPfvsKZZ5zz57joXLLbHYcqtLrrPPaiwDlgqLLbfEYsstsdhySyxcbomFy62wzHv22XMsXG6JxZZbYrHlllgGLBUWW26JxZvEKrEw79lnz7FwuSUWLrfAcnH2WXXJvTj7rMZiyy2x2HJLLAOWCostt8TC5ZZYuNwSC5dbYuFyKyzOPqux2HJLLLbcEostt8QyiIVCLMx79tlzLFxuiYXLLbHYcstLri23wuLssxqLLbfEYsstsdhySywDlgoLl1ti4XJLLFxuicWWW2Kx5VZYnH1WY7Hllli8SawSC/OeffYcy4ClwsLlllhsueUl15ZbYrHlllhsuRUWZ5/VWGy5JRYut8TC5ZZYBiwVFi63xGLLLbHYckssttwSiy23wjLv2WdPxcK8Z589x8Lllli43BLLcMmtLrm23BKLLbfEYsstsdhySyy23ArLvGefPcfC5ZZYuNwSC5dbYhmwVFhsuSUWW26JxZZbYvEmsUoszHv22VMs85599hwLl1tiseVWl1xnn9VYBiwVFltuicWWW2Kx5ZZYuNwSC5dbYZn37LPnWLjcEostt8Riyy2xDFgqLLbcEos3iVViYd6zz55j4XJLLFxuhcXZZ+Ul19lnNRZbbonFlltiGbBUWGy5JRYut8TC5ZZYuNwSC5dbYLk6+6zGYsstsdhySyy23BLLIBY+ioXrvGefPcfC5ZZYuNwSiy23vOTacisszj6rsdhySyy23BKLLbfEMmCpsHC5JRYut8TC5ZZYbLklFltuhcXZZzUWW26JxZvEKrEw79lnz7EMWCosXG6JxZZbXnJtuSUWW26JxZZbYXH2WY3Fllti4XJLLFxuiWXAUmHhckssttwSiy23xGLLLbHYciss85599lQszHv22XMsXG6JxZZbXlsGLBUWW26JxZZbYrHlllhsuSUW71iobtDOPqux2HJLLFxudW2Z9+yz51gGLBUWW26JxZZbYrHllli8Say8QdtyKyzznn32HIstt8Riy60uuc4+q7EMWCosttwSiy23xGLLLbFwuSUWv7FQYZn37LPnWPxebonFlltimXXL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AlyQJQEuyJLwuYKO7QLvGIbjhqBSEFuQJQEuyJIQF7Qt41XQPr794GPat4ugl2+fvv3gR//g4DibHb6STRvFV7Jp0PhCNsv68ZVsmkq+kk27yleyaYT5SjZLm1/IpnnnK9m0BX0lm7agr2TTFvSVbNqCvpDNxRb0lWzagr6STVvQV7JpC/pKNkubX8imLegr2bQFfSWbtqBPtnmF92Lzxo/hLeYduCCLzecKqnG6CKra3n7wdMzLBd6x/HjL3z7ZX794Dvvlw1iG43j94O/qV/PO06q3BT2tesPR06q3Mj2t+lL9s6q3Xz2temPX06q3jD2tepvb06q35j2r+s2a97TqrXlPq96a97TqrXlPq75U/6zqrXlPq96a97TqrXlPq96a97TqrXnPqn635j2temve06q35j2temve06ov1T+remve06q35j2temve06q35j2temves6o/rHlPq96a97TqrXlPq96a97TqS/XPqt6a97TqrXlPq96a97TqrXlPq96a96Tqp8Ga97TqrXlPq96a97TqrXlPq75U/6zqrXlPq96a97TqrXlPq96a97TqrXnPqn605j2temve06q35j2temve06ov1T+r+u6aV2Nd1c/HI/Xzy/+7Mh/rB/Rxv/Xpvnywy/TjA3/F/dvj//qM16f7jDf2Zzyv0/UzrvHRZ1x1eePLqz/fx375ZG/WinE9hsv72IbhwSe7rvvx16PXbaoHH9ByXNCs86vHDtvlIzoCH9G2zNePaJseXYrt+o/JTvvwWsB4S239cLvU+ODR4zhcP9/x5X+mR19i9/36JfYYlh+PrptvfDqub3vbXz/4P7z8x3/87//6b//2r//5//u3//qf/uV//ut//S//49vR4dv/N9188VLzBXG9+oNx/OPPxVQfPrF8+MT64RPbh0/sHz5x8z4u1y8jy/rziXn48InxwyemD5+46Xy5PqMv2/LzifrwieXDJ9YPn7jpfLl+eVhePW//dWL/8Injoydq+PCJ8e0T67D9fGL68In5wyduOl/X7frldP35xPLhE+uHT2wfPnHT+Xp9effydPLzieOjJ5bhwyfGD5+46XwbLq9pt7F+PjF/+ER9+MTy4RPrgxPT9POJ7cMn9g+fuOl8Oy4+9uFnH7f/teM3T4wfPjF9+MRN5/v1M99/8XH7X3J888Ty4RPrh0/cdL5fX+Xs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","brillig_names":["get_public_keys_and_partial_address","random","decompose_hint","notify_created_note_oracle_wrapper","get_key_validation_request","lt_32_hint","lte_16_hint","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","pack_returns_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"value_internal","is_unconstrained":false,"custom_attributes":["private","internal"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"input","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7ZbbioMwEIbfJddeZCaHSXyVZSna2hIQLWoXFum7b3Q99KAUaXtT9EIy5puZf34jWLNdEp8OG5ft85KFXzVL821UuTzzUc1AtM/KY5Q1YVlFRcVC0JYHLMl2fkmcnwO2d2nCQmH8+o5GMtTRaLgdaNAwQQupTUcLJeEBDcBtj4O/cNSCaoo3Rve45Wqk5WRxtENtMpfwd8BArtbMWaNWa+as0as1c9bQ89YIK6Ef1hKNwxrdtjDvb2GXtvBJyJ/XpbXpzdWE8krXPa2Gt6zFBcuplQMvkENKDHIIH8j50CONuBr5AiN9EBcuTd1hc/V3wpubmPymCbGrRorfnm9hF6dIvjwFFqacffgTFS6K06SZr9k9Zdt+XB9Wv8f/HQ//AQ==","brillig_names":["pack_returns_oracle_wrapper"]},{"name":"private_get_value","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"16137133351287663689":{"error_kind":"fmtstring","item_types":[],"length":17}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_notes_internal","get_collapse_hints","lt_32_hint","decompose_hint","lte_16_hint","pack_returns_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3dbhw3EoXfRde+4G+RzKssFoGTOIEAww5iZ4FFkHffsazpmVV3q6Sa4swppW4CO+5qH38i6/Bwptl/3f3y4ac/f/vx/tOvn7/c/fCvv+4+fv75/df7z58Ov/vr73d3P/1x//Hj/W8/nv/vu/DtP6U+XP/l9/efvv32y9f3f3y9+yGG8u7uw6dfvv1qHOp/vf/44e6H3MPf/353V+jVJTW9ruTd6tqWHi9tbbmyjod754n3LhPvXSfemybeu028d5947zHv3hQm3jtOvPfEeUkT5yVNnJc0cV7SxHlJE+clTZyXNHFetonzsk2cl23ivGwT52WbOC/bxHnZJs7LNnFetonzsk2cl33ivOwT52WfOC/7xHnZJ87LPnFe9onzsk+cl33ivOwT5+WYOC/HxHk5Js7LMXFejonzckycl2PivBwT5+WYOC/HxHkZQ5h58zjz5mnmzfPMm5eZN68zb04zb95m3rzPvPnMGRpnztA4c4bGmTM0zpyhceYMjTNnaJw5Q+PMGRpnztA4c4ammTM0zZyhaeYMTTNnaJo5Q9PMGZpmztA0c4ammTO0XPwDpdDH48UUc1yufqhcXZ37iI9X5xHzcnUq3+VULDmEJadhyelYcgaUnBqw5EQsOQlLTsaSg9WVK1ZXrlhduWJ15YrVlStWVyasrkxXnlkU6Xhx6icx/VHNlYcO5eXiUtdqBpKaFqDURCg1CUpNhlJToNQo9Bs6U5MYNS0f+00r4XTnRt/VEJSaBqWmQ6kZSGp6gFITodQkKDUZSk2BUnN5L44nZ0gxXqaGoNQ0KDUdSs1AUnP5V4xU1UQoNQlKTYZSU6DUQPXiAdWLB1QvHlC9eCD14hSQenEKSL04BaRenAJSL04BqRengNSLU0DqxSkg9eIUkHpxClC9OEL14gjViyNUL45QvThC9eII1YsjVC+OML1442PHRu3x4txXHzumCNO4Xy8dpsu/WnqCsYTXS4fxj9dLhzGb10uHcabXS4exsddLh/G810uHMcjXS7frpsmumya7bprtumm266bZrptmu26a7bpptuum2a6bZrtumu26abbrpsWumxa7blrsummx66YKzzzeTLpdNy123bTYddNi102LXTetdt202nXTatdNq103VXhW9WbS7bppteum1a6bVrtuWu26Kdl1U7LrpmTXTcmum15+Ev7tpNt1U7Lr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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"608":"attempt to add with overflow","925":"Nested call failed!","276":"Function pub_inc_value_internal can only be called internally","500":"attempt to add with overflow","1073":"Array index out of bounds","453":"Stack too deep","482":"attempt to add with overflow","511":"Array index out of bounds","979":"Nested call failed!","522":"attempt to add with overflow","551":"Array index out of bounds","842":"Nested call failed!","1095":"attempt to add with overflow","504":"Array index out of bounds","597":"Array index out of bounds","696":"Nested call failed!","559":"attempt to add with overflow","1068":"Index out of bounds"}},{"name":"set_value_with_two_nested_calls","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiAHYqCAECAAABAgEkAgEAAyoOAwIqCAEEAAABAgEkAgAABSoOBQQqCAEGAAABAgEkAgACByoOBwYeAgAAByYCBPCjT18ACCQCBAAJJAIEAAskAgQCDQA4Cw0MKggBCgAQAQwBJAMEAQoAKAoCDCoOCwwkAgQCDAA4CgwLJAIEDQwqCAANKgwCDioMBA8qDAYQKgwHESoMCBIqDAkTKgwKFCoMAxUqDAUWKgwDFyoMBRgAEAAMACIAeyoEAAAqDA4LHgIAAAcmAgSl+R9pAAgkAgQODSoIAA4qDAIPKgwEECoMBhEqDAcSKgwIEyoMCRQqDAoVKgwDFioMBRcqDAMYKgwFGQAQAA0AIgB7KgQAACoMDwwkAgAUAiQCBAEDKggBBCQCBAIFABABBQEkAwQBBAAoBAIFKgwFBioOAgYkAgABBSoMCQEgAFIKOAEJBiECAGYABiAAVSQCBAEEJAIEAgYAOAQGBSoIAQEAEAEFASQDBAEBACgBAgUqDgQFJAIEAgUAOAEFBCoMBAUqDgIFACgBAgYqDQYFACgGAgQ0DQAEAAUjHAwAAQYAOAUGByQCBAEIDDgBCAohAgBsAAo5AQAAACgEAggAOAgBCioNCgYtDAAGAAcAOAEDBg44AQYHIQIAdAAHOQEAACoMBgEgAFIlAAR4AIAEDQAAAIAEgAMhAAB6gAM5AQAAIyIAdhwMAAUNKggBBQAAAQIBJAIEAQ4qDg4FKggBDwAAAQIBJAIEAREkAgQCEwA4ERMSKggBEAAQARIBJAMEARAAKBACEioOERIkAgQCEgA4EBIRKgwREioODRIqDhAPJAIBAQ0kAgQAECoMEAwgAJQMOAwGASECAL8AASAAlyoNBQIqDQ8DKQIAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAABSECAJ4ACCAAnCoMBQEgAKAqDAkBIACgIQIApAAKIACiKgwFBiAApioMCwYgAKYqCAEFJAIEAwcAEAEHASQDBAEFACgFAgcqDAcIKg4BCAAoCAIIKg4GCCYCANVEGw0ABwAoBQIIACgDAgsqDQsKACgLAgkqCAELAAABAgEkAwQBCwAoCwINNj+VAAgABAAJAAoADQAAAAwAByQCAgEBCjgMAQIhAgC9AAI5AQAAKgwLASMMOAwGASECAMIAATkBAAAAKAcCAioNAgIMOAwCAyECAMcAAzkBAAAkAgQCAwA4BwMCADgCDAMqDQMBKg0FAioNDwMAKAICECsEAAOAAyUABAABgAQiAN8rCIAFABErCIAGABIqDgESKg0RAQAoAQIBKg4BESoOEAUqDhEPADgMDgEOOAwBAiECAN0AAjkBAAAqDAEMIACUAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAA94ANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIADuAQCACoAHgAYjKwAYyhjK","debug_symbols":"1ZzdSisxFIXfZa57kf2TnWxf5XCQqlUKpYrWAwfx3a3amVY6OhC7Qnojjmb7rcp8yW4y9KW7WVw9310u17f3T93Fn5dudX893yzv19url9dZd/W4XK2Wd5eHP+7C+xf/GP70MF+/Xz1t5o+b7oLMw6xbrG+236YQtn/gdrladBeSw+vfWUehpIhKirikSEqKtKQolhRZSVEqKcolRSV3BJfcETx6R4ir7orETb8UzUZGWxxGp/1oynFktGmm3WhTT19Gvwfi8UDSB9IQ8kQgi9oHsphkj3D6QAgeoXhExCMMj0h4RMYjHI6QgEcQHoG3W/B2C95uwdsteLsFb7fg7Ra83Yq3W/F2K95uxduteLsVb7fi7Va83Yq3W/F2R7zdcdRuDcoDwrhmHx95PJAMgSjEX75mwSMUj4h4hOERCY/IeITDERbwCMIj8HYb3m7D2214uw1vt+HtNrzdhrc7j3tB7AMi2gSC2HK/Y8d+sAwLjQUKIfWBAvvEoh2T90liPtgN3C3aefxu3W4cDvF9qlFJqSdkSRNxkksfPvnhf3MXx9qKk9qKk9uK403F8dBWHGorDrcVR9qKo23FaWtW9rZmZW9rVva2ZmVva1am0Na0TKH1hi0PJ7ExRz3OL63nZ/8xv7aeP9qQ3+Jx/njm+e3M86czz5/PPL+fd34KZ56fWs9PcZ/fJkY7iexGO6Xj1YKaX62/f7Uf+ZtfrSfyN79aT+RvfrX+Of/4Y2Vsw0Eim4WpjjgP3fPBoSOzfhLiNwQeCOmXBIMTEpyQ4QRHE8YfKDspgeAEhhMETlA4Ae60wJ0WuNMCd1rgTivcaYU7rXCnFe60nuBeIqMeQcb7PsM+W4FIp0CoDYiDxqFHMBwxfnbNKfTbgTy9xZeV+weRsiY6aprGD69PzMgVGI5npFCBQRUYXIEhFRhagRErMCp4nip4nip4nip4nit4nit4nit4nit4nit4Pv5wD3vstxzYLR1XWVFVKqrKJVVO8GbLGY8QPELxiIhHGB6R8Aj8OwR3NIJDwCMIj2A8QvAIxSNOYvdPbwg5GB6R8IiMRzgcQQGPIDyC8QjBIxSPwNtNeLsJbzfh7Sa83Qy2+3V79W/+uJxfrRa7T8C5fV5fH3wgzub/w+dvtoPfAA==","brillig_names":["set_value_with_two_nested_calls"],"assert_messages":{"121":"Stack too deep","193":"Index out of bounds","115":"attempt to add with overflow","220":"attempt to add with overflow","188":"Nested call failed!","198":"Array index out of bounds","107":"Array index out of bounds"}},{"name":"value","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"input","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7ZbdioMwEIXfJddeZCY/k/gqy1K0tSUgWtQuLNJ339g12m6VIu3eFL2QjPlm5swxgi3bZenpsHHFvqxZ/NGyvNwmjSsLH7UMxOVZfUyKLqybpGpYDNryiGXFzi+J83PE9i7PWCyMX9/RSIZ6Gg23Aw0aJmghtelpoSQ8oAG4DTj4C0ctqKZ4Y3TALVcjLSeLox1qk7mGPyMGcrVmzhq1WjNnjV6tmbOGnrdGWAlhWEs0Dmv0pYX5/xb2+RZam+CTJpQ3Le5pNbwwLa5YTp0c5C+QQ0oMcggfyHnT04mwGvkCI32QVi7P3WFz86PBu5uY/DwJsa9Giv8938IuTpF8eQosTDn78CupXJLmWTdft3sqtmFcHzbfx98dD/8A","brillig_names":["pack_returns_oracle_wrapper"]},{"name":"pub_inc_value","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"new_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiAHQqCAEDAAABAgEkAgEABCoOBAMqCAEDAAABAgEkAgAABCoOBAMqCAEDAAABAgEkAgACBSoOBQMqCAEDJAIEAgUAEAEFASQDBAEDACgDAgUqDAUGKg4EBioNAwUAKAUCBSoOBQMqCAEFAAABAgEqDgMFJAIEAAMkAgQBBCQCAAEGKgwDAiAAKQo4AgMHIQIAXgAHIAAsKg0FBwAoBwIIADgIAwkqDQkFADgFAQcqDAMCIAAzCjgCAwUhAgBHAAUgADYkAgQBAyQCBAIGADgDBgUqCAECABABBQEkAwQBAgAoAgIFKg4DBSQCBAIFADgCBQMqDAMFKg4BBQAoAgIGKg0GBQAoBgIDNA0AAwAFIxwMAAIFADgGBQgqCAEFJAIEAgkAEAEJASQDBAEFACgFAgkqDAkKKg4HCiQCBAEKDDgCCgshAgBUAAs5AQAAACgFAgoAOAoCCyoNCwktDAAJAAgAOAIEBQ44AgUIIQIAXAAIOQEAACoMBQIgADMqDQUHHAwAAggAOAYICSwMAAkACCQCBAEKDDgCCgshAgBmAAs5AQAAKwQAB4ADJQAEAAKABCIAeSsIgAUACQAoCQIKADgKAgsqDggLADgCBAcOOAIHCCECAHEACDkBAAAqDgkFKgwHAiAAKSUABHgAgAQNAAAAgASAAyEAAHiAAzkBAAAjKwGAA4AGCwCABgACgAchAAB9gAcgAH8rAIADgAUgAI0rAAABgAUBAAABgAQAASUABAAAgAkNAIAJgASAChcAgAqACiEAAIuACgEAgAOACYALKwGAC4AIAQCABYAJgAsrAoAIgAsBAIAJAAKACSAAgiUBBAABgAUgAI0jKwAYyhjK","debug_symbols":"1dvbbuIwEAbgd8k1Fx4f5sCrrFYVtFBFQlABXWmFePdNtjjQJo0l33TmpiLFE38Bx3+imEvzslm/vz61++3h1Cx/XZrd4Xl1bg/7butyXTTrY7vbta9Pj/9uXP8H4H/709tq32+ezqvjuVkCils0m/1L95Kc6/awbXebZhnYXX8vGvA1RaGmKNYUpZoirCmimiKuKZKKIu9qimpGhK8ZEX5yRHhO/lbkmfhT0WLcheOYuwAnQ2sIMNE6Ycz7Tojh3prTVOvAlFsH5k+te360zU+2+WibT7b5bJsvpvnB2eaDbb63zbedusF26gbbqRu1n7oR8r67l2nE1z54YnADP+CI/wODxw/DAYkLfB9hkEQPQ2vf9dPz0TafbPOnL9kEOBdJkK+3aOmb8324r+vqqXTMHnMX4CUWjhmdy8eMzkvphCGR/Anxwx3m7YRJ0+e7pDu/+JUR5R44UIFDEjKehMKIk3RxUBeHdHFYF0dUcdDp4oAujtfFCbo4umZl1DUro65ZGXXNyqhrVkZdszJpv1zjONyecYojvtfO9zLHD9r5CQc+jm6OKdrmJ9t8tM0n23y2zRfTfHa2+epTd56vPnXn+bZTl22nLttOXbaduqw+dSHd+VhoLRDCrXXHHl1es/qM/v5ge776jJ7li/qMnuerz+h5fjT93FW0P/WOODxoi0Qjvva1ZnGQTPK1rzWLQe780mNOcT5LxKXxwWpfmTb/iF+0r0yb54PTvjSt5Fe/wKXg1744reTXvjqt5Fcf1AW/+qQu+NVHdcGvP6vn/bbjt+vOth+M5y8Yz18wnr9gOX+v3eaf1bFdrXeb2y8ft+/754cfQp7/vn280zX+Bw==","brillig_names":["pub_inc_value"],"assert_messages":{"112":"attempt to add with overflow","101":"Array index out of bounds","91":"attempt to add with overflow","119":"Stack too deep","83":"Array index out of bounds"}},{"name":"pub_get_value","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"base_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiABUeAgQAAgA4AQIDHgIFAAEAOAMBAh4CBgABADgCAQMeAgcAARwMAAECADgDAgEjJQAEeACABA0AAACABIADIQAAGYADOQEAACMrABjKGMo=","debug_symbols":"hdNRjoMgEAbgu/DsAwgzDF5ls2mw1YaEYKN2k43x7qvbUttAwotx9B8yn8LCLl17v55c6IeJNV8L88PZzm4IW7WsFWtH5727nt4fM75fhPjPTzcb9nKa7TizRgDXFevCZb+t5bZC73zHGkl8rZK0Qi2faYV0pAVBJo0EcW0krT7S3xUTdXYgRfUxEHwMtDfJvELxVxNASaFlnEtphSWFESYqjIREoYoK0IkC8gp9NJm6pCAOUUHCFBUU05pzTBRYVBiVKHS2CXn8XgJrLCqOHUWkCgrNQbwUaBIFFQeS6b8wJXrStG7ljx2dbX33PHf9PZzfjuH8e3u82cJ/","brillig_names":["pub_get_value"],"assert_messages":{"24":"Stack too deep"}},{"name":"set_value_twice_with_nested_first","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiAI4qCAECAAABAgEkAgEAAyoOAwIqCAECAAABAgEkAgAAAyoOAwIqCAECAAABAgEkAgACAyoOAwIeAgAAAioIAQMAAAECASQCBAEEKg4EAyoIAQUAAAECASQCBAEHJAIEAgkAOAcJCCoIAQYAEAEIASQDBAEGACgGAggqDgcIJAIEAggAOAYIByoMBwgmAgDrHjNCAAkqDgkIKg4GBSQCAAoGJAIEAAcqDAcBIAAuCjgBBwghAgB7AAggADEqDQMGKg0FAykCADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAAAUmAgDVRBsNAAgqCAEJJAIEAwoAEAEKASQDBAEJACgJAgoqDAoLKg4FCwAoCwILKg4FCwAoCQIKACgDAg0qDQ0MACgNAgsqCAENJAIEAg4AEAEOASQDBAENACgNAg82P5UACgACAAsADAAPAAEADgAIJAICAQIKOA4CAyECAEwAAzkBAAAqCAECJAIEAgMAEAEDASQDBAECACgCAgMqDAMFJAIAFAYqDgYFJAIAAQMqDAcBIABXCjgBBwUhAgBrAAUgAFokAgQBAiQCBAIFADgCBQMqCAEBABABAwEkAwQBAQAoAQIDKg4CAyQCBAIDADgBAwIqDAIDKg4GAwAoAQIFKg0FAwAoBQICNA0AAgADIxwMAAEFADgDBQgkAgQBCQw4AQkKIQIAcQAKOQEAAAAoAgIJADgJAQoqDQoFLQwABQAIADgBBAUOOAEFCCECAHkACDkBAAAqDAUBIABXCjgBBwghAgB+AAg5AQAAKg0DCCoNBQkAKAgCCisEAAmAAyUABAABgAQiAJMrCIAFAAsrCIAGAAwqDgYMKg0LCAAoCAIIKg4ICyoOCgMqDgsFKgwEASAALiUABHgAgAQNAAAAgASAAyEAAJKAAzkBAAAjAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAAq4ANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIACiAQCACoAHgAYjKwAYyhjK","debug_symbols":"1dzBbuJADAbgd8mZgz322DO8ympVQQsVEoIK6EorxLtvYJMATZqRcqjsS9WAnXxIw/wQzXCu3lbLz/eXzW69P1bzX+dqu39dnDb7XX10vsyq5WGz3W7eXx4fruD6J9/Kjx+L3fXoeFocTtUcJcOsWu3e6n8VoD7BerNdVXNKcPk9qxCmNOGUpjCliaY08ZSmOKVJpjTplKY0pWnKiAhTRkQYHBHEGpsm4hyfmmb96ixddVbuqjHFgWrhhE21cNan6isoDIPul4gBCyBO0F6CU8j3S2QcqA5CoakOolDga8pNcYLU1YbANzx5xrNnfPSMF8949YxPnvHZMZ7AMx494z0nLHlOWPKcsOQ5YclzwpLnhCXPCUueE5Y9Jyx7Tlg2PtugYKtHCfcv7HL7Bs7GBz0KS6cX+KKPxkd9Qf/zw76+KdTqE2lBnzi0506s+FR95QfffPLNZ9/86Jsvvvnqm59887NrvoBvvu/UFd+pK75TV3ynrvhOXfGduuI7dcV36orv1FXfqau+U1d/PnVzbM8dsvRWTihZA7E1UDQGSsPTf+Q7SEMBhEFSe0Mp5IfVNzQEEgBtqgUe+YNvgai5vVEYE8BXfh6egGJq73CRIBf4qt2N1OI7UjO1eM1KPQ7a4gRbHLLFYVucaIsjtjhqi5NscbIpDoKtaRnB1ryMYGtiRrA1MyPYmpoRbM3NCNY/tSXm7lNb5L4/WfeHPOrP1v1ROr/Enh/BuR+d+4NzPzn3s3N/dO4X636Md78UqjMSNdUZtZ8WaD6tv3+1N7/5tC74zaf1uD+YT+uC3/iK+fHFiGh9V1qJb3zVfInveiUrWt+bVuIbXzs/vpYVre9PK/Ct71Ar8Y2voC/xje9SK/HNp+4433zqjvPNp+4433zqjvPNp+4433fqWt+zNsa/1Ed/FofNYrldNb+as/7cvT78iM7p78f/Z+rifw==","brillig_names":["set_value_twice_with_nested_first"],"assert_messages":{"112":"Array index out of bounds","120":"attempt to add with overflow","125":"Index out of bounds","145":"Stack too deep","75":"Nested call failed!"}},{"name":"pub_inc_value_internal","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"new_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiAHkqCAEDAAABAgEkAgEABCoOBAMqCAEDAAABAgEkAgAABCoOBAMqCAEDAAABAgEkAgACBSoOBQMeAgEAAx4CAAAFCjgDBQYhAgAcAAY5AQAAKggBAyQCBAIFABABBQEkAwQBAwAoAwIFKgwFBioOBAYqDQMFACgFAgUqDgUDKggBBQAAAQIBKg4DBSQCAAEDJAIEAAQkAgQBBioMBAIgAC4KOAIEByECAGMAByAAMSoNBQcAKAcCCAA4CAQJKg0JBQA4BQEHKgwEAiAAOAo4AgQFIQIATAAFIAA7JAIEAQMkAgQCBQA4AwUEKggBAgAQAQQBJAMEAQIAKAICBCoOAwQkAgQCBAA4AgQDKgwDBCoOAQQAKAICBSoNBQQAKAUCAzQNAAMABCMcDAACBQA4AwUIKggBBSQCBAIJABABCQEkAwQBBQAoBQIJKgwJCioOBwokAgQBCgw4AgoLIQIAWQALOQEAAAAoBQIKADgKAgsqDQsJLQwACQAIADgCBgUOOAIFCCECAGEACDkBAAAqDAUCIAA4Kg0FBxwMAAIIADgDCAksDAAJAAgkAgQBCgw4AgoLIQIAawALOQEAACsEAAeAAyUABAACgAQiAH4rCIAFAAkAKAkCCgA4CgILKg4ICwA4AgYHDjgCBwghAgB2AAg5AQAAKg4JBSoMBwIgAC4lAAR4AIAEDQAAAIAEgAMhAAB9gAM5AQAAIysBgAOABgsAgAYAAoAHIQAAgoAHIACEKwCAA4AFIACSKwAAAYAFAQAAAYAEAAElAAQAAIAJDQCACYAEgAoXAIAKgAohAACQgAoBAIADgAmACysBgAuACAEAgAWACYALKwKACIALAQCACQACgAkgAIclAQQAAYAFIACSIysAGMoYyg==","debug_symbols":"1ZvNjtowEMffJWcOng97bF6lqlawC6tICFbAVqoQ797Q4kBJiFX3sDMXlMCM/bMz9t/Gk1Pztlp+vr+02/Xu0My/nZrN7nVxbHfb7u50njXLfbvZtO8v91837vIB8Nv+8LHYXm4Px8X+2MwhJDdrVtu37lKc60pYt5tVM6fozt9nDWCNE9U4cY2Tr3EKNU5S4xRrnFKFE7oap5qIwJqIwH+OiNnAmh3FqzU7Dr01RD9iHTxn6+AD/WV9AeL/B6IU/NWaknAJiCNkIE4yAKqJZKyJZKyJZByNZEJIuQeQfaG/wEXOVYBLtx4gGLH2gfFq7cPDAxyxpijZmmIc9G4yjU/ONj7Yxkfb+GQbn23je9v4wTa+2Ma3rbpkW3XZtuqy9qHLkMvuLv0AX3vwMLken8Ijvv+C4ME+HILEAj4y5MYiI/TW2NVzwQfb+Ggb/8mSLfb7TXLhcYvmn4x3L32bI5fajCHvmgETF9ocnMtlB4epNGAk5d738W6HmQfM+Hgn6PGp+MhEcg2RpIAjiXLJkmTwB0FwunBAFw7qwiFdOKwLx+vCCbpwRBdO1IWja1YWXbOy6JqVRdesLLpmZdE1K4v25VrkfnsWPQ/wRTs+pin8qB3fhx4/DDbHkkzjR2cbH2zjo218so3PtvG9bXz1qjuNr151p/Ftq260rbrJtuom26qb1Ksu+Bt+Kb0qAdHVOoEMltdJvUY/b+wFX71GT+Or1+hpfPUaPY2v/uBy8twVnPZjbw79SRuLDPm1Z5uxx0l+7elmTOnGXzrpTA4zSXJ+pLXas9Omj/nBsXF+7flpJX71WS4Ffu0ZaiV+7SlqJX7baUZdfcb51at1gV+/Wk/zG9dfMK6/YFx/wbj+gnH9Bcv6e+5ufyz27WK5WV3fX11/bl/vXmc9/vz480tn/As=","brillig_names":["pub_inc_value_internal"],"assert_messages":{"88":"Array index out of bounds","96":"attempt to add with overflow","106":"Array index out of bounds","117":"attempt to add with overflow","124":"Stack too deep","27":"Function pub_inc_value_internal can only be called internally"}},{"name":"pub_set_value","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"new_value","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiADskAgABAyQCBAAEJAIEAQUqDAQCIAAQCjgCBAYhAgAkAAYgABMkAgQBAyQCBAIGADgDBgQqCAECABABBAEkAwQBAgAoAgIEKg4DBCQCBAIEADgCBAMqDAMEKg4BBAAoAgIGKg0GBAAoBgIDNA0AAwAEIxwMAAIGADgDBgcqCAEGJAIEAggAEAEIASQDBAEGACgGAggqDAgJKg4BCSQCBAEJDDgCCQohAgAxAAo5AQAAACgGAgkAOAkCCioNCggtDAAIAAcAOAIFBg44AgYHIQIAOQAHOQEAACoMBgIgABAlAAR4AIAEDQAAAIAEgAMhAAA/gAM5AQAAIysAGMoYyg==","debug_symbols":"1dnNaoNAFAXgd5l1FjNz585PXqWUYBITBNGgplAk715t1aTV6vbMRhw96OfmngFbcU6P9+shKy5lLfZvrcjLU9JkZdGt2sdOHKssz7Pr4fWykP1B2e98fUuKflk3SdWIvXKediItzt2pV7J7wiXLU7En353P09r6Ma2DmdKK1ELaSumGtJU6PNOeF9LsQhjS7KX8lX7fCRUW+Z7UxOewwXdufIMnt8FxgUa8C47+crTE4igsjsbiEBbHYHEYi2OxOA6L47E4WFOZsKYyYU1lwprKhDWVCWsqE/p2zRszbdfYzPgOna/DGt+j89lOfMszfoiab2TcfBU3X8fNp7j5Jm4+x82Hb911PnzrrvPjbl0Td+ty3K3Lcbcuw7eu4iffbqSDotEdlJttrxm+o///2J4P39HrfPiOXufDd/QK/9EtP5IqS455OvyyudyL08sfnObz9nOnC38B","brillig_names":["pub_set_value"],"assert_messages":{"48":"Array index out of bounds","56":"attempt to add with overflow","62":"Stack too deep"}},{"name":"set_value_twice_with_nested_last","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiAI4qCAECAAABAgEkAgEAAyoOAwIqCAECAAABAgEkAgAAAyoOAwIqCAECAAABAgEkAgACAyoOAwIkAgQBAioIAQMkAgQCBAAQAQQBJAMEAQMAKAMCBCoMBAUkAgAUBioOBgUkAgABBCQCBAAFKgwFASAAIgo4AQUHIQIAfgAHIAAlJAIEAQQkAgQCCAA4BAgHKggBAwAQAQcBJAMEAQMAKAMCByoOBAckAgQCBwA4AwcEKgwEByoOBgcAKAMCCCoNCAcAKAgCBDQNAAQABx4CAAADKggBBAAAAQIBKg4CBCoIAQYAAAECASYCAOseM0IAByQCBAEJJAIEAgsAOAkLCioIAQgAEAEKASQDBAEIACgIAgoqDgkKJAIEAgoAOAgKCSoMCQoqDgcKKg4IBiQCAAoHKgwFASAATAo4AQUIIQIAawAIIABPKg0EASoNBgIpAgAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAAAAEJgIA1UQbDQAFKggBBiQCBAMHABABBwEkAwQBBgAoBgIHKgwHCCoOBAgAKAgCCCoOBAgAKAYCBwAoAgIKKg0KCQAoCgIIKggBCiQCBAILABABCwEkAwQBCgAoCgIMNj+VAAcAAwAIAAkADAABAAsABSQCAgEBCjgLAQIhAgBqAAI5AQAAIwo4AQUIIQIAbgAIOQEAACoNBAgqDQYJACgIAgorBAAJgAMlAAQAAYAEIgCTKwiABQALKwiABgAMKg4HDCoNCwgAKAgCCCoOCAsqDgoEKg4LBioMAgEgAEwcDAABBwA4BAcIJAIEAQkMOAEJCiECAIQACjkBAAAAKAMCCQA4CQEKKg0KBy0MAAcACAA4AQIHDjgBBwghAgCMAAg5AQAAKgwHASAAIiUABHgAgAQNAAAAgASAAyEAAJKAAzkBAAAjAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAAq4ANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIACiAQCACoAHgAYjKwAYyhjK","debug_symbols":"1dzBbuIwEAbgd8mZg2dsz3j6KqtVRVtaISGogK60Qrz7BpYE2tBYyqGa/1I17Zh8TRP/jh04NC+Lp4+3x+X6dbNrHn4dmtXmeb5fbtbt1uE4a562y9Vq+fZ4++MmnL7YuXz3Pl+ftnb7+XbfPJBYmDWL9Uv7rYbQvsDrcrVoHmIJx9+zhsKURjSlEU9pFKc0SlMa5SmNZEojndKoTGk05YzgKWdEvHvIo1i8NIrKnxvNhrtgKd0u2FJfTZHuVEsIeqmWwHatLvlOdVazS3UuN/xT9Yl/918SNaaeL1zhq3Z7KFErHLXY4dU0DjjFF8dccVLwxSFfHPbFib44yRcn++KIL46vXjn56pWTr145++qVs69eOfvqlfP9XrkdGXWcUh2uRZPcVZumCkhSoW64lkwHoG/6ZbuCklRAqYRuF6ncjgjt3viRJfKlmkVD7XiW/tiH0tcypzM+I+MFGa/I+IKMN2C8BGQ8IeMZGR+R8cgJK8gJK8gJK8gJK8gJK8gJq8gJq8gJq8gJq867ShLq9CR8veeV802sOr9iSZL0eglf9MX5JVvR//w1q/1sCdcnZEri7rVLUvpUfeIzNj9i8xM2P2PzBZuv2PyCzTdovgVsPnbqGnbqGnbqGnbqGnbqGnbqGnbqGnbqGnbqUsCOXQrYuUvh54PXcve0ApvoUBTdiZI7UXYncr46MT5fSMH5+kSN736+c5RP7ic8x/nOVylqfOfrFOPTzUTOnwWo8RM23/nzADW++2Wucb771B3nu0/dcT70KiMx9DIjsfvUHedjpy5jpy6L83dJltS9HyGXnAa3W6ze/Wyj/uLdn6X3t+fMwG/Y/hjA/QTuZ3B/BPcncH/27qd89Uul2trz6VJtpMO0iO7T+vu/9ux3n9YVv/u0rvjdp/WI/9hu/plvl/On1eLywTOvH+vnm8+h2f99//+btvgf","brillig_names":["set_value_twice_with_nested_last"],"assert_messages":{"131":"Array index out of bounds","109":"Index out of bounds","105":"Nested call failed!","145":"Stack too deep","139":"attempt to add with overflow"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Child"}},{"name":"fields","value":{"fields":[{"name":"current_value","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"a_map_with_private_values","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_inc_value_internal_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_inc_value_internal_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Child::set_value_twice_with_nested_last_parameters"}}],"kind":"struct","path":"Child::set_value_twice_with_nested_last_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"base_value","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_get_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_get_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"input","type":{"kind":"field"}}],"kind":"struct","path":"Child::value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"amount","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Child::private_get_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::private_get_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Child::set_value_twice_with_nested_first_parameters"}}],"kind":"struct","path":"Child::set_value_twice_with_nested_first_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Child::private_set_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::private_set_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_inc_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_inc_value_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"input","type":{"kind":"field"}}],"kind":"struct","path":"Child::value_internal_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::value_internal_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"Child::set_value_with_two_nested_calls_parameters"}}],"kind":"struct","path":"Child::set_value_with_two_nested_calls_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_value","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_set_value_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"Child::pub_set_value_abi"}]}},"file_map":{"101":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"120":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"141":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest,\n};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission,\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"144":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/comparison.nr","source":"struct ComparatorEnum {\n    EQ: u8,\n    NEQ: u8,\n    LT: u8,\n    LTE: u8,\n    GT: u8,\n    GTE: u8,\n}\n\nglobal Comparator = ComparatorEnum { EQ: 1, NEQ: 2, LT: 3, LTE: 4, GT: 5, GTE: 6 };\n\npub fn compare(lhs: Field, operation: u8, rhs: Field) -> bool {\n    // Values are computed ahead of time because circuits evaluate all branches\n    let is_equal = lhs == rhs;\n    let is_lt = lhs.lt(rhs);\n\n    if (operation == Comparator.EQ) {\n        is_equal\n    } else if (operation == Comparator.NEQ) {\n        !is_equal\n    } else if (operation == Comparator.LT) {\n        is_lt\n    } else if (operation == Comparator.LTE) {\n        is_lt | is_equal\n    } else if (operation == Comparator.GT) {\n        !is_lt & !is_equal\n    } else if (operation == Comparator.GTE) {\n        !is_lt\n    } else {\n        panic(f\"Invalid operation\")\n    }\n}\n\nmod test {\n    use super::compare;\n    use super::Comparator;\n\n    #[test]\n    unconstrained fn test_compare() {\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(compare(lhs, Comparator.LT, rhs), \"Expected lhs to be less than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.LTE, rhs), \"Expected lhs to be less than or equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(compare(lhs, Comparator.GT, rhs), \"Expected lhs to be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(!compare(lhs, Comparator.EQ, rhs), \"Expected lhs to be not equal to rhs\");\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.NEQ, rhs), \"Expected lhs to not be not equal to rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.LT, rhs), \"Expected lhs to not be less than rhs\");\n\n        let lhs = 11;\n        let rhs = 10;\n        assert(\n            !compare(lhs, Comparator.LTE, rhs),\n            \"Expected lhs to not be less than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 10;\n        assert(!compare(lhs, Comparator.GT, rhs), \"Expected lhs to not be greater than rhs\");\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n\n        let lhs = 10;\n        let rhs = 11;\n        assert(\n            !compare(lhs, Comparator.GTE, rhs),\n            \"Expected lhs to not be greater than or equal to rhs\",\n        );\n    }\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"149":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/collapse_array.nr","source":"// Collapses an array of Options with sparse Some values into a BoundedVec, essentially unwrapping the Options and\n// removing the None values. For example, given:\n//   input: [some(3), none(), some(1)]\n// this returns\n//   collapsed: [3, 1]\npub fn collapse_array<T, let N: u32>(input: [Option<T>; N]) -> BoundedVec<T, N>\nwhere\n    T: Eq,\n{\n    // Computing the collpased BoundedVec would result in a very large number of constraints, since we'd need to loop\n    // over the input array and conditionally write to a dynamic vec index, which is a very unfriendly pattern to the\n    // proving backend.\n    // Instead, we use an unconstrained function to produce the final collapsed array, along with some hints, and then\n    // verify that the input and collapsed arrays are equivalent.\n    let (collapsed, collapsed_to_input_index_mapping) = unsafe { get_collapse_hints(input) };\n    verify_collapse_hints(input, collapsed, collapsed_to_input_index_mapping);\n    collapsed\n}\n\npub(crate) fn verify_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n    collapsed: BoundedVec<T, N>,\n    collapsed_to_input_index_mapping: BoundedVec<u32, N>,\n)\nwhere\n    T: Eq,\n{\n    // collapsed should be a BoundedVec with all the non-none elements in input, in the same order. We need to lay down\n    // multiple constraints to guarantee this.\n    // First we check that the number of elements is correct\n    let mut count = 0;\n    for i in 0..N {\n        if input[i].is_some() {\n            count += 1;\n        }\n    }\n    assert_eq(count, collapsed.len(), \"Wrong collapsed vec length\");\n\n    // Then we check that all elements exist in the original array, and are in the same order. To do this we use the\n    // auxiliary collapsed_to_input_index_mapping array, which at index n contains the index in the input array that\n    // corresponds to the collapsed entry at index n.\n    // Example:\n    //  - input: [some(3), none(), some(1)]\n    //  - collapsed: [3, 1]\n    //  - collapsed_to_input_index_mapping: [0, 2]\n    // These two arrays should therefore have the same length.\n    assert_eq(\n        collapsed.len(),\n        collapsed_to_input_index_mapping.len(),\n        \"Collapse hint vec length mismatch\",\n    );\n\n    // We now look at each collapsed entry and check that there is a valid equal entry in the input array.\n    let mut last_index = Option::none();\n    for i in 0..N {\n        if i < collapsed.len() {\n            let input_index = collapsed_to_input_index_mapping.get_unchecked(i);\n            assert(input_index < N, \"Out of bounds index hint\");\n\n            assert_eq(\n                collapsed.get_unchecked(i),\n                input[input_index].unwrap(),\n                \"Wrong collapsed vec content\",\n            );\n\n            // By requiring increasing input indices, we both guarantee that we're not looking at the same input\n            // element more than once, and that we're going over them in the original order.\n            if last_index.is_some() {\n                assert(input_index > last_index.unwrap_unchecked(), \"Wrong collapsed vec order\");\n            }\n            last_index = Option::some(input_index);\n        } else {\n            // BoundedVec assumes that the unused parts of the storage are zeroed out (e.g. in the Eq impl), so we make\n            // sure that this property holds.\n            assert_eq(\n                collapsed.get_unchecked(i),\n                std::mem::zeroed(),\n                \"Dirty collapsed vec storage\",\n            );\n        }\n    }\n    // We now know that:\n    //  - all values in the collapsed array exist in the input array\n    //  - the order of the collapsed values is the same as in the input array\n    //  - no input value is present more than once in the collapsed array\n    //  - the number of elements in the collapsed array is the same as in the input array.\n    // Therefore, the collapsed array is correct.\n}\n\nunconstrained fn get_collapse_hints<T, let N: u32>(\n    input: [Option<T>; N],\n) -> (BoundedVec<T, N>, BoundedVec<u32, N>) {\n    let mut collapsed: BoundedVec<T, N> = BoundedVec::new();\n    let mut collapsed_to_input_index_mapping: BoundedVec<u32, N> = BoundedVec::new();\n\n    for i in 0..N {\n        if input[i].is_some() {\n            collapsed.push(input[i].unwrap_unchecked());\n            collapsed_to_input_index_mapping.push(i);\n        }\n    }\n\n    (collapsed, collapsed_to_input_index_mapping)\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"165":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"166":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"177":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"376":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n        traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    }, oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"380":{"path":"/usr/src/noir-projects/noir-contracts/contracts/child_contract/src/main.nr","source":"// A contract used along with `Parent` contract to test nested calls.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Child {\n    use dep::aztec::prelude::{AztecAddress, PublicMutable, PrivateSet, Map};\n\n    use dep::aztec::{\n        note::note_getter_options::NoteGetterOptions,\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys, utils::comparison::Comparator,\n        macros::{storage::storage, functions::{private, public, internal}},\n    };\n    use dep::value_note::value_note::ValueNote;\n\n    #[storage]\n    struct Storage<Context> {\n        current_value: PublicMutable<Field, Context>,\n        a_map_with_private_values: Map<AztecAddress, PrivateSet<ValueNote, Context>, Context>,\n    }\n\n    // Returns a sum of the input and the chain id and version of the contract in private circuit public input's return_values.\n    #[private]\n    fn value(input: Field) -> Field {\n        input + context.chain_id() + context.version()\n    }\n    // Returns a sum of the input and the chain id and version of the contract in private circuit public input's return_values.\n    // Can only be called from this contract.\n    #[private]\n    #[internal]\n    fn value_internal(input: Field) -> Field {\n        input + context.chain_id() + context.version()\n    }\n\n    // Returns base_value + chain_id + version + block_number + timestamp\n    #[public]\n    fn pub_get_value(base_value: Field) -> Field {\n        let return_value = base_value\n            + context.chain_id()\n            + context.version()\n            + context.block_number()\n            + context.timestamp() as Field;\n\n        return_value\n    }\n\n    // Sets `current_value` to `new_value`\n    #[public]\n    fn pub_set_value(new_value: Field) -> Field {\n        storage.current_value.write(new_value);\n        context.emit_unencrypted_log(new_value);\n\n        new_value\n    }\n\n    #[private]\n    fn private_set_value(new_value: Field, owner: AztecAddress) -> Field {\n        let owner_keys = get_public_keys(owner);\n\n        let mut note = ValueNote::new(new_value, owner_keys.npk_m.hash());\n        storage.a_map_with_private_values.at(owner).insert(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            owner_keys.ovpk_m,\n            owner_keys.ivpk_m,\n            owner,\n        ));\n        new_value\n    }\n\n    #[private]\n    fn private_get_value(amount: Field, owner: AztecAddress) -> Field {\n        let mut options = NoteGetterOptions::new();\n        options = options.select(ValueNote::properties().value, Comparator.EQ, amount).set_limit(1);\n        let notes = storage.a_map_with_private_values.at(owner).get_notes(options);\n        notes.get(0).value\n    }\n\n    // Increments `current_value` by `new_value`\n    #[public]\n    fn pub_inc_value(new_value: Field) -> Field {\n        let old_value = storage.current_value.read();\n        storage.current_value.write(old_value + new_value);\n        context.emit_unencrypted_log(new_value);\n\n        new_value\n    }\n\n    // Increments `current_value` by `new_value`. Can only be called from this contract.\n    #[public]\n    #[internal]\n    fn pub_inc_value_internal(new_value: Field) -> Field {\n        let old_value = storage.current_value.read();\n        storage.current_value.write(old_value + new_value);\n        context.emit_unencrypted_log(new_value);\n\n        new_value\n    }\n\n    #[public]\n    fn set_value_twice_with_nested_first() {\n        let _result = Child::at(context.this_address()).pub_set_value(10).call(&mut context);\n        storage.current_value.write(20);\n        context.emit_unencrypted_log(20);\n    }\n\n    #[public]\n    fn set_value_twice_with_nested_last() {\n        storage.current_value.write(20);\n        context.emit_unencrypted_log(20);\n        let _result = Child::at(context.this_address()).pub_set_value(10).call(&mut context);\n    }\n\n    #[public]\n    fn set_value_with_two_nested_calls() {\n        Child::at(context.this_address()).set_value_twice_with_nested_first().call(&mut context);\n        Child::at(context.this_address()).set_value_twice_with_nested_last().call(&mut context);\n        storage.current_value.write(20);\n        context.emit_unencrypted_log(20);\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"65":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"96":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"98":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"}}}
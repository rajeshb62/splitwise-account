{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"PriceFeed","functions":[{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiAX8mAgCyyAqeAAIKOAECAyQCAAECJAIBAAQkAgQBBSQCACIGJAIEAgckAgAACCQCBAAJIQIAFQADIABmKggBCiQCBAMLABABCwEkAwQBCgAoCgILHzwABQAHAAsqDQoLACgLAgsqDgsKKggBCwAAAQIBKg4KCyoIAQoAAAECASoOCQokAgAEDCQCBA8OKggADyoMCxAqDAoRKgwMEgAQAA4AIgGEKgQAACoMEA0kAgQQDyoIABAqDAsRKgwKEioMDBMAEAAPACIBhCoEAAAqDBEOKggBCgAAAQIBKg4ECioIAQsAAAECASoOCAsqCAEMAAABAgEkAgAqDyoODwwkAgQUEyoIABQqDAoVKgwLFioMDBcqDAIYKgwGGSoMDRoAEAATACIByyoEAAAqDBUPKgwWECoMFxEqDBgSHAwADgooAgD/////////////////////AAsOOAoLDCECAFUADDkBAAAcDAUOCxwMAAsKAjgOCgsoAgAAAAAAAAAAAQAAAAAAAAAAAAwIOAsMDSoMCQMgAFwMOAMHCyECAWYACyAAXyoIAQMAAAECASQDBAEDACgDAgoAKAMCCjgDAAoAACAAZiYCACnVqC8AAwo4AQMKIQIAagAKIADqKggBAyQCBAIKABABCgEkAwQBAwAoAwIKHzwABQAFAAoqDQMKACgKAgoqDgoDKggBCgAAAQIBKg4DCioIAQsAAAECASoOCQsqDQMMACgMAgwqDgwDKggBDAAAAQIBKggBDSQCBAIOABABDgEkAwQBDQAoDQIOKgwODyoOCA8qDg0MKg0DDgAoDgIOKg4OAyoNDQMAKAMCAyoOAw0qDAkBIACOCjgBCQMhAgFGAAMgAJEqDQoDKg0LDgA4DgUPDjgODxAhAgCXABA5AQAAKg4DCioODwsqDQwKKg0DCwIoCwILKg4LAyoNDQsCKAsCCyoOCw0AKAoCDAA4DAkNKg0NCyoNAwoCKAoCCioOCgMqCAEDAAABAgEqDgQDKggBCgAAAQIBKg4ICioIAQwAAAECASQCAA8NKg4NDB4CCgANCjgNAg4hAgC0AA45AQAAJAIEEhEqCAASKgwDEyoMChQqDAwVKgwCFioMBhcqDAsYABAAEQAiAcsqBAAAKgwTDSoMFA4qDBUPKgwWECoIAQIkAgQDAwAQAQMBJAMEAQIAKAICAyoMAwYqDggGACgGAgYqDggGKg0CAwAoAwIDKg4DAioIAQMAAAECASoOAgMqDAkBIADUDDgBBwIhAgEwAAIgANcqDQMBACgBAgMAOAMJBioNBgIAKAECBgA4BgUHKg0HAyoIAQEkAgQDBQAQAQUBJAMEAQEAKAECBSoMBQYqDgIGACgGAgYqDgMGACgBAgU4AwAFAAIgAOokAgJ0ASQCAmUCJAICdwMkAgJuBSQCAnIGJAICbAckAgIgCCQCAmsKJAIBAQsqCAEMJAIEEQ0AEAENASQDBAEMACgMAg0qDA0OJAICVQ8qDg8OACgOAg4qDgUOACgOAg4qDgoOACgOAg4qDgUOACgOAg4kAgJvECoOEA4AKA4CDioOAw4AKA4CDioOBQ4AKA4CDioOCA4AKA4CDiQCAnMRKg4RDgAoDgIOKg4CDgAoDgIOKg4HDgAoDgIOKg4CDgAoDgIOJAICYxIqDhIOACgOAg4qDgEOACgOAg4qDhAOACgOAg4qDgYOCjgECw0hAgEvAA0qCAEOJAIEEhMAEAETASoMDhMnAwXG8730236AAAATACgTAhMAKAwCFCQCBBAVKwQAFIADKwQAE4AEKwQAFYAFIgJSJAIEEBQAOBMUEyoOCRMAKBMCEzkDDhIjKg0DAhwMAAEGADgQBggsDAAIAAYkAgQCCgw4AQoLIQIBOAALOQEAACsEAAKAAyUABAADgAQiAl0rCIAFAAgAKAgCCgA4CgELKg4GCwA4AQUCDjgBAgYhAgFDAAY5AQAAKg4IAyoMAgEgANQqDQwDKg0KDioNCw8AOA8BEA44DxARIQIBTQAROQEAACQCBAERDDgQERIhAgFRABI5AQAAACgOAhEAOBEQEioNEg8kAgQBEAw4ARARIQIBWAAROQEAACsEAAOAAyUABAACgAQiAl0rCIAFAA4AKA4CEAA4EAERKg4PEQA4AQUDDjgBAw8hAgFjAA85AQAAKg4ODCoMAwEgAI4cDAADCwA4EgsMKggBCyQCBAMOABABDgEkAwQBCwAoCwIOKgwODyoOCg8AKA8CDyoODQ8kAgQCDww4Aw8QIQIBdQAQOQEAAAAoCwIPADgPAxAqDRAOLQwADgAMADgDBQsOOAMLDCECAX0ADDkBAAAqDAsDIABcJQAEeACABA0AAACABIADIQABg4ADOQEAACMiAX8qCAEFAAABAgEkAgAABioIAQckAgQCCAAQAQgBJAMEAQcAKAcCCCoMCAkqDgYJKg4HBSoNBwgAKAgCCCoOCAckAgQBCCQCBAAJKgwJBCABlwo4BAkDIQIBqwADIAGaKg0BAyoNAgQAOAQICg44BAoLIQIBoAALOQEAACoOAwEqDgoCKg0FASoNBwICKAICAioOAgcAKAECAwA4AwkEKg0EAioMAgEjKg0FAyoNAQoqDQILADgLBAwOOAsMDSECAbIADTkBAAAkAgQCDQw4DA0OIQIBtgAOOQEAAAAoCgINADgNDA4qDQ4LJAIEAQwMOAQMDSECAb0ADTkBAAArBAADgAMlAAQAAoAEIgJdKwiABQAKACgKAgwAOAwEDSoOCw0AOAQIAw44BAMLIQIByAALOQEAACoOCgUqDAMEIAGXIgF/JAIAAAgqCAEJJAIEBAoAEAEKASQDBAEJACgJAgoqDAoLKg4ICwAoCwILKg4ICwAoCwILKg4ICyoNCQoAKAoCCioOCgkqDQkKACgKAgoqDgoJKg0JCgAoCgIKKg4KCSoNCQoAKAoCCioOCgkqCAEKAAABAgEqDgkKKggBCSQCBAULABABCwEkAwQBCQAoCQILKgwLDCoOCAwAKAwCDCoOCAwAKAwCDCoOCAwAKAwCDCgCAAAAAAAAAAACAAAAAAAAAAAADSoODQwqDQkLACgLAgsqDgsJKggBCwAAAQIBKg4JCyoIAQkAAAECASQCBAAMKg4MCSoIAQ0AAAECASQCAQAOKg4ODSQCBAIPJAIEARAqDAwHIAIHDDgHDwUhAgIuAAUgAgoqDQ0ECjgEDgUhAgIOAAU5AQAAJAIEDwQqCAAPKgwKECoMCxEqDAkSKgwNEwAQAAQAIgJyKgQAACoNCgQqDQsFKg0JBioOBAoqDgULKg4GCSQCAQEGKg4GDQAoBQIHADgHDAkqDQkGKg0EBwIoBwIHKg4HBCoNBQQCKAQCBCoOBAUKOAYIBAo4BA4FIQICLAAFOQEAACoMBgQjDDgHDwUhAgIxAAUgAkwqCAEFJAIEAxEAEAERASQDBAEFACgFAhEqDBESKg4EEgAoEgISKg4GEiQCBAISDDgHEhMhAgI+ABM5AQAAACgFAhIAOBIHEyoNExEkAgQSBSoIABIqDAoTKgwLFCoMCRUqDA0WKgwRFwAQAAUAIgK/KgQAACACTAA4BxAFDjgHBREhAgJQABE5AQAAKgwFByACByUABAAAgAcNAIAHgAWACBcAgAiACCEAAlyACAEAgAOAB4AJKwGACYAGAQCABIAHgAkrAoAGgAkBAIAHAAKAByACUyMrAYADgAYLAIAGAAKAByEAAmGAByACYysAgAOABSACcSsAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQACb4AKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIAJmJQEEAAGABSACcSMiAX8kAgQDBiQCBAEHJAIEAAgqDAgFIAJ4DDgFBgghAgKQAAggAnsqDQEFKg0DBioNBAcqDQIIJAIEBAkqCAEKJAIEBQsAEAELASQDBAEKACgIAgskAgQEDAAoCgINPA8ACwANKg0KCAAoCAIIKg4ICioOBQEqDgoCKg4GAyoOBwQjKg0DCAw4BQgJIQIClAAJIAK5Kg0BCCoNAgkqDQMKKg0ECyoNAgwkAgQEDgw4BQ4PIQICnQAPOQEAAAAoDAIOADgOBQ8qDQ8NKg0BDCQCBAMPDDgFDxAhAgKlABA5AQAAACgMAg8AOA8FECoNEA4AOA0ODCQCBAQODDgFDg8hAgKtAA85AQAAKwQACYADJQAEAAWABCICXSsIgAUADQAoDQIOADgOBQ8qDgwPKg4IASoODQIqDgoDKg4LBCACuQA4BQcIDjgFCAkhAgK9AAk5AQAAKgwIBSACeCIBfyoNBAYkAgEABwo4BgcIIQICxQAIOQEAACoNAwYkAgQDBwo4BgcIJAIEAQYhAgLsAAggAssqDQEHKg0CCCoNAwkqDQQKKg0DCyQCBAMNDDgLDQ4hAgLUAA45AQAAKwQAB4ADJQAEAASABCICXSsIgAUADAAoDAINADgNCw4qDgUOKg4MASoOCAIqDgkDKg4KBCoNAQUqDQIHKg0ECCoNAwkAOAkGCg44CQoLIQIC5wALOQEAACoOBQEqDgcCKg4KAyoOCAQgAw0kAgQIByoIAAgqDAEJKgwCCioMAwsqDAQMABAABwAiAnIqBAAAKg0BByoNAggqDQMJKg0ECiQCBAALKwQAB4ADJQAEAASABCICXSsIgAUADAAoDAINADgNCw4qDgUOKg4MASoOCAIqDgkDKg4KBCoNAQUqDQIHKg0ECCoOBQEqDgcCKg4GAyoOCAQgAw0jKwAYyhjK","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"573":"Array index out of bounds","311":"Array index out of bounds","84":"call to assert_max_bit_size","343":"Array index out of bounds","372":"Array index out of bounds","433":"attempt to add with overflow","555":"Storage slot 0 not allowed. Storage slots must start from 1.","386":"Stack too deep","415":"attempt to add with overflow","322":"attempt to add with overflow","354":"attempt to add with overflow","380":"attempt to add with overflow","150":"attempt to add with overflow","336":"Array index out of bounds","179":"Function get_price can only be called statically","444":"Array index out of bounds","455":"attempt to add with overflow","668":"Array index out of bounds","676":"Array index out of bounds","700":"attempt to add with overflow","723":"Array index out of bounds","437":"Array index out of bounds","591":"attempt to add with overflow","332":"attempt to add with overflow","684":"Array index out of bounds","742":"attempt to add with overflow"}},{"name":"get_price","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"asset_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"price","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"asset::Asset"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3hTtw6EIXfZX/zw/aMPU5f5eqqoi2tVkJQFXqlq6rvfgMl2SWTjcUxuorl+VOxxQcOX2bHZ6Ik++vw5ebTz28fj3df7x8OH/76dbi9/3z9eLy/G1/9+n11+PTjeHt7/Pbx/L8P7ukfH57XP3y/vnt6+fB4/ePx8MGnwV0dbu6+jF+Kc+NP+Hq8vTl8YJ9/X6nVMfDwsjqGFOfVPseV1cJuWi1M4dXqv68Ont5q6EnEiCgiooSIZE0kzk8cnrBuIh5oYjbk4YQsDCtrfUwva4M74SW/djC8cxwn584NdFof1tbTMHk+P3TEK0sDOZ58UCgsTjR5TiTnS5/oZaNXQW8weji94IxeBT1v9CroBaNXQY+MXgU9NnoV9KLRq6CXjF4FPZs1aujZrFFDz2aNCnpks0YNPZs1aujZrFGiJ9MZviR+Sc9mjRp6bPQq6NmsUUPPZo0aejZr1NCzWSMskdgAsUTCNhUoJBb1FRLL7wqJhXKFhA3JEonFZ4XEMrFCYkFXIbH0qpBYel0iiZZeFRJLrwqJpVeFxNKrQsKGZInE0qtCYulVIbH0qpBYelVILL0ukSRLrwqJpVeFxNKrQmLpVSFhQ7JEYulVIbH0qpBYelVILL0qJJZel0jE0qtCYulVIelzx+ETkhiXSLrsJTlMnkNmgheP/HKXject/LwITTZkWF4YmLvsUu/Ir8uB/B35dTm9v4lfzpNpP7jl/pHZ+FXx6/K8wDvy6zLSvSO/Ls84vCO/Lk9PvCM/mz+q+A02f9Txs/mjjp/NH3X8bP6o48fGr4qfzR91/Gz+qONn80cdP5s/6vjZ/FHFb3RmAAuLXQizadIAbQKpBGgjSCVAm0EqAbIBrANoU0glQBtDKgHaHFIJ0AaRSoDVk8jYBaYrvbwPvoCQwnRZBFHpU2+STC5SPrnw5J+de9esc9+s89Cs81LaJCo6zyfnbnj1G/TqmHh628WUTj97/RObImWZVtO5+5dPbPLctPvYtPvUtHtp2n1u2v3QsvviBzPt271v2n1o2n3Te23xg3n27b7pvTY0vdeGpvda2ne/Zz/97PHLqN3vu+cwudk9Je3+f+85Ya6FJLngntN8akLOp7Dhj/fYsPfUsHfZtXeZTpVxjtp7btj70K533nmX3O7xzPt2n+bjxCLa/b6TGcew6X7fyYzns/ij+9J7ZHBhcjK4uPK37jvHFbIE7/ucScn9vs+ZFNzHnWfogvt9nzMpud/3OZOS+6bnl+KDY/ftfuc7c8H93nfmbfdN77Wx6b02Nr3Xpqb32tT0Xpua3ms7fSri/ECSQPnVRUPPTLq8kIr97IMDKyZd3qWxzaTPR94VmHR5L0WBSZe3RxSYdHnHQ4EJGxPFpMt8UmDS5a0GBSZd3j1QYGI5VjOxHKuY9PkE1QITy7GaieVYzcRyrGbCXTJx871l5xdsTEz6zLHbTPrMsdtM+syx20z6zLHbTPrMsZtM+nwSZ4FJnzl2m0mfOXabSZ85dpuJZTbNxDKbZmKZTTOxzLZkEtafGJF5+jtzJCVZbUHezReoe5f070mISBBRRkSr0dX7+UEu3p9dtv4iWr8DuyTyiCggIkJEjIgiIkqISBBRRkRIRRBSEYRUBCEVQUhFEFIR6zfubbYVuvBmn+858o6UiB0i8ogoICJCRIyIkKbMSFNmpCkz0pTX7zUpiKJDRB4RBUR0oSLS/G5yOSgRI6KIiBIiEkSUEdEAiFK5IlZESEUkpCISISJGREiPSEiPSEiPSEiPSEiPEKRHCFIRglSEIBUhSEUIUhGCHFxBDq4gBzcDB5cckGBp/fGqftz1J9HYRpRIEFFGRAMgWn9qY0m0/tYYy2sWDYre+uRZEq0jj366oWD8UtsTRJQR0QCILoyRBdE68kTzcUrJKVFARISIGBFFRJQQkSCijIgGQHRhjCyIkIogpCIIqQhCKoKQiiCkIgipCEIqgpCKuDDnpjxvauKCEnlEFBARISJGRBERJUQkiGj94PL8jGfPrHr5hZG1IPKIKCAiQkSMiCIiSohIEFFGREhFJKQiElIRF0ZWjjKLRHWjCyNrQcSIKCKihIgEEWVENACiCyNrQeQREVIRglSEIBUhSEUIUhGCjA2CjA2CjA35zWPD7/HVP9c/jtefbm8eRs3TN3/efX483t+9vHz89/uf74yL/wM=","brillig_names":["get_price"],"assert_messages":{"16":"Function get_price can only be called statically","112":"Storage slot 0 not allowed. Storage slots must start from 1.","256":"Array index out of bounds","343":"attempt to add with overflow","180":"Array index out of bounds","161":"attempt to add with overflow","324":"Array index out of bounds","248":"Array index out of bounds","264":"Array index out of bounds","280":"attempt to add with overflow","204":"Stack too deep","150":"Array index out of bounds","198":"attempt to add with overflow"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnNaoNAFEDhd5m1Cydx7o+vUkrQRIMgGtQUivjuNW0ogazPRrjjnbP7VrOGS1Pfr6duaMc5lB9r6MdztXTjsE/rloV66vq+u55ej0P++BTF7/58q4bHOC/VtISykCw0wyWUKe63265v9rNoW/a2qYfnpur/ZvLtMwtFwsqClRUrG1Z2qpxyrByx8gErH7EyZjBhBhNmMGEGE2YwYQYFMyiYQcEMCmZQMIOCGRTMoGAGBTMomEHFDCpmUDGDihlUzKBiBhUzqJhBxQwqZtAwg4YZNMygYQYNM2iYQcMMGmbQMIOGGXTMoGMGHTPomEHHDDpm0DGDjhl0zKBjBmOec+nIpQ9c+silCy6duLRwaeXSxqU5jZHTGDmNEdK47dNXNXVV3TfPl4f2PpxfHiKW79vfn335Bw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"set_price","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"asset_id","type":{"kind":"field"},"visibility":"private"},{"name":"price","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3bbts8EITfxde54JLLU17lx48iadPCQOAUSVqgCPruVQ5SXC0tIkMXkMC9KeKGY40/rchZWVKedl9urn98+7Q/fL172F3+97S7vft89bi/Owyvnn5f7K7v97e3+2+fjv97Z57/IXoZ//D96vD88uHx6v5xd+ktXexuDl+Gn1wa9F/3tze7S6bhZzE2u/w2Nqc8jSWbC2PJh7ex1thprCNfGmsM+7fRw8/ZvY+3pfEuj57ZHb03F4ZaZ3j04WxlcHCj5+Di8dD/L3ZklV4DPaf0Guix0mug55VeA72g9BroRaXXQC8pvQZ6Wenh9KxReg30tNdooae9Rgs97TVa6LHSa6CnvUYLPe01avSiGelFmtPTXqOFnvYaLfS012ig57TXaKGnvUYLPe017ByJNhACCSuSORKN+gKJ5neBREO5QKJJWyDR+DxHwpqJBRINugKJpleBRNOrQMKKZI5E06tAoulVINH0KpBoehVINL3OkXhNrwKJpleBRNOrQKLpVSBhRTJHoulVINH0KpBoehVINL0KJJpe50iCpleBRNOrQKLpVSDR9CqQsCKZI9H0OkcS+5xe+R2J93MkXR44yY6ebWIHD37m1+VR9hF+FKMbbcQ8vzAwdtlQnpFfl93nGfl12ap+iF9Ko2nKRqwfXfa15+OXumyCz8ivy0h3Rn5dttdn5NdlL35Gfqz8mvhp/9HGT/uPNn7af7Tx0/6jjZ/2H038svYfbfy0/2jjp/1HGz/tP9r4sfJr4qf9R+37I2PtZNoJftp/tPHT/qONn/Yfbfy0/2jiNzhTgG0AtQNpBKgtSCNA7UEaAXIrQDJhvMiLyFIFobPjFRHOmco7hzi6COndBTl6de436zxs1nncrPNy2EzjIRqo9v7MfjyQmOP7UReKg0Mcxx4d+Ta8esnr8UJmRV5oRV7siry4Zi/eTKuLN/nYy8sG+F9vwLdvwKVpA8xiA+EMG5h2gfdObCD+4w2c+HMMfvzUPuTa1GrDOHiYTfmvKbAwXRoz2gnGHiWfVEonPuYxcvhkzF+jX9zzqt2n6Tr0YY+xdO/X7d7mRfdh3e6n0OxT8NJ93LT7tGn3ecvu3bpnzJp72rR7u2n3btPuV77WVtyvfK2tuN/0Wus2vda6Ta+1btNrLW96reVNr7W88rWW/Lv7UBmdh7V3PN1OUfYyvPKV+fRnfXG/8pW54n7lK3PF/cpX5or7Pp/RM90ea12a395OfT48kGnywZYFky6/76wwYWUimHR5bWSFSZfXO1aYdHkNY4VJl9clVph0mU+WmfT5EMEKky6vCKww0RwrmWiOlUxYmQgmmmMlE82xkonmWMmkzxxrpsudmcTlzqHPHLvIJPaZY5eZ9Jljl5n0mWOXmfSZY5eZsDIRTPrMsctM+syxy0z6zLHLTDSzCSZ9Pru1wkQzm2SimU0wKT/3JPH4OZMXlyKUH7VAZrrDi0yYb8eWHy9QExEisoioGF2JpptNiGISIkZEHhEFRBQRUUJEGRCVb7asiQgRWUSEVAQhFUFIRRBSEYRUBCEVUb6Bb2lasfbEwU7TLdLGSREjIo+IAiKKiCghImRSdsik7JBJ2SGTcvnOlJqIEZFHRAERnaiIMB1NJlkhSogoAyI2iIgQkUVEDhHVK6IgQiqCkYrgiIgSIkLmCI/MER6ZIzwyR3hkjvDIHOGRivBIRXikIjxSER6piIDs3IDs3IDs3IDs3ICEnPL3ZzTMUqNoYDUXlb9gqokIEVlE5BBRGbmNU09rs6BXPgtcE5WRezKjyJOwVz4/VBMRIrKIyCGiMvIw3VFEIRgh8ogoIKKIiBIiyoCo/LT1mogQkUVEDhEhFZGRishIRWSkIjJSERmoCGcMIiJEZBHRiYpI06IWjRUiRkQeEQVEFBFRQkQZEJ04P1URlXcuT48dJGYSIoeIGBF5RBQQUURECRFlQFQ+P1UTESJCKsIiFWGRijhxLox9nERRzEYnzoVVRBERJUSUAdGJc2EVESEii4gcImJEhFSEQyrCIRXhkIpwSEUw0DY4JkRkEdGH24bfw6ufV/f7q+vbm4dB8/zLH4fPj/u7w9vLx1/fX38zDP4D","brillig_names":["set_price"],"assert_messages":{"112":"call to assert_max_bit_size","240":"Array index out of bounds","138":"Array index out of bounds","164":"Array index out of bounds","107":"Storage slot 0 not allowed. Storage slots must start from 1.","232":"Array index out of bounds","248":"Array index out of bounds","146":"attempt to add with overflow","264":"attempt to add with overflow","188":"Stack too deep","287":"Array index out of bounds","182":"attempt to add with overflow","306":"attempt to add with overflow"}}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"PriceFeed"}},{"name":"fields","value":{"fields":[{"name":"assets","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"asset_id","type":{"kind":"field"}}],"kind":"struct","path":"PriceFeed::get_price_parameters"}},{"name":"return_type","type":{"fields":[{"name":"price","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"asset::Asset"}}],"kind":"struct","path":"PriceFeed::get_price_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"asset_id","type":{"kind":"field"}},{"name":"price","type":{"kind":"field"}}],"kind":"struct","path":"PriceFeed::set_price_parameters"}}],"kind":"struct","path":"PriceFeed::set_price_abi"}]}},"file_map":{"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"418":{"path":"/usr/src/noir-projects/noir-contracts/contracts/price_feed_contract/src/main.nr","source":"mod asset;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract PriceFeed {\n    use dep::aztec::prelude::{Map, PublicMutable};\n    use crate::asset::Asset;\n\n    use dep::aztec::macros::{storage::storage, functions::{public, view}};\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        assets: Map<Field, PublicMutable<Asset, Context>, Context>,\n    }\n\n    #[public]\n    fn set_price(asset_id: Field, price: Field) {\n        let asset = storage.assets.at(asset_id);\n        asset.write(Asset { price: U128::from_integer(price) });\n    }\n\n    #[public]\n    #[view]\n    fn get_price(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n}\n"},"419":{"path":"/usr/src/noir-projects/noir-contracts/contracts/price_feed_contract/src/asset.nr","source":"use dep::aztec::protocol_types::traits::{Serialize, Deserialize};\n\npub struct Asset {\n    price: U128,\n}\n\nglobal ASSET_SERIALIZED_LEN: u32 = 2;\n\nimpl Serialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn serialize(asset: Asset) -> [Field; ASSET_SERIALIZED_LEN] {\n        [asset.price.lo, asset.price.hi]\n    }\n}\n\nimpl Deserialize<ASSET_SERIALIZED_LEN> for Asset {\n    fn deserialize(fields: [Field; ASSET_SERIALIZED_LEN]) -> Asset {\n        let price = U128 { lo: fields[0], hi: fields[1] };\n        Asset { price }\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"}}}
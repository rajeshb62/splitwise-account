{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"EcdsaRAccount","functions":[{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","noinitcheck","view"],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","build_msg_block","attach_len_to_msg_block","pack_returns_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":5,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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Pe+0F5y2wmkrnfai015y2iqnrXbay057xWlrnLbWaa867TWnve60dU57w2lvOm290zY47S2nve20jU7b5LR3nPau0zY7bYvT3nPa+077wGlbnfah0z5y2janbXfax077xGk7nLbTaZ867TOnfe60XU77wmlfOu0rp+122tdO+8Zp3zptj9O+c9r3TtvrtH1O+8FpPzptv9MOOO0np/3stF+cdtBpvzrtN6cdctphp/3utD+c9qfTjjjtL6f97bSjTnMPwMQ5LYfT4p2W02m5nJbbaXmcltdp+ZyW32kFnFbQaYWcVthpRZxW1GnFnFbcaSWcluC0kk4r5bTSTivjtLJOO8Vp5ZxW3mkVnFbRaZWcFnVaZadVcVpVp1Vz2qlOq+60Gk6r6bTTnHa602o5rbbTznDamU6r47REpxmn1XVaPaclOa2+0xo4raHTGjmtsdPOctrZTmvitHOcdq7TmrqfBXPaeU4732nNndbCaRc47UKntXRaK6dd5LSLndbaaW2cdonT2jqtndPaO62D0y51WkendXLaZU673GmdndbFaV2ddoXTujmtu9N6OO1Kp/V0Wi+n9XZaH6f1dVo/pyU7rb/TBjhtoNMGOe0qpw122hCnDXXaMKcNd9oIp13ttJFOG+W0FKeNdtoYp4112jinjXfaNU6b4LSJTrvWadc5bZLTJjvteqfd4LQpTpvqtBuddpPTpjltutNudtotTpvhtJlOu9VptzntdqfNctodTrvTaXc5bbbT7nbaPU6b47S5TrvXafc5bZ7T5jvtfqc94LQFTlvotAed9pDTHnbaIqc94rRHneZ+B737Peru94q737vsfnew+92q7vdFut956H4HoPsdae73fLnfe+V+p5T7fU3udyG53zPkfoeP+/047nfPuN/r4n5nivt9JO53fbjffeF+r8Rap7nfYeB+P4D77H33ufbuM+Pd57G7zzp3nyPuPqPbff61+2xp97nN7jOR3ecNu8/ydZ+T6z6D1n2+q/vsVPe5pO4zP93nabrPqnSfA+k+Y9F9fqH7bED3uXvuM+3c58W5z2Lb5TT3GWLu87ncZ1+5z5Vyn9nkPg/JfdaQ+xwf9xk57vNn3Ge7uM9NcZ9J4j7vw32WhvucCvcZEO7zFdxnF7jPBXBjl/t5dvez4u7nsN3POLufH3Y/m+t+7tX9TKn7eU33s5BuYHc/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","debug_symbols":"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GqPYaYxipzGKncYodhqj2GmMYqcxip3GKHYao9hpjGKnMYqdxih2GqPYaYxipzGKncYodhqj2GmMYqcxip3GKHYao9hpjGKnMYqdxih2GqPYaYxipzGKncYodhqj2GmMYqcxip3GKHYao9hpjGKnMYqdxih2GqPYaYxipzGKncYodhqj2GmMYqcxip3GKHYao9hpjGKnMYqdxih2GqPYaYxipzGKncYodhqj2GmMYqcxip3GKHYao9hpjGKnMYqdxih2GqPYaYxipzGKncYodhqj2GmMYqcxip3GKHYao9hpjGKnMYqdxih2GqPYaYxipzGKncYodhqj2GmMYqcxip3GKHYao9hpjGKnMYqdxih2GqPYaYxipzGKncYodhqj2GmMYqcxip3GKA4aozhojOKgMYqDxiiOBabUg8YoDhqjOGiM4qAxioPGKA4aozhojOKgMYqDxigOGqM4aIzioDGKg8YoDhqjOGiM4qAxioPGKA4aozhojOKgMYqDxigOGqM4aIzioDGKg8YoDhqjOGiM4qAxioPGKA4aozhojOKgMYqDxigOGqM4aIzioDGKg8YoDhqjOGiM4qAxioPGKA4aozhojOKgMYqDxigOGqM4aIzioDGKg8YoDhqjOGiM4qAxioPGKA4aozhojOKgMYqDxigOGqM4aIzioDGKg8YoDhqjOGiM4qAxioPGKA4aozhojOKgMYqDxigOGqM4aIzioDGKg8YoDhqjOGiM4qAxioPGKA4aozhojOKgMYqDxigOGqM4aIzioDGKg8YoDhqjOGiM4qAxioPGKA4aozhojOKgMYqDxigOGqM4YIxiLjBGcS2IpdRrQSylXgtiKfVaEEup14JYSr0WxFLqtSCWUq8FsZR6LYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLYim1DBGcS2IptQwRnEtiKbUMEZxLQim1EJjFIXGKAqNURQaoygLTKmFxigKjVEUGqMoNEZRaIyi0BhFoTGKQmMUhcYoCo1RFBqjKDRGUWiMotAYRaExikJjFIXGKAqNURQaoyg0RlFojKLQGEWhMYpCYxSFxigKjVEUGqMoNEZRaIyi0BhFoTGKQmMUhcYoCo1RFBqjKDRGUWiMotAYRaExikJjFIXGKAqNURQaoyg0RlFojKLQGEWhMYpCYxSFxigKjVEUGqMoNEZRaIyi0BhFoTGKQmMUhcYoCo1RFBqjKDRGUWiMotAYRaExikJjFIXGKAqNURQaoyg0RlFojKLQGEWhMYpCYxSFxigKjVEUGqMoNEZRaIyi0BhFoTGKQmMUhcYoCo1RFBqjKDRGUWiMotAYRaExikJjFIXGKAqNURQaoyg0RlFojKLQGEWhMYpKYxSVxigqjVFUGqOoC0yplcYoKo1RVBqjqDRGUWmMoh7OKK5C83Hobp8LulV9ZlzL70tcN18XlDe2b2PR35u3IR9b5+9mpVKzWqlZq9SsV2o2KjXbKjWblZrtlZodhZpVtoPqYXI9dHjfaHY9UePS7frvLn/Z/lfDbBf1hIbZTuoJDbPd1BMa9moNs13VExrew1ml+qWq9LGx8O6iH9P5tPH4XVDSCuq0gsbRBWV+bDzsS0G7sOe7FiS0gpRWkNEKclpBQSuo0QpKWkFHK/W6xrneXvXT3Xgt6MaRYz3JL4cOHcvXm7GNyRvwZfYGZPYGaHcap91pdmHndy0o2Oecf9jRaIvfOOfa7A3k7A3scedr7bpsTdlatq5KdDl0xLJxaO153XosH7MRu7W1Rb9M0pp82lr8xtbD8rIkHtZ3WBHvEkNwzvLPWe6SoHDO8tcs5ZzlbrPUc5a7zdLOWe42S5/ciMTsXjZm97Ixu5cN+FOc7QbgT3E2G2gL7BePJrSClFaQ0QpyWkFBK4j2y2uj/fLaaL+8tgErKGlKnTSlTppSJ02pk6bUSVPqpCl10pQ6aUqdNKXuNKXuNKXuNKXuNKXuNKXuNKXuNKXuNKXuNKXuNKUeNKUeNKUeNKUeNKUeNKUeNKUeNKUeNKUeNKUeMKW2BabUtsCU2haYUtsCU2pbYEptC0ypbYEptS0wpbYFptS20JRaaEotNKUWmlILTamFptRCU2qhKbXQlFpoSi00pVaaUitNqZWm1EpTaqUptdKUmkbdG426Nxp1b0pTaqMptdGU2mhKbTSlNppSG02pjabURlNqoym10ZTaaUrtNKV2mlI7TamdptROU2qnKbXTlNppSu00pQ6aUgdNqYOm1EFT6qApddCUOmhKHTSlDppSB02paYyi0RhFa2+Vzhspl2zqWE/Hv2z9q923yubdbtdrtftWubzb7bLfd7B7u+w3HuzeLuztS9Zgb1+yhL0nzxL2njxLpRUEe0+e7cK17loQ7D15lo1WEOw9eZY0pU6aUneaUneaUneaUneaUneaUneaUneaUneaUneaUneaUg+aUg+aUg+aUg+aUg+aUg+aUg+aUg+aUg+aUg+YUvsCU2pfYErtC0ypfYEptS8wpfYFptS+wJTaF5hS+wJTal9oSi00pRaaUgtNqYWm1EJTaqEptdCUWmhKLTSlFppSK02plabUSlNqpSm10pRaaUqtNKVWmlIrTamVptRGU2qjKbXRlNpoSm00pTaaUhtNqY2m1EZTaqMptdOU2mlK7TSldppSO02pnabUTlNqpym105TaaUodNKUOmlIHTamDptRBU+qgKXXQlDpoSh00pQ6aUjeaUjeaUjeaUjeaUjeaUjeaUjeaUjeaUtMYRacxik5jFJ3GKDqNUXQao+g0RtFpjKLTGEWnMYpOYxSdxig6jVF0GqPoNEbRaYyi0xhFpzGKTmMUncYoOo1RdBqj6DRG0WmMotMYRacxik5jFJ3GKDqNUXQao+g0RtFpjGLQGMWgMYpBYxSDxijGAlPqoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxiozGKjcYoNhqj2GiMYltgSt1ojGKjMYqNxig2GqPYaIxiozGKjcYoNhqj2GiMYqMxio3GKDYao9hojGKjMYqNxig2GqPYaIxiozGKjcYoNhqj2GiMYqMxio3GKDYao9hojGKjMYqNxig2GqPYaIxiozGKjcYoNhqj2GiMYqMxio3GKDYao9hojGKjMYqNxig2GqPYaIxiozGKjcYoNhqj2GiMYqMxio3GKDYao9hojGKjMYqNxig2GqPYaIxiozGKjcYoNhqj2GiMYqMxio3GKDYao9hojGKjMYqNxig2GqPYaIxiozGKjcYoNhqj2GiMYqMxio3GKDYao9hojGKjMYqNxig2GqPYaIxiozGKjcYoNhqj2GiMYqMxio3GKDYao9hojGKjMYqNxig2GqPYaIxiozGKjcYoNhqj2GiMYqMxio3GKCaNUUwao5g0RjFpjGIuMKVOGqOYNEYxaYxi0hjFpDGKSWMUk8YoJo1RTBqjmDRGMWmMYtIYxaQxikljFJPGKCaNUUwao5g0RjFpjGLSGMWkMYpJYxSTxigmjVFMGqOYNEYxaYxi0hjFpDGKSWMUk8YoJo1RTBqjmDRGMWmMYtIYxaQxikljFJPGKCaNUUwao5g0RjFpjGLSGMWkMYpJYxSTxigmjVFMGqOYNEYxaYxi0hjFpDGKSWMUk8YoJo1RTBqjmDRGMWmMYtIYxaQxikljFJPGKObhjKIu9nHobp8LulX9Kt3X8vsS182l3zp4G4v+3rwN+dg6fzc7CjV7OFv50malUrNaqVmr1Czojv51Y1vs0qstsVw3NtHf5YPu/4+UD3ILj5Sf6Culh8n10OF940rRdaPLpbL+u8tftv/VMNu7PKFhtn/Zv+HO9jBPaBjuY8T9KlimcaOB9/ImXa63667jb2/X/b28yUazXqnZqNRsq9Qs2yX9uNlm12b7l/VEf6+nOxvNvtfTnfvNjvd6urPR7Hs93dlo9s0c1P1m38xB3W/WKzX7Zg7qfrNv5qDuN1vJQY1KDmoUclB9KeSg+lLIQfWlkIPqSyEH1Rev1GwhB9WXQg6qL4UcVF8KOai+VHJQUslBSSUHJZUclFRyUIenEL202UoOSio5KKnkoKSSg5JKDkorOSit5KC0koPSSg7q8HSwlzZbyUFpJQellRyUVnJQWslBWSUHZZUclFVyUFbJQR2e2vfSZis5KKvkoKySg7JKDsoqOSiv5KC8koPySg7KKzmow9M0X9psJQfllRyUV3JQXslBeSUHFZUcVFRyUFHJQUUlB3V4yu1Lm63koKKSg4pKDioqOaio5KBaJQfVKjmoVslBtUoO6vD06Zc2W8lBtUoOqlVyUG+W9r3RbCUH9WZp3xvNVnJQb5b2vdFsJQd1eNr3S5ut5KCykoOC547v3GwlBwXPG9+3WXjW+M7NVnJQ75ZJfr/ZSg7q3TLJ7zdbyUG9Wyb5/WYrOahKmeS9UiZ5r5RJ3itlkvdKmeS9UiZ5r5RJ3itlkvdKmeS9UiZ5r5RJ3itlko9KmeSjUib5qJRJPiplko/FKzVbyEGNSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnko1Im+aiUST4qZZKPSpnk4/hMcvPlcmjrbaPZcNHLoaMt/pdm/2zg+JzxvRsQdgPNPzXQxo0GdPYGbPYGfPYGAt1AC7keuoX3Tcm9XvOt6/hbyT0+i/uVzWalZnulZtnOYd9mB9tl/LjZu55wsB3Jzs2y3cvOzbKdzs7NeqVm38xB3W/2zRzU/WbfzEHdb/bNHNT9Zt/MQd1pti9LHQe1NlvHQa3N1nFQa7N1HNTarFdqto6DWput46DWZus4qLXZOg5qbbaSg5JKDkoqOSip5KCkkoM6Pov7lc1WclBSyUFJJQcllRyUVHJQWslBaSUHpZUclFZyUMdncb+y2UoOSis5KK3koLSSg9JKDsoqOSir5KCskoOySg7q+CzuVzZbyUFZJQdllRyUVXJQVslBeSUH5ZUclFdyUF7JQR2fxf3KZis5KK/koLySg/JKDsorOaio5KCikoOKSg4qKjmo47O4X9lsJQcVlRxUVHJQUclBRSUH1So5qFbJQbVKDqpVclDHZ3G/stlKDqpVclCtkoNqlRxUq+SgspKDykoOKis5qKzkoI7P4n5ls5UcVFZyUFnJQWUlBwXP4t63WXhu987NVnJQ8DzwnZut5KDgOeM7N1vJQb1bJvn9Zis5qHfLJL/fbCUHVSiTfG22koMqlEm+NlvJQRXKJF+breSgCmWSr81WclCFMsnXZgs5KKmUSS6VMsmlUia5LOw36vYwuR56u1ldN7q8imn9d5e/bP+rYa/WMPvNuk9omP123Sc0zH7D7hMaZr9l9wkNj2INH59X/uqGpVrDWq3hak7r8PxyGXHx0X+86fxzw78KClpBjVbQHk4i1S+fkT42Csr82Hh8nKM5fhfUaQUNWEG75FLvWpDQClJaQUYryGkFBa2gRisoYbcOPVqpVZerAdFPfmWd0I0jx/qQ7XLo0LF8tSs6Jm/AltkbkNkb0NkbMJiqHJ4/u1kQbQ1htDWE0e5Mh+ehbha0x52mtWtBKVtPAtYr/3LoiGXj0NrzuvVYPhRI7NbWFv0iKtbk09biN7YelpenDMP6Dg8ZdolEPWf5a5ZyznK3Weo5y91maecsd5uln7PcbZZxznK3WbZzlrvNMs9Z7jbLfs5yt1kO2ELs8DTgzYLgT8Bc9PoAqS3+9SsO+BOw7QZs9gZ89gZi9gba7A3k7A3Af4vabgD+W9RmAw3+W9R2AwKzBoens24WRPut6PCU082CaL8VNdpvRe3wvzfrHxd+t/FZJn4V1GkFDVhBudAKElpBSivIaAU5raCgFdRoBdF+1U/ar/pJU+pOU+pOU+pOU+pOU+rDU9u2rrJO89Sd5qk7Tak7Tak77XeIQVPqQVPqQVPqQVPqXdKhdi2I5qkHzVMP2tOPQXv6MWCeWhfYL8a6wJ5T6wJTal1gSq0LTKl1gSm1LjCl1gWm1LrAlFoXmlILzFOrwDy1CuwXRRXYL4pKS7BQWoKF0hIsVGBPP1RoSi00pVaaUitNqZXmqZXmqY9PsNgqiOapleapleapFfacWhX2nFqNptRGU2qjKbXRlNpoSk1LdFBaooPSEh2UluigRlNqpz2ndppSO02pnabUTlNqp3lqp3lqp3lqpz39cNrTj6B56qD9ohi059RBU+qgKXXQlDpoSh00pQ6aUgdNqRtNqRvNUzeap6YxikpjFJXGKCqNUdRGe/rRaE8/aIyi0hhFpTGKSmMUlcYoKo1RVBqjqDRGUZPmqZPmqZP2nLrTnlPTGEWlMYpKYxS105S605SaxigqjVFUGqOoNEZRB02pB+05NY1RVBqjqDRGUWmMotIYRaUxikpjFJXGKNoCe/phC8xT2wL7RdEW2HNqW2BKbTRG0WiMotEYRaMxikZjFI3GKBqNUTSBeWoTmKc2GqNoNEbRaIyi0RhFE9jTDxPY0w9T2NMPU9jTD1Oap1aap1aaUitNqZWm1LS3bBuNUTQao2hGU2qjKbXRlJr21mmjvXXaaIyi0RhFozGKRmMUjcYoGo1RNKcptdOU2mlK7TSldppSO02pnabUTlNq2nsyjfaeTKMxikZjFC1oSh00pQ6aUgdNqYOm1EFT6qApdaMpNe09ikZ7j6LRGEWjMYpGYxSNxigajVE0GqNojabUSVPqpCl10pQ6aUqdNKVOmlInTalp71E02nsUjcYoGo1RtE5T6k5T6k5Tatp7FI32HkWjMYpGYxSNxigajVE0GqNoNEbRBk2pB02pB02pB02pB02pB02pB02pB0ypnfYeRae9R9FpjKLTGEVfYErtC0ypfYEptS8wpfYFptS+0JRaaEotNKWmvUfRae9RdBqj6DRG0WmMotMYRacxik5jFJ3GKDqNUXQao+g0RtFpjKLTGEWnMYpOYxSdxig6jVF0GqPoNEbRaYyi0xhFpzGKTmMUncYoOo1RdBqj6DRG0WmMotMYRacxik5jFJ3GKDqNUXQao+g0RtFpjKLTGEWnMYpOYxSdxig6jVF0GqPoNEbRaYyi0xhFpzGKTmMUncYoOo1RdBqj6DRG0WmMotMYRacxik5jFJ3GKDqNUXQao+g0RtFpjKLTGEWnMYpOYxSdxig6jVF0GqPoNEbRaYyi0xhFpzGKTmMUncYoOo1RdBqj6DRG0WmMotMYRacxik5jFJ3GKDqNUXQao+g0RtFpjKLTGEWnMYpOYxSDxigGjVEMGqMYNEYxFphSB41RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUg8YoBo1RDBqjGDRGMWiMYtAYxaAxikFjFIPGKAaNUQwaoxg0RjFojGLQGMWgMYpBYxSDxigGjVEMGqMYNEYxaIxi0BjFoDGKQWMUG41RbDRGsdEYxUZjFNsCU+pGYxQbjVFsNEax0RjFRmMUG41RbDRGsdEYxUZjFBuNUWw0RrHRGMVGYxQbjVFsNEax0RjFRmMUG41RbDRGsdEYxUZjFBuNUWw0RrHRGMVGYxQbjVFsNEax0RjFRmMUG41RbDRGsdEYxUZjFBuNUWw0RrHRGMVGYxQbjVFsNEax0RjFRmMUG41RbDRGsdEYxUZjFBuNUWw0RrHRGMVGYxQbjVFsNEax0RjFRmMUG41RbDRGsdEYxUZjFBuNUWw0RrHRGMVGYxQbjVFsNEax0RjFRmMUG41RbDRGsdEYxUZjFBuNUWw0RrHRGMVGYxQbjVFsNEax0RjFRmMUG41RbDRGsdEYxUZjFBuNUWw0RrHRGMVGYxQbjVFsNEax0RjFRmMUG41RbDRGsdEYxUZjFBuNUWw0RjFpjGLSGMWkMYpJYxRzgSl10hjFpDGKSWMUk8YoJo1RTBqjmDRGMWmMYtIYxaQxikljFJPGKCaNUUwao5g0RjFpjGLSGMWkMYpJYxSTxigmjVFMGqOYNEYxaYxi0hjFpDGKSWMUk8YoJo1RTBqjmDRGMWmMYtIYxaQxikljFJPGKCaNUUwao5g0RjFpjGLSGMWkMYpJYxSTxigmjVFMGqOYNEYxaYxi0hjFpDGKSWMUk8YoJo1RTBqjmDRGMWmMYtIYxaQxikljFJPGKCaNUUwao5g0RjFpjGLSGMWkMYpJYxSTxigmjVFMGqOYNEYxaYxi0hjFpDGKSWMUk8YoJo1RTBqjmDRGMWmMYtIYxaQxikljFJPGKCaNUUwao5g0RjFpjGLSGMWkMYpJYxSTxigmjVFMGqOYNEax0xjFTmMUO41R7DRGsS8wpe40RrHTGMVOYxQ7jVHsNEax0xjFTmMUO41R7DRGsdMYxU5jFDuNUew0RrHTGMVOYxQ7jVHsNEax0xjFTmMUO41R7DRGsdMYxU5jFDuNUew0RrHTGMVOYxQ7jVHsNEax0xjFTmMUO41R7DRGsdMYxU5jFDuNUew0RrHTGMVOYxQ7jVHsNEax0xjFTmMUO41R7DRGsdMYxU5jFDuNUew0RrHTGMVOYxQ7jVHsNEax0xjFTmMUO41R7DRGsdMYxU5jFDuNUew0RrHTGMVOYxQ7jVHsNEax0xjFTmMUO41R7DRGsdMYxU5jFDuNUew0RrHTGMVOYxQ7jVHsNEax0xjFTmMUO41R7DRGsdMYxU5jFDuNUew0RrEfzijqYh+H7va5oFtHDpProcP7dXPpNw++bqSXo8uq+n/Z/lfDUq1hrdawVWvYqzUc1Rre406f6peq0sfGbaOLfkzn08bjd0FJK6jTChpHF5T5sfGwvy1o7MK47lqQ0ApSWkFGK8hpBQWtoEYrKGkFHa3Uqsv19qqf7sZrQTeOHGrXQ4eO5cvNeCxj8gZkmb0Bmb0B2p1GaHeaXRjdXQsK9jnnH3Y02uI3zrk2ewM5ewN73Plauy5bU7aWrasSXQ4dsWwcWtdfay9brze5j/rt1tYW/TJJa/Jpa/EbWw/Ly5J4WP/HV8RjF9z5nOWfs9yF1D5n+WuWcs5yt1nqOcvdZmnnLHebpU9uRHR2L6uze1md3csq/CnOdgPwpzibDdjC+sVjmNAKUlpBRivIaQUFrSDYL6/DYL+8DoP98jpswApymlI7TamdptROU2qnKbXTlNppSu00pXaaUjtNqYOm1EFT6qApddCUOmhKHTSlDppSB02pg6bUQVPqRlPqRlPqRlPqRlPqRlPqRlPqRlPqRlPqRlPqRlPqpCl10pQ6aUqdNKVOmlInTamTptRJU+qkKXXSlLrTlLrTlLrTlLrTlLrTlLrTlLrTlLrTlLrTlLrTlHrQlHrQlHrQlHrQlHrQlHrQlJpG3Q8adT9o1P0YLKUey8JS6rUgllKvBbGUei2IpdRrQSylXgtiKfVaEEup14JYSr0WxFLqtSCaUgtNqYWm1EJTaqEptdCUWmhKLTSlFppSC02phabUSlNqpSm10pRaaUqtNKVWmlIrTamVptRKU2qlKTWMUVwLoik17M3Sa0GsHPi1IKcVxMqBXwti5cCvBbFy4NeCWDnwa0GsHPixwN4svRbEemPHWhBNqWFvll4Loik17M3Sa0E0pYa9WXotiKbUsDdLjwX2Zum1IJpSw94svRZEU2rYm6XXgmhKDXuz9FoQTalhb5ZeC6IpNezN0mtBNKWGvVl6LYim1LA3S68F0ZQa9mbptSCaUsPeLL0WRFNq2Jul14JoSg17s/RaEE2pYW+WXguiKTXszdJrQTSlhr1Zei2IptSwN0uvBdGUGvZm6bUgmlLD3iy9FkRTatibpdeCaEoNe7P0WhBNqQdNqQdNqQdNqQdNqQdNqQdNqQdNqQdNqQdNqQdMqWWBKbUsMKWWBabUssCUWhaYUssCU2pZYEotC0ypZYEptSw0pRaaUgtNqYWm1EJTaqEptdCUWmhKLTSlFppSC02plabUSlNqpSm10pRaaUqtNKVWmlIrTamVptRKU2qjKbXRlJrGKAqNURQaoyg0RlFojKLQGEWhMYpCYxSFxigKjVEUGqMoNEZRaIyi0BhFoTGKQmMUhcYoCo1RFBqjKDRGUWiMotAYRaExikJjFIXGKAqNURQaoyg0RlFojKLQGEWhMYpCYxSFxigKjVEUGqMoNEZRaIyi0BhFoTGKQmMUhcYoCo1RFBqjKDRGUWiMotAYRaExikJjFIXGKAqNURQaoyg0RlFojKLQGEWhMYpCYxSFxigKjVEUGqMoNEZRaIyi0BhFoTGKQmMUhcYoCo1RFBqjKDRGUWmMotIYRaUxikpjFHWBKbXSGEWlMYpKYxSVxigqjVFUGqOoNEZRaYyi0hhFpTGKSmMUlcYoKo1RVBqjqDRGUWmMotIYRaUxikpjFJXGKCqNUVQao6g0RlFpjKLSGEWlMYpKYxSVxigqjVFUGqOoNEZRaYyi0hhFpTGKSmMUlcYoKo1RVBqjqDRGUWmMotIYRaUxikpjFJXGKCqNUVQao6g0RlFpjKLSGEWlMYpKYxSVxigqjVFUGqOoNEZRaYyi0hhFpTGKSmMUlcYoKo1RVBqjqDRGUWmMotIYRaUxikpjFJXGKCqNUVQao6g0RlFpjKLSGEWlMYpKYxSVxigqjVFUGqOoNEZRaYyi0hhFpTGKSmMUlcYoKo1RVBqjqDRGUWmMotIYRaUxikpjFJXGKCqNUVQao6g0RtFojKLRGEWjMYpGYxRtgSm10RhFozGKRmMUjcYoGo1RNBqjaDRG0WiMotEYRaMxikZjFI3GKBqNUTQao2g0RtFojKLRGEWjMYpGYxSNxigajVE0GqNoNEbRaIyi0RhFozGKRmMUjcYoGo1RNBqjaDRG0WiMotEYRaMxikZjFI3GKBqNUTQao2g0RtFojKLRGEWjMYpGYxSNxigajVE0GqNoNEbRaIyi0RhFozGKRmMUjcYoGo1RNBqjaDRG0WiMotEYRaMxikZjFI3GKBqNUTQao2g0RtFojKLRGEWjMYpGYxSNxigajVE0GqNoNEbRaIyi0RhFozGKRmMUjcYoGo1RNBqjaDRG0WiMotEYRaMxikZjFI3GKBqNUTQao2g0RtFojKLRGEWjMYpGYxSNxigajVE0GqNoNEbRaYyi0xhFpzGKTmMUfYEptdMYRacxik5jFJ3GKDqNUXQao+g0RtFpjKLTGEWnMYpOYxSdxig6jVF0GqPoNEbRaYyi0xhFpzGKTmMUncYoOo1RdBqj6DRG0WmMotMYRacxik5jFH0XRnHoct16kY2ClhbX8peWH5ubxs1ue7s2sMTH1n5rY9Fx2Viyf974V7dWqlsv1e0ON7B1k7hu7RuXVvRFf28cXcZ1Y+m3tlbpcdl8/XeXv2z/q4M2fQc5fQd9+g7G7B3swau+uAOZvgOdvoOjl3y62Mehu322WreOHCbXQ4f3HRr2Qg2v//Xf/ue//Ou//sv/+b/967//93/+z3/593/7jz/2Xv74P7fXIbk+QP59wFxXlx/Hkz8dxO21wtZO8shO+shO9shO/shO8chO7ZGd8pGd+iM7PXJG+CNnhD9yRvgjZ4Q/ckb4I2eEP3JG+CNnhD9yRvgjZ4Q/ckbEI2dEPHJGxCNnRDxyRsQjZ0Q8ckbEI2dEPHJGxCNnRDxyRrRHzoj2yBnRHjkj2iNnRHvkjGiPnBHtkTOiPXJGtEfOiPbIGZGPnBG3mbAMvzx8yd7yLzv9l/tb968foc//CHv+R/jzPyKe/xHt+R+R//hHeC52WZMt+WlNttiNrW193P57a/vLCm7d+o+COq2gASvoNv/0yoKEVpDSCjJaQU4rKGgFNVpBNKXuNKXuNKUeNKUeNKUeNKUeNKUeNKUeNKUeNKUeNKUeNKUeNKWWhSbVstC0WhaaWMtCU2tZaHItC02vZaEJtiw0xZaFJtmy4DRbcJotOM0WnGYLTrMFp9mC02zBabbgNFt20OxYfd+lolXgvn7GeP5n6HLAZ8jen5FfP0MP+Aw74DN8j8/Ij8/oN76POOAz2vM/I3b5zsflT8hDP/8Ie/mMPWY12uUv6GIM+foZ7YDPyAM+ox/wGduamMtfPuOPvdry0F7y0F760F720F7+0F7x0F7tob3yob36Q3s9dG7kQ+dGPnRu5EPnRj50buRD50Y+dG7kQ+dGPnRu5EPnRj50bvSHzo3+0LnRHzo3+kPnRn/o3OgPnRv9oXOjP3Ru9IfOjf7QuTEeOjfGQ+fGeOjcGA+dG+Ohc2M8dG6Mh86N8dC5MR46N8Yj54Yuy0N7yUN76UN72UN7+UN7xUN7tYf2yof26g/t9dC5IQ+dG/LQufF3PBH8mz8TvEXpmP/eer1vfDA60X99hD3/I/z5HxHP/4j2/I/I539Ef/5HjKd/xN/x1Osf/gh5/kc8/+rW51/d+vyrW59/devzr259/tWtz7+69flXtz3/6rbnX932/Kvbnn912/Ovbnv+1W3Pv7rt+Ve3Pf/qtudf3f78q9uff3X7869uf/7V7c+/uv35V7c//+r251/d/vyr259/dcfzr+54/tUdz7+64/lXdzz/6o7nX93x/Ks7nn91x/Ov7nj+1d2ef3W351/d7flXd3v+1d2ef3W351/d7flXd3v+1d2ef3W351/d+fyrO59/defzr+58/tWdz7+68/lXdz7/6s7nX935/Ks7n3919+df3f35V3d//tXdn3919+df3f35V/ceuGvodetY10QfW//6e0Hdg8+MuAYeR4R8/Yx+wGeMp3+G7cFFbn6GHPAZesBn2AGf4Qd8xh5/3+wj735GO+Az8oDP6Ad8xi7XeX58xvjyN+0mywGfIQd8hh7wGXbAZ/gBnxEHfMYe13nzK/PR4sZn5AGf0Q/4jPH8z9iF7WpXC7d+Rn79DDngM/SAz7ADPsMP+Iw44DPaAZ+RO39G86+f0Q/4jPH8z7A9rvN+fZVKdL/xGXLAZ+gBn2EHfMYe13leM/rXz4i/fMbXrT375U6w/vNjFaztV0FBK6jRCkpaQZ1W0IAV5Hp0QU0ur6Zq+vEwa30Y96uewy+yZhcZap+2vdbTYPUkrJ4Oq2ePC6zn1SkMaRv16CKXY6///HgW4Yv8WVEsuIoEV5HiKjJcRY6rKI6vyMe1oli+VtRwFSWuoo6raNAqaguuohdodr++hEyW9rUixVVkuIr8pRVJ/1pR4CpquIoSV1HHVTRoFeWCq+h4PRL/eLXjp2dq14qOv9Ykrvc1afa1ouOvNb2+iVNV42tFHVfRoFXUl5dWZPm1IsFVpLiKDFeR4yoKXEUNV9FrNdvH14o6rqJBq2gcr9kfqaBrcV/dyBBcRYqryHAVOa6iwFXUcBUlrqIXaHa/ro5s+fqMbQxYRb4suIrkpRWJfq1IcRUZriLHVRS4ihquoqRVJMfrkVm7VmT9a0XHX2vrb8PXiiK/VnT8tebXtyGoy/haUeAqariK8qUVmXytqOMqGrSKdMFVJLiKFFeR4Sp6rWa7fa0ocBU1XEXHa/b6POZ67x9f3Yh2XEWDVpEtuIoEV5HiKjJcRY6rKHAVNVxFOM02nGbbC3z2R0Xx9S993RdcRYKr6Mma/edn2AGf4Qd8xi7vA7y+WzTGJjWy8UY834Xz2beixFXUn1vRn5+xh/aNcTn72vLpKeZjXe/C7+xbkeAqUlxFhqvIcRXFcyv68zPaAZ+RB3zG89/K6rtwMBufsQvZsvUZcsBn6AGfYQd8hh/wGXHAZ7QDPiMP+IwDrvN2wHWeB1znecB1ngdc53nAdZ4HXOd5wHWeB1znecB1ngdc53nAdd4PuM77Add5P+A67wdc5/2A67wfcJ33A67zfsB13g+4zvsB1/k44DofB1zn44DrfBxwnY8DrvNxwHU+DrjOxwHX+TjgOh/Pv85jWQ74DDngM/SAz7ADPsMP+Iw44DPaAZ+RB3xGP+AzDrjO5YDrXA64zuWA61wOuM7lgOtcDrjO5YDrXA64zuWA61wOuM71gOtcD7jO9YDrXA+4zvWA61wPuM71gOtcD7jO9YDrXA+4zu2A69wOuM7tgOvcDrjO7YDr3A64zu2A69wOuM7tgOvcDrjO/YDr3A+4zv2A69wPuM79gOvcD7jO/YDr3A+4zv2A69wPuM7jgOs8DrjO44DrPA64zuOA6zwOuM7jgOs8DrjOD/h7uDjg7+HigL+HiwP+Hi4O+Fu1OOBv1eKAv1WLA/5WLV6Qj3s/KSNekI9r1xmppX6tSHAVKa4iw1XkL6ho+ajIvlYUuIoarqLEVdRxFQ1aRX3BVfQCzb6btxQvyFneqoiWSRUvyFneqihwFTVcRYmrqOMqGrSKXpCzvFURTrMHTrNfkSF8910d8YoM4bzOSPLrCvIVGcIbFXVcRQNWUXtBhrC09lHR+FqR4CpSXEWGq8hxFQWuooar6AWaffeNT23puIoGraIX5CxvVSS4ihRXkeEqclxFgauI9k68JjjNFpxm7/I3zz9777xcbrRNP1z27/fOt13+Pvpn9cRl+diafq3HYPU4rJ6A1dMOr8f7tR77Wk/C6umwegarnl3+/nzPegRWj8LqOV6f7XJDbZ+2vdbjsHoCVk+D1ZOwejqsnsGqxxdYPQKrR2H1wPTZYfrsMH12mD47TJ8dps+3cxZd4/K3h66f/vpI261yfLmsyMPVP2/85yeMZ3/C7b+o3fUT5OmfoE//BHv6J/jTPyGe/gnt6Z+QT/+Ep1/T/elna3/62dqffrb2p5+t/elna3/62dqff7Y+/Q40nn4HGk+/A43nXtPrf8gfm97+uXDkZUdZPr3tWuOWoWlXQ5P5edO1i9s//e12dP+Hj351bin+t0ePf/zol+8qP/808uvo7alHz3/06KsFvhz982P5X0fvTz36+IePPi7vR+zL354zt4OHfnb0y9qgq/zt0eUfPXq3y7fav0xGdcej/83VtP6H/qkHt28w188I+RCdvHM23N1j/HSP29/a3T3kx3voz/ZY/8P+2PC2RY24/i66/vNj1vbnZ902nRv79Af2GT/f5zZcs7GPPLCPPrCPPbCPP7BPPLDPA+dBf+A86A+cB/2B82A8cB6MB86D8cB5MB44D8YD58F44DwYD5wHt/+EPNafmy/7NB9/u09/YJ/x833k9l9Kb+0kj+ykmzs1/7LTN3PI60O5XPRvd7r9d3sx4rrT6F930kd2skd28gd2uv23JG35+MF1iS8jv/0HDW3J5brT10+6/av6xifd/ul7PfzV4MvX7+n279NbO9kjO/kjO8U3O8XHTvZlp/bITvnITv2RncYDO/nyyE7yyE76wAnr9shO/shO8chO7ZGdHrlyvT+y03hgp1ge2Uke2emRMyIeOSPikTMiHjkj4pEzIn58Rqz/4X+u+m7zEH1cb6JjWcbfd+fd2mk8sNPtP/zf2kke2Ukf2en2IJarb+mLfb3z3i7v44bTZYkvO+kjO9kjO/kjO8UjO7VHdspHduqP7DQe2Om2Q+ry8fxF/O90SOtO7bpT+8v1+/UBz45PoL/xXq8rx1jlOKucYJXTWOUkq5zOKmegyvGFVQ5Llf2bC73rtZxuf5/t73J9uXPXT79l3LX9GzvF8shO8shO/sAgbpvxrsunT1r+PjO+tVM+slN/ZKfb35Pqx07W/nan2wGfWzvJIzvpIzvZIzv5IzvFIzu1B07Ylo/s9MiV2x65cvORKzcfuXJTH9nJHtnJH9kpHtnpkTMiHzkj8pEzIh85I/ojZ0R/5Izo/sACun+z2Izr7/NL+/KMpLdHdspHduqP7DQe2On2L3VbO8kjO+kjO9kjO/kjOz1yRoxHzojxyBkxHjkjxgNnhC4/PiPW/4g/nwTe/jVtXExVfvph54/nHn/s2P7c8fZD4utfu/fl81/Gt19l/nwX+fku+vNd7Oe7+M93+cZ5XHfx/mWX9vNd8ue79J/vMn68yzePyO7uIj/fRX++i/18F//5Lre//X69TY7xl11uZEHkNZB6fFroLH9KwDcPYHY7fD738P0fPby1y4+Ilv7l8OOph//mAcZuh5fnHl6fe3h77uH9uYeP5x6+7Xj4/uWy8nzu4ftzD3/7D4P18rRsWP6tyN5+GnV/F/n5LvrzXeznu/jPd4mf79J+vEt7YJf8+S43Ty71ywmjnzjN3yfM7ccgd3e5/RDk/i7y813057vYz3fxn+8SP9+l/XyXm9/+XUNw+6HH/V3Gj3e5/cDj/i7y813057vYD3dZ/yv/2LJ9g2pcAInRP92DxL6/au7uksvPd5Gf76I/38V+vov/fJf4+S7t57vkz3f5+befP//2+8+//f7zb7///NvvP//2bz+IHD6uu+SXXeLnu7Sf75I/36X/fJfxw13W/+p/Pv25+YWuPw9cZr0+69ZPt/Q/JGr9z//fP//Pf/nn//av/+M/1p3++F//73/77//5L//+b7//8z/////Xr/9l3fj/BQ==","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","build_msg_block","attach_len_to_msg_block","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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gkpBbEEuCXBBLglwQS4JcEEuCXBBLgloQdPgkgAX5JIAF+SSABfkkgAXVApiC3JJgAtySYALckmAC3JJgAtySWALGl0S4IJcEuCCXBLgglwS4IJKQWxBLglwQS4JcEEuCXBBLglxQetx/xS3Gh4wdxxIM69lub241nH5kflk7/czN+H7mVvl/cwN7X7mJfN25uZwP3MLt5+50drP3A6NM1+3O/NtfufF+zrfPuh9XccHgoxWtqDZwoULMofhgmxnuCBDGy6oFMQWZMLDBdn7cEGOA3BBLglwQS4JbEHlkgAX5JIAF+SSABfkkgAXVApiC3JJgAtySYALckmAC3JJgAtySWALWlwS4IJcEuCCXBLgglwS4IJKQWxBLglwQS4JcEEuCXBBLglwQS4JbEGrSwJckEsCXJBLAlyQSwJcUCmILcglAS7IJQEuyCUBLsglAS7IJYEtaHNJgAtySYALckmAC3JJgAsqBbEFuSTABbkkwAW5JMAFuSTABbkksAXtLglwQS4JcEEuCXBBLglwQaWgSwUd2w3eMQzHA0EuCXBBLglwQS4JcUHbMt4F7ePbLz6+GLgJmsd3XvzuPzi4Ozt8JptuFJ/I5uGg8Zlsun58JptOJZ/JprvKZ7JZ2vxENl1sPpNN553PZNMt6DPZdAv6TDbdgj6PzXlwC/pMNt2CPpNNt6DPZNMt6DPZLG1+IptuQZ/JplvQZ7LpFvSZbLoFXWzzDu+LzeOBIOcdtqDRxeZaQTVON0FV29svno75puXLFxy//sh/fLI//uY57LcPYxmO49sX/63eeedl1bsFvax6h6OXVV+qf1X1TlIvq9796mXVO3a9rHqXsZdV7+b2quon17yXVe+a97LqXfNeVr1r3suqL9W/qnrXvJdV75r3supd815WvWvey6p3zXtV9bNr3suqd817WfWueS+r3jXvZdWX6l9VvWvey6p3zXtZ9a55L6veNe9l1bvmvar6cs17WfWueS+r3jXvZdW75r2s+lL9q6p3zXtZ9a55L6veNe9l1bvmvax617xXVb+45r2sete8l1Xvmvey6l3zXlZ9qf5V1bvmvax617yXVe+a97LqXfNeVr1r3quqX13zXla9a97LqnfNe1n1rnkvq75U/6rqXfNeVn33mldj3dXPx3vq5y//c2c+1tePZNwffbrTuC83kl/+92+4//H6vz/j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","brillig_names":["get_contract_instance_internal","get_public_keys_and_partial_address","decompose_hint","notify_created_note_oracle_wrapper","get_key_validation_request","random","lt_32_hint","lte_16_hint","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","directive_integer_quotient","directive_invert"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000004c141a0"},{"kind":"string","value":"EcdsaPublicKeyNote"},{"fields":[{"name":"x","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"y","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000020"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000040"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"EcdsaRAccount"}},{"name":"fields","value":{"fields":[{"name":"public_key","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"EcdsaRAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"EcdsaRAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"signing_pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signing_pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"EcdsaRAccount::constructor_parameters"}}],"kind":"struct","path":"EcdsaRAccount::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"EcdsaRAccount::entrypoint_parameters"}}],"kind":"struct","path":"EcdsaRAccount::entrypoint_abi"}]}},"file_map":{"101":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"120":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: &mut Note) -> NoteEmission<Note>\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"165":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"166":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"177":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"308":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"309":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"313":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"401":{"path":"/usr/src/noir-projects/noir-contracts/contracts/ecdsa_public_key_note/src/lib.nr","source":"use dep::aztec::prelude::{NoteHeader, NoteInterface, NullifiableNote, PrivateContext};\n\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note_custom_interface, generators::Ga1 as Gx_1, generators::Ga2 as Gx_2,\n    generators::Ga3 as Gy_1, generators::Ga4 as Gy_2, generators::Ga5 as Gnpk_m_hash, generators::G_slot\n};\n\nuse std::hash::from_field_unsafe;\n\nglobal ECDSA_PUBLIC_KEY_NOTE_LEN: u32 = 5;\n\n// Stores an ECDSA public key composed of two 32-byte elements\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[note_custom_interface]\npub struct EcdsaPublicKeyNote {\n    x: [u8; 32],\n    y: [u8; 32],\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NoteInterface<ECDSA_PUBLIC_KEY_NOTE_LEN> for EcdsaPublicKeyNote {\n    // Cannot use the automatic serialization since x and y don't fit. Serialize the note as 5 fields where:\n    // [0] = x[0..31] (upper bound excluded)\n    // [1] = x[31]\n    // [2] = y[0..31]\n    // [3] = y[31]\n    // [4] = npk_m_hash\n    fn serialize_content(self) -> [Field; ECDSA_PUBLIC_KEY_NOTE_LEN] {\n        let mut x: Field = 0;\n        let mut y: Field = 0;\n        let mut mul: Field = 1;\n\n        for i in 1..32 {\n            let byte_x: Field = self.x[31 - i] as Field;\n            x = x + (byte_x * mul);\n            let byte_y: Field = self.y[31 - i] as Field;\n            y = y + (byte_y * mul);\n            mul *= 256;\n        }\n\n        let last_x = self.x[31] as Field;\n        let last_y = self.y[31] as Field;\n\n        [x, last_x, y, last_y, self.npk_m_hash]\n    }\n\n    // Cannot use the automatic deserialization for the aforementioned reasons\n    fn deserialize_content(serialized_note: [Field; ECDSA_PUBLIC_KEY_NOTE_LEN]) -> EcdsaPublicKeyNote {\n        let mut x: [u8; 32] = [0; 32];\n        let mut y: [u8; 32] = [0; 32];\n\n        let part_x:[u8; 32] = serialized_note[0].to_be_bytes();\n        for i in 0..31 {\n            x[i] = part_x[i + 1];\n        }\n        x[31] = serialized_note[1].to_be_bytes::<32>()[31];\n\n        let part_y:[u8; 32] = serialized_note[2].to_be_bytes();\n        for i in 0..31 {\n            y[i] = part_y[i + 1];\n        }\n        y[31] = serialized_note[3].to_be_bytes::<32>()[31];\n\n        EcdsaPublicKeyNote { x, y, npk_m_hash: serialized_note[4], header: NoteHeader::empty() }\n    }\n\n    fn to_be_bytes(self, storage_slot: Field) -> [u8; ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 64] {\n        let serialized_note = self.serialize_content();\n\n        let mut buffer: [u8; ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 64] = [0; ECDSA_PUBLIC_KEY_NOTE_LEN * 32 + 64];\n\n        let storage_slot_bytes: [u8; 32] = storage_slot.to_be_bytes();\n        let note_type_id_bytes: [u8; 32] = EcdsaPublicKeyNote::get_note_type_id().to_be_bytes();\n\n        for i in 0..32 {\n            buffer[i] = storage_slot_bytes[i];\n            buffer[32 + i] = note_type_id_bytes[i];\n        }\n\n        for i in 0..serialized_note.len() {\n            let bytes: [u8; 32] = serialized_note[i].to_be_bytes();\n            for j in 0..32 {\n                buffer[64 + i * 32 + j] = bytes[j];\n            }\n        }\n        buffer\n    }\n\n    fn get_note_type_id() -> Field {\n        comptime\n        {\n            let bytes = \"EcdsaPublicKeyNote\".as_bytes();\n            let hash = aztec::protocol_types::hash::poseidon2_hash_bytes(bytes);\n            let hash_bytes = hash.to_be_bytes::<4>();\n            aztec::protocol_types::utils::field::field_from_bytes(hash_bytes, true)\n        }\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn compute_note_hash(self) -> Field {\n        let serialized = self.serialize_content();\n        std::embedded_curve_ops::multi_scalar_mul(\n            [Gx_1, Gx_2, Gy_1, Gy_2, Gnpk_m_hash, G_slot],\n            [\n            from_field_unsafe(serialized[0]),\n            from_field_unsafe(serialized[1]),\n            from_field_unsafe(serialized[2]),\n            from_field_unsafe(serialized[3]),\n            from_field_unsafe(serialized[4]),\n            from_field_unsafe(self.get_header().storage_slot)\n        ]\n        ).x\n    }\n}\n\nimpl NullifiableNote for EcdsaPublicKeyNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl EcdsaPublicKeyNote {\n    pub fn new(x: [u8; 32], y: [u8; 32], npk_m_hash: Field) -> Self {\n        EcdsaPublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}\n"},"402":{"path":"/usr/src/noir-projects/noir-contracts/contracts/ecdsa_r_account_contract/src/main.nr","source":"// Account contract that uses ECDSA signatures for authentication on random version of the p256 curve (to use with touchID).\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract EcdsaRAccount {\n    use dep::aztec::prelude::{PrivateContext, PrivateImmutable};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, functions::{private, initializer, view, noinitcheck}},\n    };\n\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness,\n    };\n\n    use dep::ecdsa_public_key_note::EcdsaPublicKeyNote;\n\n    #[storage]\n    struct Storage<Context> {\n        public_key: PrivateImmutable<EcdsaPublicKeyNote, Context>,\n    }\n\n    // Creates a new account out of an ECDSA public key to use for signature verification\n    #[private]\n    #[initializer]\n    fn constructor(signing_pub_key_x: [u8; 32], signing_pub_key_y: [u8; 32]) {\n        let this = context.this_address();\n        let this_keys = get_public_keys(this);\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n        let mut pub_key_note =\n            EcdsaPublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this_keys.npk_m.hash());\n        storage.public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note(\n            &mut context,\n            this_keys.ovpk_m,\n            this_keys.ivpk_m,\n            this,\n        ));\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts\n    #[private]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[noinitcheck]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // Load public key from storage\n        let storage = Storage::init(context);\n        let public_key = storage.public_key.get_note();\n\n        // Load auth witness\n        let witness: [Field; 64] = unsafe { get_auth_witness(outer_hash) };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify payload signature using Ethereum's signing scheme\n        // Note that noir expects the hash of the message/challenge as input to the ECDSA verification.\n        let outer_hash_bytes: [u8; 32] = outer_hash.to_be_bytes();\n        let hashed_message: [u8; 32] = std::hash::sha256(outer_hash_bytes);\n        std::ecdsa_secp256r1::verify_signature(\n            public_key.x,\n            public_key.y,\n            signature,\n            hashed_message,\n        )\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"73":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, CANONICAL_AUTH_REGISTRY_ADDRESS,\n    }, hash::poseidon2_hash_with_separator,\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let result: Field = context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n            [on_behalf_of.to_field(), inner_hash].as_slice(),\n            GasOpts::default(),\n        )\n        .deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n            [message_hash, authorize as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n            [context.this_address().to_field(), reject as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n"},"75":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"76":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator,\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"79":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: u32 = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            fields.extend_from_array(self.function_calls[i].serialize());\n        }\n        fields.push(self.nonce);\n        fields.push(self.is_fee_payer as Field);\n        fields.storage\n    }\n}\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"96":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"98":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
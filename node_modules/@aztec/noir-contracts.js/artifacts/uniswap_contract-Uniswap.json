{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"Uniswap","functions":[{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["public","internal","view"],"abi":{"error_types":{},"parameters":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"token_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAo4AIBFAAAiAEoeAgAAAx4CAAAEMDgAAwAEAAUkAgEBAyECABEABTkBAAAeAgEAAx4CAAAECjgDBAUhAgAWAAU5AQAAHgIKAAMkAgABBAo4AwQFIQIAGwAFOQEAACQCBAEEJAIEAgYAOAQGBSoIAQMAEAEFASQDBAEDACgDAgUqDgQFJAIEAgUAOAMFBCoMBAUmAgDZXYfiAAYqDgYFJAIEAQQmAgDVRBsNAAUpAgAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAAAAHKggBCCQCBAMJABABCQEkAwQBCAAoCAIJKgwJCioOBwoAKAoCCioOBwoAKAgCCQAoAwIMKg0MCwAoDAIKKggBDCQCBAINABABDQEkAwQBDAAoDAIONz+VAAkAAgAKAAsADgABAA0ABSQCAgECCjgNAgMhAgBCAAM5AQAAJAIEAAIAKAwCBAA4BAIFKg0FAwo4AQMCIQIASQACOQEAACMlAAR4AIAEDQAAAIAEgAMhAABOgAM5AQAAIysAGMoYyg==","debug_symbols":"1ZrdbuIwEIXfxddceDw/HvMqq1UVWqgiRaECutIK8e6bbOMUSqqoIa2YG4ThzMwZO5Pvxkf3tF69Pj+U9Wa7d8tfR1dtH4tDua2b1fG0cKtdWVXl88P5z863HwD/9fuXom6X+0OxO7glSPILt66fmq/R+ybDpqzWbknMp8WVOjF34hS514LCgBaTZDGmSGfqocxCCp1aKMUL9e+Fg3C7efAYstpz+FH7OMPeJ+jdw9jmQ+CU1XihHkodI2qnjrHN98E9zeueL923FfjbK8i3V4i3VyDfHwR5krGHjimrhQWvjk1vNzTvFKSvGmqCgp8SBFOCZnjHcKA8dxxkdO7IZ3UkDB/3K+CULmhKEE8JkilBg1OSglIGC+LYJiv6/Jgp4tmUpMEXOVHOjaw6ciQqPeI0wvWRqG37ybR99Lbtg237wbZ9tG2fbNtn2/bFtn3b1EXb1EXb1CXb1CXb1CXb1CXb1CXb1CXb1CXb1CXb1CXb1CXb1GXb1GXb1GXb1GXb1GXb1GXb1GXb1GXb1GXb1GXb1BXb1BXb1JWfp654yfYF9MoQ3pshujdDfG+G5qAXaS6hDH7EEISo2MkhKKSRIQCM/T0C1Pfs2AxE20C03oBabyAZbyB+QrHY395C4osG2iCYEhS+HHRqln+KXVmsqnV3aW3zWj+e3WE7/H15+6cR/wM=","brillig_names":["_assert_token_is_same"],"assert_messages":{"16":"Not initialized","21":"Function _assert_token_is_same can only be called internally","26":"Function _assert_token_is_same can only be called statically","72":"input_asset address is not the same as seen in the bridge contract","77":"Stack too deep","65":"Nested static call failed!"}},{"name":"swap_public","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"input_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"input_amount","type":{"kind":"field"},"visibility":"private"},{"name":"output_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce_for_transfer_approval","type":{"kind":"field"},"visibility":"private"},{"name":"uniswap_fee_tier","type":{"kind":"field"},"visibility":"private"},{"name":"minimum_output_amount","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_L1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"nonce_for_swap_approval","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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KBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUAKBUCFSoODBUA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","debug_symbols":"7X3RriS5jey/9LMfRIqSSP/KxcVivOtdDDAYL+zZC1wY/vetdndm1XGqSt0aKVoq6cU47UmeoOIoREoZmfn3T//x5z/9z3/928+//udf/vbpj//n759++cu///Tbz3/59favv//jD5/+9Neff/nl5//6t8f/+5P7/D/s/nn93/77p18///Nvv/30198+/ZGiuT98+vOv/3H7MTl3+w3/+fMvf/70RwnhH//3D5+YaoK4JsjXBElNUKgJijVBqSZIa4KsIsjXzAhfMyP8d8+IP1yuthC+XmwpnNeSUuZab/G42FuSh6tzvzmK0tero1j6cPXn5P3vT56c5+NqFxiavjTg3ujMnkrkEwc7rvYfrs796pS8fr06pc+/71+yD22zDx+z/4wQuyOk7gj5NUMtHkFGUkAQd/4hxEksTbogx9UxRH/5s+XXI9UzIbVQSCi5Y8jJ39PxxJ8BxH0vwOegfFbm/UlTMSuKHE6MyOmut+R7sxpci/y9O+dd9GSF/Dkcv1w4cSF/VZKvV6uGcMmfJs+fJ8/fT56/TJ5/mDz/iM/f01EFxHO8ZJSGy0iHy8h+wKxTvmd0aUmjGy4jGi4jHi4jP1xGMlxGYbiM2q/Z3r3OKOmx/1On56XM8s982qzYwvd8YiwwJCEdDIn6Qg38vn1ZoWJGXWq0ttJok1tqtLTUaHmp0fqlRitvNVrPdmTifbg3CxSzh7PudkR8P0n0937B8xd2wmbnBTtxs/OCnffq7Vqz8169YGt23qt3bMyOvlev2Zqd9+pNW7PzXr1sa3beq/dtzY5sdl6ws3vlV+zsXvkVO7tXfsXO7pVfsbN75Rfs2O6VX7Gze+VX7Oxe+RU7u1d+xY5sdl6ws3vlV+zsXvkVO7tXfsXO7pVfsbN75RfskNvN8kt6drf8kp7dLr+kZ+1+OYi/0xPilR7Z9LyiZ+2OuUjP2i1zkZ61e+YiPWs3zUV61u6aS/TQ2l1zkZ61u+YiPWt3zUV6dtf8kp7F+56HPVd0dqVn7coVwwM9iS708NqVq0jP2pWrSM/alatIz9qVq0iPbHpe0bP2eU+RnrX7niI9a5/3FOlZ+7ynSE+bN2OR3elJBXrIgpPzt4eHpPKXF++2ePcGY6A3GAO/wRj8G4xB3mAM4Q3GEN9gDOkNxqBvMIY3qNPyBnVa3qBOyxvUaXmDOi1vUKflDeq0vEGdljeo0/IGdVreoE6HN6jT4Q3qdHiDOh3eoE63efv0Dx7DG9Tp8AZ1OrxBnQ4T1OmSmSZMUKdLY4gT1OniGCao08UxTFCni2OYoE4XxzBBnS6OYYI6XRzDBHW6OIYJ6nRxDG9Qp9MMa2vBmZom0HTJJ5Am0HRxDBNoujiGCTRdHMMEvXdpDDpB710cwwS9d3EME9SH4hgm6L2LY5A3GEMbH67erYL/vOZlUonPb7hS8qSvL+d4fk2WY7p7Bb9+4IAavXnzR44gTT8CnX4ENvsIGr0J8keOgKYfAU8/Aj/9CGT6EUxfk236mmzT12Sbvibb7DWZ3ew1md3sNZnd7DWZ3ew1md3sNZnd7DWZ3ew1md3sNZnd7DWZ3fQ1maavyTR9TabpazJNX5Np+ppM09dkmr4m0/Q1maavyTR9TebpazJPX5N5+prM09fkRi+N6jmC5I43t7A++OTz73lR4eN3qzzcfT7HO34Fbzve8et92/GO3x20He/4vUTb8Y7feTQdrx+/T2k73vG7mrbjHb8Hajve8TumtuOVxca7WH/lF+uv/GL9lV+sv/KL9VeyWH8li/VXslh/JeP3VxbCMV6L6ToCmX4E4/dApRH86K4mJCtczknPZG6RVtDNbeE7z0FvEjqvZmdfRvyj+xr8iH90Z4Mf8Y/obYKdT0+lyB+envqcU3AD5kQD5sQD5pStVOz8EcXuYYrnc/LnDPeqD9d+RQjdEWJ3hNQdQbsjWG+E/FuGmiJQdwQuImgsIKh3Z3/r/f1qstyXF7z3R+/s/cN7LfL1Ienx3Ku6e/a3W6Bfsvf47FnP7GO8dGFRhssoDJdRHC6jNFxGOlxGNlpGyQ2XEQ2XEQ+X0XBrdhpuzU7DrdlpuDU7Dbdmp+HW7DTcmq3Drdk63Jqtw63ZOtyarcOt2Trcmq3Drdk63Jqtw63ZOtyabcOt2Tbcmm3Drdk23Jptw63ZNtyabfg1W+T43T48nBA+uZcdz7uQmoiv+afJ89fJ87ep8/fOTZ4/TZ4/T56/nzx/mTz/MHn+c9df7+auv97NXX+9m7z+0uT1lyavvzR5/aXJ6y9NXn8JX3+ji0f+kfSaURwuozRcRi2qnuiBoYFcIaPv9WmST6cL1Ov9t98WrC8jsNlHwG76EeRrH8vxcn/mB9/4E7eYxWN98ZakkFGU0xscxS6edJ9/WwhTODllV3KABjsOzKLz9zF/8a/5/Ns8miJId4TQHSF2R0jdEbQ7gvVGyL8ZoCkCdUformnfXdO+u6Z9d0377pr23TXtu2vad9e0dNe0dNe0dNe0dNe0dNe0dNe0dNe0dNe0dNe0dNd06K7p0F3TobumQ3dNh+6aDt01HbprOnTXdOiu6dBd07G7pmN3Tcfumo7dNR27azp213TsrunYXdOxu6Zjd02n7ppO3TWdums6ddd06q7p1F3TqbumU3dNp+6aTt01rd01rd01rd01rd01rd01rd01rd01rd01rd01rd01bUVN3xbHAkIMctyZiiHdMfL31jje79vF+PEd6terX75lwBv9gOxfvQHeGw+XkR8uIxkuozBcRnG4jNJwGelwGdlgGYlzw2U02potbrQ1W9xoa7a40dZscaOt2eJGW7PFjbZmixttzRY33JpNw63ZNNyaTcOt2TTcmk34Nbvl25eFwuT5x8nzT5Pnr5Pnb3Pnz27y/Gny/Hny/P3k+U9ef3ny+suT11+evP7y5PWXJ6+/fvL66yevvx5ff19/iUS8Hy4jGS6jfNUL95kR2BUyavqsnjx5nkRUz4zK75r3Z0LyMft/IqTuCNodwXojPHmepCUCdUfg7gi+O4J0RwjdEbprWrprWrprWrprOnTXdOiu6dBd06G7pkN3TYfumg7dNR26azp013TorunYXdOxu6Zjd03H7pqO3TUdu2s6dtd07K7p2F3TsbumU3dNp+6aTt01nbprOnXXdOqu6dRd06m7plN3TafumtbumtbumtbumtbumtbumtbumtbumtbumtbumtbumrbumrbumrbumrbumrbumrbumrbumraippMb9uknMf0B2b90HJoNllFwbriMaLiMeLiM/HAZyXAZheEyisNllIbLaLQ1O7jh1mwabs2m4dZsGm7NpuHWbBpuzabh1mwabs2m4dZsGm7NpuHWbB5uzWb8mt3SPRiYJ8/fT56/TJ5/mDz/OHn+afL8dfL8be78vZs8/8nrr5+8/vrJ66+fvP76yeuvn7z++snrr5+8/np8/X39ZE8QN1xGNFxG+apn/rgR6Z0rPv10fjvNP3w1Ub68cTI8eT6kJYJ0RwjdEWJ3hNQdQbsjWG+EJ8+HfEAoKfR2WH/o+XbeWlKo9/5Yhb0PsbAKv3QIhCfPnnTN/rza+xgv60vg4TLyw2Ukw2UUhssoDpdRGi4jHS4jGy2j6IbLaLg1Ow63Zsfh1uw43Jodh1uz43BrdhxuzY7DrdlxuDU7Dbdmp+HW7DTcmp2GW7MTfs0WOdzfPjzsNp+csMXzrEYT8TX/MHn+cfL80+T56+T529z5q5s8f5o8f548fz95/pPXX528/urk9Vcnr786ef3VyeuvTV5/bfL6a5PXX8PX3+ji8bsj6TUjGS6jMFxGLaoe2zEzgicrZEScznvMt6E8Xn/klAbMSQfMyYbLKTo3YE40YE48YE7ZFdw7PasESSzk9NI/Ep10RwjdEWJ3hNQdQbsjWG+E/HPRHxCCb1tL23mRYv4Z6r7Zvzz/j/lnqH9oRn64jGS4jMJwGcXhMkrDZaTDZWSjZcRuuIyGW7N5uDWbh1uzebg1m4dbs3m4NZuHW7N5uDWbh1uz/XBrth9uzfbDrdl+uDXb49fslmfh0YfJ84+T558mz18nz9/mzl/c5PnT5Pnz5Pn7yfOfvP7K5PVXJq+/Mnn9lcnrr0xef8Pk9TdMXn/D5PU34Ovva59NDDJcRmG4jFpUvcaeiJAGzEkHzMnGyym6AXOiAXPiAXPKr+Ac0pETmxZyIueOq8nxvUp4cl8w5AnGuUp5d/lKTsw/SV6MilVR+dVH3PmXkaKLpsiCPsHwdwy9ZmY1UflnlYtRec2EcLzx2msqsRDtIDrao6/uixsn/3xwUwT/+xHUnY6iGK4I0h0hdEeI3RFSdwTtjmC9EfLPYn4fgrmjIBjbFYG6I3B3BN8dQbojhO4IsTtCA01bimeRdHKF0P4Q1h3CXH8I6g/B/SF8f4gG0iYXj6uJ6CoMCwCMCMBIAAwFYFh3jOQcAKOByIminBjXhjk5BmB4AIYAMAIAIwIwEgCjhc5ZHk8vrhjWH4McAIMAGAzA8AAMAWC00Lk/ryZv8YoRARgJgKEADOuPwQ6AQQCMFjqX8/FYkiRXDA/AEABGAGBEAEYCYCgAo4XOb8cUB0b6cNT/BcM7AAYBMBiA4QEYAsAIAIwIwEgADAVgAHQuAJ0LQOcC0LkAdC4AnQtA5wLQuQB0LgCdC0DnAaDzANB5AOg8AHQeADoPAJ0HgM4DQOcBoPMA0HkE6DwCdB4BOo8AnUeAziNA5xGg8wjQeQToPAJ0ngA6TwCdJ4DOE0DnCaDzBNB5Aug8AXSeADpPAJ0rQOcK0LkCdK4AnStA5wrQuQJ0rgCdK0DnCtC5AXRuAJ0bQOcG0LkBdG4AnRtA5wbQuQF0bv11rs4BMAiAwQAMD8AQAEYAYEQARgJgKAADoHMC6JwAOieAzgmgcwLonAA6J4DOCaBzAuicADpngM4ZoHMG6JwBOmeAzhmgcwbonAE6Z4DOAX44BfjhFOCHU4AfTgF+OAX44RTgh1OAH04BfjgF+OEU4IdTgB9OAX44BfjhFOCHU4AfTgF+OAX44RTgh1OAH04BfjgF+OEU4IdTgB9OAX44BfjhFOCHU4AfTgF+OAX44RTgh1OAH04BfjgF+OEU4IdTgB9OAX44BfjhFOCHU4AfTgF+OAX44RTgh1OAH04BfjgF+OEU4IdTgB9OAX44BfjhFOCHU4AfTgF+OAX44RTgh1OAH04BfjgF+OEU4IdTgB9OAX44BfjhFOCHU4AfTgF+OAX44RTgh1OAH04BfjgF+OEU4IczgB/OAH44A/jhDOCHMycAjADAiACMBMBQAAZA5wA/nAH8cAbwwxnAD2cAP5wB/HAG8MMZwA9nAD+cAfxwBvDDGcAPZwA/nAH8cAbwwxnAD2cAP5wB/HAG8MMZwA9nAD+cAfxwBvDDGcAPZwA/nAH8cAbwwxnAD2cAP5wB/HAG8MMZwA9nAD+cAfxwBvDDGcAPZwA/nAH8cAbwwxnAD2cAP5wB/HAG8MMZwA9nAD+cAfxwBvDDGcAPZwA/nAH8cAbwwxnAD2cAP5wB/HAG8MMZwA9nAD+cAfxwBvDDGcAPZwA/nAH8cAbwwxnAD2cAP5wB/HAG8MMZwA9nAD+cAfxwBvDDGcAPZwA/nAH8cAbwwxnAD2cAP5wB/HAG8MMZwA9nAD+cAfxwBvDDGcAPZwA/nAH8cAbwwxnAD2cAP5wB/HDkAIa4GwghQBgB4hEgggAJCJCIAEkIEEWAIBRPCMUTQvGEUDwhFE8IxRNC8YRQPCEUTwjFE0LxjFA8IxTPCMUzQvGMUDwjFM8IxTNC8YxQPCMU7xGK9wjFe4TiPULxHqF4j1C8RyjeIxTvEYr3CMULQvGCULwgFC8IxQtC8YJQvCAULwjFC0LxglB8QCg+IBQfEIoPCMUHhOIDQvEBofiAUHxAKD4gFB8Rio8IxUeE4iNC8RGh+IhQfEQoPiIUHxGKjwjFJ4TiE0LxCaH4hFB8Qig+IRSfEIpPCMUnhOITQvGKULwiFK8IxStC8YpQvCIUrwjFK0LxilC8IhRvCMUbQvGGULwhFG8IxRtC8YZQvCEUbwjFIzx3hPDcEcJzRwjPHSE8d7czWwRIQIBEBEhCgCgCBKF4hOeOEJ47QnjuCOG5I4TnjhCeO0J47gjhuSOE544QnjtCeO4I4bkjhOeOEJ47QnjuCOG5I4TnjhCeO0J47gjhuSOE544QnjtCeO4I4bkjhOeOEJ47QnjuCOG5I4TnjhCeO0J47gjhuSOE544QnjtCeO4I4bkjhOeOEJ47QnjuCOG5I4TnjhCeO0J47gjhuSOE544QnjtCeO4I4bkjhOeOEJ47QnjuCOG5I4TnjhCeO0J47gjhuSOE544QnjtCeO4I4bkjhOeOEJ47QnjuCOG5I4TnjhCeO0J47gjhuSOE544QnjtCeO4I4bkjhOeOEJ47QnjuCOG5I4TnjhCeO0J47gjhuSOE544QnjtCeO4I4bkjhOeOEJ47QnjuCOG5I4TnjhCeO0Z47hjhuWOE544Rnjt2ggAJCJCIAEkIEEWAIBSP8NwxwnPHCM8dIzx3jPDcMcJzxwjPHSM8d4zw3DHCc8cIzx0jPHeM8NwxwnPHCM8dIzx3jPDcMcJzxwjPHSM8d4zw3DHCc8cIzx0jPHeM8NwxwnPHCM8dIzx3jPDcMcJzxwjPHSM8d4zw3DHCc8cIzx0jPHeM8NwxwnPHCM8dIzx3jPDcMcJzxwjPHSM8d4zw3DHCc8cIzx0jPHeM8NwxwnPHTcwxieMJwpoBaTCFb+dZ4evVtwMhyYA0mMK3wwB3gNxqxweQ69Vmcgzb8f1Xe86S5OJJkkt2vzp7Mas/LvZOCxcHfwzx9qN/vPgLMXETkycmbWLyxOgmJk+MbWKyxLSwdb0nMbSJyRPDm5g8MX4TkydGNjF5Ynbn+4SY3fk+IWZ3vk+I2Z3vE2J255snxnbn+4SY3fk+IWZ3vk+I2Z3vE2JkE5MnZtnON6aTmKh8JWbZzrdEzLKdb4mYZTvfEjHLdr6vifFu2c63RMyynW+JmGU73xIxy3a+JWJkE5MnZne+T4jZne8TYnbn+4SY3fk+IWZ3vnliaHe+T4jZne8TYnbn+4SY3fk+IUY2MXliduf7hJjd+T4hZne+T4jZne8TYnbnmyeGd+f7hJjd+T4hZne+T4jZne8TYmQTkydmd75PiNmd7xNiduf7hJjd+T4hZne+eWL8sp1v0pOYpP5KzLKdb4mYZTvfEjHLViXl820M6tOFGFl1jbndUTuHSJIhZtU1pkjMqmtMkZhVd9dFYmQTkydm1d11kZhVd9dFYlbtY4rErLq7LhKz6u66REzYne8TYtbtfKM/idEMMet2vgVi1u18C8TIJiZPzLKdbwjHeYwPSldilu187yd4Xj9e/IWYZfsY9XIO8fMV/0JMXLZcl4hZtlyXiFm2XJeIWbZcl4hZtVwL8ZGH5PZKcdVyXSRm1YOqIjGrHlQViVm1wSsRk1Y9qCoSs2rnWyRm1c63SMyqnW+RGNnE5InZne8TYnbn+4SY3fk+IWZ3vk+IWbbzZWcHMczXY4dlP/FRJGbZzrdEzLKdb4mYZTvfEjGyKjG3e7QHMV6ulvllP/FRJGbZPubW2x7EiLveu172gw0lYpb9YEORmGX7mBIxy/YxJWKW7WNKxMgmJk/Mun1MgZhlT/B80Dsx1y3Bsh9sKBKzbudbIGbdzvclMbLsBxuKxKzb+RaIWbfzLRCzbudbIEY2MXli1u18C8TszvcJMbvzfULMsp1voJOYQHYhZtnvEhSJWbbBC+G4WCKF1xerpYNFcy7D4rLdYFMWl20dm7Iom8UGLC7blDZlcdkOtimLyx7bfReL7nyFoDp/ZXHZV+98H4t0Pt9++/HiKpFl37rynSyeSSszXVnc/WILFne/2IJF2Sw2YHH3ixcWvxCzW8AnxCx7iFkiZjdqT4hZdh8Q00lM8peXLklc9nQ3BTqJ+fiaru+6+AuLy7b2TVlctrX/HhaN9EjDMi/ek2Xf/dSWRdksNmBx2da+KYvL7gOasrjspqEpi8vuMJqyuOx2pCWL6742qymLe+/SgsW9d2nB4t67tGBRNosNWNx7lxYs7r1LCxb33qUFi3vv0oLFvXdpwOK6Lz5ryuLeu7Rgce9dvoVF1sMkaZ6ud6/Wff9aUxZls9iAxb13acHi3ru0YHHvXVqwuPcuLVjce5dvYjHqncXr4yDrvuywKYt779KCxb13acHi3ru0YFE2iw1Y3HuXFizuvUsLFvfepQWLe+/SgsW9d/n9LIZ1X1fZlMVdo7+FxfvrmW8/6pXFvS5+C4tyP9MJLsMifF0kF+40mhRojO6QUnx4QQlr/JI+/vVqbdOnudPnwdP3x6+O4jLp+7nTl7nTD4OnH8/0Uy79OHf6aer0efS5r8dH1aJRJv3B2df7e8EeXgdwT1/HTt/ikYgln0l/8J6nkL4fvOcppT94z/OQvnIm/cF7nlL6g/c8FulMP2XSH3zdtxBepj94z1NKf/Cep5T+4FW3lP7gVZecc+fVD0cN9wGMXncfzndy+Uu+8Nr5AV1vD59DzedPyZ0nPYnvICScuTpEObgJMd5/N2nud99myHHWc/tRP1z9ZQA0+wB49gH42Qcgsw8gzD6AOPsA0uwD0NkHYJMPIMxeicPslTjMXonD6HVA6OhGbz+GzABGX4XkPP+//RgzA/gBq9D5pv4QU2ZSRDdeSjReSjxeSn68lGS8lMJ4KeW7WT2fub1lp6UzAU/HoSF70cK6pHweUyiLZFIafmEtVIY4ensn8ZwUktJ1AGn09k7OI6snAxi9vRNv9wGUFGOOjwlnLuSGO3ozWGpF0ujHMsUByOwDGL4dLw1g9GOZ4gBGP5YpDmD2DVEavm4XBqDD1+3SAMav24UBzF6JdfZKrLNXYp29EuvslVhnr8Q2uiv/tTvTBneoJT0uTpZxZ9rgDrVS+oM71Erpy9zpD+5QSyme6cdM+oM71ErpD+5QK6U/uEOtlP7g/rTX6Uc3eNUtpT961S2kP3rVPdNXFzLpj151C+mPXnXTYe1Vcpn0R6+60V6mP3rVLaQ/etUtpD941dXz7pF6yqQ/eNUtpD/6E+il9Aevumr3W4+ZuT/6E+il9AevuqX0B6+6pfQHr7p3E4y5nHQHr7ql9Ed/BrqQ/uhVt5D+6FX3dfo8etUtpD961S2kP3rVffhiR2bd59Grrp7PgWbevhBHf/fF65dHRB696hbSH73qFtKf+s0jcfQ3j5TSH73qvk7f79eF//4XF0a/Xxf+TS8upOPUy4TlyqJsFhuwuF9F2oLF/brwFizu14V/G4v+zmK4srhfi9uCxf268AYsyn5deAsW96eOWrC49y4tWNx7lxYsymbxO1n0135R9t7l21g8Xwgqkl5fzOaPo2e28HDyHzMXB6dHGsGZPV785e+zd0Vj/332fmvsv8/eyY3999l7xKH/PmHvPsf+++y9xDf9fdL5RnRJfOmCw+6yfv9nsGLYvVALFnfH0oLF3Vc0YDHu874G1SXuGv1NLJre56K/siibxQYs7vO+FizufrEFi7tfbMHi7hdbsLj7xQYspn1a1ILF7VX4Nhb9Sxb33qUFi3vv0oJF2Sw2YHHvXb6bxXRlce9dWrC49y4tWNx7lxYs7r3Lt7AYzg+cWGC6sKh779KCxb13acHi3ru0YHHvXVqwKJvFBizuvUsLFvfepcFdfd17lxYs7r1LCxb33qUBi7b3Li1Y3HuXFizuvUsLFvfepQWLsllswOLeu7Rgce9dWrC49y4tWNx7lxYs7r3L72cxub13acHi3ru0YFFWZTGE42KJD28tzV6spAcftx/9lcVl+8XvYpHd+VGR22CvLC7bLzZlcdl+sSmLy/aLTVlctl/8PhbvH1vihw8jHyzSsv1iUxaX7RebsrjsWXdTFpc9627KomwWG7C49y4tWNx7l2/aR9tDv0hXFvfepQWLe+/SgsW9d2nAIu+9SwsW996lBYt779KCxb13acGibBYbsLj3Li1Y3HuXFizuvUsLFvfepQWLe+/SgEW/9y4tWNx7lxYsymbxG1h0fLid1Hm7srj7xW9iMbiTxchXFne/2ILF3S+2YHH3iy1Y3P1iAxbX/W5pUxZ3v9iCxX3W3YLFfdbdgkXZLDZgce9dWrC49y4tWNx7lxYs7r1LCxb33qUBi+t+9bIpi6v2i6TxzEPT9THTIJuYPDGrdnVFYlZt1IrErNp7FYlZtZ0qErNqh1QiJq7a9BSJWfUM9nYX3o6LbyldiVn1WLVIzLKdb4kY2cTkiVm28y0Rs2znWyJm2c63RMyynW+JmGU73wIxy362tEjMqp0vO3cQw85fX3G27Acdi8Ss2scUiVm1jykSs2ofUyRm1XLNQodvnUWu7v9lv45WJGbZqhTp+KI6R7neiVz261tFYpatSlFOKcV0XXyX/UbWbcY8EHPdEiz7qaEiMcvulRIdQ+SUeRnYsh8EKhKz6l2CIjGyickTs2wfUyJm2T6mRMyyfUyJmFXvEhSJWfbYIZo/iZHL69t12Q/VFIlZtvMtEbNs51siZtnOt0SMbGLyxKx7glcgZt0TvAIx657gFYhZtvMtEbM73zwxy35yp0jMbvCeELMbvCfEyCYmT8xu8J4Q06Bcf36r8ZFQYv1AzBcQawFyPg78+UnOK0iLrx+UQQgBwggQ3wTkNHjebvZnQAQBEhAgEQGSECCKADEAiG+ieH8HCTkQQoAwAsQjQAQBEhAgEQGSECCKADEAiCAULwjFC0LxglB8izfOfT5PO0Buu7sMSECARARIQoC0ULzSHcRnOsgWL4MqgrR4V1IZhBAgjADxCBBBgDSp8RbvOpEMSESAJASIIkAMABIdAoQQIIwA8QgQQYAgFB+b1PhwB3l4M90dJCFAFAFiAJDUpMbfT1DVKANCCBBGgHgEiCBAAgIkIkCaKF7CXSeZrj4pAsQAIOoQIIQAYQSIR4AIAiQgQCICBKF4baF4Ox3Ztx8tA2IAkBYP9pVBCAHSQvHG5y1cC5l60uLhrTKIIEACAiQiQBICRBEgTRTv6ARhdwEx5xAghABhBIhHgAgCJCBAIgIkIUAUAYJQPDVRfLqX32QZEEKAMALEI0CaKP40nLFzMQMSECARAZIQIIoAMQBIE89dEaSJ4uN97dLM2tXEc1cE8QgQQYAEBEhEgCQEiCJADADSxHNXBEEovoXnju/fQGfnJQPiESCCAAkIkBaPGzp/vpTMZW43WZOPgRdBFAFiAJAmX1oughAChBEgTRRP8a6TkAERBEhAgEQESEKAKALEACBNvk9YBCEECCNAEIpv8lE/97DTskxL1OQDeUWQiABJCJAmij+fE2TK/uENANLk41xFEEKAMALEI0AEAdJE8ecZ5A2PMiARAZIQIIoAMQBIk4+SFEEIAcIIEI8AEQQIQvFNPkdBp22UKWOOsSafdiiCKALEACAtPHe333we4JBqBoQQIIwA8QgQQYAEBEhEgDRR/Om5u+FlziBVESAGAGnyMv0iCCFAGAHiESCCAAkIkIgAQSjeEIq3/oq/3T7P6uTzbaivYZ/nRgGEItP5xHf0D0l9/pBJ5pcHd77p6HbuQoXLXfT3FyNFefg2Coevg/DvMAh5h0GEdxhEfIdBpHcYhL7DIOwNBpF3as42CHqHQbxDxaZ3qNj0DhWb3qFi0ztUbHqHik3vULHpHSo2z1Cxz/fjfh5QbhAzVOziIGao2MVBzFCxi4OYoWIXBzFDxS4OYoaKXRzEDBW7OIgZKnZxEDNU7NIg/DtUbP8OFdu/Q8X271CxfZM64YXvg4iFQYiE46ayiN5zIs3/cru/Nt+5Qiqe7bx748P96VuKVNfl+7T5ecmPbn5e8mObn1f8iNv8vOSHNj8v+eHNz0t+/Nr8lPofkc3PS37C5uclP4v3z0V+Fu+fi/ws3j8X+Vm8fy7xExbvn4v8LN4/F/lZvH8u8rP759f8yObnJT+7f37Nz+6fX/KTfxw86vHKm8eUmL8+dJB/vLsUlL4/iPJv+/38ubNjWBrvNylu7dzXsHzVYTn/6vwQ5o8oXxUlVVGhKipWReX3SJzOV9Gz6TVKa6KeuFsDnfMw0DXDJ3bSUpRURYWqqFgVlWc+3lefGN01SquirCbqicusFEVVUVwV5auipCoqVEXFqqiqucFVc4Or5oavmhu+am74qrnhq+aGr5obvmpuPLn/HZXvRZ+vUakqSquirCbqyX21UhRVRXFVlK+Kyv+Vhc8okes6/+SUthSVqqK0Kspqop6c/pSiqCqKq6J8VZRURVXNjVA1N0LV3AhP5sa5IbnNuesaFawmKrqqKKqK4qooXxUlVVGhKipWRaWqqKq5EavmRqqaG6lqbqSquZGqdhypaseRqnYcqWrHkX/nz23jeKfjthN/iPt6EED59/hQSmd7kywDx1VRvipKqqLy5Kuen3c0F65RsSoqVUVpVZTVROVfEFOMoqoororyVVFSFVU1N6xqbljV3LCquWE1c4Odq4qiqiiuisrOjc8PaH2N+vAm3TNKqqJCVVSsico/nJ/0cG6rux+0HUejnH8YvhTENUG+JkhqgkJF0LPDqAfjO9/fnBPD16gnhwASc9v5MypURVlNhs+OXwpRVWw8O34pRPmqKKmKClVRsSoqVUVpVVTV3JCquSFVc0Oq5saz45fXSpEqVUqVKp8c2pSiUlWUVkVZTdSTQ5tSFFVFcVVU1dwIVXMjVM2NUDU3QtXcCFVzI79rSOe3SpKke59B7muQVQTl9wylIKoJyncnFM4g/RB0veOtdnwCyigWrpXz3aNi9zvjHL/m4gfKRQbKJQyUSxwmF5/fPQnfvSCcPkRdAYK4Q/JBHkrqCUH9Ibg/hO8PIf0hQn+I2B8i9YfQ/hDWHYL6qzu/YQ7h/EzQ7ceHmhm+RoWqqFgVlaqitCrKaqLybpZiFFVFcVWUr4qqmhtcNTe4am5w1dzgqrnBVXPDV80NXzU3fNXc8FVzw1fNjfxxSojn5zpDFLtGxaqoVBWlVVFWE5U/TvkQ9fDy7TPqCRvp2OSEDw6TIyqfoYUzyvQald/UF6OoKoprovL36KM7rbrRhSvzT/zHLrkzKoelVViWjzqPlyNl/l75e9nFKKqK4qoo/yQq3KP8NUqqokJVVKyKSlVRWhVlNVHqamavUlUUV0X5qiipiqrSssaqqFQVpVVRVhNlVXPDquaGVc0Nq5obVjU3rGpu5G9ki50emNuP9K9R8uQophRFVVFcFeWroqQqKlRFxaqoVBWlVVFVc4Oq5gZVzQ2qmhtUNTeoam5Q1dygqrlBVXODquYGVc0NfhIl93PfeI16stej0/IRHr/DekY9+XvZ0ekF9/A83BkVqqJiVVR+n3K3stx+vHREkr9ZHFxwJxvXDlbyN4tvHOqdQ7lGSVVUqIqKVVGpKiq/8yV/jwqZKKuJerKvLEVRzZwPVUoJvipKqqJCVVSsikpVUVoVZTVR0VVFVc2NWDU3YtXciFVzI1bNjVg1N2LV2ps/qXhce128YuVPKoLTO5amaxRXRfmqKKmKyv+9XEr3KL1GxaqoVBWlVVFWE6WuKoqqorgq6sncSPwySqqiQlVUrIpKxSi7dkSqVVFWE2WuKurJ3Ih6j7quUcZVUb4qSqqiQlVUrIpKVVFaisr12GYVnXlwriqKqqK4KspXRUlNVH7XpnL608PDX0u+xuRNge78DCx9qMpHlFZFWU3UEzNxKSpvGCU+bcGU9BrFVVG+KkqqokJVVKyKSlVRWhVlNVFPzMSlqKq5EarmRqiaG6FqboSquRGq5kZ+p/d6rXnyJLej+1uc/TXqydPVpShfFSVVUaEqKlZFVa3XsWq9jlXrdapar588XV2K4qooXxUlVVFP5kY81fXhztIRFauiUlWUVkVZTdTT579fR1FVVHlu5KKq5oZWzY0nD3+XomJVVNW6oVXrhlatG1a1bljVumFV64ZVzQ2rmhtWNTesam5Y1dywmr9ydK4qiqqivvuv/I/bv/7fT3/9+ac//fLnv91iPv/H//n133/7+S+/fv3nb///v7/8l9vF/ws=","brillig_names":["swap_public"],"assert_messages":{"317":"Nested static call failed!","1719":"Array index out of bounds","1847":"attempt to add with overflow","2231":"Index out of bounds","1902":"Array index out of bounds","1640":"Array index out of bounds","37":"Not initialized","1701":"attempt to add with overflow","1957":"attempt to add with overflow","1689":"Array index out of bounds","1939":"Array index out of bounds","1738":"Array index out of bounds","2372":"attempt to add with overflow","1598":"Array index out of bounds","1659":"attempt to add with overflow","2494":"Array index out of bounds","245":"Nested call failed!","1586":"attempt to add with overflow","434":"Nested call failed!","1708":"attempt to add with overflow","2482":"attempt to multiply with overflow","1891":"attempt to add with overflow","1629":"attempt to add with overflow","666":"L1 portal address of input_asset's bridge is 0","1946":"Array index out of bounds","2586":"Array index out of bounds","1873":"Array index out of bounds","1678":"attempt to subtract with overflow","2062":"Stack too deep","2056":"attempt to add with overflow","2446":"attempt to subtract with overflow","1983":"Array index out of bounds","252":"Message not authorized by account","1575":"Array index out of bounds","1636":"attempt to subtract with overflow","1880":"Array index out of bounds","1618":"Array index out of bounds","655":"Nested static call failed!","1935":"attempt to add with overflow","2258":"attempt to add with overflow","1990":"Array index out of bounds","1917":"Array index out of bounds","1594":"attempt to subtract with overflow","2039":"Array index out of bounds","2490":"attempt to add with overflow","2033":"attempt to add with overflow","1826":"Array index out of bounds","2466":"attempt to add with overflow","1369":"Array index out of bounds","2454":"Array index out of bounds","595":"Nested static call failed!","1869":"attempt to add with overflow","1674":"attempt to subtract with overflow","2570":"Array index out of bounds","1924":"Array index out of bounds","1851":"Array index out of bounds","1979":"attempt to add with overflow","2296":"call to assert_max_bit_size","1833":"Array index out of bounds","1382":"attempt to add with overflow","1961":"Array index out of bounds","1760":"attempt to multiply with overflow","541":"Nested call failed!","2016":"Array index out of bounds","1815":"attempt to add with overflow","2339":"attempt to add with overflow","2394":"attempt to add with overflow","1614":"attempt to subtract with overflow","2120":"Array index out of bounds","2376":"Array index out of bounds","1858":"Array index out of bounds","2504":"attempt to add with overflow","2236":"Array index out of bounds","1913":"attempt to add with overflow","2486":"attempt to subtract with overflow","1712":"Array index out of bounds","1968":"Array index out of bounds","2352":"attempt to subtract with overflow","1895":"Array index out of bounds","2474":"attempt to add with overflow","2602":"attempt to add with overflow","670":"L1 portal address of output_asset's bridge is 0","1822":"attempt to add with overflow","2139":"attempt to add with overflow","1749":"attempt to add with overflow","1682":"Array index out of bounds","1999":"attempt to add with overflow","2383":"Array index out of bounds","2578":"Array index out of bounds","1670":"attempt to multiply with overflow","1731":"attempt to add with overflow"}},{"name":"swap_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"input_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"input_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"input_amount","type":{"kind":"field"},"visibility":"private"},{"name":"output_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce_for_unshield_approval","type":{"kind":"field"},"visibility":"private"},{"name":"uniswap_fee_tier","type":{"kind":"field"},"visibility":"private"},{"name":"minimum_output_amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_L1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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","brillig_names":["pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","pack_arguments_oracle_wrapper","call_private_function_internal","pack_arguments_oracle_wrapper","pack_arguments_oracle_wrapper","unpack_returns","build_msg_block","attach_len_to_msg_block","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"192":"attempt to add with overflow","771":"Array index out of bounds","599":"Array index out of bounds","203":"Array index out of bounds","479":"Array index out of bounds","502":"Array index out of bounds","787":"attempt to add with overflow","214":"attempt to add with overflow","496":"attempt to add with overflow","525":"Stack too deep","618":"attempt to add with overflow","519":"attempt to add with overflow","196":"Array index out of bounds","452":"Array index out of bounds","702":"Array index out of bounds","755":"Array index out of bounds","763":"Array index out of bounds","373":"Initializer address is not the contract deployer","82":"attempt to add with overflow","367":"Initialization hash does not match","399":"SharedImmutable already initialized","463":"attempt to add with overflow","710":"attempt to add with overflow"}},{"name":"_approve_bridge_and_exit_input_asset_to_L1","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"token_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQDBCQCBAAFHxgABQAEgEMrCIBDAAErCIBEAAIrCIBFAAMiAAs4AIBGAAAiAvsqCAEFAAABAgEkAgEABioOBgUqCAEFAAABAgEkAgAAByoOBwUqCAEFAAABAgEkAgACCCoOCAUeAgAABR4CAAAIMDgABQAIAAkkAgEBBSECAB4ACTkBAAAeAgEACB4CAAAJCjgICQohAgAjAAo5AQAAKggBCAAAAQIBKg4FCCgCAAAAAAAAAAACAAAAAAAAAAAABSQCBA4NKggADioMBQ8AEAANACIDACoEAAAqDA8JKgwQCioMEQsqDBIMKg0JBQAoBQIFKg4FCSoIAQUAAAECASoOCQUqDQoJACgJAgkqDgkKKggBCQAAAQIBKg4KCSoIAQoAAAECASoOCwoqCAELAAABAgEqDgwLJAICAAwqCAENJAIEIA4AEAEOASQDBAENACgNAg4kAgQfDwA4Dw4PKgwOEAw4EA8RFgwRESECAFIAESoODBAAKBACECAATCoNDQ4AKA4CDioODg0qCAEOAAABAgEqDg0OJAIEHg8kAgIpECQCAkYRJAICaRIkAgJfEyQCAnUUJAIEARUkAgQfFiQCBAAXJAICLBgkAgJlGSQCAmMaJAICcBskAgJyHCQCBCAdKggBHiQCBCEfABABHwEkAwQBHgAoHgIfKgwfICQCAmIhKg4hIAAoIAIgKg4UIAAoIAIgKg4cIAAoIAIgJAICbiIqDiIgACggAiAqDhMgACggAiAqDhsgACggAiAqDhQgACggAiAqDiEgACggAiAkAgJsIyoOIyAAKCACICoOEiAAKCACICoOGiAAKCACICQCAigkKg4kIAAoIAIgKg4kIAAoIAIgKg4RIAAoIAIgKg4SIAAoIAIgKg4ZIAAoIAIgKg4jIAAoIAIgJAICZCUqDiUgACggAiAqDhAgACggAiAqDhggACggAiAqDhEgACggAiAqDhIgACggAiAqDhkgACggAiAqDiMgACggAiAqDiUgACggAiAqDhggACggAiAqDhEgACggAiAqDhIgACggAiAqDhkgACggAiAqDiMgACggAiAqDiUgACggAiAqDhAgKgwXBCAAsww4BB0fIQICxAAfIAC2Kg0IBCECALkABCAAzSoNDgQkAgQYDCoIABgqDAQZKgwGGgAQAAwAIgMf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","debug_symbols":"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","brillig_names":["_approve_bridge_and_exit_input_asset_to_L1"],"assert_messages":{"896":"attempt to add with overflow","637":"attempt to add with overflow","1015":"attempt to add with overflow","34":"Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally","671":"attempt to add with overflow","988":"Index out of bounds","854":"attempt to add with overflow","1107":"Array index out of bounds","589":"Array index out of bounds","839":"Array index out of bounds","580":"Nested call failed!","705":"attempt to add with overflow","766":"Stack too deep","827":"attempt to subtract with overflow","760":"attempt to add with overflow","620":"Array index out of bounds","1123":"Array index out of bounds","29":"Not initialized","477":"call to assert_max_bit_size","654":"Array index out of bounds","715":"Array index out of bounds","450":"Nested call failed!","831":"attempt to subtract with overflow","1139":"attempt to add with overflow","688":"Array index out of bounds","877":"Array index out of bounds","993":"Array index out of bounds","1115":"Array index out of bounds","600":"attempt to add with overflow","722":"Array index out of bounds"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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KDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEAKDECMSoOGzEA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AAAkAgQgJww4JScoIQIK8wAoOQEAAAAoCwInADgnJSgqDSgmHAwAJiUEOCUkJgA4IyYkKg4kIAA4BAgjDjgEIyQhAgr+ACQ5AQAAKgwjBCAHbioNIiMCOAsgJA44IAsmIQILBQAmOQEAACQCBAgnDDgkJyghAgsJACg5AQAAACgjAicAOCckKCoNKCYcDAAmIyoIASQkAgQFJgAQASYBJAMEASQAKCQCJkE6ACMAJgAEAAQAKgwRISALFQw4IQYjIQILHgAjIAsYADggCCEOOCAhIyECCxwAIzkBAAAqDCEgIAdeKg0lIwQ4BiAmJAIEACgKOCggJyECCycAJwY4JiArCjgrBiohAgsnACo5AQAAAjgdJicOOCYdKCECCysAKDkBAAACOCchJg44IScoIQILLwAoOQEAACQCBAQoDDghKCohAgszACo5AQAAACgkAigAOCghKioNKickAgQgKgw4JiorIQILOgArOQEAACsEACOAAyUABAAhgAQiDP4rCIAFACgAKCgCKgA4KiYrKg4nKyoOKCUAOCEIIw44ISMmIQILRgAmOQEAACoMIyEgCxUqDSEmADggIygOOCAoKyECC00AKzkBAAAkAgQILAw4IywtIQILUQAtOQEAAAAoJQIsADgsIy0qDS0rJAIEQC0MOCgtLiECC1gALjkBAAArBAAmgAMlAAQAQYAEIgz+KwiABQAsACgsAi0AOC0oLioOKy4qDiwhADgjCCYOOCMmKCECC2QAKDkBAAAqDCYjIAcnKg0hJSQCBEAoDDgjKCohAgtrACo5AQAAKwQAJYADJQAEAEGABCIM/isIgAUAJgAoJgIoADgoIyoqDhsqADgjCCUOOCMlKCECC3YAKDkBAAAqDiYhKgwlIyAHDAQ4IwQlJAIEACgKOCgEJiECC4EAJgY4JQQrCjgrIyohAguBACo5AQAAJAIEKyoqCAArKgwgLCoMJC0qDCUuABAAKgAiEIkqBAAAKgwsJioMLSgMOCUkKiECC44AKiALkyoNJioAKCoCKioOKiYqDiYiIAuTDDglJCYhAguWACYgC5gqDighIAuYDDglJCYqDSElCjglIygEOCYoJSECC54AJSALtCoNIiUkAgQqKCoIACoqDCUrABAAKAAiEN4qBAAAKgwrJioNJyUqCAEoJAIECSoAEAEqASQDBAEoACgmAioAKCUC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","debug_symbols":"7b3djiQ9ciT6Lt+1Lkj/I6lXOThYjHa1iwEGo4U0e4ADQe++2V0VkVlfRhW7PINsY5A3Qn+a8KCZlYfTyQxj/Ocf/+Nf/+X//K//9te//89/+48//vn/+c8//vZv//0v//jrv/399l//+V//9Me//Ptf//a3v/6v//b4//4j/Pg/Mfy8/j/+91/+/uM//+Mff/n3f/zxz8z6T3/869//x+1fEm7x//Ovf/vXP/5ZVP/r//2nP2L8doh8c5R/ero25yjvF+f844r3q2N+GyC2HoBaD8CtB5DWA2jrAez7iZe+H5K/H1K+HaLff+70+8+d0vdD+Psh8v2Ql3NFLL1fK4X3a8l+3t2a3j01vXt++Smisj1EIvu1HA6vjRuSrPzh2h9QCgwUCzhQIg4UwoHCOFAEB4riQDEcKF3riiZ+v1aT/BlK6voEad6u1ZKfoDAOlK5PkMmWK2ZPuZIUB4rhQEk4UDIOlAIDJQccKBEHCuFAYRwoONU241TbjFNt8+vV9qt2KOe2ty9Nb19C29vHtrentrfntreXtrfXtre3trdv+9SWl5/aaCW8XxxTeNoiK6XxADGE5iPE5iNQ8xG4+QjSfARtPoI1HyE1H6HpI31wte4dSlQp+9Uxx4OrudgOpDzsZPz4ceSooclx62ikpA9X/+RaenNNtF1twSpco+h+tZT7D0GlHJVp3cv0w1bG7dIfPGOYhGechCdNwpMn4SmT8FRsnhLuPO0JvI0MPo0MPo8MHrzH+BI8gTcOX4MH7wa+Bo89xev+jtKtf69MCbQ34RzifqnmN57YU/x5PGUSnthT/Ld4ygaa7L52fN/5ioTdDpxIFLt1OJEodpvxLaJp68Kp8DNR7JbkPKKM3b4o233n66kDYOyZ8XbJfjVJZVF41ktTkbGn0d8kCvac+5tEwZ6ff5Mo2HP5bxIFe97/TaJg9wi/RxTB7id+kyjY2yy/SRTs7ZvfJMrqaA9EkSXKsyiroz0QZXW0B6KsjvZAlNXRHoiyOtpnUXR1tAeirI72QJTV0R6IMueU/KWbNOqchfZLM2m0OQttRZQ5C+2XPqtocxbaiihzbh1URJElyrMoc24dVESZs0+piDLn1kFFlDm3DiqizNnRfi1KmrOjrYiyOtoDUVZHeyDK6mgPRJHriPLpxtHBjVPeX3lMDz5VfjsNMaYL9bRnynKhrvZMWS7U135Hliz7jbOWZ1ku1NmeKcuFetsTZckX6m6/I0uhzdwTC8uzLBfqb8+U5UId7pmyXKjH/ZYsaQddMj/LIkuWI1km7XJrsszZ5VLYT52gYPosy5xdblWWObvcqixzdrkUMu+yPBwysMlS5uxyq7LM2eVWZZmzy63KMmeXS3H3aVOk522o189lvaYsc3a5VVkm7XJrskza5cb7SR1R87Msk3a5NVkm7XK/loXCpF3u7QeyXZZcnmWZtMutyTJpl1uTZdIul8J+wtDt38+yyJLlSJZJu9yaLJN2uTVZJu1yifMui9KzLJN2uTVZJu1yK7KAH/L/22SZtMul/VdFoizPskza5dZkmbXLrcgic8rCYf9VkaM9yzJpl1uTZdIutybLpF1uTZZJu1zmfeef5XnTEvy7Eb9LFvAvUvw2WSbtcmuyTNrlsu17uZyf91vAP7rx22SRJcuRLLN2uWXfWJD4vLEA/gGQ3ybLrF1uRZZZ38uN+8aC0McJ+vlqibbdWmJ+vDq9iTjrW7xnigj+UZRBRJz1DeFvichlAy0S+VnEWd8nPlXESXv5c0WUJWJdRNtvLcYHNXHSdcK5Is7q9jtVxFm9gd8SMctm3pZsBzVxrVhOEHGtWF4X8UqfXfrqOHG60qeUviY6Q+f/g+ikJ1x/eUA8TXrCdUWUOc8DrIgicx6SGLf50MieRZn0hOuvRZn0hOuvRZn0hOuvRZn0hOtwFyU9izLpCddfijLrCddfizLpCddfizLpCddfizLpCddfiyJLlGdR5uxov/w4Fl3pdOvzRJmzo62IMmdHWxFlfYXwWZQrnWp9niiT7tF+Lcqke7RfizLpHu3XosgS5VmU1dEeiLI62gNRVkd7IMrqaA9EWR3tsyhXOsH6LFH4t5558vB67bEoybaffFO6C6j5DTqNC713d2hWduhZK9CFdMMut/3qh6uP7p3zfi5tzqofrv7JVSbiqhNxtYm4pom45om4FmiuvL+dIEz2hL77ARfnoo9DoyfspyTTHX16Rg/ef1TQy9DowXuECnrwWb+CHnwer6AHn5kr6LvPtfvCN6YYPqD/gae7ub2GJ4LhITA8DIZHwPAoGB4Dw5PA8HSv5rt17oantn1FlndbXgpUuTrtVHO47zHSbRvzJ9OCzVTuTK26TRukbC6uGJQfv8P0Ns91tyD+XrZxKrY0FVueiq1MxVanYmtTsU1TsQXvo05mO1UvpVP1UjpVL6VT9VI6VS+lMhXbqXopnaqX0ql6KZ2ql9KpeimbqpeyqXopm6qXsql6qe4HG/1etlP1UjZVL2VT9VJ2qV5Khe9s1Z7ZXqqXqrFNl+qlqmwv1UtV2V6ql6qyvVQvVWUrU7G9VC9VZXupXqrK9lK9VJXtVL1UvtZ8+9AnWyjPbC9Vk00f2Kb4zPZSNbnK9lI1ucr2UjW5yvZSNbnK9lLr2xrbcqn1bZXtpebbKttLrW+rbC+1vq2ylc5sE+2HlqQHPJvHoSgYHgPD07tjyLwvPbLmSr5xuAMJer83R3pD37sDyHlXswSpoJfA22eWJchHB/fz1aayXW1q/OHqn1x7z//Z9M61VhnSfmZyYvvz30lC6J5ldMee/pz1EiIYHgLD8/qcFfaPmMZ4mxsqV1PYnWr0WBXkPX8EDI+C4bHeeO5Xc0wf8DxfrSbb1WrPlU1CGhp9Hhp9GRl9DEOjj0Ojp6HR89DoZWj0OjT6oefaCD7XUtrRp/wB/cHexa0GbXsXQve17a1ZeuMKPjOfyhV8Hj+TK/We9Vn3lTCn8NR9UwTDQ2B4GAyPgOFRMDy9Zzi97wmqlkotsRC2WmKBytMMR2lo9Hlo9GVk9ByGRh+HRk9Do+eh0cvQ6HVo9EPPtTz0XMtDz7U89FwrQ8+1MvRcK0PPtTL0XHvCGW+nof+JB2j2/IkHaD78iaf7DFe2t0A+fITJmW15aPRlZPQahkYfh0ZPQ6PnodHL0Oh1aPQ2NPqh51odeq7VoedaG3qutaHnWht6rrWh59reJzPp/kky5drb71z298e5JPmA/YCp5O3WJiU9M+3s47g7pNW0xjTvn2Xl/Cfsz1envDtuUv7T9wN/Mv3mHP4zJjlisiOmfD/muyfV/IyJjhh2xMj3Y173nFS+CSmvOz0qI+jrfozqCLH5CNR8BG4+wvfzT7/rPfgZY46Y5IjJjpjv1xSNwRETHTHkiGFHjCMPoiMPoiMPoiMPoiMPoiMPyJEH5MgDcuQBOfKAHHlAjjwgRx6QIw/IkQfkyAN25AE78oAdecCOPGBHHrAjD9iRB+zIA3bkATvyQBx5II48EEceiCMPxJEH4sgDceSBOPJAHHkgjjxQRx6oIw/UkQfqyAN15IE68kAdeaCOPFBHHqgjD8yRB+bIA3PkgTnywBx5YI48cOxBqGMPQh17EOrYg1DHHoQ69iA0OfLAsW+hjn0LTY48SI48SI48SI48SI48yI48yI48yI48yI48yI48yI48yI48yI48yI48yI48KI48KI48KI48KI48eP3UpUz795PlvlfP4f3+2vj+1vj+qfH9c+P7l6b3txP2g7++f2x8f2p8/9d3guP2Q15Wfr6/NL6/Nr6/Nb5/anz/3Pj+pe39Xz8HpXL/78995tg7N8feuTn2zs2xd26OvXNz7J2bY+/cHHvnRk3PZPs5Qmw+AjUfgZuPIM1H0OYjWPMRUvMRcvMRSusRuPkzzc2faW7+THPzZ5qbP9Pc/Jnm5s80N3+mT3B45nI/8TVK5epTT3y1ExyeD+fV5lJ7N/HLM1ztBMfmF2h+jvD6c1nubq5S5RtvM+MO6DbD3N/cS9z8j3uCEfCbZDnsz8qtjJcKWdLt5kJ/ekvx2+852Qkuw4HI2kxk00xk80xky0RkTzBrNiXL+4v3wmTP8OPY8Gls+Az+pGS6w0/P8GVs+Oi9RQU+erdQgY8+/1fgo8/oFfjoc/TX8O33zrocvoaf8v6bYLifWUskb+AjEPifgAgNEKMB6j/T7adx3/798HmtDZCiATI0QAkNUEYDVMAApYAGKKIBIjRA/XdeY7kDSvb1RByLBtnvrg+fsTu+PMjDF5+V743H+1cKLclkfHUyvjYZ3zQZ3zwZ3zIX3xwm4xsn40uT8Z2sv/quL2V4vpP1V3my/ipP1l/lyfqrPFl/VSbrr8pk/VWZrL8qk/VXr/s9B+M7WX9VJuuvymT9VZmsvypz9VcpzNVfpXCx/up++u/t32rPfC/WX1X5Xqy/qvKVyfherL+q8r1Yf1Xle7H+qsr3Yv1Vle/F+qsa33ix/qrK92rz70M/aaE8871YfTZ94Ptw+c73YvW5yvdi9bnK92L1ucaXLlafq3wvtv6t8r3Y+rfK92Lzb5WvTMb3YuvfKt/+No98fwH95zVfEki0fw0sJo7568vJeLs5Wbojf7eZJUpTsc1TsS0zseUwFds4FVuaii1PxVamYqtTsZ2ql+KpeimeqpfiqXopmaqXkql6KZmql5KpeqnfcHDm72Q7VS8lU/VSMlUvJVP1UjJVL6VT9VI6VS+lU/VSOlUv9RuO/vydbKfqpXSqXkqn6qV0ql5Kp+qlbKpeyqbqpWyqXsqm6qV+w+GyLdmm/Shdyvzx6Obnq7PQdu8sD+8b7dpcq/M6V5tr9WnnanOtru5cba7VA56rzbU6xlO1SdfqL8/V5lrd6LnaXKt3PVeba3W652ojS5tPtVl98efarL74c21WX/y5Nqsv/lyb1Rd/qk1effHn2qy++HNtVl/8uTarL/5cG1nafKrNtfriohtwKpae2V6r062xvVbvWmN7rW60xnak/lJT5fOlkW4T2Hb5LbJUqhpJ3H8hvBW4/WoK5ac6ZaQOs786I/WY/dVB7zK17CdUJKMPJ1T8xI/eCdbwy+D40TuqGv6XuwYKvI1A4eHxPb6a96eXc3649h1NhkJTgNDk18++PhVNhEJDUGgYCo2ciiZb5erMYV+DMt+vjiW+4VEwPAaGJ4HhyWB4ChaeGMDwRDA8BIaHwfCA1ecIVp8jWH2OYPU5gtXnCFafCaw+U+/6LNk2PBrDBzyv769ETvvuDef73TnSG1uaii1Pxfb1mYtkO1CV6GHf+5N1TrH91iVJBb3Jvq9oUp721PPrZ9NS1P1vRaG2c6Mlb3AC37V8X6W9fnLsqWgSFJoMhaYgoXn95NJT0UQoNASFhqHQCBQaqFrMULWYoWoxQ9VihqrFAlWLBaoWC1QtFqhaLFC1WKBqsUDVYoGqxQJViwWqFitULVaoWqxQtViharFC1WKFqsUKVYsVqhYrVC1WqFpsULXYoGqxQdVig6rFBlWLDaoWG1QtNqhabFC12KBqcYKqxQmqFieoWpyganGCqsUJqhYnqFqcoGpxgqrFCaoWZ6hanKFqcYaqxRmqFmeoWpyhanGGqsUZqhZnqFqcoWpxgarFBaoWF6haXE6txZxqb52ZynZr03THs73PWQQMj4LhMTA8CQxPBsNToPCUEMDwRDA8BIYHqz6XgFWfS8CqzyVg1ecSsOpzCVj1uQSw+nyC/1HvZ1wp1a4+1QVQTnBLSs47+rpX+9M7/0RDUGgYCo1AoVEoNAaFJkGhyVBoChKaE7yRZ6KBqsUEVYsJqhYTVC0mqFpMULWYoGoxQdVigqrFDFWLGaoWM1QtZqhazFC1mKFqMUPVYoaqxQxVixmqFgtULRaoWixQtVigarFA1WKBqsUCVYsFqhYLVC0WqFqsULVYoWqxQtViharFClWLFaoWK1QtVqharFC1WKFqsUHVYoOqxQZViw2qFhtULTaoWmxQtdigarFB1WKDqsUJqhanU2txCq++lZIIDA+D4REwPAqGx8DwJDA8GQxPwcKTAxgesPqcwepzBqvPGaw+Z7D6nMHqcwarzyd4/W6/yW0Xh1C7+stvEJUTvH4nojnB63cmmgiFhqDQMBQagUKjUGjsXDS1+qeRtmqp0Z7r3wkuv3PxZDA8BQpPDCGgAYpogAgNEKMBEjRAigYIq0zfAGHV6RsgrEJ9A4RWqSNapY5olTqiVerYu1JT2W6t/PidKcd3qd4IyOgEdHQCNjqBNDqBPDqBMjiB1+2SHPJmvecotc/7fbnkvsGJWHAICw5jwREsOIoFx7DgpFPhKL/awL1unDwbUAEDxAENUEQDRGiAGA2QoAFSNECGBgitUjNapWa0Si1olVrQKrWgVWpBq9TSu1KfvZQUHZ2AjU4gjU4gj06gDE5Aw+gEXp/5SNN2MZVcufrH730bott+0X41x/AOiE4AZNvFHJ6MCrchuP0Q0n6I1+cPCXvqSXXDpP6XsxMA8R1QPuCc2g+R2w/xetVTpX33KtX+cla2TLLyuGMub3Bet3SeCyf2hZPD9oNCNj2AQ1hwGAuOYMFRLDiGBSdhwcl94ZSw3blQOYBToOCkgAUnYsEhLDiMBUew4HSuyiXZ3qgGOcBjYHgSGJ4Mhqdg4ckBDE8Ew9O5OP9o0jdAMR4UoMxogAQNkKIBMjRACQ1QRgPUuUzHaLIDOtpJKAENUEQDRGiAGA2QoAFSNEC9KzXJ428aB4ASGqCMBqhgAYohoAGKaIAIDVDvSs371ZGLHQASNECKBsjQACU0QBkNUAEDFHtXatn9PlGSHACKaIAIDRCjARI0QIoGyNAA9a7UlveXTdKHt182QBkNUAEDRAENUEQDRGiAGA2QoAFSNECGBgitUhNapSa0Ss1olZrRKjWjVWpGq9SMVqkZrVIzWqVmtErNaJWa0Sq1oFVqQavUglapBa1SC1qlFrRKLWiVWtAqtaBVakGr1IpWqRWtUitapVa0Sq1olVrRKrWiVWpFq9SKVqkVrVIbWqU2tEptaJXa0Cq1oVVqQ6vUhlapDa1SG1qlNrRKndAqdUKr1AmtUie0Sp3QKnVCq9QJrVIntEqd0Cp1QqvUGa1SZ7RKndEqdUar1BmtUme0Sp3RKnVGq9QZrVJntEpd0Cp1QavUBa1SF7RKXdAqdUGr1AWtUhe0Sl3QKnUBq9QUwCo1BbBKTQGsUlMAq9QUwCo1BbBKTQGsUlMAq9QUwCo1BbRKHdEqdUSr1BGtUke0Sh3RKnVEq9QRrVKjeRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FQvMoEppHkdA8ioTmUSQ0jyKheRQJzaNIaB5FRvMoMppHkdE8iozmUeQAVqkZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0jyKjeRQZzaPIaB5FRvMoMppHkdE8iozmUWQ0j6KgeRQFzaMoaB5FQfMoSgCr1ILmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdA8ioLmURQ0j6KgeRQFzaMoaB5FQfMoCppHUdE8iormUVQ0j6KieRQ1gFVqRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaOoaB5FRfMoKppHUdE8iormUVQ0j6KieRQVzaNoaB5FQ/MoGppH0dA8ihbAKrWheRQNzaNoaB5FQ/MoGppH0dA8iobmUTQ0j6KheRQNzaNoaB5FQ/MoGppH0dA8iobmUTQ0j6KheRQNzaNoaB5FQ/MoGppH0dA8iobmUTQ0j6KheRQNzaNoaB5FQ/MoGppH0dA8iobmUTQ0j6KheRQNzaNoaB5FQ/MoGppH0dA8iobmUTQ0j6KheRQNzaNo3a04iWwHRPkAUOfCSFG2W9Pt7/MMqLfRhIjCBogkfQD0fHUpsskZ6H5rpkPxg+3ih1TuVx9eTJm3iznkysXKG8Ufp1w8XvwmYlwivi4iLRFfF5GXiK+LKEvE10XUJeLrItoS8XUR0xLxdRHzEvF1EcsS8WUR01qxnCDiWrGcIOJasZwg4lqxnCCiLBFfF3GtWE4Qca1YThBxrVhOEHGtWE4Qca1YXhcxrxXLL4h4a6e3iy3Ts4hrxXKCiGvFcoKIa8VygoiyRHxdxLViOUHEtWI5QcS1YjlBxLViOUHEtWJ5XcSyViwniLhWLCeIuFYsJ4i4ViwniChLxNdFXCuWE0RcK5YTRFwrlhNEXCuWE0RcK5aXRUxhrVhOEHGtWE4Qca1YThBxrVhOEFGWiK+LuFYsJ4i4ViwniLhWLCeIuFYsJ4i4ViyvixjXiuUEEdeK5QQR14rlBBHXiuUEEWWJ+LqIa8XyCyKmvIuYMj+LuFYsJ4i4Viyvi0hrdv4FETPtJ4FlTs8irppYF5Fvo28UoxyIuGriCSKumniCiGsX5wQR1y7O6yLy2sU5QcS1i3OCiKtPPEHEtYtzgoiyRHxdxLViOUHEtWL5FRGNdxHzgYhrxXKCiGvFcoKIa8XyuoiyViy/IKLqtp/ImuOziGvF8gsi3ne2OX+8+E1EWSLWRcwsO8UfV/xZxNXinCDianFOEHG1OCeIuFqc10XU1eLURZRIGw45WjvranFOEHFtyp4g4tqUPUFEWSK+LuLalD1BxLViOUHEtWI5QcS1YjlBxLVieV3E9RnOM0RcK5YTRFwrlhNEXCuWE0SUJWJdRAplE5HoeStsfYbzDBHXiuUEEdeK5QQR14rlBBHXiuUXROS43VlYnm1p6zOcZ4i4+sRfETFt7+KIhOd3cdbHD88QcfWJJ4i4+sQTRFx94gkirj7xBBFXn/i6iOvjh2eIuHa2f0VEzXcRn5d96+OHZ4i4ViwniChLxNdFXCuWE0RcK5YTRFwrlhNEXCuWE0RcK5bXRVwfPzxDxLViOUHEtWI5QcS1YvkFETXuImoszyKuZvsEEVez/Ssi6naxWNSvL84lbYqXEA4UX515b8VXG99b8dXz91U8r28Ndld8rSZ6Ky5L8ZMVD/sR5Tnws+LrENTTFY/7+UO3f/Kz4ivHT1d8B52J4rPiaxnZW/G15uyt+Fpz9lZ8rTlfUvxNxLWMfF3EdbbmGSKuRvgEEddPR78goqVdxMT5WcT109EviJg07iJ+PCr3Wxe/KS5L8c6KryXZyYqXmDcY5eAA7rxO7O2u+FqS9VZ8Lcl6K77Wb50VX6cMd1d8rQx7K76Wkb0VX2vO3orLUryz4mvN2Vvxtebsrfhac/ZWfK05eyu+1pydFV/nRHdXfK05eyu+1py9FV9rzt6Ky1K8s+JrzXm24pS3F9oLx+dfltep2d0VX2vO3oqvNWdvxdeas7Pi66Tv7oqvNWdvxdea83TFLd8Vf7Y7rqPvuysuS/HOiq81Z2/F15qzt+Jrzdlb8bXm7K34WnN2Vnx9NaC74mvN2Vvxtebsrfhac/ZWfPXjZyt+/1TM7Z/PnuV1BPjpist971DDs+LY54XHoHfJi1Qkt7A9zvZwKBxle6cK3SScSxV6dj6XKvS0+E2qvN3aHlDfqco8VKE3H8+lCt1lfJOq7VTTEVXo7bZzqULvc51JtYQrTTZ5+/i6lXhA9UJlKd/P0H04gulO9UJlqdgGpCQ+oHqhslSjeqGyVKMKvZZ0U830TDVeaBFXo3qhRVyxuFNNB1QvNK8W1S+pXmgRV6Mq81C9ULdUo3qhbimGEParH7YM72Sv1C897Okecn29Ybp1ItvFRbhydRbaJoUs6b4EiVnfARUwQBTQAMW+gGIK++Z9onsORaGDq9VkS3014wP4NDZ8Hhu+jA1fx4ZvY8NPY8PPY8MvQ8PnMDZ88Fl3/36V2sOLB3f44LNuDT74rFuDDz7r1uCDz7o1+OCzbg0++Kxbg//6rJv30yNuTHJtNc1xWz8Ry0dAB6st2jcDMokcwP/mrPsz6LufmnkLip4g8gSxJ0g8QeYIev3Mz5zj/lGqrPr8V339kMv6ENZ+iNR+iNx+iNJ8CPM8j+Z5Hs3zPJrneTTP8/jdg3begjwP8XePO3kLyp6gl/PHZJvCHlt/Du8DvH7GQm2A2HqAl7v/TGXflJSDAbj1ANJ6AG09gLUeILUeILceoDQe4HXnWm2Al5/kHPcPUevBk/y6L6k2ALceQFoPoK0HsNYDpNYD5NYDtH6SS+sn+XU3RW2A1nNyaT0nv/6+fm2A1nNyaT0nl9Zzcmn9JJfSdIDb9ktoPUBsPQC1HoBbDyCtB9DWA7R9km8DpNYD5NYDlMYDxNB6gNh6AGo9ALceQFoP0PpJjtZ6gNR6gNx6gNZzMrWek6n1nEyt5+TX3wOLVvb3UFN42ti8DSHth9D2Q1j7IVL7IXL7IUrzIV5/B6c+RGw/BLUfov3Tze2fbm7/dHP7p5vbP93c/unm9k+3tH+6penT/Xy13P4071dLkLuR4vhlDlPZz9LQ55f4bvCpL3y+/eC63fr2E1YNvuTtzRWTkg7gt69K0r4qSfuqJK+vIZj2Vwq4UA1Q1B1QLPd7Ex06eCJr3i9n++jheSOQRieQsQkI3QkIlwMCBZuAFtovN6ZnAhpGJxBHJ0CjE+DRCcjoBHR0AuAzcZ0A+ExcJwA+E9cJjD4T2+gzsY0+E9voM7GNPhO//k3V301g9JnYRp+JbfSZ2EafiW30mTiNPhOn0WfiNPpMnEafiU9wUvxmAqPPxGn0mTiNPhMn8JnYTO4ETA8IgM/EVQIZfCauEwCfiesEwGfiOgHwmbhOAHwmrhMAn4nrBMBn4joB8Jm4TmD0mTiPPhOX0WfiMvpMXEaficvoM/EJTsbfTGD0mbiMPhOXwWfiCL+kzPc3th5f+tsJoC9o8v0o7h8fADsgAP4Q1wmAP8T3D1LEH8bmAwLgD3GdAHg7XScAXoWqBNDb6ToB8Ha6TgB8HqgTAG+n6wQEnMB+WtoPMgetBHo7XSeAPhNXCaDPxFUC6DNxlQD6TFwhQAF9Jq4SQJ+JqwTQZ+IqAfSZuEoAeyL7cSDKdvkPG/8BAeyJ7BcIYE9kv0AAeyL7BQLYE1mdQMSeyH6BAPZE9gsEsCeyXyCAPZH9AgEZnUDvmZhsO8crcuAPBN4AGRqghAYoowEqYIAooAGKaIBenzk0bj98ZWWpXC2WtkIklj8egfJ8tWXdvxuQ/3Q+yRv81+cN3Qtp1offHT+Bn3gDJKl+3kuJm/pWWA/gvz5rWNjTwaim/rnnvdDrp7M9fkzWrAb/9vPRPZ1zfpj2Er8jMjhECQ5RhkNU0BC9fhDd6YgiHCKCQ8RwiAQOEVzNZriazXA1m+FqNsPVbIGr2QJXswWuZgtczZbuNbvY/upgLlkfET1fnvJ+/vnDt0b3BZ10r+9lv/y2ERXC1+hj0X3B8uMDkbFyebgtPLbLg/LBxpXYbITTbITzbITLZIQ1zEY4zkaYZiPMsxGW2QjP1mnpbJ2WztZp6Wydls7WadlsnZbN1mnZbJ2WzdZpnXBW6WCEZ+u0bLZOy2brtGy2Tstm67TSbJ1Wmq3TSrN1WulinZYK3wmrHRCW2QhfrNOqE75Yp1UnfLFOq074Yp1WnfDFOq0q4XyxTqtO+GKdVp3wxTqtOuGrzcMPraWFckD4YlXa9IHww+V3wher0lXC5WJVuk74YlW6TvhiVbpO+GLr4TphmY3wxebhOuGLrYfrhC+2Hq4T7t1p3UjanXCqvN7+4zN0W3P84yMgr+9aljIXYQ5hNsJxNsI0G2GejbDMRlhnI2yzEU6zEZ6s0+IwW6cVZ+u04mydVpyt04qzdVonnNw3GOHZOq04W6cVZ+u04mydVpyt06LZOi2ardOi2Totmq3TOuG0y8EIz9Zp0WydFl2s06q9mMZ0sU6rTvhinVaVMF+s06oTvlinVSd8sU6rTvhinVadsMxG+GKdVp3wxTqtOuHZOi252jxcsQCwXKxK197EY7lYla4TvliVrhO+WJWuE75Yla4Tvth6uE74YuvhKmG92DxcJ3yx9XCd8MXWw3XCr3daiTZIOT0McXw1RbJNn9u/S35k8IZI4BApHCKDQ5TgEGU4RAUN0QlHgJ6NKMIhIjhEcDXb4Gq2wdVsg6vZBlezDa5mG1zNTnA1O8HV7ARXsxNczU5wNTvB1ewEV7MTXM1OcDU7wdXsDFezM1zNznA1O8PV7AxXs084nSyH/aPxt82z2tUP22vygH/7EDlnQwOU0ADlvoBiCvvv24nuKRR/RD5drSb0frWa8QH8MjT8E84++63w49jwaWz4PDZ8GRu+jg3fxoafxoYPPutS2uGnfAAffNb9Gr4E8Fm3Bh981q3BB591a/DBZ90afPBZtwb/hFm37Gveoly5mvc3LG4rpYdr+R2OYcFJWHAyFpwCBeeEM4JOhROx4BAWHMaCI1hwsKpyxKrKEasqR6yqHLGqMmFVZcKqyoRVlQmrKhNWVSasqkxYVZmwqjJhVWXCqsqMVZUZqyozVlVmrKrMWFWZsaoyY1VlxqrKjFWVGasqC1ZVFqyqLFhVWbCqsmBVZcGqyoJVlQWrKgtWVRasqqxYVVmxqrJiVWXFqsqKVZUVqyorVlVWrKqsWFVZsaqyYVVlO7Mql0C5crWpbLc2TQ9vRJX4DojQADEaIEEDpGiADA1QQgOU0QAVMEApoAFCq9QJrVIntEqd0Cp1QqvUCa1SJ7RK/V0j7VtQcQR91476FhQ9QeQJYk+QeoLME3TCBBa3D3nn/OOKLRW2d17PMInVhojth6D2Q3D7IaT9EJ7cLZ7c/a6J5i3IU5iKozBpCJ6g6AkiTxB7gsQTpJ4g8wQlT1D2BHkyInoyInoyInoyInoyInoyInoyInoyInoyInoyInoygjwZQZ6MeP3Vx2glvF8cUzgagtsPIe2H0PZDWPshUvshcvshSvMhXn81rz5EbD9E+6eb2z/d3P7p5vZPN7d/urn9083tn25u/3RL06f7+WoJvJlLJYh9WB0d7qLkfRflwGevEvvC52L7rUuSGvzbNsoG/7YYO4DfvipJ+6ok7auSaN+/862PKu9X35oRrfydk4Tt6iRMB3/n9hVP2lc8aV/xXn/VqlDetl8K02u/ouvrr1qdCydiwSEsOIwFR7DgKBYcOxUOV3dlOezn5DE/9B3vv8fo6y9bnQ0oowEqYIAsoAGKaIAIDRCjARI0QIoGCK1SG1qlNrRKbWiVOqFV6oRWqRNapU69K7Xk7dNo+fY74AdABwtJSnt/GSnHUlmhR04b3cj5fneO9E5X5qKrc9E9YQ5LutMV/a+nnYuU2g+R2w/h+Y3W84KZel4wU88LZup5wUy/e/b+W9DLaZa2Y2XTfbdYy/vdU9O756Z3Ly3v/voLdF/ePTa9OzW9Oze9uzS9uza9e9NntTR9VkvTZ7W0fFYthKZ3j03vTk3vzk3vLk3vrk3vbk3vnprePTe9e9NnNTZ9VmPTZzU2fVZj02c1Nn1WY9NnNTZ9VmPTZzU2fVZj02eVmj6r1PRZpabPKjV9Vqnps0pNn1Vq+qxS02eVmj6r1PRZ5abPKjd9Vrnps8pNn1Vu+qxy02eVmz6r3PRZ5abPKjd9VqXpsypNn1Vp+qxK02dVmj6r0vRZlabPqjR9Vk847O7hk6RmUrk6lhC2n4Zu/073HyV+uOafLqdg+09DFDLFry+P4Vb0t7uHW8rulzO9bdrbCcfpDUY4zkaYZiPMsxGW2QjrbIRtNsJpNsJ5NsKzdVo2W6dls3VaNlunZbN1WiccUjoY4dk6LZut07LZOi2brdOyq3VaFO6E+YBwulqnVSV8tU6rSvhqnVaV8NU6rSphmY3w1TqtKuGrdVpVwlfrtKqEr9ZpVQnP1mnl2TqtPFunlWfrtHLveTiX/fIf5EOFQdGwr/eKpteXh9lmI5xmI5xnI1wmI1zCbITjbIRpNsI8G2GZjfBsnVaZrdMqs3VaZbZOq0zWaaUwWaeVwmSdVgqTdVopXK3TqmzxpCCzEb5ap1UlfLVOq0r4ap1WlfDVOq0q4at1WjXC8WqdVpXw1TqtKuGrdVpVwrN1Wq8f5TMa4dk6rThbp/X6OUaZaf9EMheqEY66I7oR3q8mksOrE+1nB9/+XZ4JvH5U0u8mEEcnQKMTYHACRncCD8/8nYCMTkBHJ2CjE0ijE8ijE0CfiWsEGH0m5nInoAfzAKPPxFUC6DNxlQD6TFwlgD4TVwmgz8RVAugzcZUA+kxcJYA+E1cJoM/ENQIy+kwso8/Egj4T7997uv276AEB8Hkg051ANjogAD4P1AmAzwN1AuDzQJ0A+DxQJaDg80CdAPg8UCcAPg/UCYCvyHK8X57p4AeOE06T/M0E0GfiKgH0mbhKAH0mrhJAn4mrBNBn4hoBQ5+JqwTQZ+IqAfSZuEoAfSYuD63E0ZLyhNMGfzMB9Jm4SgB9Jq4SQJ/IqgTQJ7IagYQ+kVUJoE9kVQIvl1FW3X7K5ZyscjXR/g7ZDXN6uPqQQNC7P6fIB/jPV1ve9lGt3H9RpmzvVPU6VO87ro/7rXeqNg/VNA/VPA/VciGqyXaq9kz19WPCxqEa56FK81DleajKPFSv1C1VqF6pW9qp5nAwr+YrdUsVqlfqltKG+raxd0D1St2Sla+olit1SxWqV+qWKlQv1C3lh/2cg12IcqFuqUZV5qF6oW7pvmdYwtGzeqFuqUb1Qt1SjeqFuqUa1Qt1SznbTvW5LOVwoW6pRvVC3VKN6pW6pQrVK3VLFaoyD9UrdUsVqlfqlu5UDxZxOVypW8q6U9UDqlfqllL+kuqVuqWvqcYrdUsVqlfqlipUr9QtVaheqVuqUIWeV8v9tatAVmEag+0fdQrpwf55eDHtn3SKHPLXF0vS7Tgwuf34/vXFhVPaFOf04c5vikNP70MqLnHbFS9C8qw4dJdxScWhm50rKk7QPdclFYdu/QZVnO+K67Pi0B3oJRWHboQvqbgsxTsrDr2JeknF15qzt+Jrzdlb8bXmbKk4H/Tja815vuK0K/7A8PBiKrvSVPThFzw7uFhD3mBoKOXx4p9/S16r2ev8Ldc6+Tp/y7UCv87fcq3tr/O3lPW3vMzfcq3VTv9bprj/LRM9rRxkdZunK57338A1PP8GLqsn7K346tx6K776q96Kr33l3jPn6lVOV7zke47zs+JrX7m34mtfubPiuvrx3oqvfry34qsf76346sd7Ky5L8c6Kr3eZzlecv1R8rTl7K77WnL0VX2vO3oqvNWdTxdOT4rbWnL0VX2vO3oqvNWdvxdea82zFNe6/SCjFZ8VlKd5Z8bXm7K34WnP2VnytOXsrvtacvRVfa87Oiqe15uz8hlBaa87eiq81Z2/F15qzt+KyFO+s+Fpz9lZ8rTl7K77WnL0VX2vO3oqvNWdnxbG/knpJxdeas7fia83ZW/G15uytuCzFOyu+1py9FV/9+C8orrpdLPZwwv/hxTnmTY/bP5/fO8T+AO6QilPYP3h5I/ukOPZ3eC+p+OrHeyu++vHeiq9+/HTF7x8uJrZnxWUp3lnx1Y/3Vnz9BtRb8fUbUG/F15qzt+JrzdlX8YL9NfMx91XKQz8enxVfa87eiq81Z2/F15qzt+KyFO+s+Fpz9lZ8rTl7K77WnL0VX2vO3oqvNWdnxeNac/ZWfK05eyu+1py9FV9rzt6Ky1K8s+Jrzdlb8dWPn614oO1Nzxy4PCu++vHTFdewK25PX+4otPrx3oqvfry34qsf76346sd7Ky5L8c6Kr368t+LrN6Deiq/fgHorvtacvRVfa87OivNac/ZWfK05eyu+1py9FV9rzt6Ky1K8s+KrH68rHrPtOHLKzyKuFvsEEVfX/LqIshrhE0Rcve0JIq529QQRVwd6goiyRHxdxPXbxC+IWKRsF98gPYu4fm44QcS1YjlBxLViOUHEtWJ5XURdK5YTRFwrlhNEXCuWE0RcK5YTRJQl4usirhVLXUQKYRORAvOziKtPPEHE1Se+LqKtPvEEEVefeIKIq8X5BRElbr4sEnl2wq0vjZ8h4pqdf0FEi3kDbfL8BsT6OvUJIq4PTv+SiLI/zpaeJ5b1Delfy8QHEZ+XfeuTuWeIuNbOvyBiihtFSgeH4a4P254h4vq17wQRV594goirT3xdxPWR2DNEXH3iCSKuX/tOEHFthf1Ks114F1HCs4iyRHxdxLViOUHEtWI5QcS1YjlBxLViOUHEtWJ5XcT1Gd0zRFwrlhNEXCuWE0RcK5YTRJQl4usirmb7BBFXs32CiKvZPkHE1Wy/KiKH3t9WjIl2ponyBxHfAHFvQPtxLbd/6gEgQQOkaIAMDVDqDmg3RqRsB4AyGqACBqj3N6XqgCIaIEIDxGiAuldqvgPSI0CKBsjQACU0QBkNUAEDRAENUEQDRGiAGA0QWqUmtEpNaJWa0Cp171PWYw7bG9wxRz4AVMAA9T6juw4oogHqXalzvAPig5Vr7wOQ64AEDZCiATI0QAkNUEYD1L2nLnavQ/IMSAIaoIgGiNAAMRogQQOkaIAMDVBCA5TRAKFVau3eU+sd0MPXBO6AIhogQgPEaIC699T3X5dziQeAFA2QoQFKaIAyGqACBsgCGqDulVr0XocOdj+M0AAxGiBBA6RogAwNUEIDlNEAFTBAKaABQqvUqXelLrsL+fbPcgCI0QAJGiBFA9S7UhfaX1MtetAP9T5opg4oowEqYIB6HyZSBxTRABEaoO6VOsQdEIUDQIIGSNEAGRqghAYoowEqYIBKQAMU0QARGiC0Sl26V+p0b2HTQQtbFA2QoQFKaIC6V+rdHEchHLw2WAoWoBgCGqCIBojQADEaIEED1L1S230uy+EAkKEBSmiAMhqgAgaou0exCiiiASI0QIwGSNAAoVXq3h5FCrSfzB9YDgAlNEAZDVABA9Tbo3hDsX+sJRy88hV7exTrgAgNEKMBEjRAigbI0AB1r9TR7nVIDwBlNEAFDBAHNEARDRChAWI0QIIGSNEAGRogtErN3Sv1ww5aOVgGcQEDJAENUEQD1L1S72cMUjxKamE0QIIGSNEAGRqghAYoowHqXqn331xv2J5f+Yoa0ABFNECEBojRAAkaIEUDZGiAEhqgjAYIrVL39ihS3K3JFA+MJrG3R7EOiNAAMRqg3pU62v7jS8z5AJCiATI0QAkNUEYDVMAApYAGqHul3j2KN2wHv7kmQgPEaIAEDZCiATI0QAkNUEYDVMAAdf/geRUQWqXOaJU6o1Xq1x14sfDdl1m0drVR3E87Nn4gkPjw5hr2rwsVTbFyeTC+f4zI5L6I+PE1ojfCaTbCeTbCZTLCrzsgRyMcZyNMsxHm2QjLbIR1NsKzdVpltk6rzNZplck6LQqTdVoUJuu0KEzWaVGYrNOiIBcjvH+r+Qf5I8JX67SqhK/WaVUJX63TqhK+WqdVJXy1TqtGOF6t06oSvlqnVSV8tU6rSvhqnVaVsMxGeLZOK87WacXZOq3Xz5eIVvYxUqhfLfuhKenhQ6Yxx4OryWS7NyWzytW/sDh8/fSKsejSXHR5LroyF12di67NRTfNRTfPRbdMRZfn6qp4rq6K5+qqeK6u6vUzeMaiO1dXxdfqqmrLe75WV1Wle62uqkr3Wl1Vja5cq6uq0r1WV1Wle62uqkr3Wl1Vla7MRfdaXVWV7lxdlczVVclcXZXM1VW9foJYpu0nzCx3CyqHo2s1bb+Oavp47RsYRgIjSGC0JxiLW0oa2QEYQwKTkMBkJDClK5hwB5Oewbx+QtiZYCISGEICw0hgBAmMIoHpWoE1b9dqyQdgEhKYjASmAIFJAQlMRAJDSGAYCYwggVEkMEgVOCFV4IRUgRNSBc5IFTgDVWA+tqnefgPZjx0Wur/tTKG8h4kvTH1hh4kdOe37N/zwHUiO9B5WXGHHFqlq2PFuneXtg2OPG1JE8h5UHEHHp/PXgg7/0PFWNPbX5m+Zef/+eszvGXK8G/MrgeoNNG9g8gZmb+Dh3094/1uIxPAcdrzyFNG0h2U+CGNfWHGFHbet9TAfyOOGpx6WfGHZF+ZTMvuUPJ4ovgp7dUs857i9x5Oz6gEkwoPEeJAED5LiQTI8SKk3JKayHzt6m03u97bjn5WkbFBiUH7YoKKNQh6fQhmeQgnjU4jjU6DxKfD4FGR8Cjo+BRufwvizcxl/di7Dz84Shp+dJQw/O0sYfnaWMPzsLGH42VnC8LOzhOFnZwnDz84Shp+dJYw/O8fxZ+c4/uwcx5+d4/izcxx/do7jz84RfnZW4TsFtQMK8LNznQL87FynAD87VykQ/OxcpwA/O9cpwM/OdQrws3OdAvzsXKcAPzvXKeDPCw8NhoXyTIHhK5LpA4WH80/vFOArUp0CfEWqU4CvSHUK8BWpTgF+vVCnAL9eqFOAnxfqFODXC1UKAr9eqFPAnxcqx6+J4M8LVQr480KVAv68UKWAPy9UKeDPC1UK+PNCjYLizwuVE1xE8VdtVQr4q7YqBfzZuUoBf3auUsCfnasU8GfnKgX82blKAX92rlLAn51rFGz82dnGn51t/NnZxp+dDc6nJpbwIGU8SAUOUgp4kOBcxpLgXMaSxn+X7PsOezwK479LlsZ/0zuN/6Z3Gv9N7zT+m955/De98/hveufx3/TO48/O/c8MOZ/C+LNzHn92Hv8MExn/DBMZ/wwTGf8MExn/DBMZ/wwTGf8MExn/DBMZ/wwTGf8MExn/DBMZ/wwTGf8MEx3/DBMd/wwTxT/DpGafUfwzTOoU4GfnOoXhfViKf4ZJncLwLmnFP8OkTmF4l7Tin2FSpzC8S1rxT8+oOUMV/9yGmn1G8c9tqFMY3oel+Oc21CkM75JW/HMb6hSGd0kr/rkNdQrDu6SVhndJ6wDnNlR8WDrAuQ1VCsP7c3WAcxuqFIb35+oA5zZUKQzvz9UBzm2oWAZ0gHMbahQGOLehSmF4B5DK8A4gHeD0jCoF/Nm5SmF4f64OcHpGlcLw/lwd4PSMKoXxZ+fxT8/Q8U/P0P7nNtR8aqpw33lUhfPPqsL5Z1Xh/LOqcP5ZNTj/rLY+Z+BtEOoxCPcYRHoMoj0GsR6DpA6D4PmtNcF91Vn7+6frkPBm+4Q32ye82T7hzfbj+4l1fD+xju8n1vH9xDq+n1jH9xPr+H5iHd9PrOP7iXV8P7GO7yfW8f3EOr6fWMf3E+v4fmId30+s4/uJdXw/sY7vJ9bx/cQ6vp/YxvcT2/h+YsP3E9cpDD87Wxh+djZ8P3GdwvCzs+H7iesUhvcT2/h+YhvfT2zj+4ktDn/ah8XhT/uwAVzdVQrDn/ZhcfjTPgzfW1+lgO/qrp1wYOP7iW18P7GN7ye28f3ERsOf9mE0/GkfRsOf9mE8/GkfNoC3vkph+NM+7DNXt8idgnyg8BZmvrDkCyuusAH8oRWvtA3gD61SGP70Bhv/6+o2/tfVbfyvq9v4X1e38f2hNr4/1Mb3h9r4/lAb/+vqNv7X1W38r6vb+F9Xt/G/rm7jf13dxv+6uo3/dXUb/+vqNv7X1e347c+YJW9x2e47IhTkPeywCkS6/1RDD2G8RWVXVHFEpeNX+apR0RVFx1FJ96iSn6PYFXWsvMb9D63xAGF2RRVP1PFrGtWo6Io6Vv6W6lvUrc48R7ErSlxR6ooyV1RyRWVXVPFEHf9UW42KrihXbpArN8iVG+TKDXLlBrlyg1y5Qa7cYFdu8Ce5kek+q9JzFLmi2BUlrih1RZkrKrmisifq+EjNKLRHiTzX+eNfKapR5IpiV5S4otQVZa6o5IrKrqjiiVJXbqgrN9SVG/pJbtx/QZT0XKNUXFHqijJXVHJFZVdU8URZcEVFVxS5oly5Ya7cMFdumCs3zJUb5lpxmGvFkVwrjuRacRyfNlR/iSAdnwkUU9rbm1QOhkuuqOyKKp6o4/NmYs62RZWgz1HRFUWuKHZFiStKXVHmikquqOyKKp6o4sqN4sqN4sqN4sqN4sqN4sqN4sqN4sqN4w06CntTRIEPooojKh9v0FWjoivqUHnlvNXs2z/vW23bu1H52HxXD0u+sOwLK66w4126elj0hZEvjH1h4gvzZUn0ZUn0ZUn0ZcnxtpbKfh7e7Z96EHbMTTjsYWwHYdk32nEqi+3cJKXnsOONIxWlr8PiJ9zKPeyjks+/sJRAG6VbPT0ahFwCMvvCxBemvjBfchzvNtXDsi+suMIk+MKiL8yXJeLLEvFlifiyRHxZIr4sOd400VuPsoXlhx9Z72HHWZL3l6c16/PL0/l4U0JvhezrsOMsyWp7mB2Ux+NtiXoY+8LEF6a+MPOFJV/YcS25dQD3MKuV/rj/MFFiOvorl+8O8jMsBV9Y9IWRL+zwz5XLnvi5HCX+8W5GNex4i+H+lN0e03vLH7ag6AkiTxB7gsQTpJ4g8wQlT1D2BBVHUPFkRPFkRPFkRPFkRPFkRPFkRPFkxPGOwm0ZswUpHwRlT1D5flA53k6oBUVPEHmC2BMkniDHk1tC9gQ5ntwSgycoeoLIE8SeIPEEqSfIPEGejIiejIiejCBPRpAnI8iTEeTJCPI8ucevA9WCzBOUPEHZE+Sp5eyp5eyp5ez5O7Hn78SevxN7/k7s+Tux5+/0yUbC/nuhpoNH45OFfd6XzI8vve5B2RN0yMlk42R2wOn4HZRaUPQEkSeIPUHiCVJPkHmCkicoO4I+2a/5OmE/2a2pBJEn6PiPG+PGiewgSDxB6gkyT9DxHzfcg9JBUPYEFUfQ8W5LLSh6gsgTxJ4gcRTLpJ4g8wR5JoDkmQBScQTl4AmKniDyBLEnyJMR2ZMR2ZMR2ZMR2ZMR2ZMRx7s5twly2/5Nj1vMR0asHwX3/eIfj+fD1Uc7yyZ5f76lPP+oWD55/STw/u5qUOoM6TBZSok7olgTKZJuf4bIf/p5+PnqlHizqKWU4wEiqyHSj4jeopIrKn8/SsLx7lPakzGHezISyXsQeYLYEySeIPUEmSPoM+tX3JPI6J7Wpu9Rn9gqZH8v6tFkskeZJ+ozs9PXCD8zO1WiXGp8ZnaqRIkrSl1R5opKrqjsiiqeKHblBrtyg125wa7c+Mzs9PWTwq6nkl1P5Wdmp0pUdkUVT9QnFqlaVHRFkSuKXVGu3BBXbogrN8SVG+LKDXHlxvH+D/P+Wgyz1t5cqEysx7tFzJT3IZ5fCbiFqS/MfGHJF5Z9YcUVdrzdVA+LvjDyhbEvzJcl5ssS82WJ+bLEfFlivixJvixJvixJvixJvixJvixJvixJvixJviw5fp2E7weu/vjmaqUUZ9t3EXKKdDAI9RiEewwiPQbRHoNYj0FSj0Fyj0FK+0Hi8es/Zw8SewxCPQbhHoNIj0G0xyDWY5DUY5DcY5AeT3zs8cQfv3j247N82yAW80EY+cLYFyausOPlON0PN6bHBahnKRmP1+63IXa3pqVwgMx8YckXln1hxRV2/H5JPSz6wsgXxr4w8YX5skR9WaK+LFFflqgvS8yXJebLEvNlifmyxHxZYr4sMV+WmC9LzJclx28CUArbrh5lTrW5TGj7uTFLigeDcI9BpMcg2mMQ6zFI6jFI7jFI6TDIse3n7EFij0F6PPGlxxNfejzxpccTX3o88aXHE196PPGlwxNPIfQY5PiJv7/hRcXSQRj5wtgXJr6ww1R4eHlKHt4gjeE9qDiCjhfktaDoCTp+B2r3LCfJH4IOUmJ/NatEq1x7P35Eyv2dcrJ3LAyERYCwKBAWw8HyyceK6f7NAEofop4HUNl3dlQe3sHZh4jth6D2Q3D7IaT9ENp+CGs/RGo/RG4/RGk+BLd/uj8540njHqXxYc58bwM+OeKpFmWuqOSKyq6o4on65HSnWlR0RZEril1RrtwQV26IKzfElRviyg1x5Ya6ckNduaGu3FBXbqgrNz45T8toP5LPpDxHmSsquaKyK6p4oj7xjz5GmTxHfaJG2hY5+uFDCVvUMcKie1TJz1GfnB5Vi4quKPJE5U98kPsXpyzos/LHW74WUtijjsbKrrE+MZLuv3VaPPh7leCKiq4ockV9YibNeo/i5yhxRakrylxRyRWVXVHFEcUhOLKXQ3RFkSuKXVHiilJXlLmikisqu6KKJyq6ciO6ciO6ciO6ciO6ciO6cuP43CEp+6ccbv+MT1GfbMXUoqIrilxR7IoSV5S6oswVlVxR2RXlyg125Qa7coNducGu3GBXbrArN9iVG+zKDXblBrtyQz6Jkvu+rz1HfbLWi/uXCzQ+frlgi/rk73U/zzg8nGe8R6krylxRx+uU+xcZbv987og+OR8n6H6880EHy58cZRx3p8ZNQ3mOEleUuqLMFZVcUccr38j3KD2IKp6oT9aVtajoyfnkelISu6LEFaWuKHNFJVdUdkUVT9QnJ+bUoly5kV25kV25kV25kV25kV25kV2193in4rH2Bnse63inQkO+j5XTcxS5otgVJa6o479XSOkelZ+jzBWVXFHZFVUcURKCKyq6osgV9UluJPoySlxR6ooyV1SqRhV6jsquqOKJisEV9UluWL5H8XMUuaLYFSWuKHVFmSsquaJyLeqgx5ZYHJ25UHBFRVcUuaLYFSWuqO8fwXsLKo4gx1HJt6DoCSJPEHuCjvP2q7NTReT7JzDegsgT9P0jeG9B4glST5B5gpInKHuCiiPIcSjzLSh6gsgTJI6E/exLVV8HmSfo+I/71bm9t6DsCSqOoOMf1WtB3z+C9xZEniD2BIknSD1B5glKnqDvH7h6CyqOoBQ8QZ4JIHkmgMSeIPEEqSfIPEHJE+TJiOTJiOzJiOzJiOzJiOzJiE8+372/FRTT/dUUyvYelD1BxRH0ybe7K0GffZ75PYgeXo64B5EniD1B8v0g/cQdtHuKiOgg6HCk2wbrexCXoyDzjJQ8QdkRFD+xSe3HTIR4EESeIPYEiSdIa0F6EGSeoOQJyp6g4gii6AkiT9AnR8ntp61pOAgST5B6gswTlDxB2RNUHEEcakHlICh6gj45XnBbP91+fjwIOs4I0i+DxBOkniBz1PLj1xhqQdkTVBxBxw6IWlD0BH0iedkmXX5MpGiHnwYIUrYMikEfHL+3P937MNZnmNRnmNxnmNJlmOPtm/OHiX2GoT7DcJ9hpM8wfaqA9qkC2qcKaJ8qoH2qgPWpAtanClifKmB9qoD1qQLWpwpYnypgfaqA9akC1qcKpD5VIPWpAqlPFUh9qkA6pQqo8H2Yh49R3IfRPsNYn2FSn2Fyn2FKl2Fy6DNM7DMM9RmG+wzTpwqUc1LgoaZZKAfDnCKa6cMwD0eI3YeRPsNon2GszzCpzzC5zzClxzAWQp9hYp9hqM8w5zye+9Hot38LHwyjfYaxPsOkPsPkPsOULsPE0GeYcx5PCvdh+GgY6jMM9xlG+gyjfYaxPsOkPsPkPsOULsNQ6DNMnypAfaoA9akC1KcKfOIBoP2DKfLxVd2DQ0e/fE3ePvELnDfAJ96CEweIrQeg1gNw6wGk9QDaegBrPUBqPUDrJ5lbP8nS+kmW1k+yvJxFX5skTF7+G3z9uq9paD3Ay3+Dr20uptR6AG49gLQeQFsPYK0HSK0HyK0HKI0HsNB6AIc/04w8QewJEk+QeoLME5Q8QQ7HrqXYeFJK1HoAbj3A6xX3SyOgJW09gLUeILUe4PWK+6Uz0FJpPEAOrQeIrQeg1gNw6wGk9QDauEHO1nqA1HqA3HqA1qug0noVVGLrAaj1ANx6AGk9QOsnubR+kkvrJ7m0fpJL4yc5hcZPcjr+DSVLOWrJ5T3m8NmJQem+Wa/PUeKKUleUuaKOveJxVzvGlJ+jsiuqeKKOfyyoRkVXFLmi2BUlrih1RZkrypUb7MoNduWGuHJDXLkhrtw4Pp7p61ojnzz/8f7qBh9EZVdU8UQdbzlXo6IrilxRrnqtrnqtrnqtrnp9vItajcquqOKJsuCK+iQ3bH+6PnyeYYsiVxS7osQVpa4oc0UlV1Q9N46iXLmRXLmRoiuKXFGuupFcdSO56kZy1Y3kqhvJVTeSKzeyKzeyKzeyKzeyKzey66+cXX/l7Por52//lf/r9l//31/+/a9/+Ze//et/3GJ+/I//5+///R9//be/v//nP/7///32v9wu/r8=","brillig_names":["public_dispatch"],"assert_messages":{"4541":"attempt to add with overflow","2682":"attempt to add with overflow","2548":"Function _assert_token_is_same can only be called statically","3249":"attempt to add with overflow","3280":"attempt to add with overflow","3079":"Array index out of bounds","4292":"attempt to add with overflow","4414":"Array index out of bounds","3835":"Array index out of bounds","2933":"attempt to add with overflow","2866":"Array index out of bounds","4402":"attempt to multiply with overflow","2665":"Array index out of bounds","2854":"attempt to multiply with overflow","3232":"Array index out of bounds","3031":"attempt to add with overflow","3287":"Stack too deep","3988":"attempt to add with overflow","3086":"Array index out of bounds","4366":"attempt to subtract with overflow","4756":"Array index out of bounds","2885":"attempt to add with overflow","3141":"attempt to add with overflow","4677":"attempt to add with overflow","2873":"Array index out of bounds","3952":"attempt to add with overflow","4464":"Array index out of bounds","289":"attempt to add with overflow","2782":"Array index out of bounds","2892":"attempt to add with overflow","3715":"Array index out of bounds","2045":"Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally","2813":"attempt to add with overflow","3258":"attempt to add with overflow","4471":"Array index out of bounds","3057":"Array index out of bounds","4526":"Array index out of bounds","4514":"attempt to subtract with overflow","3167":"Array index out of bounds","3734":"attempt to add with overflow","4624":"attempt to add with overflow","2820":"attempt to subtract with overflow","3966":"attempt to add with overflow","3064":"Array index out of bounds","3119":"attempt to add with overflow","3174":"Array index out of bounds","3217":"attempt to add with overflow","267":"attempt to add with overflow","4296":"Array index out of bounds","4607":"Array index out of bounds","4406":"attempt to subtract with overflow","4272":"attempt to subtract with overflow","2858":"attempt to subtract with overflow","1767":"attempt to add with overflow","164":"attempt to add with overflow","4394":"attempt to add with overflow","1054":"L1 portal address of input_asset's bridge is 0","3035":"Array index out of bounds","4772":"Array index out of bounds","4114":"Nested static call failed!","4303":"Array index out of bounds","2578":"input_asset address is not the same as seen in the bridge contract","396":"Initialization hash does not match","3145":"Array index out of bounds","3846":"attempt to add with overflow","2944":"attempt to multiply with overflow","3200":"Array index out of bounds","4681":"Array index out of bounds","2999":"attempt to add with overflow","2798":"attempt to subtract with overflow","3042":"Array index out of bounds","3097":"attempt to add with overflow","2896":"Array index out of bounds","3152":"Array index out of bounds","4688":"Array index out of bounds","3463":"attempt to add with overflow","3006":"attempt to add with overflow","3262":"Array index out of bounds","3183":"attempt to add with overflow","2726":"Array index out of bounds","422":"SharedImmutable already initialized","2915":"attempt to add with overflow","3872":"attempt to add with overflow","4518":"attempt to subtract with overflow","2903":"Array index out of bounds","788":"Nested call failed!","4049":"attempt to add with overflow","2824":"Array index out of bounds","3269":"Array index out of bounds","3970":"Array index out of bounds","4482":"attempt to add with overflow","3446":"Array index out of bounds","3123":"Array index out of bounds","2544":"Function _assert_token_is_same can only be called internally","2733":"Array index out of bounds","2922":"Array index out of bounds","4446":"attempt to add with overflow","795":"Message not authorized by account","2843":"attempt to add with overflow","271":"Array index out of bounds","3977":"Array index out of bounds","3075":"attempt to add with overflow","3130":"Array index out of bounds","4410":"attempt to add with overflow","4788":"attempt to add with overflow","2862":"attempt to subtract with overflow","4654":"attempt to add with overflow","1058":"L1 portal address of output_asset's bridge is 0","3551":"attempt to add with overflow","2716":"attempt to add with overflow","4386":"attempt to add with overflow","278":"Array index out of bounds","2771":"attempt to add with overflow","4374":"Array index out of bounds","77":"attempt to add with overflow","3661":"attempt to add with overflow","4764":"Array index out of bounds","4027":"Array index out of bounds","4216":"call to assert_max_bit_size","2802":"Array index out of bounds","4204":"Nested call failed!","4460":"attempt to add with overflow","4259":"attempt to add with overflow","3101":"Array index out of bounds","1754":"Array index out of bounds","2778":"attempt to subtract with overflow","4314":"attempt to add with overflow","3534":"Array index out of bounds","2699":"Array index out of bounds","4424":"attempt to add with overflow","3010":"Array index out of bounds","3644":"Array index out of bounds","4022":"Index out of bounds","3053":"attempt to add with overflow","3108":"Array index out of bounds","3998":"Not initialized","3163":"attempt to add with overflow","3864":"Array index out of bounds","4699":"attempt to add with overflow","402":"Initializer address is not the contract deployer","3017":"Array index out of bounds"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"TokenBridge"}},{"name":"fields","value":{"fields":[{"name":"token","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Uniswap"}},{"name":"fields","value":{"fields":[{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"input_asset","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"input_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"input_amount","type":{"kind":"field"}},{"name":"output_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce_for_unshield_approval","type":{"kind":"field"}},{"name":"uniswap_fee_tier","type":{"kind":"field"}},{"name":"minimum_output_amount","type":{"kind":"field"}},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"}},{"name":"caller_on_L1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"Uniswap::swap_private_parameters"}}],"kind":"struct","path":"Uniswap::swap_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"input_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"input_amount","type":{"kind":"field"}},{"name":"output_asset_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce_for_transfer_approval","type":{"kind":"field"}},{"name":"uniswap_fee_tier","type":{"kind":"field"}},{"name":"minimum_output_amount","type":{"kind":"field"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"secret_hash_for_L1_to_l2_message","type":{"kind":"field"}},{"name":"caller_on_L1","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"nonce_for_swap_approval","type":{"kind":"field"}}],"kind":"struct","path":"Uniswap::swap_public_parameters"}}],"kind":"struct","path":"Uniswap::swap_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"Uniswap::constructor_parameters"}}],"kind":"struct","path":"Uniswap::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"token_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Uniswap::_assert_token_is_same_parameters"}}],"kind":"struct","path":"Uniswap::_assert_token_is_same_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"token_bridge","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"Uniswap::_approve_bridge_and_exit_input_asset_to_L1_parameters"}}],"kind":"struct","path":"Uniswap::_approve_bridge_and_exit_input_asset_to_L1_abi"}]}},"file_map":{"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"142":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize},\n};\n\n// Just like PublicImmutable but with the ability to read from private functions.\npub struct SharedImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // Intended to be only called once.\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"154":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: Header,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"190":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"274":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"310":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"333":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot: Field,\n    value: Field,\n    next_slot: Field,\n    next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"353":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        oracle::random::random,\n        prelude::{\n            NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n            FunctionSelector,\n        },\n        encrypted_logs::{\n            encrypted_note_emission::{\n                encode_and_encrypt_note, encode_and_encrypt_note_unconstrained,\n                encrypt_and_emit_partial_log,\n            }, encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n        }, keys::getters::get_public_keys,\n        macros::{\n            storage::storage, events::event,\n            functions::{initializer, private, view, public, internal},\n        }, utils::comparison::Comparator, protocol_types::{point::Point, traits::Serialize},\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote, token_note::TokenNote, balance_set::BalanceSet,\n    };\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[event]\n    #[derive(Serialize)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<TokenNote, Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote, Context>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: SharedImmutable<FieldCompressedString, Context>,\n        name: SharedImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n    // docs:start:mint_public\n    #[public]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n    // docs:start:mint_private\n    #[public]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[private]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_public_keys(caller);\n        storage.balances.at(caller).add(caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller),\n        );\n        Token::at(context.this_address())\n            .assert_minter_and_mint(context.msg_sender(), amount)\n            .enqueue(&mut context);\n    }\n    #[public]\n    #[internal]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n    // docs:start:shield\n    #[public]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n    // docs:start:transfer_public\n    #[public]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n    // docs:start:redeem_shield\n    #[private]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options\n            .select(TransparentNote::properties().amount, Comparator.EQ, amount)\n            .select(TransparentNote::properties().secret_hash, Comparator.EQ, secret_hash)\n            .set_limit(1);\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n        storage.balances.at(to).add(to_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to),\n        );\n    }\n    // docs:end:redeem_shield\n    // docs:start:unshield\n    #[private]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                from_keys.ivpk_m,\n                from,\n            ),\n        );\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n    }\n    // docs:end:transfer\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n    // docs:start:transfer_from\n    #[private]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            from_keys.ivpk_m,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            to_keys.ivpk_m,\n            to,\n        ));\n    }\n    // docs:end:transfer_from\n    // docs:start:burn\n    #[private]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_keys = get_public_keys(fee_payer);\n        let user_keys = get_public_keys(user);\n\n        let fee_payer_npk_m_hash = fee_payer_keys.npk_m.hash();\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                user_keys.ovpk_m,\n                user_keys.ivpk_m,\n                user,\n            ),\n        );\n\n        // 4. Now we get the partial payloads\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let fee_payer_randomness = unsafe { random() };\n        let user_randomness = unsafe { random() };\n\n        let fee_payer_setup_payload = TokenNote::setup_payload().new(\n            fee_payer_npk_m_hash,\n            fee_payer_randomness,\n            storage.balances.at(fee_payer).set.storage_slot,\n        );\n\n        let user_setup_payload = TokenNote::setup_payload().new(\n            user_npk_m_hash,\n            user_randomness,\n            storage.balances.at(user).set.storage_slot,\n        );\n\n        // 5. We encrypt and emit the partial note log\n        encrypt_and_emit_partial_log(\n            &mut context,\n            fee_payer_setup_payload.log_plaintext,\n            fee_payer_keys,\n            fee_payer,\n        );\n        encrypt_and_emit_partial_log(\n            &mut context,\n            user_setup_payload.log_plaintext,\n            user_keys,\n            user,\n        );\n\n        // 6. We convert the hiding points to standard `Point` type as we cannot pass `TokenNoteHidingPoint` type\n        // as an argument to a function due to macro limitations (the `TokenNoteHidingPoint` type is macro generated\n        // and hence is not resolved soon enough by the compiler).\n        let fee_payer_point = fee_payer_setup_payload.hiding_point;\n        let user_point = user_setup_payload.hiding_point;\n\n        // 7. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime {\n                FunctionSelector::from_signature(\n                    \"complete_refund((Field,Field,bool),(Field,Field,bool),Field)\",\n                )\n            },\n            [\n                fee_payer_point.x,\n                fee_payer_point.y,\n                fee_payer_point.is_infinite as Field,\n                user_point.x,\n                user_point.y,\n                user_point.is_infinite as Field,\n                funded_amount,\n            ],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_point: Point, user_point: Point, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            TokenNote::finalization_payload().new(fee_payer_point, tx_fee);\n        let user_finalization_payload =\n            TokenNote::finalization_payload().new(user_point, refund_amount);\n\n        // 4. We emit the `tx_fee` and `refund_amount` as unencrypted event such that the `NoteProcessor` can use it\n        // to reconstruct the note.\n        context.emit_unencrypted_log(fee_payer_finalization_payload.log);\n        context.emit_unencrypted_log(user_finalization_payload.log);\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_finalization_payload.note_hash);\n        context.push_note_hash(user_finalization_payload.note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"},"355":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, note::utils::compute_note_hash_for_nullify, oracle::random::random,\n    keys::getters::get_nsk_app, macros::notes::partial_note,\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\n// docs:start:TokenNote\n#[partial_note(quote {amount})]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"357":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n};\n\nuse dep::std::mem::zeroed;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[note]\npub struct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nimpl NullifiableNote for TransparentNote {\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit.\n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier(\n        self,\n        _context: &mut PrivateContext,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // compute_nullifier ignores both of its parameters so we can reuse it here\n        self.compute_nullifier(zeroed(), zeroed())\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all\n"},"453":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_bridge_contract/src/main.nr","source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract TokenBridge {\n    use dep::aztec::prelude::{AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{\n        storage::storage, functions::{public, initializer, private, internal, view},\n    };\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        token: PublicMutable<AztecAddress, Context>,\n        portal_address: SharedImmutable<EthAddress, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[private]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[public]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index,\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(\n            &mut context,\n        );\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    // TODO(#8416): Consider creating a truly private claim flow.\n    #[private]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash =\n            get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private(),\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())\n            ._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes)\n            .enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n    // docs:start:get_token\n    #[public]\n    #[view]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[public]\n    #[internal]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[public]\n    #[internal]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n"},"454":{"path":"/usr/src/noir-projects/noir-contracts/contracts/uniswap_contract/src/util.nr","source":"// docs:start:uniswap_public_content_hash\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// This method computes the L2 to L1 message content hash for the public\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_public_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: Field,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: Field,\n    aztec_recipient: AztecAddress,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 260]; // 8 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_be_bytes();\n    let uniswap_fee_tier_bytes: [u8; 32] = uniswap_fee_tier.to_be_bytes();\n    let output_token_portal_bytes: [u8; 32] =\n        output_asset_bridge_portal_address.to_field().to_be_bytes();\n    let amount_out_min_bytes: [u8; 32] = minimum_output_amount.to_be_bytes();\n    let aztec_recipient_bytes: [u8; 32] = aztec_recipient.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // function selector: 0xf18186d8 keccak256(\"swap_public(address,uint256,uint24,address,uint256,bytes32,bytes32,address)\")\n    hash_bytes[0] = 0xf1;\n    hash_bytes[1] = 0x81;\n    hash_bytes[2] = 0x86;\n    hash_bytes[3] = 0xd8;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = aztec_recipient_bytes[i];\n        hash_bytes[i + 196] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 228] = caller_on_L1_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:uniswap_public_content_hash\n\n// docs:start:compute_swap_private_content_hash\n// This method computes the L2 to L1 message content hash for the private\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_private_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: Field,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: Field,\n    secret_hash_for_redeeming_minted_notes: Field,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 260]; // 8 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_be_bytes();\n    let uniswap_fee_tier_bytes: [u8; 32] = uniswap_fee_tier.to_be_bytes();\n    let output_token_portal_bytes: [u8; 32] =\n        output_asset_bridge_portal_address.to_field().to_be_bytes();\n    let amount_out_min_bytes: [u8; 32] = minimum_output_amount.to_be_bytes();\n    let secret_hash_for_redeeming_minted_notes_bytes: [u8; 32] =\n        secret_hash_for_redeeming_minted_notes.to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // function selector: 0x16f416eb keccak256(\"swap_private(address,uint256,uint24,address,uint256,bytes32,bytes32,address)\")\n    hash_bytes[0] = 0x16;\n    hash_bytes[1] = 0xf4;\n    hash_bytes[2] = 0x16;\n    hash_bytes[3] = 0xeb;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = secret_hash_for_redeeming_minted_notes_bytes[i];\n        hash_bytes[i + 196] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 228] = caller_on_L1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:compute_swap_private_content_hash\n"},"455":{"path":"/usr/src/noir-projects/noir-contracts/contracts/uniswap_contract/src/main.nr","source":"// docs:start:uniswap_setup\nmod util;\n\n// Demonstrates how to use portal contracts to swap on L1 Uniswap with funds on L2\n// Has two separate flows for private and public respectively\n// Uses the token bridge contract, which tells which input token we need to talk to and handles the exit funds to L1\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Uniswap {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, SharedImmutable};\n\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit_public, compute_authwit_message_hash_from_call,\n        set_authorized,\n    };\n\n    use dep::token::Token;\n    use dep::token_bridge::TokenBridge;\n    use crate::util::{compute_swap_private_content_hash, compute_swap_public_content_hash};\n    use dep::aztec::macros::{\n        storage::storage, functions::{public, initializer, view, internal, private},\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        portal_address: SharedImmutable<EthAddress, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal_address: EthAddress) {\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:uniswap_setup\n\n    // docs:start:swap_public\n    #[public]\n    fn swap_public(\n        sender: AztecAddress,\n        input_asset_bridge: AztecAddress,\n        input_amount: Field,\n        output_asset_bridge: AztecAddress,\n        // params for using the transfer approval\n        nonce_for_transfer_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field,\n        minimum_output_amount: Field,\n        // params for the depositing output_asset back to Aztec\n        recipient: AztecAddress,\n        secret_hash_for_L1_to_l2_message: Field,\n        caller_on_L1: EthAddress,\n        // nonce for someone to call swap on sender's behalf\n        nonce_for_swap_approval: Field,\n    ) {\n        if (!sender.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, sender);\n        }\n\n        let input_asset = TokenBridge::at(input_asset_bridge).get_token().view(&mut context);\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_public(\n                sender,\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .call(&mut context);\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n        let input_asset_bridge_portal_address =\n            TokenBridge::at(input_asset_bridge).get_portal_address_public().view(&mut context);\n        let output_asset_bridge_portal_address =\n            TokenBridge::at(output_asset_bridge).get_portal_address_public().view(&mut context);\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        assert(\n            !output_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of output_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_swap_public_content_hash(\n            input_asset_bridge_portal_address,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_portal_address,\n            minimum_output_amount,\n            recipient,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read_public(), content_hash);\n    }\n    // docs:end:swap_public\n\n    // docs:start:swap_private\n    #[private]\n    fn swap_private(\n        input_asset: AztecAddress, // since private, we pass here and later assert that this is as expected by input_bridge\n        input_asset_bridge: AztecAddress,\n        input_amount: Field,\n        output_asset_bridge: AztecAddress,\n        // params for using the unshield approval\n        nonce_for_unshield_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field, // which uniswap tier to use (eg 3000 for 0.3% fee)\n        minimum_output_amount: Field, // minimum output amount to receive (slippage protection for the swap)\n        // params for the depositing output_asset back to Aztec\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        secret_hash_for_L1_to_l2_message: Field, // for when l1 uniswap portal inserts the message to consume output assets on L2\n        caller_on_L1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n    ) {\n        // Assert that user provided token address is same as expected by token bridge.\n        // we can't directly use `input_asset_bridge.token` because that is a public method and public can't return data to private\n        Uniswap::at(context.this_address())\n            ._assert_token_is_same(input_asset, input_asset_bridge)\n            .enqueue_view(&mut context);\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .unshield(\n                context.msg_sender(),\n                context.this_address(),\n                input_amount,\n                nonce_for_unshield_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .enqueue(&mut context);\n\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n        let input_asset_bridge_portal_address =\n            TokenBridge::at(input_asset_bridge).get_portal_address().view(&mut context);\n        let output_asset_bridge_portal_address =\n            TokenBridge::at(output_asset_bridge).get_portal_address().view(&mut context);\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        assert(\n            !output_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of output_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_swap_private_content_hash(\n            input_asset_bridge_portal_address,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_portal_address,\n            minimum_output_amount,\n            secret_hash_for_redeeming_minted_notes,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read_private(), content_hash);\n    }\n    // docs:end:swap_private\n\n    // docs:start:authwit_uniswap_set\n    // This helper method approves the bridge to burn this contract's funds and exits the input asset to L1\n    // Assumes contract already has funds.\n    // Assume `token` relates to `token_bridge` (ie token_bridge.token == token)\n    // Note that private can't read public return values so created an internal public that handles everything\n    // this method is used for both private and public swaps.\n    #[public]\n    #[internal]\n    fn _approve_bridge_and_exit_input_asset_to_L1(\n        token: AztecAddress,\n        token_bridge: AztecAddress,\n        amount: Field,\n    ) {\n        // Since we will authorize and instantly spend the funds, all in public, we can use the same nonce\n        // every interaction. In practice, the authwit should be squashed, so this is also cheap!\n        let nonce = 0xdeadbeef;\n\n        let selector = FunctionSelector::from_signature(\"burn_public((Field),Field,Field)\");\n        let message_hash = compute_authwit_message_hash_from_call(\n            token_bridge,\n            token,\n            context.chain_id(),\n            context.version(),\n            selector,\n            [context.this_address().to_field(), amount, nonce],\n        );\n\n        // We need to make a call to update it.\n        set_authorized(&mut context, message_hash, true);\n\n        let this_portal_address = storage.portal_address.read_public();\n        // Exit to L1 Uniswap Portal !\n        TokenBridge::at(token_bridge)\n            .exit_to_l1_public(this_portal_address, amount, this_portal_address, nonce)\n            .call(&mut context)\n    }\n    // docs:end:authwit_uniswap_set\n\n    // docs:start:assert_token_is_same\n    #[public]\n    #[internal]\n    #[view]\n    fn _assert_token_is_same(token: AztecAddress, token_bridge: AztecAddress) {\n        assert(\n            token.eq(TokenBridge::at(token_bridge).get_token().view(&mut context)),\n            \"input_asset address is not the same as seen in the bridge contract\",\n        );\n    }\n    // docs:end:assert_token_is_same\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"65":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"73":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, CANONICAL_AUTH_REGISTRY_ADDRESS,\n    }, hash::poseidon2_hash_with_separator,\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let result: Field = context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n            [on_behalf_of.to_field(), inner_hash].as_slice(),\n            GasOpts::default(),\n        )\n        .deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n            [message_hash, authorize as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n            [context.this_address().to_field(), reject as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"97":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice,\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: arr_copy_slice(\n            fields,\n            [0; PUBLIC_DATA_TREE_HEIGHT],\n            1 + LEAF_PREIMAGE_LENGTH,\n        ),\n    }\n}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
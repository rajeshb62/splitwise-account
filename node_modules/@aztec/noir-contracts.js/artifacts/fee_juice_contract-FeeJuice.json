{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"FeeJuice","functions":[{"name":"set_portal","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiAFgkAgACAiQCAQADJAIAAAQkAgQHBioIAAcqDAMIKgwECSoMAgoqDAILABAABgAiAF0qBAAAKgwIBSQCBAAGACgFAggAOAgGCSoNCQccDAAHBSkCAAAAAAAAAAAAAAAAAP//////////////////////////AAgOOAUICSECACAACTkBAAAKOAcEBSECACMABTkBAAAmAgA7msoCAAUkAgQJCCoIAAkqDAMKKgwECyoMAgwqDAUNABAACAAiAF0qBAAAKgwKBwAoBwIJADgJBgoqDQoICjgIBAYhAgA0AAY5AQAAJQIA3q0ABioIAQckAgQCCAAQAQgBJAMEAQcAKAcCCCoMCAkqDgYJJAIECQgqCAAJKgwDCioMBAsqDAIMKgwFDSoMBw4AEAAIACIAiyoEAAAqCAEFJAIEAgYAEAEGASQDBAEFACgFAgYqDAYHKg4BByQCBAcGKggAByoMAwgqDAQJKgwCCioMAgsqDAUMABAABgAiAIsqBAAAIyUABHgAgAQNAAAAgASAAyEAAFyAAzkBAAAjIgBYKggBBiQCBAIHABABBwEkAwQBBgAoBgIHKgwHCCQCAAAJKg4JCCoNBgcAKAcCByoOBwYqCAEHAAABAgEqDgYHJAIEAAYkAgQBCCoMBgUgAHAKOAUGASECAHUAASAAcyoNBwEjKg0HARwMAAUCADgEAgMsDAADAAIkAgQBCQw4BQkKIQIAfQAKOQEAACsEAAGAAyUABAACgAQiAKQrCIAFAAMAKAMCCQA4CQUKKg4CCgA4BQgBDjgFAQIhAgCIAAI5AQAAKg4DByoMAQUgAHAiAFgkAgQBByQCBAAIKgwIBiAAkAo4BggBIQIAlAABIACTIxwMAAYBADgEAQIkAgQBAww4BgMJIQIAmgAJOQEAAAAoBQIDADgDBgkqDQkBLQwAAQACADgGBwEOOAYBAiECAKIAAjkBAAAqDAEGIACQKwGAA4AGCwCABgACgAchAACogAcgAKorAIADgAUgALgrAAABgAUBAAABgAQAASUABAAAgAkNAIAJgASAChcAgAqACiEAALaACgEAgAOACYALKwGAC4AIAQCABYAJgAsrAoAIgAsBAIAJAAKACSAArSUBBAABgAUgALgjKwAYyhjK","debug_symbols":"7ZvRTuMwEEX/Jc88eOyZ8ZhfWa1WBQqqVBUEZaUV6r9v2iUuJV4iBhC3Ul8QgTn1iT29iRr3qbuaXzze/Fqsrm8fuvMfT93y9nK2Xtyu+qOnzVl3cb9YLhc3v17+uQvbHxR29Q93s9X28GE9u19352SRzrr56mr7q0j/CteL5bw755A3Z+PqHNJQnaPVauLYqBbl+FwtqmlfbbL5edYRoQlFNKGEJsRoQoImpGhCGU3I0IQKmFBES+qIltQRLanjNyR1zFUo24HQuDoney7OnGttorCT52OWl2OW12OWz+DyJFXeDuTHtVYG6UI6Ucs6SHDZB0HU3ZzYaU5Gc1JOc/J6TlI4zcloTug0J6M5mb7R0XwwJ1soeSD2QP+5+ObhskGFaGrJYhnurChR/th9WFI0oYwmZGhCBUyIA5oQoQlFNKGEJsRoQmhJzd+Q1O+52kem4bUjx71JDGWnn49b345b/zOuGUmk6udwoN8PIeHrh6CvH+IzklpSvacWKRPrrCEM66whltdve0loQowmJGhCiiaU0YQMTaiACWlAEyI0IbSkVrSkVrSkVrSkVrSkVrSkVrSkVrSkzp+S1KVWa+QPChGaUEQTSmhCjCYkaEKKJpTRhAxNqIAJGVpSG1pSG1pSG1pSG1pSG1pSG1pSl+aSSbL68WoyG0HigdQDZQ9kHqg4IArBRZGLii4quSh2UeKi1EV5OoPam/KFiQeKScZU+7w4hUolHVPZNVa7effbOoRzHlPt7mWJb1HtrcH9yZQ9NfVspYQ4nE8J0hiDPHMXo4tKLopdlKsn2ls0J6nsosxFFQ+Vgoty9UZy9UZy9UZy9UZy9UZy9UZ7b4DkUt/DFsKYaveGcc0mEx5T7d6wWN6i2s8++1KtlI5zsP04c5KKLiq5KHZR4qLURbVzw+rWw57SqXyn+nFgodxYXXvvGDuqeCgNLoreTW36w9+z+8XsYjl//irk9ePq8sU3I9d/7v79py/+Cw==","brillig_names":["set_portal"],"assert_messages":{"153":"Array index out of bounds","51":"SharedImmutable already initialized","31":"call to assert_max_bit_size","124":"Array index out of bounds","161":"attempt to add with overflow","135":"attempt to add with overflow","91":"Stack too deep"}},{"name":"claim","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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qDnlPIeaU85zqDnlNIdTc8p5DjWnnOdQc8p5DjWnnOfQxOFpDjWnnOdQc8p5DjWnnOdQc8p5DjWnnOWwLJpTznOoOeU8h5pTznOoOeU8hyYOT3OoOeU8h5pTznOoOeU8h5pTznOoOeU0h0lzynkONaec51BzynkONaec59DE4WkONaec51BzynkONaec51BzynkONaec5pB0R9RrOdSccp5DzSnnOdSccp5DE4enOdSccp5DzSnnOdSccp5DzSnnOdSccppD0j1tr+VQc8p5DjWnnOdQc8p5Dk0cnuZQc8p5DjWnnOdQc8p5DknnlJ7yB8Be2v6LayrjjxfXVO0rh6RzypUcku5KfC2HpHPKpRySzimXckg6p1zKoYnD0xySzimXckg6p1zKIemccimHmlPOc6g55TSHpPtKX8uh5pTzHGpOOc+h5pTzHJo4PM2h5pTzHGpOOc+h5pTzHGpOOc+h5pTTHJLuDH4th5pTznOoOeU8h5pTznNo4vA0h5pTznOoOeU8h5pTznOoOeU8h5pTTnNIurf7tRxqTjnPoeaU8xxqTjnPoYnD0xxqTjnPoeaU8xxqTjnPoeaU8xxqTjnNIet+9JdyqDnlPIeaU85zqDnlPIcmDk9zqDnlPIeaU85zqDnlPIeaU85zqDnlNIes+9FfyqHmlPMcak45z6HmlPMcmjg8zaHmlPMcak45z6HmlPMcak45z6HmlLMcGut+9JdyqDnlPIeaU85zqDnlPIcmDk9zqDnlPIeaU85zqDnlPIeaU85zqDnlNIes+9FfyqHmlPMcak45z6HmlPMcmjg8zaHmlPMcak45z6HmlPMcak45z6HmlNMcsu5HfymHmlPOc6g55TyHmlPOc2ji8DSHmlPOc6g55TyHmlPOc6g55TyHmlNOc8i6H/2lHGpOOc+h5pTzHGpOOc+hicPTHGpOOc+h5pTzHGpOOc+h5pTzHGpOOc2h9qO/gEPNKec51JxynkPNKec5NHF4mkPNKec51JxynkPNKec51JxynkPNKac51H70F3CoOeU8h5pTznOoOeU8hyYOT3OoOeU8h5pTznOoOeU8h5pTznOoOeU0h9qP/gIONaec51BzynkONaec59DE4WkONaec51BzynkONaec51BzynkONaec5lD70V/AoeaU8xxqTjnPoeaU8xyaODzNoeaU8xxqTjnPoeaU8xxqTjnPoeaU0xxqP/oLONSccp5DzSnnOdSccp5DE4enOdSccp5DzSnnOdSccp5DzSnnOdSccppD7Ud/AYeaU85zqDnlPIeaU85zaOLwNIeaU85zqDnlPIeaU85zqDnlPIekc0qb5cGhLX9PS2XdYt6jhXSa8GghHRA8Wkg9v0eLiZZntJA6c48WUrPt0ULqnz1aSC2xRwunyy3rp//x4pKsf6GFdINylxZOl+vSwulyXVo4Xa5Li4mWZ7RwutyyvuKDltLq/otbGx8AW89f7+ak+3dfyyGnf76WQ06zfS2HpM7c+sd5lJrL/ou7Wf/jxd3+TPjfOCTdv/taDkk9/6Uckg4Il3JIOk1cyqGJw9Mcks4pl3JIOqdcyiHpnHIph6RzyqUcak45zSHp/t3Xcqg55TyHmlPOc6g55TyHJg5Pc6g55TyHmlPOc6g55TyHmlPOc6g55TSHpPt3X8uh5pTzHGpOOc+h5pTzHJo4PM2h5pTzHGpOOc+h5pTzHGpOOc+h5pTTHJLu330th5pTznOoOeU8h5pTznNo4vA0h5pTznOoOeU8h5pTznOoOeU8h5pTTnNIun/3tRxqTjnPoeaU8xxqTjnPoYnD0xxqTjnPoeaU8xxqTjnPoeaU8xxqTjnNIen+3ddyqDnlPIeaU85zqDnlPIcmDk9zqDnlPIeaU85zqDnlPIeaU85zyDmnWK0fL7aWvtJCuiW3SwvnNOHSwjkguLRwen6XFhMtz2jhdOYuLZxm26WF0z+7tHBaYpcWudxntJBu6OzSIpf7lBZSl9v6g5ZenBePVj5OerSWvnJIaokv5dDE4WkOSc32pRySOvNLOSS18ZdySOr5L+WQdEC4kMNGukfztRySjh6Xcqg55TyHmlPOc2ji8DSHmlPOc6g55TyHmlPOc6g55TyHmlNOc0i6y/a1HGpOOc+h5pTzHGpOOc+hicPTHGpOOc+h5pTzHGpOOc+h5pTzHGpOOc0h6Tbi13KoOeU8h5pTznOoOeU8hyYOT3OoOeU8h5pTznOoOeU8h5pTznOoOeU0h6TbiF/LoeaU8xxqTjnPoeaU8xyaODzNoeaU8xxqTjnPoeaU8xxqTjnPoeaU0xySbiN+LYeaU85zqDnlPIeaU85zaOLwNIeaU85zqDnlPIeaU85zqDnF53D28ceL57LMrxxqTjnNIek24tdySDqn9JoeHI60/+KZx0c19CzJeXFN5YPwmqp9JZx0qLmPcNIJ6D7CTYT/LOGks9V9hJMOYvcRTjq13Uc46Yh3H+Gk8+BthJPu7X4j4Zo0f5hwTZo/TLgmzR8m3ET4zxKuSfOHCdek+cOEa9L8YcI1af4w4Zo0f5bwrknzhwnXpPnDhGvS/GHCNWn+MOEmwn+WcE2aP0y4Js0fJlyT5g8TrknzhwnXpPmzhA9Nmj9MuCbNHyZck+YPE65J8x8gvI1fhH99xn6YODzNoebB8xxqxPM5tJT/ePE06/svzrPUP16cZ/31zvkZG3UZH6dRlzk/v/h3dTQPIquj4RFZHU2awOpMjaXI6miGRVZHAy+yOpqOkdUxqQOsjiZ6ZHWUFSCro6wAWR1lBcjqKCvAVacvygqQ1VFWgKyOsgJkdZQVIKtjUgdYHWUFyOooK0BWR1kBsjrKCpDVUVYArE5SVoCsjrICZHWUFSCro6wAWR2TOsDqKCtAVkdZAbI6ygqQ1VFWgKyOsgJgdbKyAmR1lBUgq6OsAFkdZQXI6pjUAVZHWQGyOsoKkNVRVoCsjrICZHWUFQCrU5QVIKujrABZHWUFyOooK0BWx6QOsDrKCpDVUVaArI6yAmR1lBUgq6OsAFgdU1aArI6yAmR1nmcFKxkfH5EsO+rk0h4nZMuvV//tyC+vHuWD8fmJlr/13j+Tp/aHPq0nT84xHnLOpf569dM3T/njW5VSH59f/Ds1RdRsUWOiZouaKmq2qGk/Tc2fz2j5Ezm/n1LHO6WBd0oT7pTqgndKCe+UMt4pFbxTMrxTqnin9PNX72V87KWScq5PTqnjndLPX71XN/ZxSv3vhHsyljzMgtmncaeUp2DTA+xS8p9e/TvYSQS2LUxgUySw5Zflrc/AZiawhQmsRQL7aXL7lJj9AluZwDYmsD3UrecT2P4EbCgH9Uhf0wr8CdhQDsoB20M5KA9sKAf16zeblif32Y7uoObHibSeXbCL1ccVapnlr/sRaZmPv/N8dtLPTuM3XA+IyUtTLX+8OJmlv56KXju66wMRaDxozMOKw/mV2Xg3CYQtELq7vkyg3+He4K/z4446Pr/6Kdz1Lzd/vHg1jI/X5v6hVn/v0x/vffrzrU9/LO99+um9Tz+/9+mX9z59e+/Tr+99+u991x3vfdcd733XHe99153vfded733Xne99153vfded733Xne99153vfded733Xne99151vfdcdy1vfdcfy1nfdsbz1XXcsb33XHctb33XH8tZ33bG89V13LG991x3LW991x/Led9303nfd9N533fTed9303nfd9N533fTed9303nfd9N533fTed9303nfd/N533fzed9383nfd/N533fzed9383nfd/N533fzed9383nfd/N533fLed93y3nfd8t533fLed93y3nfd8t533fLed90Cftcdj7ceY3ly+uB3Xe/0we+6s32cSFo+rT/77fy/vtha+1jcYG1+WtywUYoXb/3GMHAbIj2/qSe4L5Oe39QT3KhKz2/qCe7cpec39TTpGUpP8NlOen5TT/BhV3p+U0/w6V96flNP8DhEen5TT+VDofSsyodi6al8KJaeyodi6al8KJaeJj1D6al8KJaeyodi6al8KJaeyodi6al8KJSeTflQLD2VD8XSU/lQLD2VD8XS06RnKD2VD8XSU/lQLD2VD8XSU/lQLD2VD4XSsysfiqWn8qFYeiofiqWn8qFYepr0DKWn8qFYeiofiqWn8qFYeiofiqWn8qFQeqJvKis9v6mn8qFYeiofiqWn8qFYepr0DKWn8qFYeiofiqWn8qFYeiofiqWn8qFQek7lQ7H0VD4US0/lQ7H0VD4US0+TnqH0VD4US0/lQ7H0VD4US0/lQ7H0VD4USc+5KB+KpafyoVh6Kh+KpafyoVh6mvQMpafyoVh6Kh+KpafyoVh6Kh+KpafyoVB6JuVDsfRUPhRLT+VDsfRUPhRLT5OeofRUPhRLT+VDsfRUPhRLT+VDsfRUPhRKz6x8KJaeyodi6al8KJaeyodi6WnSM5Seyodi6al8KJaeyodi6al8KJaeyodC6VmUD8XSU/lQLD2VD8XSU/lQLD1NeobSU/lQLD2VD8XSU/lQLD2VD8XSU/lQKD1N+VAsPZUPxdJT+VAsPZUPxdLTpGcoPZUPxdJT+VAsPZUPxdJT+VAsPZUPhdKzKh+KpafyoVh6Kh+KpafyoVh6mvQMpafyoVh6Kh+KpafyoVh6Kh+KpafyoVB6NuVDsfRUPhRLT+VDsfRUPhRLT5OeofRUPhRLT+VDsfRUPhRLT+VDsfRUPhRKz658KJaeyodi6al8KJaeyodi6WnSM5Seyodi6al8KJaeyodi6al8KJaeyodC6TmUD8XSU/lQLD2VD8XS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i9Z7vj/xRes9d9BS5VLRes8dtFReiqr33Kh6z42q99yoes+NqvfcovWeO2ipcqlovecOWqpciqr33Kh6z42q99yoes8tWu/5/sQXrffcQUuVS0XrPXfQUnkpqt5zo+o9N6rec6PqPTeq3nOL1nvuoDUqtFS5VLTecwctlZei6j03qt5zo+o9t2i95/sTX7TecwctVS4VrffcQUvlpah6z42q99yoes+Nqve8UvWe12i95w5aplyqRus9d9AaFVomL1Wpes8rVe95peo9r9F6z3cnvhqt99xBy5RL1Wi95w5aKi9F1XteqXrPK1XveaXqPa9Uvec1Wu/5PtpovecOWqpcKlrvuYOWyktR9Z5Xqt7zStV7XqP1nu9PfNF6zx20VLlUtN5zBy2Vl6LqPa9UveeVqve8UvWeV6re8xqt99xBS5VLRes930cbrffcQUvlpah6zytV73ml6j2v0XrP9ye+aL3nDlqqXCpa77mDlspLUfWeV6re80rVe16pes8rVe95jdZ77qClyqWi9Z47aKlyKare80rVe16pes8rVe95jdZ7vj/xRes9d9BS5VLRes8dtFReiqr3vFL1nleq3vNK1XteqXrPa7TecwetUaGlyqWi9Z47aKm8FFXveaXqPa9Uvec1Wu/5/sQXrffcQUuVS0XrPXfQUnkpqt7zStV7Xql6zytV73ml6j2v0XrPHbRUuVS03nMHrVGhpfJSVL3nlar3vFL1ntdovee7E1+L1nvuoGXKpVq03nMHLZOXWrmgQsvkpRpV73mj6j1vVL3nLVrv+T7aaL3nDlqmXKpF6z130FJ5Kare80bVe96oes9btN7z/YkvWu+5g5Yql4rWe+6gpfJSVL3njar3vFH1njeq3vNG1XveovWeO2ipcqlovef7aKP1njtoqbwUVe95o+o9b1S95y1a7/n+xBet99xBS5VLRes9d9BSeSmq3vNG1XveqHrPG1XveaPqPW/Res8dtFS5VLTecwctVS5F1XveqHrPG1XveaPqPW/Res/3J75ovecOWqpcKlrvuYOWyktR9Z43qt7zRtV73qh6zxtV73mL1nvuoDUqtFS5VLTecwctlZei6j1vVL3njar3vEXrPd+f+KL1njtoqXKpaL3nDloqL0XVe96oes8bVe95o+o9b1S95y1a77mDliqXitZ77qA1KrRUXoqq97xR9Z43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nqh6zxNV73mK1nu+P/FF6z130FLlUtF6zx20VF6Kqvc8UfWeJ6re80TVe56oes9TtN5zB61RoaXKpaL1njtoqbwUVe95ouo9T1S95yla7/n+xBet99xBS5VLRes9d9BSeSmq3vNE1XueqHrPE1XveaLqPU/Res8dtFS5VLTecwetUaGl8lJUveeJqvc8UfWep2i95/sTX7TecwctVS4VrffcQUvlpah6zxNV73mi6j1PVL3niar3PEXrPd9HG6333EFLlUtF6z130FJ5Kare80TVe56oes9TtN7z/YkvWu+5g5Yql4rWe+6gpfJSVL3niar3PFH1nieq3vNE1XueovWeO2ipcqlovef7aKP1njtoqbwUVe95ouo9T1S95yla7/n+xBet99xBS5VLRes9d9AyealM1XueqXrPM1XveabqPc+LUaFlyqVytN5zBy1TLpWj9Z47aKm8FFXveabqPc9Uvec5Wu/57sSXo/WeO2iZcqkcrffcQUvlpah6zzNV73mm6j3PVL3nmar3PEfrPXfQGhVaqlwqWu+5g5bKS1H1nmeq3vNM1Xueo/We70980XrPHbRUuVS03nMHLZWXouo9z1S955mq9zxT9Z5nqt7zHK333EFLlUtF6z130BoVWiovRdV7nql6zzNV73mO1nu+P/FF6z130FLlUtF6zx20VF6Kqvc8U/WeZ6re80zVe56pes9ztN7zfbTRes8dtFS5VLTecwctlZei6j3PVL3nmar3PEfrPd+f+KL1njtoqXKpaL3nDloqL0XVe56pes8zVe95puo9z1S95zla77mDliqXitZ7vo82Wu+5g5bKS1H1nmeq3vNM1Xueo/We70980XrPHbRUuVS03nMHLZWXouo9z1S955mq9zxT9Z5nqt7zHK333EFLlUtF6z130FLlUlS954Wq97xQ9Z4Xqt7zEq33fHfiK4tRoWXKpUq03nMHLZOXKlS954Wq97xQ9Z4Xqt7zQtV7XqL1njtojQotUy5VovWeO2ipvBRV73mh6j0vVL3nJVrv+f7EF6333EFLlUtF6z130FJ5Kare80LVe16oes8LVe95oeo9L9F6zx20VLlUtN5zB61RoaXyUlS954Wq97xQ9Z6XaL3n+xNftN5zBy1VLhWt99xBS+WlqHrPC1XveaHqPS9UveeFqve8ROs930cbrffcQUuVS0XrPXfQUnkpqt7zQtV7Xqh6z0u03vP9iS9a77mDliqXitZ77qCl8lJUveeFqve8UPWeF6re80LVe16i9Z47aKlyqWi95/too/WeO2ipvBRV73mh6j0vVL3nJVrv+f7EF6333EFLlUtF6z130FJ5Kare80LVe16oes8LVe95oeo9L9F6zx20VLlUtN5zBy1VLkXVe16oes8LVe95oeo9L9F6z/cnvmi95w5aqlyKqve8UPWeF6re80LVe25UvedG1Xtu0XrPd+9ARtV7botRoWXKpSxa77mDlslLGVXvuVH1nhtV77lF6z3fvwNF6z130FJ5qWi95w5aKi9F1XtuVL3nRtV7blS950bVe27Res8dtEx/47NovecOWqNCS+WlgvWe95E+0PZRvqJF91I9P9D2ljy0ufYPtLn/Ce2T01gjyD9eXNdf9Fdq0I3XjdSgu7T7qIGvX7+RGnT/dyM16GbxRmrQneWN1Jio2aIG3bPeSA26wb2RGrnhTWrkhjepkRveoga+QP9GauSGN6mRG96kRm54kxoTNVvUyA1vUiM3vEmN3PAmNXLDm9TIDW9RA78Fwo3UyA1vUiM3vEmN3PAmNSZqtqiRG96kRm54kxq54U1q5IY3qZEb3qIGfhOLG6mRG96kRm54kxq54U1qTNRsUSM3vEmN3PAmNXLDm9TIDW9SIze8RQ38NiQ3UiM3vEmN3PAmNXLDm9SYqNmiRm54k5pYbtgpkIDflOVatLE8q4c2lg110MJvyvJNtPvLd+E3ZbkWbSz/56GNZek8tEaFNpbx8q7JVF4KflOWa9FSeSn4TVkuvUrBb8pyLVoqLwW/Kcu1aKm8FPymLNeiDealHLTBvJSDNpiXctAG81IOWiYvVeE3ZbkWLZOXqvCbslyLNpiX2p346mJUaJlyqQq/Kcu1aJm8VIXflOVatFReCn5TlmvRUnkp+E1ZrkXLlEtV+E1ZrkXLlEtV+E1ZrkVL5aXgN2W5Fi2Vl4LflOVatMG81P7EB78py7VoqXIp+E1ZrkVL5aXgN2W5Fi2Vlwq2z4qHlspLBdsNxUNLlUsF27PEQ0uVSwXbWcRDS+Wlgu3/4aGl8lLBdunw0DKt46vB9tLw0FLlUsF2vPDQUnmpYPtSeGipvFSw3SM8tFReKtgeDx5aqlwq2E4MHlqqXCrYfgkeWiovFWxXAw8tlZcKtveAh5apE6EG2yHAQ0uVSwXr8ffQUnmpYG37HloqLxWsE99DS+WlgjXXe2ipcqlg/fIeWqpcKlgLvIeWyksF62r30FJ5qWCN6h5aqk4Eqt7zStV7Xql6z2u03vP9qxRV73ml6j2vVL3nlar3vFL1ntdovecOWqpcKlrvuYOWKpei6j2vVL3nlar3vFL1ntdovef7E1+03nMHLVUuFa333EFL5aWoes8rVe95o+o9b1S9542q97xF6z130BoVWqZcqkXrPXfQMnmpRtV73qh6zxtV73mL1nu+O/G1aL3nDlqmXKpF6z130FJ5Kare80bVe96oes8bVe95o+o9b9F6zx20VLlUtN5zB61RoaXyUlS9542q97xR9Z63aL3n+xNftN5zBy1VLhWt99xBS+WlqHrPG1XveaPqPW9UveeNqve8Res930cbrffcQUuVS0XrPXfQUnkpqt7zRtV73qh6z1u03vP9iS9a77mDliqXitZ77qCl8lJUveeNqve8UfWeN6re80bVe96i9Z47aKlyqWi95/too/WeO2ipvBRV73mj6j1vVL3nLVrv+f7EF6333EFLlUtF6z130FJ5Kare80bVe96oes8bVe95o+o9b9F6zx20VLlUtN5zBy1VLkXVe96oes8bVe95o+o9b9F6z/cnvmi95w5aqlwqWu+5g5bKS1H1njeq3vNG1XveqHrPG1XveYvWe+6gNSq0VLlUtN5zBy2Vl6LqPW9Uveedqve8R+s93534erTecwctUy7VF6NCy+SlOlXveafqPe9Uveedqve8U/We92i95w5aplyqR+s9d9AaFVoqL0XVe96pes87Ve95j9Z7vj/xRes9d9BS5VLRes8dtFReiqr3vFP1nneq3vNO1XveqXrPe7Te83200XrPHbRUuVS03nMHLZWXouo971S9552q97xH6z3fn/ii9Z47aKlyqWi95w5aKi9F1XveqXrPO1XveafqPe9Uvec9Wu+5g5Yql4rWe76PNlrvuYOWyktR9Z53qt7zTtV73qP1nu9PfNF6zx20VLlUtN5zBy2Vl6LqPe9Uveedqve8U/Wed6re8x6t99xBS5VLRes9d9BS5VJUveedqve8U/Wed6re8x6t93x/4ovWe+6gpcqlovWeO2ipvBRV73mn6j3vVL3nnar3vFP1nvdovecOWqNCS5VLRes9d9BSeSmq3vNO1XveqXrP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PXfQUuVSVL3nlar3vFL1nleq3vNK1XteqXrPa7TecwctVS4VrffcQUuVS1H1nleq3vNK1XteqXrPa7Te8/2JL1rvuYOWKpeK1nu+j5aq97xS9Z5Xqt7zStV7Xql6zytV73mN1nvuoKXKpaL1njtoqXIpqt7zStV7Xql6zytV73mN1nu+P/FF6z130FLlUtF6zx20VF6Kqve8UfWeN6re80bVe96oes/XKzYVWqZcqkXrPXfQMuVSjar3vFH1njeq3vNG1XveovWe7058LVrvuYPWqNAy5VKNqve8UfWeN6re80bVe96oes8bVe95i9Z77qClyqWi9Z47aKlyKare80bVe96oes8bVe95i9Z7vj/xRes9d9BS5VLRes8dtEZ1laLyUlS9542q97xR9Z43qt7zFq333EFLlUtF6z130FLlUlS9542q97xR9Z43qt7zFq33fH/ii9Z7vo82Wu+5g5Yql6LqPW9UveeNqve8UfWeN6re80bVe96i9Z47aKlyqWi95w5aqlyKqve8UfWeN6re80bVe96i9Z7vT3zRes8dtFS5VLTe8320VL3njar3vFH1njeq3vNG1XveqHrPW7TecwctVS4VrffcQUuVS1H1njeq3vNG1XveqHrPW7Te8/2JL1rvuYOWKpeK1nvuoKXyUlS9542q97xR9Z43qt7zRtV73qL1njtoqXKpaL3nDlqqXIqq97xR9Z53qt7zTtV73qP1nu9OfD1a77mD1qjQMuVSnar3vFP1nneq3vNO1XveqXrPO1XveY/We+6gZcqlerTecwctUy7VqXrPO1XveafqPe9Uvec9Wu/5/sQXrffcQUuVS0XrPXfQGtVVispLUfWed6re807Ve96pes97tN5zBy1VLhWt99xBS5VLUfWed6re807Ve96pes97tN7z/YkvWu/5PtpovecOWqpciqr3vFP1nneq3vNO1XveqXrPO1XveY/We+6gpcqlovWeO2ipcimq3vNO1XveqXrPO1XveY/We74/8UXrPXfQUuVS0XrP99FS9Z53qt7zTtV73ql6zztV73mn6j3v0XrPHbRUuVS03nMHLVUuRdV73ql6zztV73mn6j3v0XrP9ye+aL3nDlqqXCpa77mDlspLUfWed6re807Ve96pes87Ve95j9Z77qClyqWi9Z47aKlyKare807Ve96pes87Ve95j9Z7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","brillig_names":["build_msg_block","attach_len_to_msg_block","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","build_msg_block","get_l1_to_l2_membership_witness","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert","directive_integer_quotient"]},{"name":"check_balance","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"fee_limit","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["check_balance"],"assert_messages":{"317":"Array index out of bounds","119":"Storage slot 0 not allowed. Storage slots must start from 1.","14":"Function check_balance can only be called statically","424":"attempt to add with overflow","197":"Array index out of bounds","258":"call to assert_max_bit_size","325":"Array index out of bounds","188":"Balance too low","208":"attempt to add with overflow","251":"Stack too deep","341":"attempt to add with overflow","405":"Array index out of bounds","245":"attempt to add with overflow","309":"Array index out of bounds","227":"Array index out of bounds"}},{"name":"_increase_public_balance","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["_increase_public_balance"],"assert_messages":{"285":"Array index out of bounds","151":"Array index out of bounds","311":"call to assert_max_bit_size","267":"Storage slot 0 not allowed. Storage slots must start from 1.","133":"Array index out of bounds","162":"attempt to add with overflow","383":"Array index out of bounds","415":"attempt to add with overflow","438":"Array index out of bounds","141":"attempt to add with overflow","391":"Array index out of bounds","97":"attempt to add with overflow","27":"Function _increase_public_balance can only be called internally","303":"attempt to add with overflow","399":"Array index out of bounds","169":"Stack too deep","457":"attempt to add with overflow"}},{"name":"balance_of_public","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["balance_of_public"],"assert_messages":{"329":"Array index out of bounds","253":"Array index out of bounds","138":"call to assert_max_bit_size","269":"Array index out of bounds","285":"attempt to add with overflow","209":"Stack too deep","203":"attempt to add with overflow","155":"Array index out of bounds","261":"Array index out of bounds","111":"Storage slot 0 not allowed. Storage slots must start from 1.","348":"attempt to add with overflow","15":"Function balance_of_public can only be called statically","185":"Array index out of bounds","166":"attempt to add with overflow"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"1024":"call to assert_max_bit_size","1143":"Array index out of bounds","1201":"attempt to add with overflow","686":"attempt to add with overflow","104":"SharedImmutable already initialized","869":"Array index out of bounds","223":"Function _increase_public_balance can only be called internally","781":"Array index out of bounds","1159":"attempt to add with overflow","708":"attempt to add with overflow","379":"Function check_balance can only be called statically","1016":"attempt to add with overflow","690":"Array index out of bounds","818":"attempt to add with overflow","1135":"Array index out of bounds","745":"call to assert_max_bit_size","998":"Array index out of bounds","672":"attempt to add with overflow","282":"attempt to add with overflow","858":"attempt to add with overflow","84":"call to assert_max_bit_size","980":"Storage slot 0 not allowed. Storage slots must start from 1.","526":"Function balance_of_public can only be called statically","651":"Stack too deep","697":"Array index out of bounds","880":"attempt to add with overflow","810":"Array index out of bounds","1127":"Array index out of bounds","862":"Array index out of bounds","1182":"Array index out of bounds","792":"attempt to add with overflow","466":"Balance too low","844":"attempt to add with overflow"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnBaoNAEIDhd9mzBzW7OzN5lVKCJhoWRIOaQhHfvZs2lEDO/0V2dPxv32k3d+na+/WUxn5a3PFjc8N0btY0jXna9sK1cxqGdD29vnbl4+H97/5ya8bHuKzNvLqj94Xrxks+WP67T0OXj6Xsxdum1M9Nkf/NYPtn4XzAyhErC1ZWrGxUOZRYucLKNVY+YGXMYMAMBsxgwAwGzGDADEbMYMQMRsxgxAxGzGDEDEbMYMQMRsxgxAwKZlAwg4IZFMygYAYFMyiYQcEMCmZQMIOKGVTMoGIGFTOomEHFDCpmUDGDihlUzKBhBg0zaJhBwwwaZtAwg4YZNMygYQYNM1iVJZeuuHTNpQ9c2nPpwKUjlxYurVya01hxGitOYwVp3PP01cypaYfuefPQ38fzy0XE+n37+5KXfwA=","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"initialize","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VfRbtswDPwXP+dBFCWRzK8MQ5G0aWHAcIokHTAE/ffJXiU3iTyDW5Yhg/MQmPGdRd6JVHysnjbrt5eHun3e7qvll2PVbB9Xh3rbxuhYAfa/7V9XbRfuD6vdoVpCELOoNu1TvCRj3hfVc91sqqUz9L64QFti+kBbNpLREKCARhf4A43ewQQawEiCQ/zYjEfrS3jmkOBi/IB2xYdbyc8m/gz+uqjAzdKMSeNnacakCbM0Y9LQn0uD4iAVK0RDsRz6JfjvLyHFJaxJloFlnliCDCcPCMyABrlrg62ZpRmTBmZpxqSxV5AGYJDG4YQ0ntM4CDCkHqFdNniNbDzmbGTKKGCPaeDEa8cnE6dwOkSQTcdD9AHOJ5R191+Cv3kJAs7lHd1v+rOUygc7ok8s9DKREqOkruGTniyqRJy6hq0bmgawT6d8mCJlH3BSIWZKJbMEM5FOlDPpCcEMAwJi+3cJlY9e53NC3rjbtbFcI5t/2gNo7r8EuHkJv27jGK13ddPULw8nr8Gm+8LyDgaTs41T52yfoeg5zvwGB7ScGED/hl+syksyjj5Nrb6VY2Q7ZCgSJQ8Y4YuhFERNIaOngJ5i9RTUU5ye4vWUoKeQnqJ3n/Tus9591rvPevdZ7z6X3XeSKXRB8XpK0FNIT2E9RZSUGGE/oMqjLf4XyO/sZC9GlPsPJ3aMvq129WrdbLpTqbv51j6mQyqGh++vP+9E8A8=","brillig_names":["pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","pack_arguments_oracle_wrapper"]}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"FeeJuice"}},{"name":"fields","value":{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"portal_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"FeeJuice::set_portal_parameters"}}],"kind":"struct","path":"FeeJuice::set_portal_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"portal_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"FeeJuice::initialize_parameters"}}],"kind":"struct","path":"FeeJuice::initialize_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"FeeJuice::claim_parameters"}}],"kind":"struct","path":"FeeJuice::claim_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"FeeJuice::balance_of_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"FeeJuice::balance_of_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}}],"kind":"struct","path":"FeeJuice::_increase_public_balance_parameters"}}],"kind":"struct","path":"FeeJuice::_increase_public_balance_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"fee_limit","type":{"kind":"field"}}],"kind":"struct","path":"FeeJuice::check_balance_parameters"}}],"kind":"struct","path":"FeeJuice::check_balance_abi"}]}},"file_map":{"102":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT, utils::arr_copy_slice,\n};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message =\n        get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"142":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize},\n};\n\n// Just like PublicImmutable but with the ability to read from private functions.\npub struct SharedImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // Intended to be only called once.\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"154":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: Header,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"180":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress}, merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"274":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"310":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"313":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"333":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot: Field,\n    value: Field,\n    next_slot: Field,\n    next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"406":{"path":"/usr/src/noir-projects/noir-contracts/contracts/fee_juice_contract/src/lib.nr","source":"use dep::aztec::prelude::AztecAddress;\nuse dep::aztec::context::PublicContext;\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\npub fn calculate_fee<TPublicContext>(context: PublicContext) -> Field {\n    context.transaction_fee()\n}\n\npub fn get_bridge_gas_msg_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes: [u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = amount.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x63f44968 keccak256('claim(bytes32,uint256)')\n    hash_bytes[0] = 0x63;\n    hash_bytes[1] = 0xf4;\n    hash_bytes[2] = 0x49;\n    hash_bytes[3] = 0x68;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n"},"407":{"path":"/usr/src/noir-projects/noir-contracts/contracts/fee_juice_contract/src/main.nr","source":"mod lib;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract FeeJuice {\n    use dep::aztec::{\n        protocol_types::{address::{AztecAddress, EthAddress}, constants::FEE_JUICE_INITIAL_MINT},\n        state_vars::{SharedImmutable, PublicMutable, Map},\n        macros::{storage::storage, functions::{private, public, view, internal}},\n    };\n\n    use crate::lib::get_bridge_gas_msg_hash;\n\n    #[storage]\n    struct Storage<Context> {\n        // This map is accessed directly by protocol circuits to check balances for fee payment.\n        // Do not change this storage layout unless you also update the base rollup circuits.\n        balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        portal_address: SharedImmutable<EthAddress, Context>,\n    }\n\n    // Not flagged as initializer to reduce cost of checking init nullifier in all functions.\n    // This function should be called as entrypoint to initialize the contract by minting itself funds.\n    #[private]\n    fn initialize(portal_address: EthAddress) {\n        // Validate contract class parameters are correct\n        let self = context.this_address();\n\n        // Increase self balance and set as fee payer, and end setup\n        FeeJuice::at(self)._increase_public_balance(self, FEE_JUICE_INITIAL_MINT).enqueue(\n            &mut context,\n        );\n        context.set_as_fee_payer();\n        context.end_setup();\n\n        // Enqueue call to set the portal address\n        FeeJuice::at(self).set_portal(portal_address).enqueue(&mut context);\n    }\n\n    // We purposefully not set this function as an initializer so we do not bind\n    // the contract to a specific L1 portal address, since the Fee Juice address\n    // is a hardcoded constant in the rollup circuits.\n    #[public]\n    fn set_portal(portal_address: EthAddress) {\n        assert(storage.portal_address.read_public().is_zero());\n        storage.portal_address.initialize(portal_address);\n    }\n\n    #[private]\n    fn claim(to: AztecAddress, amount: Field, secret: Field) {\n        let content_hash = get_bridge_gas_msg_hash(to, amount);\n        let portal_address = storage.portal_address.read_private();\n        assert(!portal_address.is_zero());\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, portal_address);\n\n        // TODO(palla/gas) Emit an unencrypted log to announce which L1 to L2 message has been claimed\n        // Otherwise, we cannot trace L1 deposits to their corresponding claims on L2\n        FeeJuice::at(context.this_address())._increase_public_balance(to, amount).enqueue(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.balances.at(to).read().add(U128::from_integer(amount));\n        storage.balances.at(to).write(new_balance);\n    }\n\n    #[public]\n    #[view]\n    fn check_balance(fee_limit: Field) {\n        let fee_limit = U128::from_integer(fee_limit);\n        assert(storage.balances.at(context.msg_sender()).read() >= fee_limit, \"Balance too low\");\n    }\n\n    // utility function for testing\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).read().to_field()\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"97":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice,\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: arr_copy_slice(\n            fields,\n            [0; PUBLIC_DATA_TREE_HEIGHT],\n            1 + LEAF_PREIMAGE_LENGTH,\n        ),\n    }\n}\n"}}}
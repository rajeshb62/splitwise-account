{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"Escrow","functions":[{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"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uSWWAUuFxZZbfuXackssttwSiy23xGLLrbA4+6zGosstsehySyy63BLLgKXCYsstsdhySyy23BKLLbfE4kliVbGw37PPPseiyy2x6HJLLLbc6ivX2Wc1FltuicWWW2Kx5ZZYbLklFl1ugWXs9+yzz7HockssutwSiy23xDJgqbDYckssttwSiyeJFcXC2O/ZZ59j0eVWWPZ79tnnWGy51Veus89qLLbcEsuApcJiyy2x2HJLLLrcEosut8Siy62w7Pfss8+x2HJLLLbcEostt8QyYKmweJJYVSzs9+yzz7HockssutwSiy23+sp19lmNxZZbYrHlllhsuSWWAUuFRZdbYtHlllh0uSUWXW6JxZZbYXH2WY3FlltiseWWWDxJrCoW9nv22edYdLklFl1uicWWW37l2nJLLLbcCouzz2osttwSiy23xKLLLbEMWCosutwSiy63xGLLLbHYckssttwKi7PPaiyeJFYVC/s9++xzLLrcEsuApcJiyy2/cm25JRZbbonFlltiseVWWJx9VmPR5ZZYdLklFl1uiWXAUmGx5ZZYbLklFltuicWWW2LxJLGqWNjv2WefY9Hlllh0uSUWW271levssxqLLbfEYsstsdhySyy23BKLLrfCst+zzz7HosstsehySyy23BLLgKXCYsstsdhySyyeJFYVC/s9++xzLLrcAstlv2effY7Fllt85V6cfVZjseWWWAYsFRZbbonFllti0eWWWHS5JRZdboVlv2effY7FlltiseWWWGy5JZYBS4XFk8SqYmG/Z599jkWXW2LR5ZZYbLnVV66zz2osttwSiy23xGLLLbEMWCosutwSiy63xKLLLbHockssttwKi7PPaiy23BKLLbfE4kliVbGw37PPPseiyy2x6HJLLLbc8ivXlltiseVWWJx9VmOx5ZZYbLklFl1uiWXAUmHR5ZZYdLklFltuicWWW2Kx5VZYnH1WY/EksapY2O/ZZ59j0eWWWAYsFRZbbvmVa8stsdhySyy23BKLLbfC4uyzGosut8Siyy2x6HJLLAOWCostt8Riyy2x2HJLLLbcEosniVXFwn7PPvsciy63xKLLLbHYcquvXGef1VhsuSUWW26JxZZbYrHlllh0uRWW/Z599jkWXW6JRZdbYrHlllgGLBUWW26JxZZbYvEksapY2O/ZZ59j0eVWWPZ79tnnWGy5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8pToXk3J8pToXk3J8pToXk3J8pQMU2JKFqdE92pKlqdE92pKlqdE92pKlqdE92pKlqdE92pKFqfkoXs1JctTons1JctTons1JctTons1JctTMkyJKVmcEt2rKVmeEt2rKVmeEt2rKVmeEt2rKVmeEt2rKVmakttB92pKlqdE92pKlqdE92pKlqdE92pKlqdkmBJTsjgluldTsjwluldTsjwluldTsjwluldTsjwluldTsjglR92rKVmeEt2rKVmeEt2rKVmeEt2rKVmekmFKTMnilOheTcnylOheTcnylOheTcnylOheTcnylOheTcnilJx0r6ZkeUp0r6ZkeUp0r6ZkeUp0r6ZkeUqGKTEli1OiezUly1OiezUly1OiezUly1OiezUly1OiezUli1Ny1r2akuUp0b2akuUp0b2akuUp0b2akuUpGabElCxOie7VlCxPie7VlCxPie7VlCxPie7VlCxPie7VlCxOydC9mpLlKdG9mpLlKdG9mpLlKdG9bnVKnqn8mJLH++CH4LcZ/Die3t7zGLfPX3x6nC9vqTwuv37yqQR3uL+9jcvh8fj9xT9HSvdqpMIjpag1UuGR0uoaqfBIqYCNVHik9MVGKjtSF+WykQqPlCbaSIVHSm1tpMIjpeM2UuGRGkbKSGVHSntupMIjpT03UuGR0p4bqfBIac+NVHiktOdGKjtSV+25kQqPlPbcSIVHSntupMIjpT03UuGRGkbKSGVHSntupMIjpT03UuGR0p4bqfBIac+NVHiktOdGKjtSN+25kQqPlPbcSIVHSntupMIjpT03UuGRGkbKSGVHSntupMIjpT03UuGR0p4bqfBIac+NVHiktOdGKjtSd+25kQqPlPbcSIVHSntupMIjpT03UuGRGkbKSGVHSntupMIjpT03UuGR0p4bqfBIac+NVHiktOdGKjtSD+25kQqPlPbcSIVHSntupMIjpT03UuGRGkbKSGVHSntupMIjpT03UuGR0p4bqfBIac+NVHiktOdGKjpS98Nu2/Mf/cm/X3w/3RdGapwubzzG6XZeQD4ObzN1GafxHvlu2+XXId9t+/o65LttJ1+HfEA+G/lu263XId9t+/M65LttR16HfLftweuQ79auX4b8yD6nI2ef05Gzz+nI2ed05APy2cjZ53Tk7HM6cvY5HTn7nI6cfc5GfmKf05Gzz+nI2ed0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","brillig_names":["get_contract_instance_internal","get_public_keys_and_partial_address","random","decompose_hint","notify_created_note_oracle_wrapper","get_key_validation_request","lt_32_hint","lte_16_hint","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"withdraw","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"address_note::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"address_note::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7Z3bbhy3EkX/Rc9+YLFupH/lwAjsxAkEGHJgOwc4MPTvp0dSX0ZNTac5XZVyrBdDY7G493D2KvX09fvNbx8//PXHL7d3v3/+evP2P99vPn3+9f232893w6vvN4AP//f1z/d3p5dfv73/8u3mLUhNb24+3v02/Kgp3b+5+f3208ebt5Tw/s1qdNaiT6NzSXUaDQKN0UhSnkYjE2yMBkgCoxVIStN4zNwaTzmPw2kxO1Jz8lynubUsB797cwP0ujQvLQ2/Ls1LSyPhl6aWyf7wXraWphQZh9fEVy2Nvi7NS0tTrl8arDRmHqvq/GaLPEhUc4mcrpeAzDSOzmXxAZfWR1Z5mrtKOjfUCA8UHjkffi6wegPwo7+B3HwDNAeVU9lCrCiOGnWJGOZWJDKOozHL3GgBHoKdMZohcjdEPEFDtZwZasRHuM5hw5V9Dm5fF/brevXF3T7j/CdAN+0nnVBPdf4DACed1WiqI4xUZeGat2Kp8+hcH9ZFf9p1wflPClZ8vi7lNS/NvNTXvLTyguk1L628ILzmpZmX/NOui8r4RQoLLNbl4e80YvB1yWlalwzn63KyTz+2ff6x7UffyFt+Q1uA0oYK6kRVTrK5JykJ60SsKPjtQ8Do25D/0mWPvon6L132f2ALuIwLiQJ1Y9kr6rjdUbGUa3fsUPq53m57e5XzlDamevZ2T0XtjTmeDwVwkY014mkPsCx2vgzE/ch7lwm3FkZgc8f7sP9y/MSGzjC/2dp6s1zGDQSB2fow9OSGDnCTQSY3yhtuhrDAdHyHJdEqbhzPkvhbElpYkrqypPEslWMtEaUNS0hp6oqLLd+a7t8Nrz58uf306faPX86OsafTP+2DXzqnQCnL/bPdpe3DQltFtaOofehmqwh6inJPEfYUUU8R9xRJT1FPInJPInJPIrAnEdiTCOxJBPYkAnsSgT2JwJ5EYE8isCcR2JMI6kkE9SSCehJBPYlob4woT11ei+jGtu/Z6LKWYHsJsZdQe4liL1HNJThdL0HDkd+n0Zx0sdXTPiuDMM27cs9HnwxBNEM5miGMZoiiGeJohiSaIY1mqEQzVIMZkmidWqJ1aonWqSVap5ZonVqidWqJ1qklWqeWaJ1aonVqjdapNVqn1midWqN1ao3WqTVap9ZonVqjdWqN1qk1Wqcu0Tp1idapS7ROXaJ16hKtU5donbpE69QlWqcu0Tp1idapa7ROXaN16npAp2ZI46kIDItTEUYJtJcgewk+WkJXEmIvofYS5QgJnSXK+rOo5hKQkr0GHPI+6nhWHOflsd8njXwE4HW6joJrhbUGOmiQgwY7aGxDrulM46FKu6pKV1XtqcLUVQVdVbmrCruqqKuKu6q6soFd2cCubGBXNqgrG9SVDerKBnVlg7qyQV3ZoK5sUFc2qCsb1JUN7soGd2WDu7LBXdngrmxwVza4KxvclQ3uygZ3ZUO6siFd2ZCubEhXNqQrG9KVDenKhnRlQ7qyIV3Z0K5saFc2tCsb2pUN7cqGdmVDu7KhXdnQrmxoVzZKVzb+xl70Z2dCti5owulCxELzNUpcHiWyvQTaS5C9BNtLiL2E2ksUe4lqLvE39tNeLWFPd7Wnu9rTXe3prvZ0V3u6qz3d1Z7uak53TsleAuwlsr0E2kuQvQTbS4i9hNpLFHsJe7rBnm6wpxvs6QZ7usGebrCnG+zpBnu6wZ5usKc729Od7enO9nRne7qzPd3Znu5sT3e2pzvb053t6UZ7utGebrSnG+3pRnu60Z5utKcb7elGe7rRnm6yp5vs6SZ7usmebrKnm+zpJnu6yZ5usqeb7Olme7rZnm62p5vt6WZ7uo+4KpzzNJozL5678XhuYj7iMmbmPGkww1pDHTSKg0a11zjikuBNDXDQyA4a6KBBB2hQ1Ysa7KAhDhrqoHEI5zprVFlrVHuNkhw0wEEjO2iggwY5aBzBuUzP/WDhhoY4aKiDRnHQOIJzmTbhBo3VlVH5iMsRNzXAQSM7aKCDBjlosIOGHKyxfKTgqKEOGsVB4wjOy3Qnei600sBDrh3c0gAHjeygcQTnOj11YNDgM43GF22a75xOi/ubI+RHRxTOEYdzJOEcaThHJZojAG9HMj12QPK8S2vYwH70406a4NiMZDF28sPB/EgwPxrMzxGEFZ22FyrIhp+Xnz744KfG8pNTMD8QzE8O5geD+aFgfjiYHwnm54j+XKf7BXF91p8fNI7ouZfvkYG52mtgctAAB43soIEOGuSgwQ4a4qChDhoOnKMD5+TAOTlwTg6ckwPn5MA5OXBODpyTA+fkwDk5cM4OnLMD5+zAOTtwzg6cswPn7MA5O3DODpyzA+fiwLk4cC4OnIsD5+LAuThwLg6ciwPn4sC5OHCuDpyrA+fqwLk6cK4OnKsD5+rAuTpwrg6cqwPnxYHz4sB5ceC8OHBeHDgvDpwXB86LA+fFgfPiwHl14Lw6cF4dOK8OnFcHzqsD59WB8+rAeXXgvNpzTik5aICDRnbQQAcNctBgBw1x0FAHjeKg4cA5OHAODpyDA+fgwDk4cA4OnIMD5+DAOThwDg6cZwfOswPnDs9BIofnIJHDc5DI4TlIlB04zw6cO5wPRw7nw5HD+XDkcD4cOZyrRg7nqpHDuWrkcK4aHXKO13HXnNAh54Pt88PjObuyuCZn8gPB/ORgfjCYH3L3Q2Xyg2s/HMyPBPOjwfyUYH5qLD+cgvnx78+XrnkjzsH8YDA/FMxPrGtKiWNdU0oc65pS4hLMT43lR1IwP8H6swTrzxKsP0uw/izB+rNE6s/DKziNbB8kqTp+0YaU5ucpZm6JyCSiuhz67vRUadPZ6erZp9XU03Kfz87Xzz7uP9Hl7orH2cV0dr129iGW4+zLr8qPsxfT2evVs9fxXiklPc9M+6DHvtlHXkuG57PDtbMXHD/VslqZnA+c/RlNw4t8Gti+OBQgTbefgUXahr2C705nn+yvae+s26iBvTXDC3zock2Hc3ssadlK5eWgXC6B/SV5fwnuL6H9Jc3uN9/xa3kf67FE9pfo/pKyv6TuLmkfM7lcAvtL8v4S3F9C+0van34Zu3ap9axk3WnydI/UXOddL/h0OwuxnV5tpy/XTo/CT2NRaTV9NZ2+3XiPmx5sp8+206Pt9GQ7PdtOLwdOX1ZYkdpOX2ynb2+15nHbrKI+b7Lt/eGXS2B/Sd5fgvtLaH8J7y+R3SXSUaL7S5rhyjQGJi++2D8Fpn2l5cWS9oWTl0tgf0neX4L7S2h/Ce8vkf0lzU//4gZB+4K9yyV1d0n7crrLJbC/JO8vwZ0l98PL/77/cvv+w6ePX4eS02//uvv12+3nu6eX3/735+NvhsH/Bw==","brillig_names":["get_note_internal","decompose_hint","pack_arguments_oracle_wrapper","call_private_function_internal","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":9,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Escrow"}},{"name":"fields","value":{"fields":[{"name":"owner","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"token","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"field"}},{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Escrow::withdraw_parameters"}}],"kind":"struct","path":"Escrow::withdraw_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"owner","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"Escrow::constructor_parameters"}}],"kind":"struct","path":"Escrow::constructor_abi"}]}},"file_map":{"101":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"120":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"132":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: &mut Note) -> NoteEmission<Note>\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"165":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"166":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"177":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"190":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"308":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"309":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"353":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        oracle::random::random,\n        prelude::{\n            NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n            FunctionSelector,\n        },\n        encrypted_logs::{\n            encrypted_note_emission::{\n                encode_and_encrypt_note, encode_and_encrypt_note_unconstrained,\n                encrypt_and_emit_partial_log,\n            }, encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n        }, keys::getters::get_public_keys,\n        macros::{\n            storage::storage, events::event,\n            functions::{initializer, private, view, public, internal},\n        }, utils::comparison::Comparator, protocol_types::{point::Point, traits::Serialize},\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote, token_note::TokenNote, balance_set::BalanceSet,\n    };\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[event]\n    #[derive(Serialize)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<TokenNote, Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote, Context>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: SharedImmutable<FieldCompressedString, Context>,\n        name: SharedImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n    // docs:start:mint_public\n    #[public]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n    // docs:start:mint_private\n    #[public]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[private]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_public_keys(caller);\n        storage.balances.at(caller).add(caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller),\n        );\n        Token::at(context.this_address())\n            .assert_minter_and_mint(context.msg_sender(), amount)\n            .enqueue(&mut context);\n    }\n    #[public]\n    #[internal]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n    // docs:start:shield\n    #[public]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n    // docs:start:transfer_public\n    #[public]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n    // docs:start:redeem_shield\n    #[private]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options\n            .select(TransparentNote::properties().amount, Comparator.EQ, amount)\n            .select(TransparentNote::properties().secret_hash, Comparator.EQ, secret_hash)\n            .set_limit(1);\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n        storage.balances.at(to).add(to_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to),\n        );\n    }\n    // docs:end:redeem_shield\n    // docs:start:unshield\n    #[private]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                from_keys.ivpk_m,\n                from,\n            ),\n        );\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n    }\n    // docs:end:transfer\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n    // docs:start:transfer_from\n    #[private]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            from_keys.ivpk_m,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            to_keys.ivpk_m,\n            to,\n        ));\n    }\n    // docs:end:transfer_from\n    // docs:start:burn\n    #[private]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_keys = get_public_keys(fee_payer);\n        let user_keys = get_public_keys(user);\n\n        let fee_payer_npk_m_hash = fee_payer_keys.npk_m.hash();\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                user_keys.ovpk_m,\n                user_keys.ivpk_m,\n                user,\n            ),\n        );\n\n        // 4. Now we get the partial payloads\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let fee_payer_randomness = unsafe { random() };\n        let user_randomness = unsafe { random() };\n\n        let fee_payer_setup_payload = TokenNote::setup_payload().new(\n            fee_payer_npk_m_hash,\n            fee_payer_randomness,\n            storage.balances.at(fee_payer).set.storage_slot,\n        );\n\n        let user_setup_payload = TokenNote::setup_payload().new(\n            user_npk_m_hash,\n            user_randomness,\n            storage.balances.at(user).set.storage_slot,\n        );\n\n        // 5. We encrypt and emit the partial note log\n        encrypt_and_emit_partial_log(\n            &mut context,\n            fee_payer_setup_payload.log_plaintext,\n            fee_payer_keys,\n            fee_payer,\n        );\n        encrypt_and_emit_partial_log(\n            &mut context,\n            user_setup_payload.log_plaintext,\n            user_keys,\n            user,\n        );\n\n        // 6. We convert the hiding points to standard `Point` type as we cannot pass `TokenNoteHidingPoint` type\n        // as an argument to a function due to macro limitations (the `TokenNoteHidingPoint` type is macro generated\n        // and hence is not resolved soon enough by the compiler).\n        let fee_payer_point = fee_payer_setup_payload.hiding_point;\n        let user_point = user_setup_payload.hiding_point;\n\n        // 7. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime {\n                FunctionSelector::from_signature(\n                    \"complete_refund((Field,Field,bool),(Field,Field,bool),Field)\",\n                )\n            },\n            [\n                fee_payer_point.x,\n                fee_payer_point.y,\n                fee_payer_point.is_infinite as Field,\n                user_point.x,\n                user_point.y,\n                user_point.is_infinite as Field,\n                funded_amount,\n            ],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_point: Point, user_point: Point, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            TokenNote::finalization_payload().new(fee_payer_point, tx_fee);\n        let user_finalization_payload =\n            TokenNote::finalization_payload().new(user_point, refund_amount);\n\n        // 4. We emit the `tx_fee` and `refund_amount` as unencrypted event such that the `NoteProcessor` can use it\n        // to reconstruct the note.\n        context.emit_unencrypted_log(fee_payer_finalization_payload.log);\n        context.emit_unencrypted_log(user_finalization_payload.log);\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_finalization_payload.note_hash);\n        context.push_note_hash(user_finalization_payload.note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"},"355":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, note::utils::compute_note_hash_for_nullify, oracle::random::random,\n    keys::getters::get_nsk_app, macros::notes::partial_note,\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\n// docs:start:TokenNote\n#[partial_note(quote {amount})]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"357":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n};\n\nuse dep::std::mem::zeroed;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[note]\npub struct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nimpl NullifiableNote for TransparentNote {\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit.\n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier(\n        self,\n        _context: &mut PrivateContext,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // compute_nullifier ignores both of its parameters so we can reuse it here\n        self.compute_nullifier(zeroed(), zeroed())\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all\n"},"403":{"path":"/usr/src/noir-projects/noir-contracts/contracts/escrow_contract/src/main.nr","source":"// Sample escrow contract that stores a balance of a private token on behalf of an owner.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract Escrow {\n    use dep::aztec::prelude::{AztecAddress, PrivateImmutable};\n    use dep::aztec::{\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        keys::getters::get_public_keys,\n        macros::{storage::storage, functions::{private, initializer}},\n    };\n\n    // docs:start:addressnote_import\n    use dep::address_note::address_note::AddressNote;\n    // docs:end:addressnote_import\n    use dep::token::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        owner: PrivateImmutable<AddressNote, Context>,\n    }\n\n    // Creates a new instance\n    #[private]\n    #[initializer]\n    fn constructor(owner: AztecAddress) {\n        let owner_keys = get_public_keys(owner);\n        let msg_sender_keys = get_public_keys(context.msg_sender());\n        // docs:start:addressnote_new\n        let mut note = AddressNote::new(owner, owner_keys.npk_m.hash());\n        // docs:end:addressnote_new\n        storage.owner.initialize(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            msg_sender_keys.ovpk_m,\n            owner_keys.ivpk_m,\n            owner,\n        ));\n    }\n\n    // Withdraws balance. Requires that msg.sender is the owner.\n    #[private]\n    fn withdraw(token: AztecAddress, amount: Field, recipient: AztecAddress) {\n        let sender = context.msg_sender();\n\n        let note = storage.owner.get_note();\n        assert(note.address == sender);\n\n        Token::at(token).transfer(recipient, amount).call(&mut context);\n    }\n}\n"},"405":{"path":"/usr/src/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    }, oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext,\n    macros::notes::note,\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"96":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"98":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
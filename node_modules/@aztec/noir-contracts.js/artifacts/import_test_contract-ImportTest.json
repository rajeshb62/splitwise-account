{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"ImportTest","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"call_no_args","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7ZjdbiIxDIXfZa65iO3ETvoqq1UFLa2QEFRAV1oh3n0ztAnDEGbkdqZCK3pRNeV8J8ZJnJ999Tyfvb8+LlYv62318GtfLddP091ivYqtfQV0/N/2bbqqm9vddLOrHoCDmVTz1XP8U4w5TKqXxXJePVjjD5MLNYqXTzV6E7IaGApqsuw/1eQs9KgBTEhyiD+Y9YSupPeekzwYd1LbojmG7C2+Kf49qcDeU3MtNe6emmup4XtqrqVGvp8aChbSlw0ipy/r+diFH7+LUOxCyOUuxPV0EfN+GgNLpy5CacicT9EznJyjNEaDZohoOE03QOiLBuIcwyR3bGw7QQi3FxL+fEhsGyFxuAiJbi8kO0BIxHmpkYSekAKmZRCoqTUFLUtalWL4TFuH7m45dLGpKorYHi1hSINE5PpqPxh2eQqYmKKfq+bIN53yrG2nvA59gI2I2afksOB5xSmU8LznMjW0Ro7hDLBpsTjK4Qj2hPNfHjBiY7ZZLJeL18ezK46pf1E5x2Ag26Fv7a0U9Iw1X2BAy8QGHG9vxQiZUo58I5+xPFw/MHQjoEdQj5AesXqkuFH4PKu89RcI6xHRI16PBDVCRo+AHkE9QnrE6pHy6HubkBDOkFLlzIUznA5cFCdabc/j2su49v679sRp76fGppvsw6j25cI7nD2Ma4/j2tO49nZcezeuPQ9o7y+WlZVx7f249sVVG5DzSVzaRdYZPQJ6BPUI6RGrR5weYTXCX0BEjxQnF9o0YZClPWE4qBExegT0COoR0iNWjzg9wnqkOPqdBwLxeiSoEW/0COgR1COkRGILj7eycsW36YLum4/KH08A5XfrbiSokfLdrxsBPYJKJLbo+h1dML2HiTPtvsqHyk6kfFDsRkCJHGLzz3SzmM6W8/oNov70ffWUniRic/f37eOTKP4H","brillig_names":["pack_arguments_oracle_wrapper","call_private_function_internal","unpack_returns","pack_returns_oracle_wrapper"]},{"name":"call_public_fn","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7ZbbisIwEIbfJde9yOQ446ssIlWrFEoVrQuL+O477ZpU3ZTinmChvSiZ5ktm5p8kzVmsi+Vpuyjrze4oZi9nUe1WeVPuarbOAnT37bjP69Y8NvmhETNwJDNR1GtueikvmdiUVSFmRuIl+0Qrj/5KK5QUaXCQoLVxeKW1NTBCA0gKOPCjIq+VTfGILuAkbU+b5OSK4tweb+F5JsBM0gxJYydphqRxkzRD0vjvS6PJQEiWvO+TRde5wN93QSkXSjobSgZgRlx4gFADD0b3LihVMoshegd9ARjlaJT8iWisjtEQjkQDaHXQh9sG7wRKLGaGVAwGER4FVfD/U1B/ngKBMXFfdlv3NiS2loeyqsrt4u53L9uXTm8SkFETUPiwzjQ9P8bIL4yBZ8ewAd1NJpmVpVA4b28OUj7I5hc2X/NDmS+rohWn7T3Vq6AVm83b/qOH4Xc=","brillig_names":["pack_arguments_oracle_wrapper","enqueue_public_function_call_internal"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiAQEmAgAQjvoeAAIKOAECAyQCBAABIQIADwADIACHJAIEAQMqCAEEJAIEAgUAEAEFASQDBAEEACgEAgUfPAADAAMABSoNBAUAKAUCBSoOBQQqCAEFAAABAgEqDgQFKggBBgAAAQIBKg4BBioNBAcAKAcCByoOBwQqCAEHAAABAgEqCAEIJAIEAgkAEAEJASQDBAEIACgIAgkqDAkKJAIAAAsqDgsKKg4IByoNBAkAKAkCCSoOCQQqDQgEACgEAgQqDgQIKgwBAiAANQo4AgEEIQIA4QAEIAA4Kg0FBCoNBgkAOAkDCg44CQoMIQIAPgAMOQEAACoOBAUqDgoGKg0HBSoNBAYCKAYCBioOBgQqDQgGAigGAgYqDgYIACgFAgcAOAcBCCoNCAYqDQQFAigFAgUqDgUEKggBBAAAAQIBKg4DBCoIAQUAAAECASYCAIpIcOwAByQCBAEJJAIEAgsAOAkLCioIAQgAEAEKASQDBAEIACgIAgoqDgkKJAIEAgoAOAgKCSoMCQoqDgcKKg4IBSQCAAEHKgwBAiAAYwo4AgEIIQIAzgAIIABmKg0EAioNBQMpAgAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAAAAEJgIA1UQbDQAFKggBByQCBAMIABABCAEkAwQBBwAoBwIIKgwICSoOBAkAKAkCCSoOBAkAKAcCCAAoAwILKg0LCgAoCwIJKggBCwAAAQIBJAMEAQsAKAsCDTY/lQAIAAYACQAKAA0AAAAMAAUkAgIBAgo4DAIDIQIAgAADOQEAACoIAQIAAAECASQDBAECACgCAgMAKAICAzgDAAMAACAAhyQCAnICJAICbAMkAgIgBCQCAmsFJAIBAQYkAgJ0ByQCAmUIJAICdwkkAgJuCiQCAQALKggBDCQCBBENABABDQEkAwQBDAAoDAINKgwNDiQCAlUPKg4PDgAoDgIOKg4KDgAoDgIOKg4FDgAoDgIOKg4KDgAoDgIOJAICbxAqDhAOACgOAg4qDgkOACgOAg4qDgoOACgOAg4qDgQOACgOAg4kAgJzESoOEQ4AKA4CDioOCA4AKA4CDioOAw4AKA4CDioOCA4AKA4CDiQCAmMSKg4SDgAoDgIOKg4HDgAoDgIOKg4QDgAoDgIOKg4CDgo4CwYNIQIAzQANKggBDiQCBBITABABEwEqDA4TJwMFxvO99Nt+gAAAEwAoEwITACgMAhQkAgQQFSsEABSAAysEABOABCsEABWABSIBBiQCBBAUADgTFBMqDgETACgTAhM5Aw4SIwo4AgEIIQIA0QAIOQEAACoNBAgqDQUJACgIAgorBAAJgAMlAAQAAYAEIgERKwiABQALKwiABgAMKg4HDCoNCwgAKAgCCCoOCAsqDgoEKg4LBSoMAwIgAGMqDQcEKg0FCSoNBgoAOAoCDA44CgwNIQIA6AANOQEAACQCBAENDDgMDQ4hAgDsAA45AQAAACgJAg0AOA0MDioNDgokAgQBDAw4AgwNIQIA8wANOQEAACsEAASAAyUABAACgAQiASsrCIAFAAkAKAkCDAA4DAINKg4KDQA4AgMEDjgCBAohAgD+AAo5AQAAKg4JByoMBAIgADUlAAR4AIAEDQAAAIAEgAMhAAEFgAM5AQAAIyUABAAAgAcNAIAHgAWACBcAgAiACCEAARCACAEAgAOAB4AJKwGACYAGAQCABIAHgAkrAoAGgAkBAIAHAAKAByABByMBAIADAAKABysBgAeABwEAgAeABIAIJQAEAAKACgEAgAiACoAJKwAAAYAFAQAAAYAJAAElAQQAAYAFAQCABQACgAkrAoAIgAklAAQAAoAKAQCAA4AKgAklAAQAAoALAQCABYALgAolAAQAAIAMDQCADIAHgA0XAIANgA0hAAEpgA0BAIAJgAyADisBgA6ACwEAgAqADIAOKwKAC4AOAQCADAACgAwgASABAIAKgAeABiMrAYADgAYLAIAGAAKAByEAAS+AByABMSsAgAOABSABPysAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQABPYAKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIAE0JQEEAAGABSABPyMrABjKGMo=","debug_symbols":"5V3RbuM2EPwXP+eBXO4uyfxKURycu9zBgOEcEl+BIsi/13Yiu1elFgRrhIH4EkTxcncG0ayHMmm+rr49Pvz68WWz+/70srr/43W1ffq63m+edoer17e71cPzZrvd/Pjy7z+vwvFHDKf4l5/r3fHyZb9+3q/uJca71ePu2/E3P4z/vtk+ru41lLc/71Yxjh9i44bc9WJLifoRXIrZOToWOxVwdIGMLlDQBSq4gAR0gYguIKPvbEnjh+j4ITZ+iI8fkscPKeOH1NFD0vgmlW6+V2LS+hEcU4nn6BTlVEDQBRK6gN4sJ+nyF9VL+mCfxcbcxVr6LfYIxXigOA+UzAOl8ECpNFA08ECJPFCEB0rigcLTbZWn2ypPt1Webqs83VZ5uq3xdFubta9YTh+xlrUHZVYFWelirZYelMwDZVYFuXb3inv/Xqk0UDzwQIk8UIQHSuKBojxQjAeK80DJPFB4uq3zdNvM023z7d32f+3QZ8+dcrw8dwpv/3nulIUJTGICozgwx/SGTe/Y9Df3O9HU5RctaSDaTa1T1MGBn6NjjZ/l9iRdbs+X/+zxk4V+dD571xIu3lVET0RLK0RrI0RLaIVobIWotEI0tUJUWyFqrRD1Voi24oxKK86otOKMaivOqLbijGorzqi24oyqtkK0FWdUF/T2Ej2eF7m5XJ6S+vui17CgdhRd/UzVQ4/qghrSEFXulpRD6HKXlAeoFpUOdtEcf4s+ceXuStNy5Z6yTcuVe9Y2LVfuidu0XLnfXCflGrmnb9Ny5Z7BTcuV2zVNy5XbNk3LVRvi2pBvig35ptiQb4oN+abYkG+ShnyTNOSbpCHfJA35prFbtmfmWq2Lluq5j57bCQ2h5/Y2Q+i53coQ+tsXdtfLGuZq2q9Q0RVSgFeI8AoCr5DgFW7uQrn7ACFf7lSr78kdmTwjkxdk8gpMfvvu92vJIzK5IJMnZHJFJkcqVJEKVaRCFalQRSrUkAo1pEINqVBDKtSQCjWkQg2pUEMq1JAKNaRCHalQRyrUkQp1pEIdqVBHKtSRCnWkQh2pUEcqNCMVmpEKzUiFZqRCM1KhGanQjFRoRio0IxWakQotSIUWpEILUqEFqdCCVGhBKrQgFVqQCi1IhRakQitSoRWp0IpUaEUqtCIVWpEKrUiFVqRCK1KhFahQCQGZPCKTCzJ5QiZXZPIFbX6+vsVHyBfST0p1QRugh6g2s0dNyFfRT0p1Qdugr+9RE/I19JNSbWbnoZCvoJ+U6oK2Qw9RXZRbuk51UW7pOtVFuaXrVBfllq5SJV87PynVdtwS+cr5SanO+nXWVw8PEHEiLJkIy7zfaH3O6+J9LJUHSwpEWCIRlnnPEAgXLLmPJRFhUSIsRoTFibBkIiyFCMusfffqcTYy70lzA1giERYhwpKIsCgRFiPCwnNalijPcVky74lzA1iI+q4R9V0j6rtG1HeNqO8aS999O1z+tX7erB+2jy+HIcdXf+2+7jdPu4/L/d8/3185BP8D","brillig_names":["public_dispatch"],"assert_messages":{"208":"Index out of bounds","61":"attempt to add with overflow","253":"attempt to add with overflow","231":"attempt to add with overflow","260":"Stack too deep","235":"Array index out of bounds","242":"Array index out of bounds","127":"Nested call failed!"}},{"name":"pub_call_public_fn","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiAFMqCAEDAAABAgEkAgQBBCoOBAMqCAEFAAABAgEmAgCKSHDsAAYkAgQBCCQCBAIKADgICgkqCAEHABABCQEkAwQBBwAoBwIJKg4ICSQCBAIJADgHCQgqDAgJKg4GCSoOBwUkAgQABiQCAAEHKgwGAiAAIgo4AgYIIQIAQAAIIAAlKg0DAioNBQMpAgAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAAAAEKggBBSQCBAMGABABBgEkAwQBBQAoBQIGKgwGByoOBAcAKAcCByoOBAcmAgDVRBsNAAYAKAUCBwAoAwIKKg0KCQAoCgIIKggBCgAAAQIBJAMEAQoAKAoCDDY/lQAHAAEACAAJAAwAAAALAAYkAgIBAQo4CwECIQIAPwACOQEAACMKOAIGCCECAEMACDkBAAAqDQMIKg0FCQAoCAIKKwQACYADJQAEAAGABCIAWCsIgAUACysIgAYADCoOBwwqDQsIACgIAggqDggLKg4KAyoOCwUqDAQCIAAiJQAEeACABA0AAACABIADIQAAV4ADOQEAACMBAIADAAKABysBgAeABwEAgAeABIAIJQAEAAKACgEAgAiACoAJKwAAAYAFAQAAAYAJAAElAQQAAYAFAQCABQACgAkrAoAIgAklAAQAAoAKAQCAA4AKgAklAAQAAoALAQCABYALgAolAAQAAIAMDQCADIAHgA0XAIANgA0hAABwgA0BAIAJgAyADisBgA6ACwEAgAqADIAOKwKAC4AOAQCADAACgAwgAGcBAIAKgAeABiMrABjKGMo=","debug_symbols":"1ZrBboJAEIbfZc8edoed2cVXaZoGFQ0JQaPYpDG8e8FCtdawNzP/hbDwZ/kOE75kZi9mU67Ou4+q2e5PZvl2MfV+XbTVvulXl25hVseqrqvdx/1jY4eLs9f86VA0w/LUFsfWLMlnYWHKZjPcxqzfYVvVpVl6G7vFv7Sw5zEtHG5pl7snaZKMpr0l2Fs68pN0iPkYjsO3xyyR794XxjlkeEKGz5DhPTI8I8MLMnxAho/I8DkwPCEblpANS8iGJWTDErJhCdmwhGxYQjYsIRuWkA2bKf/bOHETvZMeeUoLX+mVF70TL7/0Yh/plVd9gv71ZR+snfaOWUjQR09uqnsf3J90j+8tNr7Dxids/Awb32PjMza+YOMHbPyIjY9tXca2LmNbl7Gty9jWZWzrMrZ1Gdu6jG1dxrYuv966OU9pyiU8AonVBuS0AZE2II/caRPljf0EvfLOfoJefZdzll59l3OWXnlzf75HG5TPzxP0ygfoCXrlE/QEvfIReoJevWtn6dW7dpZevWtn6aEnigF6ohigXRuBXdv1q8/iWBWruhyPvW/PzfruFHz7dfh504e/AQ==","brillig_names":["pub_call_public_fn"],"assert_messages":{"66":"Index out of bounds","86":"Stack too deep","62":"Nested call failed!"}},{"name":"main_contract","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7ZjdbiIxDIXfZa65iO3ETniV1aqCllZICCqgK60Q774Z2oRhCDNyYSq0ohdVU853YpzE+dlVL7Ppx9vTfPm62lTjX7tqsXqebOerZWztKqDD/zbvk2Xd3Gwn6201Bg5mVM2WL/FPMWY/ql7ni1k1tsbvR2dqFC9favQmZDUwFNRk2X+pyVnoUQOYkOQQfzDrCV1J7z0neTDuqLZFcwzZW3xT/HtUgX2k5lJq3CM1l1LDj9RcSo1cnxoKFtKXDSLHL+v50IUfvotQ6kI4Z8mi6+khpv04BJaOPYTSiDmfgmc4OkdpDAbNDYLhNNkAoS8YiDMMk9yxse30INxdRPjjEbFtRMThLCK6u4js9RER50VGEnoiCphWQKCm1hS0LGk9iuETbR25u+PIxaZyKGJ7tIQhDRGR6yv6YNjlCWBihn6ujCPfc8aztp3xOvIbbEDMPuWGBU+LTaF2572WqaE1cgjnBpsVi6McjmBPOP/lwSI2puv5YjF/ezq52pj6F5VzDAayHfrWpkpBz1jzDQa0TGzA4dZWjJAp5cg38hmrw+WTQjcCegT1COkRq0eK24TPs8pbf4awHhE94vVIUCNk9AjoEdQjpEesHimPvrcJCeEEKVXOXDjD8bRFcaLV9jysvQxr76+1J3Zpn2hsusk+DGpfLry3s4dh7XFYexrW3g5r74a15xva+7NlZWVYez+sfXHVBuR8Epd2kXVGj4AeQT1CesTqEadHWI3wNxDRI8XJhTZNGGRpTxgOakSMHgE9gnqE9IjVI06PsB4pjn7ngUC8HglqxBs9AnoE9QgpkdjCw62sXPFtuqD75mPy5xNA+b26GwlqpHz360ZAj6ASiS26fEcXTM9h4ky7r/KhshMpHxS7EVAi+9j8M1nPJ9PFrH6DqD/9WD6nJ4nY3P59//wkiv8B","brillig_names":["pack_arguments_oracle_wrapper","call_private_function_internal","unpack_returns","pack_returns_oracle_wrapper"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e91704b"},{"kind":"string","value":"TestNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003e91704b"},{"kind":"string","value":"TestNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Test"}},{"name":"fields","value":{"fields":[{"name":"example_constant","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"example_set","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::main_contract_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"ImportTest::main_contract_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::pub_call_public_fn_parameters"}}],"kind":"struct","path":"ImportTest::pub_call_public_fn_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::call_public_fn_parameters"}}],"kind":"struct","path":"ImportTest::call_public_fn_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::call_no_args_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ImportTest::call_no_args_abi"}]}},"file_map":{"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"190":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"376":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n        traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    }, oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"408":{"path":"/usr/src/noir-projects/noir-contracts/contracts/import_test_contract/src/main.nr","source":"// Contract that uses the autogenerated interface of the Test contract for calling its functions.\n// Used for testing calling into other contracts via autogenerated interfaces.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract ImportTest {\n    use dep::aztec::prelude::AztecAddress;\n\n    use dep::test::{Test, Test::DeepStruct, Test::DummyNote};\n\n    use dep::aztec::macros::functions::{private, public};\n\n    // Calls the test_code_gen on the Test contract at the target address\n    // Used for testing calling a function with arguments of multiple types\n    // See yarn-project/simulator/src/client/private_execution.ts\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[private]\n    fn main_contract(target: AztecAddress) -> Field {\n        Test::at(target)\n            .test_code_gen(\n                1,\n                true,\n                1 as u32,\n                [1, 2],\n                DummyNote { amount: 1, secret_hash: 2 },\n                DeepStruct {\n                    a_field: 1,\n                    a_bool: true,\n                    a_note: DummyNote { amount: 1, secret_hash: 2 },\n                    many_notes: [\n                        DummyNote { amount: 1, secret_hash: 2 },\n                        DummyNote { amount: 1, secret_hash: 2 },\n                        DummyNote { amount: 1, secret_hash: 2 },\n                    ],\n                },\n            )\n            .call(&mut context)\n    }\n\n    // Calls the get_this_address on the Test contract at the target address\n    // Used for testing calling a function with no arguments\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[private]\n    fn call_no_args(target: AztecAddress) -> AztecAddress {\n        Test::at(target).get_this_address().call(&mut context)\n    }\n\n    // Calls the emit_nullifier_public on the Test contract at the target address\n    // Used for testing calling a public function\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[private]\n    fn call_public_fn(target: AztecAddress) {\n        Test::at(target).emit_nullifier_public(1).enqueue(&mut context);\n    }\n\n    // Calls the emit_nullifier_public on the Test contract at the target address\n    // Used for testing calling a public function from another public function\n    // See yarn-project/end-to-end/src/e2e_nested_contract.test.ts\n    #[public]\n    fn pub_call_public_fn(target: AztecAddress) {\n        Test::at(target).emit_nullifier_public(1).call(&mut context);\n    }\n}\n"},"409":{"path":"/usr/src/noir-projects/noir-contracts/contracts/test_contract/src/test_note.nr","source":"use dep::aztec::{\n    note::{note_header::NoteHeader, note_interface::NullifiableNote}, context::PrivateContext,\n    macros::notes::note,\n};\n\n// A note which stores a field and is expected to be passed around using the `addNote` function.\n// WARNING: This Note is not private as it does not contain randomness and hence it can be easy to perform\n// serialized_note attack on it. This note has been developed purely for testing purposes so that it can easily be\n// manually added to PXE. Do not use for real applications.\n#[note]\npub struct TestNote {\n    value: Field,\n}\n\nimpl NullifiableNote for TestNote {\n\n    fn compute_nullifier(\n        _self: Self,\n        _context: &mut PrivateContext,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        // This note is expected to be shared between users and fstructor this reason can't be nullified using a secret.\n        0\n    }\n\n    unconstrained fn compute_nullifier_without_context(_self: Self) -> Field {\n        // This note is expected to be shared between users and for this reason can't be nullified using a secret.\n        0\n    }\n}\n\nimpl TestNote {\n    pub fn new(value: Field) -> Self {\n        TestNote { value, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TestNote {\n    fn eq(self, other: Self) -> bool {\n        self.value == other.value\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"65":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"}}}
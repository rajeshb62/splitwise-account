{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"Spam","functions":[{"name":"spam","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"nullifier_seed","type":{"kind":"field"},"visibility":"private"},{"name":"nullifier_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"call_public","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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XbXkrlly7hOZG3PpLLlQSy69JZfBkstoyWWy5DJbclksuayWXDZLLrsll8OSy2nJ5bLkcltyt1hyeSy5vJZcPksuvyVXwJIraMkVsuQKW3JFLLmillwxS+5WS664JVfCkitpyZWy5EpbcmUsubKW3G2WXDlLrrwlV8GSq2jJVbLkKltyVSy5qpZcNUuuuiVXw5JzLDljyYVZcuGWXIQlF2nJRVly0ZZcjCUXa8nVtORqWXK3W3J3WHK1Lbk6ltydltxdllxdS66eJXe3JXePJXevJVffkrvPkrvfknvAkmtgyT1oyT1kyT1syTW05B6x5BpZco0tuSaW3KOWXFNL7jFLrpkl19ySe9ySa2HJtbTkWllyrS25NpZcW0vuCUsuzpKLt+QSLLlESy7Jkku25NpZcu0tuSctuQ6WXEdL7ilLrpMl19mS62LJdbXkully3S25HpZcT0uulyXX25LrY8k9bck9Y8n1teT6WXL9LbkBltxAS26QJfesJTfYknvOkhtiyT1vyb1gyQ215IZZcsMtuRGW3EhLbpQlN9qSe9GSG2PJjbXkXrLkxlly4y25CZbcy5bcREtukiU32ZKbYsm9YslNteSmWXKvWnLTLbkZltxMS+41S26WJTfbkptjyc215F635OZZcvMtuQWW3BuW3JuW3EJL7i1LbpElt9iSW2LJvW3JvWPJLbXklllyyy25FZbcSktulSW32pJ715JbY8mtteTes+TWWXLrLbkNltxGS+59S26TJbfZkvvAkvvQkttiyW215D6y5LZZch9bctstuR2W3CeW3E5Lbpcl96kl95klt9uS22PJfW7J7bXk9lly+y25A5bcQUvukCV32JL7wpL70pI7YskdteS+suS+tuSOWXLHLblvLLlvLbnvLLkTltz3ltwPltxJS+6UJfejJfeTJXfakjtjyf1syf1iyZ215M5Zcr9acr9ZcuctuQuW3O+W3B+W3EVL7pIld9mSu2LJXbXkrlly7h8yb8yls+RCLbn0llwGSy6jJZfJkstsyWWx5LJactksueyWXA5LLqcll8uSy23J3WLJ5bHk8lpy+Sy5/JZcAUuuoCVXyJIrbMkVseSKWnLFLLlbLbnillwJS66kJVfKkittyZWx5MpacrdZcuUsufKWXAVLrqIlV8mSq2zJVbHkqlpy1Sy56pZcDUvOseSMJRdmyYVb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","debug_symbols":"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vNXcylvNrbzV3Mpbza281dzKW82tvNXcylvNrbzV3Mpbza281dzKW82tvNXcylvNrbzV3Mpbza281dzKW82tvNXcylvNbTxraTxraTxraTxraRcuvY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLZ1nLZ1nLZ1nLZ1nLf3CpbfzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrGXwrGXwrGXwrGXwrGVcuPQOnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrVMnrVMnrVMnrVMnrXMC5feybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWxbOWxbOWxbOWxbOWdeHSu3jWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsj7AWk7avaTuH0p68t52/nd7cxN/uL7zyfUqHfp2/fnvlh+u/37L9fluuem3bKn3W3Z5dcvu/nZ1aN6vnX6725c/2Cz7xd2O3S6enod7nWfVx+17TK/3p2jy9E6vy+NWxnWNvV+vz663ubXC4ydk/qwPWm81a7v9+uLzYd6KlrnixcVyf2eR6seL//7AXyPb1w9crvT711B58cg7br3YGS/eOa96uzbVH659S8DXHJdcvP7JxdufXLy/LL6vF19CzW8hqRbzwxd5cqt6Xe8B/PAtq/U0OPoeHNdDKNWnCaX4HR+Q9v0DSn3xAZ2PU98/zsf3vpWUv6Ek9/tPG0951TN5/zH87a833789XJ5cXXMrpB+/leTpj+C4XetpP9zqk35Ru1VxmvX9B/b5Hv3+XOqTPpfzq87tudjDd939ufRXvzztl/nql2f98prLf85+eW32P2m/6Cd9LpW33+2sH6rQt5/Tr6cXfOxz6fc/iV/+6sFk335r7IffSeSyt3t19r2eO3y/2bpe3Gyk3t470q+/fnKS8fV4fvV4eH/5wxsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF9G8cRHNGxfRvHERzRsX0RcuvZs3LqJ54yKaNy6ieeMimjcuonnjIpo3LqJ54yKaNy6ieeMimjcuonnjIpo3LqJ54yKaNy6ieeMimjcuonnjIpo3LqJ54yKaNy6ieeMimjcuonnjIpo3LqJ54yKaNy6ieeMimjcuonnjIpo3LqKNl968cRHNGxfRvHERzRsX0bxxEc0bF9G8cRHNGxfRvHERzVvN3bzV3M1bzd281dzNW83dvNXczVvN3bzV3M1bzd281dzNW83dvNXczVvN3bzV3M1bzd281dzNW83dvNXczVvN3bzV3M2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zls2zlsOzlsOzlsOzlsOzlnPh0nt41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJ41nJw1lIvnLU8JdHS+5RES+9TEi29T0m09D4l0dL7lERL71MSLb1PSbT0PiXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JvPTGWctTEi+9cdbylMRLb5y1PCXx0htnLU9JuPQWnrUUnrUUnrUUnrWUC5fewrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWwrOWyrOWyrOWyrOWyrOWeuHSW3nWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnWUnnW0njW0njW0njW0njW0i5cehvPWhrPWhrPWhrPWhrPWhrPWhrPWtoHWMtJu5fU/UNJT97bzv9ub27iD9d3Prn+2/gmfbv+20Qg+eH677dsn++WnX7Llnq/ZZdXt+zub1eH5v3a6be7ffmDzbJf3O3Y7eLpebjXeVZ93L7H9Hp/iqeMZ9del8etjOsae79en11vc2uFx0/I/FkftN5qPkd99uuLz4d5K1rmihcXy/2dRaofL/7+wPOvP3C50u9fQ+XFI++49WJnvHjnvOrt2lR/uPaWgPUnF99/cvHzBxf/GgNbXy++hJrfQlIt5ocv8uRW9breA/jhW1braXD0PTiuh1CqzxJKr2n0P/MBad8/oNQXH9D5OPX943x871tJ+htKcr//tPGUVz2T9x/DUvL++MXlydU1t0L68VtJnv4Ijtu1nvbDrT7pF7VbFadZ339gn+/R78/FPulzOb/q3J6LPXzX3Z+Lf/XL036Jr3552i/51S9P+6W++uVpv/QnfS6Vt9/trB+q0NvP6WE/l37/k/jlrx5M9u23xn74nUQu+36vdrHv9dzh+83W9eJmI/X23pF+/fWTE5Ovx/Orx8P7yx/euAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjjjYsw3rgI442LMN64COONizDeuAjnjYtw3rgI542LcN64CL9w6e28cRHOGxfhvHERzhsX4bxxEc4bF+G8cRHOW83tvNXczlvN7bzV3M5bze281dzOW83tvNXczlvN7bzV3M5bze281dzOW83tvNXczlvN7bzV3M5bze281dzOW83tvNXczrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWzrOWwbOWwbOWwbOWwbOWceHSO3jWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnjWMnnWMnnWMnnWMnnWMi/nlYRL7+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+RZy+JZy+JZy+JZy+JZy7pw6V08a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a1k8a9k8a9k8a9k8a9k8a9kXLr2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy2bZy37A6zlpN1L6v6hpCfvbed/tzc38YfrO59cr3L+AP92/fnvlh+u/37L8+lu+QOs6P/gLVvq/ZZdXt2yu79dHZr3a6ff7vblDzbLfnG3Y7eLp+fhXudZ9XH7HtPr/SmaPL3T6/K4lXFdY+/X67PrbW6t8PgJmT/rg/P3/bc62u3XF58P81a0zBUvLpb7O4tUP178/YHrX3/gcqXfv4bKi0d+zgzeLu6MF++cV71dm+oP174l4GuOSy7e/+Ti408u/uWvF9bXiy+h5reQVIv54Ys8uVW9rvcAfviW1XoaHH0PjushlOrThFL9jg9I+/4Bpb74gM7Hqe8f5+N730rq31CS+/2njae86pm8/xiWkvfHLy5Prq65FdKP30ry9Edw3K71tB9u9Um/qN2qOM36/gP7fI9+fy7zSZ/L+VXn9lzs4bvu9lxeI/HP2S+vpfon7Rf96pen/WJf/fK0X/yTPpfK2+921g9V6NvP6dfTCz72ufT7n8Qvf/Vgsm+/NfbD7yRy2du9Jvtezx2+32xdL242Um/vHenXXz85mfp6PL96PLy//OGNixjeuIjhjYsY3riI4Y2LmMt5JeH+8md44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ44yKGNy5ieOMihjcuYnjjIoY3LmJ4q7mHt5p7eKu5h7eae3iruYe3mnt4q7mHt5p7eKu5h7eae3iruYe3mnt4q7mHt5p7eKu5h7eae3iruYe3mnt4q7mHt5p7eNZycNbSLpy1PCXR0vuUREvvUxItvU9JtPQ+JdHS+5RES+9TEi29T0m09D4l8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbj0Fp61FJ61FJ61FJ61lAuX3sKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsKzlsqzlsqzlsqzlsqzlnrh0lt51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51lJ51tJ41tJ41tJ41tJ41tIuXHobz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1oaz1o6z1o6z1o6z1o6z1r6hUtv51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL51lL/wBrOWn3krp/KOnJe9v53+3NTfzh+s4n16t06Nv1579bfrj++y3H57vlpN+ypd5v+RzBvLjl07ZvV4fm/drpt7t9+YPNsl/c7djt4ul5uNd5Vn3cvsf0en+KJk/v9Lo8bmVc19j79frseptbKzx+QubP+qD1VrO2268vPh/mrWiZK15cLPd3Fql+vPj7A++//sDlSr9/DZUXj7zj1oud8eKd86q3a1P94dpbAs4fXPxruEsuXv7k4l/+emF9vfgSen69vH3HWswPX+TJrep1vQfww7es1tPg6HtwXA+hVJ8llF7T6H/mA9K+f0CpLz6g83Hq+8f5+N63kvw3lHR+mN++iKe86pm8/xiWkvfHLy5Prq65FdKP30ry9Edw3K71tB9u9Um/qN2q+Lbp6n71+R79/lzikz6X86vO7bnYw3fd/bnkV7887Zf66pen/dJf/fK0X+arX571y+vBAf+TPpfK2+921g9V6NvP6dfTCz72ufT7n8Qvf/Vgsm+/NfbD7yRy2du9Kvtezx2+32xdL242Um/vHenXXz85Sft6PL96PI470eSNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LCN64iOCNiwjeuIjgjYuIC5fewRsXEbxxEcEbFxG8cRHBGxcRvHERwRsXEbxxEcEbFxG8cRHBGxcRvHERwRsXEbxxEcEbFxG8cRHBGxcRvHERwRsXEbxxEcEbFxG8cRHBGxcRvHERwRsXEbxxEcEbFxG8cRHBGxcRvHERwRsXEbxxEcEbFxG8cRHBGxcRvHERwRsXEbxxEcEbFxG81dzBW80dvNXcwVvNHbzV3MFbzR281dzBW80dvNXcwVvNHbzV3MFbzR281dzBW80dvNXcwVvNHbzV3MFbzR281dzBW80dPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGsZPGuZPGuZPGuZPGuZPGuZFy69k2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2ctk2cti2cti2cti2cti2ct68Kld/GsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfGsZfOsZfOsZfOsZfOsZV+49G6etWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetWyetRyetRyetRyetRyetZwLl97Ds5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5bDs5aDs5Z+4azlKYmW3qckWnqfkmjpfUqipfcpiZbepyRaep+SaOl9SqKl9ymJl94fYC3PX7jdS+r+oaQn723nf7c3N/GH6zufXK/SoW/Xn/9u+eH677csn++WlX7Llnq/ZZdXt+zub1eH5v3a6be7ffmDzbJf3O3Y7eLzJ+aHe51n1cfte0yv96do8vROz8+4uJVxAsHer9dn19vcWuHxEzJ/1gett5q13X598fkwb0XLXPHiYrm/s0j148XfH7j/9QcuV/r9a6i8eOQdt17sjBfvnFe9XZvqD9feEjD+5OLzTy6+/uTiX/56YX29+BJqfgtJtZgfvsiTW9Xreg/gh29ZrafB0ffguB5CqT5NKM3v+IC07x9Q6osP6Hyc+v5xPr73W0mvafQ/UZL7/aeNp7zqmbz/GJaS98cvLk+urrkV0o/fSvL0R3DcrvW0H271Sb+o3ao4zfr+A/t8j35/LvJJn8v5Vef2XOzhu+7+XPSrX572i331y9N+8a9+edov8dUvT/slP+lzqbz9bmf9UIXefk4X+7n0+5/EL3/1YLJvvzX2w+8kctnbvTb7Xs8dvt9sXS9uNlJv7x3p118/OdH5ejy/eDy4cRGnJN5f/uDGRZySeH/5gxsXcUri/eUPblzEKYn3lz+4cRGnJN5f/uDGRZySeOmNGxdxSuKlN25cxCmJl964cRGnJF5648ZFnJJ46Y0bF3FK4qU3blzEKYmX3rhxEackXnrjxkWcknjpjRsXcUripTduXMQpiZfeuHERpyReeuPGRZySeOmNGxdxSuKlN25cxCmJl964cRGnJF5648ZFnJJ46Y0bF3FK4qU3blzEKYmX3rhxEackXnrjxkWcknjpjRsXcUripTduXMQpiZfeuHERpyReeuPGRZySeOmNGxdxSuKlN25cxCmJl964cRGnJF5648ZFnJJ46Y0bF3FKwqW38MZFCG9chPDGRQhvXIRcuPQW3rgI4Y2LEN64COGNixDeuAjBreY+JfHSG7ea+5TES2/cau5TEi+9cau5T0m89Mat5j4l8dIbt5r7lMRLb9xq7lMSL71xq7lPSbz0xq3mPiXx0hu3mvuUxEtvnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrUUnrVUnrVUnrVUnrVUnrXUC5feyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWyrOWxrOWxrOWxrOWxrOWduHS23jW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0njW0nnW0nnW0nnW0nnW0i9cejvPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWjrPWgbPWgbPWgbPWgbPWsaFS+/gWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcvgWcv4AGs5afeSun8o6cl72/nf7c1N/OH6zifXq3To2/Xnv1t+uP77Ldfnu+Wm37Kl3m/Z5dUtu/vb1eev3e/XTr/d7csfbJb94m7HbhdPz8O9zrPq4/Y9ptf7UzR5eqfX5XEr47rG3q/XZ9fb3Frh8RMyf9YHrbeatd1+ffH5MG9Fy1zx4mK5v7NI9ePFf3/gr5Ht6wcuV/r9a6i8eOQdt17sjBfvnFe9XZvqD9e+JeBrjksuXv/k4u1PLt5fFt/Xiy+h5reQVIv54Ys8uVW9rvcAfviW1XoaHH0PjushlOrThFL8jg9I+/4Bpb74gM7Hqe8f5+N730rK31CS+/2njae86pm8/xiWkvfHLy5Prq65FdKP30ry9Edw3K71tB9u9Um/qN2qOM36/gP7fI9+fy71SZ/L+VXn9lzs4bvu/lz6q1+e9st89cuzfnnN5T9nv7w2+5+0X/STPpfK2+921g9V6NvP6dfTCz72ufT7n8Qvf/Vgsm+/NfbD7yRy2du9Ovtezx2+32xdL272/M3W7b3PX99cf/3kZOLr8fzq8fD+8oc3LiJ44yKCNy4ieeMikjcuInnjIpI3LiIv55WE+8uf5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkjYtI3riI5I2LSN64iOSNi0jeuIjkreZO3mru5K3mTt5q7uSt5k7eau7kreZO3mru5K3mTt5q7uSt5k7eau7kreZO3mru5K3mTt5q7uSt5k7eau7kreZO3mru5FnL5FnL5FnL5FnL4lnL4lnL4lnL4lnLunDpXTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxrWTxr2Txr2Txr2Txr2Txr2RcuvZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLZtnLYdnLYdnLYdnLYdnLefCpffwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXwrOXgrGVcOGt5SqKl9ymJlt6nJFp6n5Jo6X1KoqX3KYmW3qckWnqfkmjpfUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6ScOktPGspPGspPGspPGspFy69hWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWcthWct5QOs5aTdS+r+oaQn723nf7c3N/GH6zufXK/SoW/Xn/9u+eH677dsn++WnX7Llnq/ZZdXt+zub1eH5v3a6be7ffmDzbJf3O3Y7eLpebjXeVZ93L7H9Hp/iiZP7/S6PG5lXOdv6N+v12fX29xa4fETMn/WB623mrXdfn3x+TBvRctc8eJiub/zOYvqx4u/P/D86w/8/K2J37+GyotH3nHrxc548c551du1qf5w7S0B608uvv/k4ucPLv41Bra+XnwJNb+FpFrMD1/kya3qdb0H8MO3rNbT4Oh7cFwPoVSfJZRe0+h/5gPSvn9AqS8+oPNx6vvH+fjet5L0N5Tkfv9p4ymveibvP4al5P3xn19Fn1xdcyukH7+V5OmP4Lhd62k/3OqTflG7VXGa9f0H9vke/f5c7JM+l/Orzu252MN33f25+Fe/PO2X+OqXp/2SX/3ytF/qq1+e9kt/0udSefvdzvqhCr39nB72c+n3P4lf/urBZN9+a+yH30nksu/3mhf7Xs8dvt9sXS9uNlJv7x3p118/OUn5ejy/ejy8v/zhjYsQ3rgI4Y2LEN64COGNixDeuAjhjYsQ3rgI4Y2LEN64COGNixDeuAjhjYsQ3rgI4Y2LEN64COGNixDeuAjhjYsQ3rgI4Y2LEN64COGNixDeuAjhjYsQ3rgI4Y2LEN64COGNixDeuAjhjYsQ3rgI4Y2LEN64COGNixDeuAjhjYtQ3rgI5Y2LUN64COWNi9ALl97KGxehvHERyhsXobxxEcobF6G8cRHKGxehvHERyhsXobxxEcobF6G8cRHKGxehvHERyhsXobxxEcobF6G8cRHKGxehvHERyhsXobxxEcobF6G8cRHKGxehvHERyhsXobxxEcobF6G8cRHKGxehvHERyhsXobxxEcobF6G8cRHKGxehvNXcylvNrbzV3Mpbza281dzKW82tvNXcylvNrbzV3Mpbza281dzKW82tvNXcylvNrbzV3Mpbza281dzKW82tvNXcylvNrTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxrqTxraTxraTxraTxraTxraRcuvY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLY1nLZ1nLZ1nLZ1nLZ1nLf3CpbfzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrKXzrGXwrGXwrGXwrGXwrGVcuPQOnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrUMnrVMnrVMnrVMnrVMnrXMC5feybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWxbOWxbOWxbOWxbOWdeHSu3jWsnjWsnjWsj7AWk7avaTuH0p68t52/nd7cxN/uL7zyfUqHfp2/fnvlh+u/37L8+lu+QOs6P/gLVvq/ZZdXt2yu79dHZr3a6ff7vblDzbLfnG3Y7eLp+fhXudZ9XH7HtPr/SmaPL3T6/K4lXFdY+/X67PrbW6t8PgJmT/rg9Zbzdpuv774fJi3omWueHGx3N9ZpPrx4u8PXP/6A5cr/f41VF488o5bL3bGi3fOq96uTfWHa98S8DXHJRfvf3Lx8ScX//LXC+vrxZdQ81tIqsX88EWe3Kpe13sAP3zLaj0Njr4Hx/UQSvVpQql+xwekff+AUl98QOfj1PeP8/G9byX1byjJ/f7TxlNe9UzefwzLSbr3bw+XJ1fX3Arpx28lefojOG7XetoPt/qkX9RuVZxmff+Bfb5Hvz+X+aTP5fyqc3su9vBdd3sur5H45+yX11L9k/aLfvXL036xr3552i/+SZ9L5e13O+uHKvTt5/Tr6QUf+1z6/U/il796MNm33xr74XcSueztXpN9r+cO32+2rhc3+20+x+1kIP366ycnWl+P51ePB/eXP8UbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsXUbxxEcUbF1G8cRHFGxdRvHERxRsX0bxxEc0bF9G8cRHNGxfRFy69mzcuonnjIpo3LqJ5q7mbt5q7eau5m7eau3mruZu3mrt5q7mbt5q7eau5m7eau3mruZu3mrt5q7mbt5q7eau5m7eau3mruZu3mrt5q7mbt5q7edayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedayedZyeNZyeNZyeNZyeNZyLlx6D89aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs9aDs5a5oWzlqckWnqfkmjpfUqipfcpiZbepyRaep+SaOl9SqKl9ymJlt6nJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKYmX3jhreUripTfOWp6SeOmNs5anJF5646zlKQmX3sKzlsKzlsKzlsKzlnLh0lt41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ41lJ51lJ51lJ51lJ51lIvXHorz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1oqz1rqB1jLSbuX1P1DSU/e287/bm9u4g/Xdz65XqVD364//93yw/Xfbzk+3y0n/ZYt9X7LLq9u2d3frg7N+7XTb3f78gebZb+427HbxdPzcK/zrPq4fY/p9f4UTZ7e6XV53Mq4rrH36/XZ9Ta3Vnj8hMyf9UHrrWZtt19ffD7MW9EyV7y4WO7vLFL9ePH3B95//YHLlX7/GiovHnnHrRc748U751Vv156TtIdrbwk4f3Dxr+EuuXj5k4t/+euF9fXiS5y/db6F5Pnb3vnhizy5Vb2u9wB++JbVehocfQ+O6yGU6rOE0msa/c98QNr3Dyj1xQd0Pk59/zgf3/tWkv+GktzvP2085VXP5P3HsJS8P35xeXJ1za2QfvxWkqc/guN2raf9cKtP+kXtVsVp1vcf2Od79PtziU/6XM6vOrfnYg/fdffnkl/98rRf6qtfnvZLf/XL036Zr3551i+vBwf8T/pcKm+/21k/VKFvP6dfTy/42OfS738Sv/zVg8m+/dbYD7+TyGVv96rsez13+H6zdb242Ui9vXekX3/95GTs6/H86vE47kSTNy5CeeMilDcuQnnjIpQ3LsJ44yKMNy7CeOMijDcuwi5cehtvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8cZFGG9chPHGRRhvXITxxkUYb1yE8VZzG281t/FWcxtvNbfxVnMbbzW38VZzG281t/FWcxtvNbfxVnMbbzW38VZzG281t/FWcxtvNbfxVnMbbzW38VZzG281t/GspfGspfGspfGspfGspfGspfOspfOspfOspfOspV+49HaetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetXSetQyetQyetQyetQyetYwLl97Bs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bBs5bJs5bJs5bJs5bJs5Z54dI7edYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedYyedayeNayeNayeNayeNayLlx6F89aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aFs9aNs9aNs9aNs9aNs9a9oVL7+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy+ZZy/4Aazlp95K6fyjpyXvb+d/tzU384frOJ9erdOjb9ee/W364/vsty+e7ZaXfsqXeb9nl1S27+9vVoXm/dvrtbl/+YLPsF3c7drt4eh7udZ5VH7fvMb3en6LJ0zu9Lo9bGdc19n69Prve5tYKj5+Q+bM+OL8d3upot19ffD7MW9EyV7y4WO7vLFL9ePH3B+5//YHLlX7/GiovHnnHrRc748U751Vv16b6w7W3BIw/ufj8k4uvP7n4l79eWF8vvoSa30JSLeaHL/LkVvW63gP44VtW62lw9D04rodQqk8TSvM7PiDt+weU+uIDOh+nvn+cj+/9VtJrGv1PlOR+/2njKa96Ju8/hqXk/fGLy5Ora26F9OO3kjz9ERy3az3th1t90i9qtypOs77/wD7fo9+fi3zS53J+1bk9F3v4rrs/F/3ql6f9Yl/98rRf/KtfnvZLfPXL037JT/pcKm+/21k/VKG3n9PFfi79/ifxy189mOzbb4398DuJXPZ2r82+13OH7zdb14ubjdTbe0f69ddPTmK+Hs8vHg9vXETzxkU0b1xE88ZFNG9cRPPGRTRvXETzxkU0b1xE88ZFNG9cRPPGRTRvXETzxkU0b1xE88ZFNG9cRPPGRTRvXETzxkU0b1xE88ZFNG9cRPPGRTRvXETzxkU0b1xE88ZFNG9cRPPGRTRvXETzxkU0b1xE88ZFNG9cRPPGRTRvXETzxkU0b1xE88ZFDG9cxPDGRQxvXMTwxkXMhUvv4Y2LGN64iOGNixjeuIjhjYsY3riI4Y2LGN64iOGNixjeuIjhjYsY3riI4Y2LGN64iOGNixjeuIjhjYsY3riI4Y2LGN64iOGNixjeuIjhjYsY3riI4Y2LGN64iOGNixjeuIjhjYsY3riI4Y2LGN64iOGNixjeuIjhjYsY3mru4a3mHt5q7uGt5h7eau7hreYe3mru4a3mHt5q7uGt5h7eau7hreYe3mru4a3mHt5q7uGt5h7eau7hreYe3mru4a3mHp61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJ61HJy1rAtnLU9JtPQ+JdHS+5RES+9TEi29T0m09D4l0dL7lERL71MSLb1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIuvYVnLYVnLYVnLYVnLeXCpbfwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXwrKXyrKXyrKXyrKXyrKVeuPRWnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrVUnrU0nrU0nrU0nrU0nrW0C5fexrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWxrOWzrOWzrOWzrOWzrOWfuHS23nW0j/AWk7avaTuH0p68t52/nd7cxN/uL7zyfUqHfp2/fnvlh+u/37L9fluuem3fP4y737LLq9u2d3frg7N+7XTb3f78gfb+YuMF3c7drt4eh7udZ5VH7fvMb3en6LJ0zu9Lo9bGdc19n69Prv+/Onh9hgfPiHzZ33QeqtZ2+3XF58P81a0zBUvLpb7O4tUP1789wf+Gtm+fuBypd+/hsqLR95x68XOePHOedXbtan+cO1bAr7muOTi9U8u3v7k4v1l8X29+BJqfgtJtZgfvsiTW9Xreg/gh29ZrafB0ffguB5CqT5NKMXv+IC07x9Q6osP6Hyc+v5xPr73raT8DSW533/aeMqrnsn7j2EpeX/84vLk6ppbIf34rSRPfwTH7VpP++FWn/SL2q2K06zvP7DP9+j351Kf9LmcX3Vuz8Uevuvuz6W/+uVpv8xXvzzrl9dc/nP2y2uz/0n7RT/pc6m8/W53/m794bm8/Zx+Pb3gY59Lv/9J/PJXDyb79ltjP/xOIpe93auz7/Xc4fvN1vXiZiP19t6Rfv31kxONr8fzq8eD+8sf542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LcN64COeNi3DeuAjnjYtw3rgI542LCN64iOCNiwjeuIjgjYuIC5fewRsXEbzV3MFbzR281dzBW80dvNXcwVvNHbzV3MFbzR281dzBW80dvNXcwVvNHbzV3MFbzR281dzBW80dvNXcwVvNHbzV3MFbzR08axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8axk8a5k8a5k8a5k8a5k8a5kXLr2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2TZy2LZy2LZy2LZy2LZy3rwqV38axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl8axl86xl86xl86xl86xlX7j0bp61bJ61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VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61VJ61NJ61NJ61NJ61NJ61tAuX3sazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazlsazls6zls6zls6zls6zln7h0tt51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51tJ51jJ41jJ41jJ41jJ41jIuXHoHz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1oGz1rGB1jLSbuX1P1DSU/e287/bm9u4g/Xdz65XuXE/9v1579bfrj++y3Pp7vlD7Ci/4O3bKn3W3Z5dcvu/nb1+SXtfu30292+/MFm2S/udux28fQ83Os8qz5u32N6vT9Fk6d3el0etzKua+z9en12vc2tFR4/IfNnfdB6q1nb7dcXnw/zVrTMFS8ulvs7i1Q/Xvz9getff+Bypd+/hsqLR95x68XOePHOedXbtan+cO1bAr7muOTi/U8uPv7k4l/+emF9vfgSan4LSbWYH77Ik1vV63oP4IdvWa2nwdH34LgeQqk+TSjV7/iAtO8fUOqLD+h8nPr+cT6+962k/g0lud9/2njKq57J+49hKXl//OLy5OqaWyH9+K0kT38Ex+1aT/vhVp/0i9qtitOs7z+wz/fo9+cyn/S5nF91bs/FHr7rbs/lNRL/nP3yWqp/0n7Rr3552i/21S9P+8U/6XOpvP1uZ/1Qhb79nH49veBjn0u//0n88lcPJvv2W2M//E4il73da7Lv9dzh+83W9eJmI/X23pF+/fWTk6ivx/Orx8P7yx/euIjgjYsI3riI4I2LCN64iOCNiwjeuIjgjYsI3riI4I2LCN64iOCNiwjeuIjgjYsI3riI4I2LCN64iOCNiwjeuIjgjYsI3riI4I2LCN64iOCNiwjeuIjgjYsI3riI4I2LCN64iOCNiwjeuIjgjYsI3riI4I2LCN64iOCNiwjeuIjgjYsI3riI4I2LCN64iOSNi0jeuIjkjYtI3riIvHDpnbxxEckbF5G8cRHJGxeRvHERyRsXkbxxEckbF5G8cRHJGxeRvHERyRsXkbxxEckbF5G8cRHJGxeRvHERyRsXkbxxEckbF5G8cRHJGxeRvHERyRsXkbxxEckbF5G8cRHJGxeRvHERyRsXkbxxEckbF5G8cRHJW82dvNXcyVvNnbzV3MlbzZ281dzJW82dvNXcyVvNnbzV3MlbzZ281dzJW82dvNXcyVvNnbzV3MlbzZ281dzJW82dvNXcybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWybOWxbOWxbOWxbOWxbOWdeHSu3jWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnjWsnnWsnnWsnnWsnnWsi9cejfPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWjbPWg7PWg7PWg7PWg7PWs6FS+/hWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvhWcvBWcu5cNbylERL71MSLb1PSbT0PiXR0vuUREvvUxItvU9JtPQ+JdHS+5TES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl8dIbZy1PSbz0xlnLUxIvvXHW8pTES2+ctTwl4dJbeNZSeNZSeNZSeNZSrn99ek/avaTuH0p68t52/nd7cxN/uL7zyfUqHfp2/fnvlh+u/37L8fluOem3bKn3W3Z5dcvu/nZ1aN6vnX672+c/2Mru9VfUD3f7/WW9e9msXvYTcvnyZc+Dtq/r9rLJ69Unef5qqW6Xn79AeW8Y06efTnfe3/2K96v9aZvovamk+vHi7zegf/oNPA/xqntFNfPiBqKvW7tHy/z1b/CfoMsPLir+1UXF3C6ueLj2evth9xN0+YEFFa2gphU0sIJ+gi0/sCChFaS0goxWkNMKoiW10pJaaUmttKRWWlIbLamNltRGS2qjJbXRktpoSW20pDZaUhstqY2W1E5LaqcltdOS2mlJ7bSkdlpSOy2pnZbUTktqpyV10JI6aEkdtKQOWlIHLamDltRBS+qgJXXQkjpoSZ20pE5aUictqZOW1ElL6qQlddKSOmlJnbSkTlpSFy2pi5bURUvqoiV10ZK6aEldtKQuWlIXLamLltRNS+qmJXXTkrppSd20pG5aUjctqftfntT/xD+u7CYWNcCi5iIWJcSilFjUvx7NfDTX+ABS+eG3HCsO8RNW+fJlOyEyOyHyE0L4x5AHvYAJqhcwQfX6HQlaEreiyuJFUdlyqylb39+73goyWkFOKyhoBSWtoPrXF3T/cZTd8Q8FNa2ggRUkF60goRWktIKMVpDTCgpaQUkriJbUQktqoSW10pJaaUmttKRWWlIrLamVltRKS2qlJbXSkprmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCZXmCbVpSd20pG5aUg8tqYeW1ENL6qEl9dCSemhJPbSkHlpSDy2pB5bUdsGS2ohO0S6g9LYLuFnLLicWFcSikljUSnrbbheg7XYB2m4XoP3M1L16me5eZruX+e5lsXtZ7l626xLZdYnsukR3XaK7LtFdl+iuS3TXJbrrEt11ie66RHddorsusV2X2K5LbNcltusS23WJ7brEdl1iuy6xXZfYrkt81yW+6xLfdYnvusR3XeK7LvFdl/iuS3zXJb7rkth1Sey6JHZdErsuiV2XxK5LYtclseuS2HVJ7Lokd12Suy7JXZfkrkty1yW565LcdUnuuiR3XZK7Lqldl9SuS2rXJbXrktp1Se26pHZdUrsuqV2X1K5LetclveuS3nVJ77qkd13Suy7pXZf0rkt61yW965LZdcnsumR2XTK7Lpldl+zmJ9pufqLt5ifabn6izapL/Lp2L5Pdy3T3Mtu9zHcvi93Lcvey2r2sdy/bdcnu7NV3Z6++O3v13dmr785efXf26ruzV9+dvfru7NV3Z6++O3v13dmr785efXf26ruzV9+dvfru7NV3Z6++O3v13dmr785efXf26ruzV9+dvfru7NXtXz8Jau5/hZgj/8+xQm5JK6hoBTWtoN134+6M23dn3L474/afnHH/MbPB/V8/J+P13/q7A/99hDtsrrN70QpqWkEDKyguWkGwaaEesGmhHrBpof5b5mX81oJg00I9YNNCPWDTQj1g00I9YHOdPWFznT1pSZ20pE5aUictqZOW1ElL6qQlddKSOmlJXbSkLlpSFy2pi5bURUvqoiV10ZK6aEldtKQuWlI3LambltRNS+qmJXXTkrppSd20pG5aUjctqZuW1ENL6qEl9dCSemhJPbSkHlpSDy2ph5bUQ0vqgSV1XLCkjguW1HHBkjouWFLHBUvquGBJHRcsqYO20zsu2L86iw/Y6f3rggQ22SgENoMuBDaDLgQ2gy5+y07v31oQbAZdCGwGXQhsBl0IbAZdCGwGXSgtqZWW1EpLaqUltdKSWmlJrbSkVlpSKy2paTu9g7bTO2g7vYO20ztoO72DttM7aDu9g7bTO2g7vYO20ztoO72DttM7aDu9g7bTO2g7vYO20ztoO72DttM7aDu9g7bTO2g7vYO20ztoO72DttM7aDu9g7bTO2g7vYO20ztoO72DttM7aDu9g7bTO2g7vYO20ztoO72DttM7aDu9g7bTO2g7vYO20ztoO72DttM7aDu9g7bTO2g7vYO20ztoO72DttM7aDu9g7bTO2g7vYO20ztoO72jgbsHo4G7B+Nfv9v7nykKOFsvGrh7MP71e77/maJWE3FjN6k/dpP6YzepP3aT+mM3qT92k/pjN6k/dpP6YzepP3aT+mM3qT93k/pzN6k/d5P6czepPy/fvSx2L8vdy2r3st69bNclu0n9uZvUn7tJ/bmb1J+7Sf25m9Sfu0n9uZvUn7tJ/bmb1J+7Sf25m9Sfu0n9uZvUn7tJ/bmb1J+7Sf25m9Sfu0n9uZvUn7tJ/bmb1J+7Sf25m9Sfu0n9uduSmrstqbnbkpq7Lam5myCfuwnyuZsgn7sJ8rnbkpq7Lam525Kauy2puduSmrstqbnbkpq7Lam525Kauy2puduSmrstqbnbkpq7Lam525Kauy2puduSmrstqbnbkpq7Lam525Kauy2puduSmrstqbnbkpq7Lam525Kauy2puduSmrstqbnbkpq7Lam525Kauy2puduSmrstqbnbkpq7Lam525Kauy2puduSmrstqbnbkpq7Lam525Kau7PX3J295u7sNXdnr7k7e83d2Wvuzl5zd/aau7PX3J295u7sNXdnr7U7e63d2Wvtzl5rd/Zau7PX2p291u7stXZnr7U7e63d2Wvtzl5rd/Zau7PX2p291u7stXZnr7U7e63d2Wvtzl5rd/Zau7PX2p291u7stXZnr7U7e63d2Wvtzl5rd/Zau7PX2p291u7stXZnr2X/+ul9vxzjVWa0gpxWEGxnbNF2xhZtZ2ztzuVrdy5fu3P52p3L10/O5f+YFa3lwH/bVsS9seUfMDf0V+s1i7Yztmg7Y4u2M7ZoO2MrYBOei7Yztmg7Y4u2M7ZoO2OLtjO2aDtji7Yztmg7Y4u2M7ZoO2OLtjO2aDtji7Yztmg7Y4u2M7ZoO2OLtjO2aDtji7Yztmg7Y4u2M7ZoO2OLtjO2aDtji7Yztmg7Y4u2M7ZoO2OLtjO2aDtji7Yztmg7Y4u2M7ZoO2OLtjO2aDtji7Yztmg7Y4u2M7ZoO2OL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","brillig_names":["get_public_keys_and_partial_address","random","decompose_hint","notify_created_note_oracle_wrapper","compute_raw_note_log_unconstrained","emit_encrypted_note_log_oracle_wrapper","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert","directive_integer_quotient"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":7,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"public_spam","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"start","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"end","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_spam"],"assert_messages":{"29":"Function public_spam can only be called internally","122":"attempt to add with overflow","439":"Array index out of bounds","148":"Array index out of bounds","177":"attempt to add with overflow","497":"attempt to add with overflow","133":"attempt to add with overflow","357":"attempt to add with overflow","191":"call to assert_max_bit_size","156":"attempt to add with overflow","313":"Storage slot 0 not allowed. Storage slots must start from 1.","339":"Array index out of bounds","304":"Storage slot 0 not allowed. Storage slots must start from 1.","423":"Array index out of bounds","455":"attempt to add with overflow","478":"Array index out of bounds","184":"Stack too deep","431":"Array index out of bounds","166":"Array index out of bounds"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"358":"Array index out of bounds","637":"Array index out of bounds","378":"call to assert_max_bit_size","279":"Array index out of bounds","695":"attempt to add with overflow","369":"attempt to add with overflow","235":"attempt to add with overflow","555":"attempt to add with overflow","261":"Array index out of bounds","290":"attempt to add with overflow","351":"Array index out of bounds","511":"Storage slot 0 not allowed. Storage slots must start from 1.","537":"Array index out of bounds","246":"attempt to add with overflow","502":"Storage slot 0 not allowed. Storage slots must start from 1.","269":"attempt to add with overflow","621":"Array index out of bounds","653":"attempt to add with overflow","676":"Array index out of bounds","347":"attempt to add with overflow","629":"Array index out of bounds","297":"Stack too deep","326":"attempt to add with overflow","67":"Function public_spam can only be called internally"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Spam"}},{"name":"fields","value":{"fields":[{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"start","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"Spam::public_spam_parameters"}}],"kind":"struct","path":"Spam::public_spam_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier_seed","type":{"kind":"field"}},{"name":"nullifier_count","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"call_public","type":{"kind":"boolean"}}],"kind":"struct","path":"Spam::spam_parameters"}}],"kind":"struct","path":"Spam::spam_abi"}]}},"file_map":{"101":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"120":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"141":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr","source":"use dep::protocol_types::{\n    constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest,\n};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission,\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"165":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"166":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"177":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"376":{"path":"/usr/src/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{\n        traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    }, oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext,\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"443":{"path":"/usr/src/noir-projects/noir-contracts/contracts/spam_contract/src/main.nr","source":"mod types;\n\nuse dep::aztec::macros::aztec;\n\n// A contract used for testing a random hodgepodge of small features from simulator and end-to-end tests.\n#[aztec]\ncontract Spam {\n\n    use dep::aztec::{\n        prelude::{Map, AztecAddress, PublicMutable},\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note_unconstrained,\n        keys::getters::get_public_keys,\n        protocol_types::{\n            hash::poseidon2_hash_with_separator,\n            constants::{\n                MAX_NOTE_HASHES_PER_CALL, MAX_NULLIFIERS_PER_CALL, GENERATOR_INDEX__NOTE_NULLIFIER,\n                MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n            },\n        }, macros::{storage::storage, functions::{private, public, internal}},\n    };\n\n    use crate::types::{token_note::TokenNote, balance_set::BalanceSet};\n\n    #[storage]\n    struct Storage<Context> {\n        balances: Map<AztecAddress, BalanceSet<TokenNote, Context>, Context>,\n        public_balances: Map<Field, PublicMutable<U128, Context>, Context>,\n    }\n\n    #[private]\n    fn spam(nullifier_seed: Field, nullifier_count: u32, call_public: bool) {\n        let caller = context.msg_sender();\n        let caller_keys = get_public_keys(caller);\n        let amount = U128::from_integer(1);\n\n        for _ in 0..MAX_NOTE_HASHES_PER_CALL {\n            storage.balances.at(caller).add(caller_keys.npk_m, U128::from_integer(amount)).emit(\n                encode_and_encrypt_note_unconstrained(\n                    &mut context,\n                    caller_keys.ovpk_m,\n                    caller_keys.ivpk_m,\n                    caller,\n                ),\n            );\n        }\n\n        for i in 0..MAX_NULLIFIERS_PER_CALL {\n            if (i < nullifier_count) {\n                context.push_nullifier(poseidon2_hash_with_separator(\n                    [nullifier_seed, i as Field],\n                    GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                ));\n            }\n        }\n\n        if (call_public) {\n            Spam::at(context.this_address())\n                .public_spam(0, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL)\n                .enqueue(&mut context);\n            Spam::at(context.this_address())\n                .public_spam(\n                    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n                    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX,\n                )\n                .enqueue(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn public_spam(start: u32, end: u32) {\n        let one = U128::from_integer(1);\n        for i in start..end {\n            let prev = storage.public_balances.at(i as Field).read();\n            storage.public_balances.at(i as Field).write(prev + one);\n        }\n    }\n}\n"},"444":{"path":"/usr/src/noir-projects/noir-contracts/contracts/spam_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, note::utils::compute_note_hash_for_nullify, oracle::random::random,\n    keys::getters::get_nsk_app, macros::notes::note,\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n// docs:start:TokenNote\n#[note]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"445":{"path":"/usr/src/noir-projects/noir-contracts/contracts/spam_contract/src/types/balance_set.nr","source":"// This file is copied from the token contract.\nuse dep::aztec::prelude::{\n    NoteGetterOptions, NoteViewerOptions, NoteInterface, NullifiableNote, PrivateSet,\n};\nuse dep::aztec::{\n    context::{PrivateContext, UnconstrainedContext},\n    protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, public_keys::NpkM},\n    note::note_emission::OuterNoteEmission,\n};\nuse crate::types::token_note::OwnedNote;\n\npub struct BalanceSet<T, Context> {\n    set: PrivateSet<T, Context>,\n}\n\nimpl<T, Context> BalanceSet<T, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { set: PrivateSet::new(context, storage_slot) }\n    }\n}\n\nimpl<T> BalanceSet<T, UnconstrainedContext> {\n    pub unconstrained fn balance_of<let T_SERIALIZED_LEN: u32>(self: Self) -> U128\n    where\n        T: NoteInterface<T_SERIALIZED_LEN> + NullifiableNote + OwnedNote,\n    {\n        self.balance_of_with_offset(0)\n    }\n\n    pub unconstrained fn balance_of_with_offset<let T_SERIALIZED_LEN: u32>(\n        self: Self,\n        offset: u32,\n    ) -> U128\n    where\n        T: NoteInterface<T_SERIALIZED_LEN> + NullifiableNote + OwnedNote,\n    {\n        let mut balance = U128::from_integer(0);\n        // docs:start:view_notes\n        let mut options = NoteViewerOptions::new();\n        let notes = self.set.view_notes(options.set_offset(offset));\n        // docs:end:view_notes\n        for i in 0..options.limit {\n            if i < notes.len() {\n                balance = balance + notes.get_unchecked(i).get_amount();\n            }\n        }\n        if (notes.len() == options.limit) {\n            balance = balance + self.balance_of_with_offset(offset + options.limit);\n        }\n\n        balance\n    }\n}\n\nimpl<T> BalanceSet<T, &mut PrivateContext> {\n    pub fn add<let T_SERIALIZED_LEN: u32>(\n        self: Self,\n        owner_npk_m: NpkM,\n        addend: U128,\n    ) -> OuterNoteEmission<T>\n    where\n        T: NoteInterface<T_SERIALIZED_LEN> + NullifiableNote + OwnedNote + Eq,\n    {\n        if addend == U128::from_integer(0) {\n            OuterNoteEmission::new(Option::none())\n        } else {\n            // We fetch the nullifier public key hash from the registry / from our PXE\n            let mut addend_note = T::new(addend, owner_npk_m.hash());\n\n            // docs:start:insert\n            OuterNoteEmission::new(Option::some(self.set.insert(&mut addend_note)))\n            // docs:end:insert\n        }\n    }\n\n    pub fn sub<let T_SERIALIZED_LEN: u32>(\n        self: Self,\n        owner_npk_m: NpkM,\n        amount: U128,\n    ) -> OuterNoteEmission<T>\n    where\n        T: NoteInterface<T_SERIALIZED_LEN> + NullifiableNote + OwnedNote + Eq,\n    {\n        let subtracted = self.try_sub(amount, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL);\n\n        // try_sub may have substracted more or less than amount. We must ensure that we subtracted at least as much as\n        // we needed, and then create a new note for the owner for the change (if any).\n        assert(subtracted >= amount, \"Balance too low\");\n        self.add(owner_npk_m, subtracted - amount)\n    }\n\n    // Attempts to remove 'target_amount' from the owner's balance. try_sub returns how much was actually subtracted\n    // (i.e. the sum of the value of nullified notes), but this subtracted amount may be more or less than the target\n    // amount.\n    // This may seem odd, but is unfortunately unavoidable due to the number of notes available and their amounts being\n    // unknown. What try_sub does is a best-effort attempt to consume as few notes as possible that add up to more than\n    // `target_amount`.\n    // The `max_notes` parameter is used to fine-tune the number of constraints created by this function. The gate count\n    // scales relatively linearly with `max_notes`, but a lower `max_notes` parameter increases the likelihood of\n    // `try_sub` subtracting an amount smaller than `target_amount`.\n    pub fn try_sub<let T_SERIALIZED_LEN: u32>(\n        self: Self,\n        target_amount: U128,\n        max_notes: u32,\n    ) -> U128\n    where\n        T: NoteInterface<T_SERIALIZED_LEN> + NullifiableNote + OwnedNote + Eq,\n    {\n        // We are using a preprocessor here (filter applied in an unconstrained context) instead of a filter because\n        // we do not need to prove correct execution of the preprocessor.\n        // Because the `min_sum` notes is not constrained, users could choose to e.g. not call it. However, all this\n        // might result in is simply higher DA costs due to more nullifiers being emitted. Since we don't care\n        // about proving optimal note usage, we can save these constraints and make the circuit smaller.\n        let options = NoteGetterOptions::with_preprocessor(preprocess_notes_min_sum, target_amount)\n            .set_limit(max_notes);\n        let notes = self.set.pop_notes(options);\n\n        let mut subtracted = U128::from_integer(0);\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                subtracted = subtracted + note.get_amount();\n            }\n        }\n\n        subtracted\n    }\n}\n\n// Computes the partial sum of the notes array, stopping once 'min_sum' is reached. This can be used to minimize the\n// number of notes read that add to some value, e.g. when transferring some amount of tokens.\n// The preprocessor (a filter applied in an unconstrained context) does not check if total sum is larger or equal to\n// 'min_sum' - all it does is remove extra notes if it does reach that value.\n// Note that proper usage of this preprocessor requires for notes to be sorted in descending order.\npub fn preprocess_notes_min_sum<T, let T_SERIALIZED_LEN: u32>(\n    notes: [Option<T>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    min_sum: U128,\n) -> [Option<T>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    T: NoteInterface<T_SERIALIZED_LEN> + NullifiableNote + OwnedNote,\n{\n    let mut selected = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let mut sum = U128::from_integer(0);\n    for i in 0..notes.len() {\n        // Because we process notes in retrieved order, notes need to be sorted in descending amount order for this\n        // filter to be useful. Consider a 'min_sum' of 4, and a set of notes with amounts [3, 2, 1, 1, 1, 1, 1]. If\n        // sorted in descending order, the filter will only choose the notes with values 3 and 2, but if sorted in\n        // ascending order it will choose 4 notes of value 1.\n        if notes[i].is_some() & sum < min_sum {\n            let note = notes[i].unwrap_unchecked();\n            selected[i] = Option::some(note);\n            sum = sum.add(note.get_amount());\n        }\n    }\n    selected\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"65":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"96":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"98":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"}}}
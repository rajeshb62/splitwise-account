{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"AppSubscription","functions":[{"name":"subscribe","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"subscriber","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"expiry_block_number","type":{"kind":"field"},"visibility":"private"},{"name":"tx_count","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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xyjZF5MTanrhvrv2/k8aelKzT564DXTy24DnkyeusSfXyDl5Mrd2uD5y7z7rqJt6UrMP7rgNdPfbgOeDO66xL9fIObgzz1PvzvPbu/P89u48bu/O4/buPB+9O9/Tkr7I01gs8jsWi/yOxSLuWCzijsUiH2OxzlPvrvPbu+v89u46bu+u4/buOh+9W6vOft1AH94x3K5yG7jGx8xneu0t13gz1zjHB+1c4tUvxJc66qmhiB2rPzjiNnAfA9X1PuS1f1zjE1zjPB+087kzXexjpiuIVz+aZzjNNvSkZhelbgOd/DbguSh1jT25Rk5R2qVRuD5y7/Z2ZE09qdk7E7eB7n4b8LwzcY19uUbOzqSfp97t57d3+/nt3X7c3u3H7d1+Pnq3wNOSPtzTWAz3OxbD/Y7FcO5YDOeOxXAfYzHZU+9O9tu7k/327mRu707m9u5kH7073xEO9OFlF6VuA5yi1PV6Lkpd481cI6codb0lK0qbNN7/ydRQxI7VF6VuA5yi1PV6Lkpd4xNcI6codb3zuTPlFKWut2RF6ZdH7f+koSc1uyh1G+jktwHPRalr7Mk1corS748K10fu3Z2OuqknNf/mnU4D3f024P3mnY6xL9fIunmnp97d67d39/rt3b3c3t3L7d29Pno3rmm4PnLvVnbUTT2p2WPhNtDdbwOex8I19uUaOWPRyFPvNvLbu4389m4jbu824vZuIx+929fxDvThZRelbgOcotT1ei5KXePNXCOnKHW9JStKFzjqqaGIHasvSt0GOEWp6/VclLrGJ7hGTlHqej0Xpa6RU5S63pIVpR82C289snqZo27qSc1/0oLTQHe/DXh/0oJj7Ms1cjZ3x524X1eyLwiumv0FwW2gk98GPH9BcI09uUbW3adPDNdH7t1THXVTT2r+3aedBrr7bcD73acdY1+ukXX3aU+929Zv77b127ttub3bltu7bX307pmelvRensail9+x6OV3LHpxx6IXdyx6+RiLfE+9m++3d/P99m4+t3fzub2b76N3ezuP4i3ZHtNVs/eYbgOd/DbgeY/pGntyjZw95oD0cH3k3r3EUTf1pGYv6W4D3f024HlJd419uUbOkj7KU++O8tu7o/z27ihu747i9u4oH7073tOSfqWnsbjS71hc6XcsruSOxZXcsbjSx1jM9tS7s/327my/vTub27uzub0720fvrnS8hbF87+hYZle5DUz3MfPrYj32lmuczTXe64P2YeLVL8Q1M0LsQXG97EFxG5juY+aeB8U1zuYa7/VBW7JB6ZAZYg+K62UPitvAdB8z9zwornE213ivD9qSDcqErBB7UFwve1DcBqb7mLnnQXGNs7nGe33QlmxQnm4ZYg+K62UPitvAdB8z9zwornE213ivD9qSDcrm7BB7UFwve1DcBqb7mLnnQXGNs7nGe33QlmxQapwcYg+K62UPitvAdB8z9zwornE213ivD9qSDUr7U0LsQXG97EFxG5juY+aeB8U1zuYa7/VBW7JBGX9qiD0orpc9KG4D033M3POguMbZXOO9PmhLNiifOeqpoYgdqz/17zbAOfXveh8Keewf1/gE18g59e9653Nnyjn173pXEK9+NL9utf+TM4sd+1AtZ/IDzt8Kzl/XaTcXJ6K18/9Ufy+rAmnXdPvZqS3TKoTCX4b50yuQNgNoP81tPz6Y9lPLO+20nRLefkiab5ykU3kqO+9jQodq3M/IEhhq53yWKKJu6KDOfrUnbcdIn3Ugn8VKn3WUmOhnnaYcmpf7WWfymXNzvwPzdvso5LRpTytHprkM7lglhsIZWjv/T/Xxyk7NyHXbrxBA+2JRy3b7Im7KwfbLS/0UTz5LlD5LIJ+5jLZmovO+ZujguLYgn08n7dCxcduifZsQTO6FMdL8QqHw9SAkzT8pFOh6acVI83N55P5xl71KIuo57wcVFnUfmzd0cH673KLcXqMLC88bXDS8cMwYmgdtu4UiT9oPVEPXX1lH10dZF0f+X0Hymt6mee07V19OoZe3BfarqpQr9Qa7nB5cLsp7zC1RoS9PNAlSbuXIZ4lSbuWDyS3NZa3gMbckhZ5uI8tLudHtc1Lp5JYeiTVSbhUV+qQIudG8K0bwyfsQ1TJR0n512wi4DzMi9UmkPqyk0FcM6fuQ9pPrrRw6dL2L0fx15yNPk+sEmkdr52+qz1fl0KE5y/vQymS6wX1oTkn3oe78kyTWoLaVlSUeuX/kcakSTP9kx0jtU54qiv5xx7Kq4jO3rWrO/xNIW1RfheRI9fS966fTOjh/qynarCgxVFXkQ6e5/WvvU1pL7dJthTsmVRW5VpLmqRrTyop5VlP4XV3A60N2sMtTamZl0ibtG7evu0nT3c/oshKn6JcESd+PtOneib2qpFFtR2nb8vjJ35fpNPsVafzo9zp5GYqRPqP1eZL0GWVIlD6jecVKn6nqvsrS/ymX+xmtCd39qL0uRerLSOsY5a8i6d31uJxG77Ynr/d5zl96w076cpfp6qQtg+tMgctfg/CptmvVJX5XP7AY/hjJHwqVrIaoodDTPnDZ3LGk21nXG3DfZUfqOzr2ur4b5vzV9Z3q+ACtLexX/JRAcsux18+ZhENeJxIkJtX4qvZJJR1ft/+qSXp5rGmf0LZo/8vfKYtbV+l2m+rHO39146Xax7p9UNJ9hzuu5acc1Jn+rm6/EqcczDFOmue+6c77WEkvv0+Qpl1N8tuXD9G684kj09x5uv1UjnzmeiO1Fa9oq5pCX05qq7yiLTqN1lCTnPf2viPI9a5l9sHxcfuIjg99xZPPqd59YoduGXX3f/tym3JwOt3G2C+3L+LJ/Kne7Z8ESX+jqw0dfAiIfLySzs/W3R9BF6P5u68NxbR4x+uOE12GgliPkqYc7Ic4aZ6UJ1bSy+8TpGlzpNwqTjk0b7oeufN0x5auo643UlsJiraqKfSJUluqdZJOo+vRrc77JGmehsfGosuUvbyPcLkkJtPzDfbcWkZW9Nxa5FdJz635OW9WkbRhv9qTebnt1ZSmu173fEGw/ZyWGvAx8Sz5uxd9leQ7Ij0eLH/Xk4+ThkLh4+S+5H0izdduvzFpV9bJrHR5lL9D0nXZ1SHUAe6FDZHqANUySb9PG1xmWqqO57ov1XKh2t+7L9XYu9x2G4WkXVknz5OuI4lltC9iFfxB9EWMoi9U20OvNZl8vLecpGnt/E31+aoWOrS/5ONFJs4nqL7nlYuQo+kaQ14+QgG0H8w1DwfPl9Btrjsvu8+yyXT6GT22ItcP7udU34q06VweqTzu544pPS6oOufmHs9XndOj83c/b0Pm31+TU0xIffyhnKRPIm3FhdTLl4qhvfO3uGNzSQoeyhgv6SsqeFTjmSDpOxfDI5+nM10XufyVCJ/qXG1Fid/Vdy2GX+6fUOjQ6xrsl9fzpS6bavl0vRWk/wfVd/ScharvaN9SvfsbzuL6TtUXqm2wzEP1tA/kvqP9Kp/bc7XxIfW6WpEw6OZjv+Tlxv0ZqmpbkCR5dPNU7duSpM/o/igxwjwjXe9R0u1PpPXd1ec7fyMd3y7JvkBVpwbyHd46uH+idVWMNO9gvr+mWSWpQ+j8k0KH7juCOJ8fL/HI/eOORXUnYkLqfSxtK9k1q4pPt3F74W/ivI8evIn4Sg90xSCFYUALm/LgjZxLKBT54I3qAE070l6M9Fl7xbxqEs+Bkx+hgz8xiHTCyF3A4yLwhxTTYkL6lUa+eNN+tXb+pnp7WfIEylxcbnIhI28I40ORT76FFNNiQuoNakgxjziNV9VubIQ8ivPSvlddgIB0EMg9CBbpINA45310+xrxFT04Hgr24HgyaZPyyBdH0fknSFr3ZmV28eieCAu2X63UsnrgVHVAXd6uJSn6O0Yxn+IOMh5N2pV1MqvqgKvq4ghXZ8+H1oDysmC/Wjt/U/29rOIu0mgi8epq1rK+X2jm/L+4kwPJzv//l04ODCPtyjp5nv/rJwe89EWMoi+iJwcOzSN6coD/Ku6AUGsynX7m9eRAe9JmW+d9aZ4c6EzmP0iTU0wo2JMDJT2YXVonB3oUw1PWTw6cWwy/3D+hUPTkgKu/0Pn7//HkQL7zV7UtKI2TA7rtj/0K8uTAEOcv9+RAa+e9qk6Nnhz4f3JyINV5D37wKhv84FVmWTl4FSfpVJ5IB7iC3ICIcc4IuJ8yAv6CceCOAZHu9EDnH2mDWdINmnwHkKA3aKrcVBu0apKe9sHhHAfVlwXVL8lipc/ipxza5/IvMmiO9o63AdGp1htX5x4gtA/+uncFCpG+sl/lp4R7WzvTU32+3GUpqF88NSM578uHaN35oP3iyT2Q7h4IbB462JZuuaMHgdz3bmFNtw3yCbw4RVuqL0R2wewujyNz84e0GT1o7LDC4UVj6AZEnkFI0RCduTtdt0ORPXFET18IR31Pcv4f6ahvb+c9eEGVW1oFVUAb+MyAb+2iLKhUP6V3l692Uw72Zbsp4UyupgPRdNBoOhJNR6KxX9wzj6oio730Gf2W0kH6jG5sXCZ7o1eDcNkveju7GOmzzuQzeiWJ66FXkpwaCp8//RmN/G0yyNsj0fmFQuriy51/UijQ5T3ibbZUt/6r5PSv/crPHTq0++jBl+YWFXYYOzy/aPCI4TQF2mysIkXdboIuFrJOXhRVNa58V70ERbs6vzzNnbfqILV8QEYeUnmaXL/KfvulWhVjNH/d+YSKmY+KOYgTSAF9P1CeQHLnpboDi9yvqjon0vcK1UH8gL8/Zqo2ie6rcqj45YVurryemKTfK9qQdmWdzKPqc7mOVC0Xqu+txX2fkvsd8ZeWJR0P+mtKL+NR0l9TxkmfoV5k19r5f3EXU7i7fdW2Qt6+0z6MdII8iGMK7pjpTqqWI59Tfadi+iEmdOiyHGk7KPNQPe0Dl83tO7ouRrpDVhno8xLdXVS1zaUncFR6OoZUf47zt7g72KjWU9X+L9L67Y7D/9BxevSLTNOjx+mLf5XCcfq06HF69it6nH7KoX0exHF6ejgnFIoep48epz+0rehxeulVWsfpRzrvsQuqTCv6q8jIL1O/iqxDdParHWkvRvqsvWJe7mfycX36GT2eLz/uhR47l3da9Ni5vCM8k3wmPxrlLPKZ/GiULuSzCtJnXclnSdJn3chn8q+ZziafVZI+604+c6fRX5K602zOIcQrb5AP7FBCgS5XJX78ijstKRTsehRpJ6PaYdn97/4a58DjV84qnDCmzfCC7rmjiwbnDm1TUDBa8RAWeamVP6cvWSPrZL3q90mmSyS6dhXXSyX9GuDyqg6TJJRObpbXksXVe32IjOrrT8C5pUVijZRbcYe+5NxUh75UPrnyilPkX9J+lbdYAfVheqQ+idSHxT2IR+7DSA/iCSi3jEiskXJTXaudGCE3mneF0sktMxJrpNyKexiOnJvqIUMqn/zbKNWyX9J+LaVlPytSn0Tqw+IeZiT3oeq3BQHn1jISa6TcivtdjJyb6ncoAeeWHYk1Um7F/W5Fzk31uxWVj+qoJkbRN/RzVb+W0rKfE6lPIvWh6qE/lRV5VFX0U5XSyS03Emuk3FQPJ5EfSEJzo3lXLZ3c8iKxRsqtmkJfNUJuNO9qEXxURzUxir6hn6v6tZSW/fxIfRKpD1UP46imyKOqop9cb6TT8qpT/ZEezCP/Xly1r1bdk0J+GJxqHS3JpQWq7zOq3/jLpzNV9ZLqvhoVpc9U2+PKIf26iHBUcoTz/0hHJd1lB/w0b0ZpHZUMaLuRGvBRT+VRSZoLvdpVPvqm8tSUprted323/7rruzjac07u8IIRwzoMLhxa4KpVFJFeCGucu8WOtMbVdt6Dr3GZ0fMAkV+mzgPIx7vbkfbo2kinu153ebTXxlrO+/yLC/OHdBs7dOjggYMLR7cfP3jMoef5dBcelnTdlbeW9qu18zfV38ty5+f2X4KC2Z1vcT9GLuvbE3fMIm1PWjjvwbcneeC//8kua7//cc/D0fcuU6RtTqTf7QS5zXT3KQH2YUZJfr+TGMy8M1XbyjhpGp1/af1+R3UEW/X7HdWFTnHSZ/FTDs1DdaGTO770Lr2Rfhyg+k2Yew5a9QMId3m323cvIrL3ke75Z/eFfoFU09BB7n35EC3qBVLuhW/uBVLHhQ62JS+b7vJK96n0fLP77Xb4iKLBAye0HV2YW1RY0G1EUaFcyNANDn2V9BdlMpz8SzIvvyxTzUtuk+rs5BGKmRTn/5GKmbpOh4IXM/nRL0eRX6a+HNFDn/arHWkvRvqsvWJeKBdJ0S947jT7728xB73yhlAubAK6Mj63pIVNWb3NleqwcqSrzUPmWFNVV7rLl4uoLq9RXcUrF89Bc5Znckbb+t9oK+AvTMplzp2X6tKwOCkP1fofH6FPqF932sz9XPU3FDp0u6eaj4pZdTmYnI/XMVadQgv418/K2w3HmGv/wGmSpGDat+TTge48VH/dcZCnueOQJLUV1H4u0uUflKeyQi/XCJUDYbWyS1ojVJb6Lpjb3x7su0iX7dC+c/unSjD9c+CSKtVlJVUU/eOOZVXFZ25b7hdz+qtw1eUVsZKevnf9dNqZzt9qijblfYnq8gw6jX7xb+e8D3hZPHC7ftrXftfxYJaLg8tppMtcKE8kfcUI+moe9dU96mt45K/psf1aHvW1PerreNTX9aivp9CrtkPusluffCZvwxuQ6YdjG+7OP0liDWrdaBA6tO/qK/rO7k+3fhxUWGQfBjzkpyZuW3UVedG8qYauO7JOVQtVldpRrYN0enXN9Bqa6TU102tpptfWTK+jmV43dOjLni4fK02U/p8k/V/eX7nrgKpfZQZVPwf5/1ApzssEq7uuqd7HSNMjLdvuZ6rL2FXrmKsv7jJ2+Xuc6tI8ebsp6+I0bavmTX2qx2PofJFyLO6y6wQpx0iXswf0HSFD9RiJUMj8971garXUrGDr7oPH0asG0/6Bu4ZUC6b9HLceoPsIuR6oEcy8S3xC251/ksRqmMdS7RfjQof2j1xL1VSwVlN8Jn+3UdWoNRXzQWxLdSk5vYPVZGmebr/pHqXrehMkfe2Yg21Ocaap7pgp3zFMda4oRvMZnabKn/rlbTw9X6DaV8r6SOccVPs91aX6AZ+vOfDzHHpXOPl4Ip1/gqSf6fwt7q5xqr6I1HeqE/uqu5tEunNnwMc3I/ZdVQWr3Hc3O3+L6zvVsV6vfUf7wGUryU+qA7rg6EDfqe5WWEXBI9+t8C7nL+duhZH6rrifbLtskX6yHfCFawf6rgLpG1XNKd9F0NU/4Pwtru9UfRGp71Q/u6V94LKpfqot/5w5oL7LVJ0zCGJs6GPmVH0hPxrM1T/u/C3pY/1oX0cam+K+g8l32oz0U+LD0Xf0O4Wu755z/pZ237lsqp/pl1LftQz4u9eBsXG3fwnF9EWCpH/V+Vvc2KjOwUQam+J+JhzpEYHyz4QDGpvsgL+3Hhgbd7+uGxs6dlT/tvO3uLFR9XWksSnu57jy2JT0Z852tHb+n+rrlVUY7DnklhmqsTfIn6k6ZmGw/QPnwOXj2nRsgvkOb5X4mII7/ySJ1fB6duCYQqSfZ9sv+ZhCDQWr23f0+7a5ccvIqqaYtzwv1bGRGoo8VG1VZbbl5l0rkLyzclSstXyy1g6GNV/FWpvJqmqris+86wSTd4aKtY5P1rqBsKalqljrMllVbSX5zLteIHlnDVSx1jOYN7cP3bzrB5N3SxVrfYN5c9dJk8tO0Ms0d98QNFeMwbZMrgsmx1Gu8Q9c7+Akf/jOEVlZMdL83PzoNDr/SPVTkuKzeB+s6alpLQtTrdScwsy0glRroNexcPWq609UtaHb1w1DgfR1huoHmvQu8vYrnnxWQ/osgXzmMtrnK3bFhPMHdH1RRkn6n85ftS7It/wr6VjWCIUva/Tmy3K78jWYqnM48nXj9vtIt1uKdBsj+VZFdL2Jkz6j61ak2ya5x/oqhg7tK3osIVbhkc/h1XOA7HxWxBzU2+F+/4jVtOn2paruNvg97sBteN3vBfQ8ZW0FT4KkT5bycvdR9BqUmop2XH0dxXzpfi5Wmm8dab7FHadRXf9I98ny90A353IafS2Jx9U3K4Yn2HE8eJ10HcIXJzHT+cv9eVwJ+1N1fWika4FU14fSPnDZ3ONedDzqlGDeNLcEzbzLhbz1xUklHEu6nAYxlvUIn6rv6kr8rj69hGOpuhY30liqrsWlfeCyuWNJx69eBB/VxRWTK22jjmLeMaHw47HFLTNyfe7Op6TLjKtvVUyfVw4duj2K0fx1WeVpcq1Ludz9c9XQof1Lj0nq+rJuhPlQf10pH1WNYfdde81+gS7L1EvPc1H9WrIP7RQTnqPquFbVkL5vYhSfyWNcXP7y8TPV8hWpJlb1PV12EyPkUbcEbUWad3Hrr3wdCeWqV4K2vH4XoG3K12FQrgYlaCvSvBsq9LRN+ToGytVQ+kz+jqXi0tV0B24I4vy/EfksiJrOZae1VSMFT4Kkz5XW3Sak71T9J9+OtbFivk2IRq7pGkvzLW6/G1C/5cj8CZp8G2n4C0uwD7Bf9HtoDZKb/YqfEkhuufZ2JTb2IIe8XiSQ+dIcQ6GDfUD18jrWWKGn4yR/N21MPpNvB676bkr7X67z3PmU0+jp9zeqH1mGlze6ndEtb0XF8Ac1lvK1wHQs3f2Vu4zRcWgozUf13YzmLY+z6y+n0cvfzVz9pBKOczDHnw6OMx1HVW3ZUOJ39VNKOM6R9nP2Sx7nSMsFZasWOnQZcGsDVR0o76+9fm9z/SWtwV39jBKOczDH6Q6OMx1HVY3XQOJ39deXcJxN1z8uW7XQocuAXO/TcZDPJ6i22zRveZxV37VqK9qXvxPcWsJxDub7+cFxpuOo2h7J389d/Z0lHGdVfa/6nhJpuaB9IG+36TLg1rzuOKuO0XC326pxjrTddvUPlJFxVh2HUX0vk4/DzPUxznSb6fV7nLzdpt9n5EcURLrewut2m3vs5OkyPM4lOd72vI9x9vN9Xd5u03F2j6MGsd122y7pdtvVv1bCcQ7oXEeOPA667bZuOZ1fwnGOtN7YL6/HhOTttnwcyH6pfrPnd7utOhcSabvt6t8vw+Ncku3Rhz7GWfV7wpKOs7zdVh0jV223a0o+elzK1anOQarWe8pckvU+VjEveb1fXUx/Vo7QFv1NperYoLyMRzouKfe3HarvGqprW+QabkMJl/GArmk4cI5I9Z1SdfxS/k75RQmXcdV3h0jniIr7TumyuWOpOq4W8PfxjEh9R8de13fbS7A878t/ysG26pLc7Ff8lEByy1Qd56PrRAKZr258qd7r+Mr7KtUxwEjbw0j7o+LWVd33rZ+LGS/V+TT5+5BqPvQ8V1m/x/SfxfQBvU92+Snmc7Bfbg5B3fQ9JvYgt/36X7jp+27HVFHDGadpO560XU7RdoKkLxd7cJ6JZPuxT6uYn62rE0EXo/m7rw3FtHjHe+C3r1MOaoJYBpOmHOyHOGmelCdW0svvE6RptaRlsOKUQ/Omy6A7T3ds6fJdcUrxbSUo2qqm0CdKbamWZzqNLoMVnf8kSfM0PDYWXabs5T3N5ZKYTM+X/r7XdPvZqRk59LfgAfCnB3xP+rSA77uhvOc9zUW+dpRuN0rycB67JqKP2LRf7cm8YqTPOpDPYqXPOioYVfe8d5lrknm502yeFqFwbrovP7COhgLt9xL/prCs3p/ePm/s1mKDCovOKpzQO3fo4ILcosEjhp9TOGps4ZgimgZtOl6RJu0GqqGLlKyji0hsSP1S/WzX9C7NS7e5etWtVORLWuyX6pY8CaWTmxWJNVJuxd32Rc4t0m1fAsotLRJrpNyKuy2LnJvqtiwqH9VRTYyib+jnqn6VN2EB9WF6pD6J1IeqZ3uVV+Shuj2L/ARoujmUf1pA846VPvP68wiERxlZzv8jfc10v2aDl3VZpVXWxQfcfkC3BFOWdarblrnLl1sm0fcuE7f0U5VXbtv0qcx2meaWfe7L/tz9WlYpdPBw9v5nprkPilU+NU0uL9yXXOXpSomQhK1aBWUdwubB7cJIm4c3nffYm4fcltibh7Qyt3lwdbKHriftiKadRqPbzFAN3RR00Gg6Ek1HjaYT0XTSaDoTTWeNRvfIWqqhj/A8S6PpQjRdNJquRNNVo+lGNN00mrOJ5myNpjvRdNdoehBND43mHKI5R6PpSTQ9NZpeRNNLozmXaM7VaHoTTW+N5jyiOU+jOZ9oztdo+hBNH43mAqK5QKPpSzR9NZoLieZCjaYf0fTTaC4imos0mv5E01+jGUA0AzSaXKLJ1WjyiCZPo8knmnyNpoBoCogmjmgKiaZQ0gT5dUmUrAFv09OsSE8FC/YuqmlpMdL8QiH10Sx3/kmhQMvrA4cuIt29137JRxjpGZ0Y6bP4KYfmobpLwYEzYyLaEJ28bMlfO2n9WTAl/DNa57nLrd1+l1A4L9XJhxBCoUPv+hBE/2enZmUFu6xnpKrGSz4iHE8+k5+QWpLxsl+PEp3bd3YdPdCZ3ob0p/0qPyWIfIM/e3tW6CD3vnyIVnXmzJ1nWT57e4bz3n1k94PO/+U7T4SxhoLcTmZY3O1kUE9GjLSdpP0jbzfkw3WGeFKDfXpnxoHD9apDkImK/neXlQqKz9y26F2A4xT6RNKHVE/fu3467ULnbzVFm3L/q+54TafR9aK38151eFU+nKxaLsop2o30xODKCl+M5q87H3maPB8Vc9D7HLdPIh3uVvUh/WW+Si/fHf3A08Ccv8VdJUifYuG2H6toX7XumtxHyfzDSN5DnPeqQ+wJRHeZx9ziyOdUfylpc6SmzZhi2pTXLd34xUoMrr7I+Vvclbd0eaHLyvgIuvIRdMX1bcDHlizVKRbKKz+lRfXkBdXpmQRJP420OcV5r3pKi7wdUrVdMaS+a7q8rVftN1TLQkmXHfkJNK5+hvO3uCucg7lTeNqBukB1B3y6/ujugH99MfzyvjMUivx9Reaheq9PcAu27w7uJ1R9R/PR9d0tzl8vVzjTbbz9ip8SSG6W3b+PEg55nUgg89WNL9V7HV+5DtA9hU+3n1ZdRhFpXVVtw+R19T7nb3FXOEc6jV3ctrKsn1t6JBS5D4K+gvZJVyviaed9cVfQvhFBF6P5u68NxbR4x4t+Be1rUm7/C1fQPue8L40raN1lyl7ed7tcEpPp+QZ7LjU/E/tcakZa9Fxq+HtZ05FoOmo00XOp4e9lTfRcavh7WRM9lxr+XtagnEulmkKiKdRoBhLNQI1mENEM0mguJpqLNZrBRDNYo7mEaC7RaIYQzRCNZijRDNVohhHNMI1mONEM12hGEM0IjWYk0YzUaEYRzSiNZjTRjNZoxhDNGI2miGiKNJqxRDNWo7mUaC7VaMYRzTiNZjzRjNdoJhDNBI3mMqK5TKOZSDQTNZpJRDNJo5lMNJM1msuJ5nKN5gqiuUKjmUI0UzSaqUQzVaO5kmiu1GimEc00ookjmquI5ipJg32dxv5z13abpX+dBv/84//6dRr9iU5etiJdp+Euv6rrNK6acrD9S0LhvLSNSMc9g/x1YXZqdmbA372U12nIYxk/JXze9DM6XvQXfO542ddiXO1oWpM+s1/lpwSRU/DXYgwOHeTelw/Rqo7BuPMsy9diDHDeu9diLHX+H+lajJJsq+h8VOegXZ3qXHeM9N7ruW7V9jLY7Xd6Nvb1F6mW6hwlXU4ulfKix3vjFF75qeyu/jXS5gRpbALal2XHSGMTq2GOk3gCetrvgfNQB84dhNTnVA4ci5X0V4bCx8L9uU4caae8oh1XX1ExX3q3afm8bkVpvrpzCXGK+dFzPYFe52ClpsrXBLnzoPMO8snkdH5uf9BpdP5JEmtQ9ZvqPJ/q+qPqTujGj7Z14Dyh26kVg0kiW1Wk0Ft12q948llFArhSYgyiULNfqhOF7rzsjdxsMl1eqeMUXnnlc/V3kzZvdd5H+g161ZB65VexxIQOXXlDocg7VloQyp+5vooaDrkQKO632/LJ6CTSFyq9fELY1d/v/C3u4o2glmd5g61bBuTHvrj6h4vhlzfwoVDklV7moXraB67eHUu6EXW9FUKH7khMfmFxWekj11Q7O9q3VO+eiPZy8QYtCOxX/JRActt38cY2wiGPYQKZb3HjZb/k8a2s0NNxcvuvmqSnY60q4itK84lTzIeyyI9bpBdUqPRyAeTqX3H+erl1pmqbXJJ7eByOi5FoUaq7GGlBCfrAfqm+4B+O5Zluf+TluaRFSqTtGx0nt/9UFyPJX9BUB3xo/8vLrGrfo/rSJO97PnT+FncxEl2/3D4o6Zezsn4x0sehyH1Af6xfLoAcUp37y+xjc9qnB7ddbjp/dz2iB4ZcXVm5qMjNxetFRVtDB7lpjnR7SfOOlfReL0KiB8BKchESbStRaqu8j7YiXdBU3mNbiRHakg/Mebk4aq3bXijYC/S+JvP81nlf3AV6uyLoYjR/97WhmBbveNEv0Nsp5fa/cIHeD8770rhAz12m7OX9DQcC+gK9tFzseyGlpUUv0JPey5qORNNRo4leoBf+XtZEL9ALfy9rohfohb+XNdEL9MLfy5roBXrh72VN9AK98PeyJnqBXvh7WVMWLtCjmquI5iqN5mqiuVqjmU400zWaa4jmGo1mBtHM0GiuJZprNZrriOY6jWYm0czUaK4nmus1mllEM0ujuYFobtBobiSaGzWam4jmJo1mNtHM1mhuJpqbNZpbiOYWjeZWorlVo7mNaG7TaG4nmts1mjuI5g6N5k6iuVOjuYto7tJo7iaauzWae4jmHo3mXqK5V6OZQzRzNJr7iOY+jeZ+orlfo3mAaB7QaB4kmgc1moeI5iGN5mGieVijmUs0czWaR4jmEY3mUaJ5VKN5jGge02geJ5rHNZoniOYJjeZJonlSo3mKaJ7SaJ4mmqc1mmeI5hmN5lmieVajeY5ontNoniea5zWaF4jmBY3mRaJ5UaN5iWhe0mheJpqXNZp5RDNPo3mFaF7RaF4lmlc1mteI5jWN5nWieV2jeYNo3tBo3iSaNzWa+UQzX6NZQDQLNJq3iOYtjeZtonlbo3mHaN7RaN4lmnc1mveI5j2NZiHRLNRo3iea9zWaD4jmA41mEdEs0mgWE81ijeZDovlQo/mIaD7SaJYQzRKNZinRLNVolhHNMo1mOdEs12hWEM0KjeZjovlYo1lJNCs1mlVEs0qjWU00qzWaNUSzRqNZSzRrNZp1RLNOo/mEaD7RaNYTzXqN5lOi+VSj2UA0GzSaz4jmM41mI9Fs1Gg+J5rPNZoviOYLjWYT0WzSaDYTzWaNZgvRbNFoviSaLzWarUSzVaPZRjTbNJrtRLNdo9lBNDs0mq+I5iuN5mui+Vqj+YZovtFoviWabzWa74jmO43me6L5XqP5gWh+0Gh+JJofNZqfiOYnjeZnovlZo/mFaH7RaH4lml81mt+I5jeN5nei+V2j+YNo/tBodhLNTo3mT6L5U6PZRTS7NJrdRLNbo9lDNHs0mr+I5i+N5m+i+Vuj2Us0ezWaf4jmH43mX6L5V6P5j2j+02hCUw9q3PeyJoZoYjSaWKKJ1WjiiCZOo4knmniNJoFoEjSackRTTqMpTzTlNZpEoknUaCoQTQWNJolokjSaikRTUaOpRDSVNJrKRFNZo6lCNFU0mqpEU1WjqUY01TSa6kRTXaOpQTQ1NJqaRFNTo6lFNLU0mtpEU1ujqUM0dTSaukRTV6OpRzT1NJr6RFNfo2lANA00moZE01CjaUQ0jTSaxkTTWKNpQjRNNJojiOYIjSaZaJI1miOJ5kiN5iiiOUqjaUo0TTWaZkTTTKM5mmiO1miOIZpjNJpjieZYjeY4ojlOozmeaI7XaE4gmhM0muZE01yjSSGaFI2mBdG00GhOJJoTNZqTiOYkjSaVaFI1GotoLI0mjWjSNJp0oknXaDKIJkOjySSaTI0mi2iyNJqWRNNSo8kmmmyNJodocjSak4nmZI3mFKI5RaM5lWhO1WhaEU0rjeY0ojlNozmdaE7XaFoTTWuNpg3RtNFoziCaMzSatkTTVqNpRzTtNJr2RNNeo+lANB00mo5E01Gj6UQ0nTSazkTTWaM5k2jO1GjOIpqzNJouRNNFo+lKNF01mm5E002jOZtoztZouhNNd42mB9H00GjOIZpzNJqeRNNTo+lFNL00mnOJ5lyNpjfR9NZoziOa8zSa84nmfI2mD9H00WguIJoLNJq+RNNXo7mQaC7UaPoRTT+N5iKiuUij6U80/TWaAUQzQKPJJZpcjSaPaPI0mnyiyddoCoimQKMpJJpCjWYg0QzUaAYRzSCN5mKiuVijGUw0gzWaS4jmEo1mCNEM0WiGEs1QjWYY0QzTaIYTzXCNZgTRjNBoRhLNSI1mFNGM0mhGE81ojWYM0YzRaIqIpkijGUs0YzWaS4nmUo1mHNGM02jGE814jWYC0UzQaC4jmss0molEM1GjmUQ0kzSayUQzWaO5nGgu12iuIJorNJopRDNFo5lKNFM1miuJ5kqNZhrRTNNoriKaqzSaq4nmao1mOtFM12iuIZprNJoZRDNDo7mWaK7VaK4jmus0mplEM1OjuZ5ortdoZhHNLI3mBqK5QaO5kWhu1GhuIpqbNJrZRDNbo7mZaG7WaG4hmls0mluJ5laN5jaiuU2juZ1obtdo7iCaOzSaO4nmTo3mLqK5S6O5m2ju1mjuIZp7NJp7ieZejWYO0czRaO4jmvs0mvuJ5n6N5gGieUCjeZBoHtRoHiKahzSah4nmYY1mLtHM1WgeIZpHNJpHieZRjeYxonlMo3mcaB7XaJ4gmic0mieJ5kmN5imieUqjeZpontZoniGaZzSaZ4nmWY3mOaJ5TqN5nmie12heIJoXNJoXieZFjeYlonlJo3mZaF7WaOYRzTyN5hWieUWjeZVoXtVoXiOa1zSa14nmdY3mDaJ5Q6N5k2je1GjmE818jWYB0SzQaN4imrc0mreJ5m2N5h2ieUejeZdo3tVo3iOa9zSahUSzUKN5n2je12g+IJoPNJpFRLNIo1lMNIs1mg+J5kON5iOi+UijWUI0SzSapUSzVKNZRjTLNJrlRLNco1lBNCs0mo+J5mONZiXRrNRoVhHNKo1mNdGs1mjWEM0ajWYt0azVaNYRzTqN5hOi+USjWU806zWaT4nmU41mA9Fs0Gg+I5rPNJqNRLNRo/mcaD7XaL4gmi80mk1Es0mj2Uw0mzWaLUSzRaP5kmi+1Gi2Es1WjWYb0WzTaLYTzXaNZgfR7NBoviKarzSar4nma43mG6L5RqP5lmi+1Wi+I5rvNJrvieZ7jeYHovlBo/mRaH7UaH4imp80mp+J5meN5hei+UWj+ZVoftVofiOa3zSa34nmd43mD6L5Q6PZSTQ7NZo/ieZPjWYX0ezSaHYTzW6NZg/R7NFo/iKavzSav4nmb41mL9Hs1Wj+IZp/NJp/ieZfjeY/ovlPozlwV0zyXtbEEE2MRhNLNLEaTRzRxGk08UQTr9EkEE2CRlOOaMppNOWJprxGk0g0iRpNBaKpoNEkEU2SRlORaCpqNJWIppJGU5loKms0VYimikZTlWiqajTViKaaRlOdaKprNDWIpoZGU5Noamo0tYimlkZTm2hqazR1iKaORlOXaOpqNPWIpp5GU59o6ms0DYimgUbTkGgaajSNiKaRRtOYaBprNE2IpolGcwTRHKHRJBNNskZzJNEcqdEcRTRHaTRNiaapRtOMaJppNEcTzdEazTFEc4xGcyzRHKvRHEc0x2k0xxPN8RrNCURzgkbTnGiaazQpRJOi0bQgmhYazYlEc6JGcxLRnKTRpBJNqkZjEY2l0aQRTZpGk0406RpNBtFkaDSZRJOp0WQRTZZG05JoWmo02USTrdHkEE2ORnMy0Zys0ZxCNKdoNKcSzakaTSuiaaXRnEY0p2k0pxPN6RpNa6JprdG0IZo2Gs0ZRHOGRtOWaNpqNO2Ipp1G055o2ms0HYimg0bTkWg6ajSdiKaTRtOZaDprNGcSzZkazVlEc5ZG04Voumg0XYmmq0bTjWi6aTRnE83ZGk13oumu0fQgmh4azTlEc45G05Noemo0vYiml0ZzLtGcq9H0JpreGs15RHOeRnM+0Zyv0fQhmj4azQVEc4FG05do+mo0FxLNhRpNP6Lpp9FcRDQXaTT9iaa/RjOAaAZoNLlEk6vR5BFNnkaTTzT5RBNHNAVEUyBpoB+QlZZ2+B6QlZYWfUAW+Yw+IKt17EGdvGxFekCWu/yqHpDlLrd2+2fFhvNSXZw0z1Do0AdkBdH/2WlZmaXxMLh9OU4Jb9/tM/sVP0Xd1/arJONlvx4h2wi37+yHZxU609uQ/rRf5acEkW/wD886kyxH+/Ih2gPHt8g0d55l+eFZbZz/uA/PekBaF1UPzyqrDxIM6B6fEbeTtH/k7Qbmg7QO3tc/UZFvoqL/5fvjy8tGTCj8GQBxCn0i6UOqp+9dP53W1+n0aoo25f6voMhHdY9+m/1c5z+qh7vJz37x+nA36pf7kPpiNH/d+cjT5PmomIPe57h9onoeTpyCR17Wymn08vNwXP1AJ+ninieTSPxu+7GK9gN9wJd4yfxDYw/mfYm07VXdR3jfQ+diveUWF1L33Vgy7xGaNmOKaVNet3TjFysxuPoxxYyfvB+Sl5VxsXpd+Qi64vo24PtGW6rnu1DeSdJ40OVfNR7yM7dc/ZVkjK+QtmmqfWnlCG3TZ2GVV3gj7TdUy0JJl51EKTdXf00xy06gz78R3yVdftXzb+j6o3v+zcwSbrtUz5aJIdPk/izu2TIumzuWdJ/peg/ns4NoPrq+u7kE2419+U852Bbdxtuv+CmB5Lbv2UGPSNsbuk4kkPnqxpfqvY6vXAfQZwdVkNpS7afp/OT9tGpdVW3D5HV1TjHjpapZ3D4o6bayrD87aG4xfRD0c1KeIPuCp6Tv8AmK+dm61yPoYjR/97WhmBbveNGfk/KqdBzgf+E5Kc86/ymN56S8To45dJHWXbnGNDXfYJ+Tsv9YHn0Z5o8+J4UwHThPSjTtiCaGaNoTTXuNpgPRdNBoOhJNR40m+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8PeyJvqclPD3sib6nJTw97Im+pyU8Peypiw8J4VqIj0nRX6Whf1y72Pm3mstNhTuae38P9XHKzs1IyP6DBWsZ6jIn8VPOTSP4p7JkR17UCcvW/IzVA4czwiFPyelrWOiz+5wX+jP7jgj9iD3vnyI9sAxFzLNnWdZfnZHjvMf99kdHUmO8vLnLpOxoUPbqiSilvO+cNjgovbD80dPGFlUWNBtRFFhlxGDQtKLLj90GyfPNzk2XBen8ceFDt1Wuv9XtWHnW9bv9es+cyjSvX7d+xu7uQRzr+3UtApkngG0n1pekV+SlCt9uUMar/DFaP4fK/2NpJWn02mVFZ+5bdZUTKsg/a1F2jO5H3Hbrx1M+8oxqkXe15bypP3c2hCD2567HiWEDn3FSp8dOLYs8cWY57NC0itOMS/3RZcV9/P/A3mS3U5QKUYA","debug_symbols":"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AbbRYANsowmicY0GG2AbDTbANhpsgG002ADbaLABrtGs2ADXmwIrNsA2GmyAbTTYANtogmhcawA2wDYabIBtNNgA22iwAbbRYANco9mwAbbRYANso8EG2EaDDbCNJojGNRpsgG002ADbaLABttFgA1xvCmzYANdodmyAbTTYANtosAGuNWDHBthGE0TjGg02wDYabIBtNNgA22iwAbbRYANcozmwAbbRYANso8EG2EaDDbCNJojGNRpsgG002ADXmwIHNsA2GmyAbTTYANNoxgEbYFoDxgEbYBsNNsA2GmyAbTRBNK7RYANso8EG2EaDDbCNBhtgGw02wDWaERtgGw02wDYabIBtNNgA22iCaF4Wzec3BUZsgG002ADbaLABttFgA2xrADbANZoJG2AbDTbANhpsgG002ADbaIJoXKPBBthGgw2wjQYbYBsNNsA2GmyAazQzNsA2GmyAbTTYANebAjM2wDaaIBrXaLABttFgA2xrADbANhpsgG002ADXaAIbYBsNNsA2GmyAbTTYANtogmhco8EG2EaDDbCNBhtgGw02wDYabIBrNAs2wPWmwIINsI0GG2AbDTbANpogGtcagA2wjQYbYBsNNsA2GmyAbTTYANdoVmyAbTTYANtosAG20WADbKMJonGNBhtgGw02wDYabIBtNNgA15sCKzbANZoNG2AbDTbANhpsgGsN2LABttEE0bhGgw2wjQYbYBsNNsA2GmyAbTTYANdodmyAbTTYANtosAG20WADbKMJonGNBhtgGw02wPWmwI4NsI0GG2AbDTbANZoDG+BaAw5sgG002ADbaLABttEE0bhGgw2wjQYbYBsNNsA2GmyAbTTYANNopgEbYBsNNsA2GmyAbTTYANtogmheFs2nNwWmARtgGw02wDYabIBtNNgA2xqADXCNZsQG2EaDDbCNBhtgGw02wDaaIBrXaLABttFgA2yjwQbYRoMNsI0GG+AazYQNsI0GG2AbDTbA9abAhA2wjSaIxjUabIBtNNgA2xqADbCNBhtgGw02wDWaGRtgGw02wDYabIBtNNgA22iCaFyjwQbYRoMNsI0GG2AbDTbANhpsgGs0gQ1wvSkQ2ADbaLABttFgA2yjCaJxrQHYANtosAG20WADbKPBBthGgw1wjWbBBthGgw2wjQYbYBsNNsA2miAa12iwAbbRYANso8EG2EaDDXC9KbBgA1yjWbEBttFgA2yjwQa41oAVG2AbTRCNazTYANtosAG20WADbKPBBthGgw1wjWbDBthGgw2wjQYbYBsNNsA2miAa12iwAbbRYANcbwps2ADbaLABttFgA1yj2bEBrjVgxwbYRoMNsI0GG2AbTRCNazTYANtosAG20WADbKPBBthGgw1wjebABthGgw2wjQYbYBsNNsA2miCal0Xz+U2BAxtgGw02wDYabIBtNNgA2xqADTCNZh6wAbbRYANso8EG2EaDDbCNJojGNRpsgG002ADbaLABttFgA2yjwQa4RjNiA2yjwQbYRoMNML0pMI/YANtogmhco8EG2EaDDbCtAdgA22iwAbbRYANco5mwAbbRYANso8EG2EaDDbCNJojGNRpsgG002ADbaLABttFgA2yjwQa4RjNjA1xvCszYANtosAG20WADbKMJonGtAdgA22iwAbbRYANso8EG2EaDDXCNJrABttFgA2yjwQbYRoMNsI0miMY1GmyAbTTYANtosAG20WADXG8KBDbANZoFG2AbDTbANhpsgGsNWLABttEE0bhGgw2wjQYbYBsNNsA2GmyAbTTYANdoVmyAbTTYANtosAG20WADbKMJonGNBhtgGw02wPWmwIoNsI0GG2AbDTbANZoNG+BaAzZsgG002ADbaLABttEE0bhGgw2wjQYbYBsNNsA2GmyAbTTYANdodmyAbTTYANtosAG20WADbKMJonlZNJ/fFNixAbbRYANso8EG2EaDDbCtAdgA12gObIBtNNgA22iwAbbRYANsowmicY0GG2AbDTbANhpsgG002ADbaLABptHEgA2wjQYbYBsNNsD0pkAM2ADbaIJoXKPBBthGgw2wrQHYANtosAG20WADXKMZsQG20WADbKPBBthGgw2wjSaIxjUabIBtNNgA22iwAbbRYANso8EGuEYzYQNcbwpM2ADbaLABttFgA2yjCaJxrQHYANtosAG20WADbKPBBthGgw1wjWbGBthGgw2wjQYbYBsNNsA2miAa12iwAbbRYANso8EG2EaDDXC9KTBjA1yjCWyAbTTYANtosAGuNSCwAbbRBNG4RoMNsI0GG2AbDTbANhpsgG002ADXaBZsgG002ADbaLABttFgA2yjCaJxjQYbYBsNNsD1psCCDbCNBhtgGw02wDWaFRvgWgNWbIBtNNgA22iw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zkFfcQ76inPQV5yDvuIcXP43r6VO508/1Oh/XtOfv2a8/I9S7100rrloWnPRfPeiT3/J/3TRFRDtPFO1Yfrzosv/2q30cr6oL18vmtdcFGsuKisuulK8w8evIIfyBfmVChvacL7o6z1dKYPb93TlPfywnBfC8aunK++271wUay4qay6qVy4qHxfNXy5qay5a1lzUV1x0+YPx9y4a11w0rbloXnFgI9ZcVNZcVNdc1NZctOaZG33FRWVYc9G45qJpzUVrTkRZcyLKmhNR1pyIsuZElKdPxD/++ddvX94K6PI/+V/6+VW0D8PX1+tlzUV9xUWX/5X9vYvGNRdNay66DGI4v3FZPi9Jp5feyw/v4xVnGYfy5aJpzUXzmotizUVlzUV1zUVtzUXLmov6iosu77jL24v/+aKv738vv696u6ieL6p/ewJf+NXZVE73EFP79JGzemlIifMsXmKKzze+/o7tdQ9n9no44fVwitfDqV4Pp3k9nMXr4XSrhxOD18Px+qkcV57oy3R+OMv8WCwsYz990GKZpvGxWLhzURnWXDSuuShWgLj8Fn6Zhk/3NDz2Fv7eRW3NRcuaiy57mqaPi+b650WX/73cvYvGNRdNay6a11wUay4qay6qKw5sbWsuWvPMrWueuW3NM7eteea2ac1F85qLYs1FZc1Fa05EW3Mi2poT0daciGXNiVjWnIglVgT0ciU2y3C+qH4ZSZa65qK25qJlzUV9xUWXf79376JxzUXTmovmNRfFmovWnIi+5kT0NSeirzkRfcWJmIanT8Q//vqs9H/9U1nzW+my5tfSZc3vpcuaX0yXNb+ZLmt+NV3W/G66rPnldFnz2+my5tfTpa85EX3FiajDsOaicc1F05qL5jUXxZqLypqL6pqL2pqLljUXrfjIQh2HNReNay6a1lw0r7ko7l705XMOdboC4tbnHOq04iML9fLyf++isuaiuuKia790v/Xpgzqv+MVnvfYL6pv3FCs+slCv/YL69kVlzUV1zUUrPrJQY1lz0YqPLNQyrLloXHPRtOaiec1FseLArvkFdV3zC+q65hfU9flfUL9ftOaZW4c1F41rLprWXDSvuWjNiahrTkRdcyLqmhNR15yI+vSJ+Mdf/1bzPW4uHoy3cen0I/1tv/i4ti9/xc347EX/ePtf/9+//M9//Zf//m//1/96u+b9/+f/++//4z//9T/+/ff//M/////56//P243/Nw==","brillig_names":["get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","pack_arguments_oracle_wrapper","call_private_function_internal","pack_arguments_oracle_wrapper","get_public_keys_and_partial_address","random","check_nullifier_exists","notify_created_note_oracle_wrapper","get_note_internal","get_key_validation_request","notify_nullified_note_oracle_wrapper","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"1207":"attempt to add with overflow","942":"SharedImmutable already initialized","1116":"Array index out of bounds","281":"attempt to add with overflow","714":"attempt to add with overflow","629":"Array index out of bounds","1199":"Array index out of bounds","1004":"SharedImmutable already initialized","1132":"attempt to add with overflow","303":"attempt to add with overflow","172":"attempt to add with overflow","736":"attempt to add with overflow","285":"Array index out of bounds","1181":"attempt to add with overflow","623":"attempt to add with overflow","1108":"Array index out of bounds","462":"Initializer address is not the contract deployer","718":"Array index out of bounds","456":"Initialization hash does not match","834":"Array index out of bounds","700":"attempt to add with overflow","292":"Array index out of bounds","606":"Array index out of bounds","853":"attempt to add with overflow","1170":"Array index out of bounds","725":"Array index out of bounds","1100":"Array index out of bounds","652":"Stack too deep","646":"attempt to add with overflow"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"subscription_recipient_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"subscription_token_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"subscription_price","type":{"kind":"field"},"visibility":"private"},{"name":"fee_juice_limit_per_tx","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3djtw2EoXfZa59QRaLLDKvslgETuIEBgw7iJ0FFobffTU/YveMxC7MWQ3DH90Edqyvi6dEqg4pifp+99uHX/7+4+ePn3//8vXup399v/v05df33z5++bz87fuPd3e//PXx06ePf/x8/b/vzP1/LD8c//XP95/v//r12/u/vt39ZEMy7+4+fP5t+aMYs/zC7x8/fbj7ScyPf7+7sx5gAsAIwESASa9nyACMBRgCGAcwQD8goB/Qa/vBu+3BntJ6sOeUD7bR7hztUvBPR7skfHW03zk6cLRPRwdO8uzo+9bLAa0XWg8OJiitt+zz0Zx8PjqlnYOjl6djY4rXh963PHbb8tRry53ptuW225ZTty131VvO5tLy8LI53FZzfFvNCW01R9pqTmyrOamp5nD1suAtZ8NEyiWKsgFyxuZDfXxoue225dRty13TLefVXFO4uGVnHtwyc79N9/02PfTbdGm66bKaN0pu0/TYb9NTt0339UupC5e1h5eV3Vcfessh+WhiZfKRl00i87NM7hxr80TFb7Muc8iMc8hMU8gMZg6Zdg6ZNIdMN4dMnkOmn0PmHC4ozOGCwhwuKMzhgmQOFyRzuCCZwwXJHC5IeA6Zc7ggGaageHFPx3rhlzLjMJcgH9dj/dW9+VXmMJeg2zKHuQQFXsdmCJuxGYe5BN2WOcxE7LbMYSZit2UOMxG7LXOYunlTZhpmInZb5jATsdsyh3FBt2UO44Juy+Q5ZM7hgtIcLii17YKKU+WdH5aYHw+Rq3cwHIUHoW37oAOFtu2EjhNqTdtm6DVKI+cfjj5tlbbth45U2rYlOlJp267oNUoTrQ8i2+R4q5SnUdq2NzpSadv26FVKJbc5RbdVOo5D0pSOY5E0peN4JEWpHcYjkclvTJIJfqt0GI+kKh3GI6lKh/FIqlIeR2l0WenVW4xZ6TAeSVU6jEdSlQ7jkcjml4zI0nbNwQ7jkVSlw3gkTSmN45E0peN4JHt5I9T6uFU6jkfSlI7jkTSlPI3ScTySlZCVxu0qKI3jkTSlA3kkRelAHklROo5HIpNfmF/+vFHqxvFImtJxPJKmdByPpCkdxyORi1mpp61SnkbpOB5JUzqOR9KUjuORKN+XIYrb+6duHI+kKR3II91WygN5JEXpOB7JmXxfxtntyjaP45E0peN4JE0pT6N0HI/kXF7ZdrxdMeNxPJKmdByPpCkdxyNpSsfxSC7kFTMXtzNxP45H0pQO5JEUpQN5JEXpQB4p5Zk42+1M3PM0SgfySIrSgTySonQcj2RsnokzPXcO26PZhvWn2cbro+UxL+M4qmPzMo7/OjQvje9++3Z5cWltNLN127wM9Kz5oXkZ6Mn0Q/My0HPsr8pLyD/Nwe1cX/jMy25eBnpG/tC8DPRE/avyEnl9G5Nj2Lm+zOp3tbzM6ne1vHTqd+/b3vhexLfb3qlvvG/7OFuP3dyZ1I6z95iic5wtWG/rHGf3MZs/Mk1hq5Mn0TnO/mO3dY6zAdltnePsw2ouOmWrc5yNWG/rHGcn1ls6qfHdx47TOc5erLd1jrMZ622d4/ih2zp5ir33qfE9x47TOYwfUnQO44cUncP4IUXnOF90uamz8Z3GjtM5zvrQbZ1zfKKHGt9j7DidPInOSfxQ47uLHadzEj/U+M5ix+mcxA8d/Tbo1WNF+zolrLdBRC458fGxNbap1hzgLUJIuTXRK61h8mtzmISujt79QmPM26jF6P2zox+a7/puPvfdfN9380PfzZe+mx9rN9/lu1/sKGwblBpr0BFv6B3bIFu9x0W6NEiUHhfi+irKdTNoMRoPjaeeG39EncsmyYo1WuPZ5+c/OTql8a9qiHZhOOKFt260+om0hom0ykRa40Ra0zhaHeVXZZy7+izWMqXc+2nDaW2JNd5db2n9mJsjXlEbNjf2zE0xN3TmppibgXzf4bnhMzfF3AzkKw/PzUA+9PDcDORbD8/NQD738NycvriYGzl9cTk3py8u5+b0xeXcnL64nBs+c1PMzemLy7k5fXE5N6cvLufm9MXl3Jy+uJibePricm5OX1zOzemLy7k5fXE5N3zmppib0xeXc3P64nJuTl9czs3Evtizu+TGh21uJvbFWm7SxL5Yzc3EvljNzcS+WM3NxL5YzQ2fuSnmZmJfrOZmYl+s5mZiX6zm5vTFpdw4M7O/uZpPBZO2uZm4TgV/lRux29xMXKfU3Excp9TcTFyn1NxMXKfU3Ey8fqPlxk68fqPmZmJ/o+Zm4vUbNTcTr9+oueEDcpO/UrLkRttQhgKvP00S1E1/tBsl7oh9wv5ZAaF3AdK7gNi7gNS5ADK9C7C9C6DeBbjeBfReian3Sky9V2LqvRJT75WYeq/ErvdK7HqvxK73Sux6r8Su90rseq/ErvdK7HqvxK73Sux6r8TceyXm3isx916JufVKrD3RcsgW1/+ogNYrsSqg9UqsCmi9EqsCWq/EqoDWK7EmwLdeiVUBrVdiVUDrlVgV0Hsl9s3XAeUBUN/6VUi7Ux9avwqpAlq/CqkCWr8KqQJavwqpArh3Aa3PB1QBrdcBVUDr8wFVQOvzAVXAAZVYKH8LTq5C3DfpPsQRu2ZqIezbhzig3kSXfV30UTl3zjj/dLQz/vLTztJjgw6oHzFmzcmw0iA2bv2wDRt+/k2h7dHB83p08OH5Y5cPzT+gesTgL83XxoLkL9uLC9ts+iNOL12aI9seFN4+hLx9iN0r3rI8u/akZZktXYd4gBIA7e8qpkEWgQiBHAIxAnkECggkCIT0iFjoETFf87wzL6FkEMgiECGQQyBGII9AAYEEgSIC7fcIH9YyssxZ5QXExiCQRSBCIIdAjEAegQICCQJFBEJ6xP47W8tcL2UohQ1kEYgQyCEQI5BHoIBAgkARgRIAEdIj9p8hd5dJwmLnNn1v/7ltDXIIxAjkESggkCBQRKAEQPvPVWoQ0iMOeH7Q5y+5eqdN0ZYan0tsEtamaBzXnw6c5OUUjQ94dvByJ8MH7Suri/vMb9PFpH1lVWJeCJH44hPGD41vfnHP8WVlhi+//rQyw80/dqcKaH5xTxPQ/OKeJqD522yKgOYfu1MFNH+bTRPQ/G02TUDzt9k0Ady7gN4rcfOP3akCeq/EzT92pwrovRI3/9idKqD5SkzmIsDtCGi+EmsCmq/EmoDmK7EmoPlKrAlovhJrApqvxJqA5iuxJqD5SqwIaP/RU01A75W4/UdPNQG9V+L2Hz3VBMy8W6vi1Gf+Oruam5l3a1VyM/PX2dXczLxbq5abmXdr1XIz826tWm544two/mbmr7OruZn5KwZabmb2xVpuZvbFWm5m9sVKbmb+Oruam5l9sZabmX2xlpuZfbGWGz5zU8zN6YvLuTl9cTk3py8u5cYXHg6K+f1jG8PlfW4y/EjtO0a6bL1DV5R7hApPwSiQRSBCIIdA+5drkvxuNaW4gTwC7afc23x+vd00r3C7U4EsAhECOQQqVMjL9gAhmA3kESggkCBQRKAEQKV1/tuQRSBCIIdASI8QpEcI0iME6RGC9AhBekREekREekREekRpshDpUjNpAzECeQQKCCQIFBEoAVAyCLR/cpkyxLy5lu+/9K9BjEAegQICCQJFBEqvh8L+S/8aZBGIEMghECNQoUdc9nxiMRsoIJAgUESgBECFD7UqkEUgQiCHQIxASI+wSI+wSI+wSI+wSI8gYNoQyCIQIZBDoP2Ua3u8hcKHnESyaZG0DZYAqPDBIgWyCLSf9WcbmvkN5BCIEcgjUEAgQaCIQAmACm/wKpBFIKRHMNIjGOkRjPQIRnoEIz2CkR7BSI/YX0Mjk50OGbeFLAIRAjkE2k85mbziStf7PTI9UhGiEkIVltE0ykJUYe0yL/tad7VvU6YcRDFEeYgKECUQFSEqIVRhQU2jLETt9w3n88KxuzJzmXIQxRDlISpAlEBUhKjC6vtl6cpf34xZqO3NmGXqvVrNZW58dfTjpjuhsBB3bAxbIQZViOEqxOAKMXyFGKFCDKkQI1aIUWGcpwrjPFUY56nCOE8VxnmqMM5ThXGeKozz9Opx/kBFiEoAJYX17WWFfaUC8f+XBSkshx8bgyrEcBVicIUYvkKMUCGGVIgRK8RIbx/DVhjntsI4txXGua0wzm2FcW4rjHNbYZxbZBVKyECUhSiCKAdRyCqUkIeoAFECURGikFUocQaiLEQRRDmIQlahxHmIChAlEBUhKiFU4S6SRr39DFKYKsRwFWJwhRi+QoxQIYZUiBErxHj7lSLxpkKMCuPcVxjnvsI49xXGua8wzn2Fce4rjHNfYZx7aBUqGIiyEFVhBhkqzCBDhRlkqDCDDBVmkKHCSlGosFIUKqwUSYWVIqmwUiQVxrlUGOdSYZxLhXEuFca5VBjnUmGc79+DjrwuDEV/9WoqPyL7lwbj84KBCS+fJZPCvVUFsghECLQ/vJZVkBWyEjcQI5BHoIBAgkARgdLroVi4H6hAFoEIgRwCMQJ5BAoIJAgE9Ii4fxPo1mUlFu7pGHvZr85tIUYgj0ABgQSBIgIBF+VIBoEsAhECOQRiBPIIFBCo9LZLHk0m0gaKCJQAqHC7QoEsAhECOQTSe8QOhPQIh/SIwn0KBYoIhFwjGLlGMHKNYOQawcg1gpFrBCM9gpEewUiPYKRHMNIjPHJyPXJyPXJyPXJy9xcsfeAV8iFo2wV5F9ep1vLH+OPFVCvuL1geG2N/efPgGLZCDKoQw1WIwRVi+AoxQoUYUiFGhXEeKoxzqTDOpcI4lyP6FeeZ0fJHv41xxPlgZ3IMFzYxYuF8UFYfJCoxiG1+G5Ppem+39BjDVohBFWL4tz/n8ZB+FbJqFtnGOOJ6xdmW7MeIh/TddImhnb1kaM1sMn6nRRVGUzIVYtgKMahCDFchBleI4SvECBViSIUYsUKMtx/nyZgKMWyFGFQhhqsQ4+3Hedp/rcIv95BWKhqzpfZH7rKSkynPW2p/LEZKN6n90RV9yFTwWyoh1P4KvEpZiCKIchDFELVfA5YbNhcqaP7F5oeylvO/PbsUXhvjgRKIihCVXk39WP76n/d/fXz/y6cPXxfo/l///vzrt49fPj/99dt//3z8l+Xg/wE=","brillig_names":["constructor"],"assert_messages":{"218":"attempt to add with overflow","87":"attempt to add with overflow","567":"Array index out of bounds","200":"Array index out of bounds","447":"Array index out of bounds","892":"Array index out of bounds","377":"Initializer address is not the contract deployer","470":"Array index out of bounds","371":"Initialization hash does not match","464":"attempt to add with overflow","493":"Stack too deep","586":"attempt to add with overflow","487":"attempt to add with overflow","196":"attempt to add with overflow","737":"SharedImmutable already initialized","822":"Array index out of bounds","830":"Array index out of bounds","854":"attempt to add with overflow","903":"attempt to add with overflow","921":"Array index out of bounds","207":"Array index out of bounds","929":"attempt to add with overflow","838":"Array index out of bounds","675":"SharedImmutable already initialized"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7V3RjiS3kfyXfdZDkcxMkv6Vw+Eg27IhQJAMSz7gYPjfr2d3uqd3qnZym2SxIqvzxZDkIisYW4zIrO1g/fvTX3/687/+/j8///q3337/9Kf/+venX377y49//Pzbr5d/+/d/fvj053/+/MsvP//9f+7/86fl5X+IP1//+z9+/PXlX3//48d//vHpT1l++PTTr3/99KcSLqP/9vMvP13+2/Kf//7hE8lj10t68Hp67PryIP7yIP5SH7j+h/WF8fXCnG8Xcn2ZuC57TRz2mjjuNXHaa2Laa2Lea2LZa+K818Rlr4n32nlhWXabOew2c9xt5rTbzLTbzLzbzLLbzHm3mctuM++2B8NuezDstgfDbnsw7LYHw257MOy2B8NuezDstgfDbnsw7LYH4257MO62B+NuezDutgfjbnsw7rYH4257MO62B+NuezDutgfTbnsw7bYH0257MO22B9NuezDttgfTbnsw7bYH0257MO22B2m3PUi77UHabQ/SbnuQdtuDtNsepN32IO22B2m3PUi77UHebQ/ybnuQd9uDvNse5N32IO+2B3m3Pci77UHebQ/ybntQdtuDstselN32oOy2B2W3PSi77UHpe55lKfX1Url0JreLL28Yv0xfd50+L/tOH/adPu47fdp3etp3et53etl3+tw5vdxNH7+afn11CsvrxSnQ28ThC5ICg6SiICkLDJIAgyTCIEkwSAgGCcMgERgkMBpbYDS282dNEt5sLYbQg6Tzd1AjkQQYJBEGSYJBQjBIGAaJwCDJMEgKDBIUjY0LisbGBUVj44KisXFB0di4oGhsXFA0Ni4oGhsXFI2NC4rGxgVGYwOMxgYYjQ0wGhtgNDbAaGyA0dgAo7EBRmMDjMYGGI2NMBobYTQ2wmhshNHYCKOxEUZjI4zGRhiNjTAaGyE0duPSLPl6bQnpdnGkz7AThCA/DhtCvR+HDSH1j8OG8IXHYUOYyOOwIRzncdgQ9vQ4bAgvexw2hPE9DtumS5JNlySbLkk2XZJsumRnpuMw2DZdkmy6JNl0SbLpkmTTJdmmS7JNl2SbLsk2XbIzdXUYbJsuyTZdkm26JNt0SbbpkmLTJcWmS4pNlxSbLtmZizwMtk2XFJsuKTZdUmy6pNh0yWzTJbNNl8w2XTLbdMnePPVRsG26ZLbpktmmS2abLpltumSx6ZLFpksWmy5ZbLpkbyT/KNg2XbLYdMli0yWLTZfEOHPgYdgYBxQ8DtumS2IcffA4bJsuiXGowuOwbbokxnENj8O26ZIYB0E8DhvVJQulG2zO72AnjCMmHoeN6pIK7E6XjBRvsKsosEOt16vjIm/AU+Stqxeq1+c7LJzyV9d/Bp8sgyfL4NkyeLEMPlsGXyyDr4bB9x4qciz4YBm8ZYcNlh2294CUY8Fbdthg2WGDZYcNlh02WHbYaNlho2WHjZYdNlp22N7jcY4Fb9lho2WHjZYdNlp22GjZYROyw/LtNevln1nW4JEdVgWP7LAqeGSHVcEjO6wKHtlhVfDIDquCR3ZYFTyyw6rgkR1WA0/QOn9XHsjLjO/BI6uN8B34HNbgkdVGBY+sNip4ZLVRwSOrjQaeket5FTxyPa+CR9Z5FTxyPa+CJ8vgOx32Ms8VfKr5K/Cfp5d9p8/7Tl/2nb7uOn3vaSDa9GHf6eO+03c+OXTbV0KVtU0bQrnuwsBvv+rc/HUfS7r+EpDl5eYfT73k5bbBa89nH1PvKQRnpKQ6Je8o6T094YyUBKfkPSXRKXlPSXJK3lNCTsl7StgpeU+JOCXvKfHqdUWJV68rSrx6fU9J8ep1RYlXrytKvHpdUeLV64oSckreU+LV64oSr15XlHj1uqLEq9cVJV69vqekevW6osSr1xUlXr2uKPHqdUUJOSXvKfHqdUWJV68rSrx6XVHi1euKEq9e31FCi1evK0q8el1R4tXrihKvXleUkFPynhKvXleUePW6osSr149hfHwCKy1e6vbx53VxF3/Bi+g+/rzi7uPPy/M+/ryW7+OPnL8u/rxL6OPPW4o+/rz/6OPP+48+/rz/6OIvev/Rx5/3H338ef/Rx5/3H338kfPXxZ/3H338ef/Rx5/3H338ef/Rx5/3H138Je8/+vjz/qOPP+8/+vjz/qOPP3L+uvjz/qOPP+8/+vjz/qOPP+8/+vjz/qOLP/L+o48/7z/6+PP+Q+Gv3D6IkQrnFX/ef/TxR85fF39n6T8i03Xq6Z+NIzpLF3Isi2fpRY5l8SwdybEsnqUvOZRFPkt3ciyLZ+lRjmXxLJ3KsSyepV85lkVyFgew6L3LCBa9dxnBovcuI1j03mUEi967DGBRvHcZwaL3LiNY9N5lBIveu4xgkZzFASx67zKCRe9dRrDovcsIFr13GcGi9y4DWDzNR3GPZdF7lxEseu8ygkXvXb6DRb791unyzyxrFslZHMCi9y4jWPTeZQSL3ruMYNF7lxEseu8ygMXTfBL5WBa9dxnBovcuI1j0evF7WLzrAOVlxvcsukd/B4vCdyzmsGbRPXoAi6f58OuxLLpHj2DRPXoEi/5+cQSL5CwOYNHrxREs+vvFESz6+8URLAL3LjcUnKkoU8fwxkuU+tXVn9cJ3F0MXCcjfzp36DqBK/Sh6wSuoYeuE7jKHbpOepJ1AleKQ9c5t5a7TRzi8v6LrTz5i60fYylAWCoOlslf5fwYSwDCEoGwTPWiGG7lf9K0S/01Gs/96uFg7GwYuxjGng1jL4axV7vY537dbTD2YBh7NIzdsK/O/ZrXYOyGfTUa9tVo2FejYV+Nhn01GfbVZNhXk2FfTYZ9de5XagZjN+yrybCvJsO+mgz7ajLsq2TYVwnYV5VfmDMB+6qKHdhXVezAvqpiB/ZVFTuwr6rYgX1VxQ7sqyp2YF/VsDOwr6rYkfX948wRM7DOKL85ZAbWGRU7sM6o2IF1RsMuwDqjYgeu31XswPW7ih1Y31XsZBg7cP2uYS/I2BO9Yae0xo5cE2jYkWsCDTtyTaBhR64JFOwVuSbQsCPXBBp25JpAw45cE2jYyTB2w75aDftqNeyr1bCvVru+KotdX5UF2Vfj24ekJW1gR/ZVDTuyr2rYkX1Vw47sqxp2ZF/VsCP7qoYd2Vc17Mi+qmAPyL6qYTfsq8GwryJnEVXshn01+Oky33O6jFKNBz8ZcwSLfjLmABajn4w5gkU/GXMEi34y5ggW/WTMESySsziART8ZcwSLfjLmCBa9dxnBovcuI1j03mUAi8l7lxEseu8ygkXvXUaw6L3L97CovKWde3rAaVn03mUEi967jGDRe5cRLHrvMoJF710GsEjeu4xg0XuXESx67zKCRe9dRrBIzuIAFr13GcGi9y4jWOysFyNd4cj8F1K9B7kcCz5YBh8tg0+WwZNl8GwZvFgGny2DL5bBW3ZYseywYtlhxbLDimWH7T3G6Fjw0A6rNCMC7bAaeGiH1cBDO6wGHtphFfAZ2mE18NAOq4GHdlgNPLTDauChHVYDb9lhs2WHzZYdNlt22NKp80upV/Ahha/Af54+7jt92nd62nd63nd62Xf6vO/0Zd/p667T9x4Gucjd9FHRBJLr32DRnX4k/rLDe892HAkl4kBJOFAIBwrjQBEcKBkHSsGBUlGg5AVGbfMCo7a59wC/8GZxMYQ+KAkHCuFAYRwoggMl40ApOFAqDJTeg+NGQgk4UHDUNuCobcBR24CjtgFHbQOO2gYctQ04ahtx1DbiqG3EUduIo7YRR20jjtpGHLWNOGobcdQ24qhtwlHbhKO2CUdtE47aJhy1TThqm3DUNuGobcJR24SjtoSjtoSjtoShtutrU5ZrsC6V8PZbgkhfcGNI8+O4MXT8cdwYov84bgyHeBw3hp08jhvDex7HjWFUD+NmDFd7HDeGBT6O26hfslG/7M2pHobbqF+yUb9ko37JRv2SjfqlGPVLMeqXYtQvxahf9qZOD8Nt1C/FqF+KUb8Uo34pRv0yG/XLbNQvs1G/zEb9sjdDehhuo36ZjfplNuqX2ahfZqN+WYz6ZTHql8WoXxajftmbUj4Mt1G/LEb9shj1y2LUL4tRv6xG/bIa9ctq1C+rUb/szdsfhtuoX1ajflmN+mU16pfVpl+WxaZflsWmXxaQcw0ex23TL8ti0y8LyPEKj+O26ZcF5OCGx3Hb9MsCciTEw7hBzo94HLdRvwQ5mWIDd6F0w815hRvWLxXcsH6p4EY+/pbq9REPC6f81fWfwSMff6uCRz7+VgWPfPytCh75gHkNfEQ+YF4Fj3zAvAoe+YB5FTzyAfMqeLIM3rLDRssOGy07bLTssNGywybLDpssO2yy7LDJssP2HmtzLHjLDpssO2yy7LDJssMmyw5Llh2WLDssWXZYQnZYvr1mvfwzyxo8ssOq4JEdVgWP7LAqeGSHVcEjO6wKHtlhNfCM7LAqeGSHVcEjO6wKHlrn78oDeZnxPXjoTzLyHfgc1uChP3qsgBfojx5r4KE/eqyBh/7osQYe+qPHGniyDB76o8caeOiPHmvgoT96rIHvdNjLPFfwqeavwH+evu46fe8RKtr0Yd/p477Tp32np32n512n7z1MgG77SqiytmmTXDdtuAez/fM+lnT91jfLy90/nnvJb18Gr11fmiy9JxWck5TopKxJSU7KmhRyUtaksJOyJkWclDUp2UlZk1KclDUp1UlZkVK9ot0gxSvaDVK8ot0gxSvaDVLISVmT4hXtBile0W6Q4hXtBile0W6Q4hXtipS6eEW7QYpXtBukeEW7QYpXtBukkJOyJsUr2g1SvKLdIMUr2g1SvKLdIMUr2jUpwSvaDVK8ot0gxSvaDVK8ot0ghZyUNSle0W6Q4hXtBile0W6Q4hXtBile0a5JiV7RioLj42Nda/Tyt5dBr5V7GfTCupdBcgY7GfSSvZdBr+97GfRmoJdB7xx6GfQ2o5PB5D1JL4Pek/Qy6D1JL4Pek/QySM5gJ4Pek/Qy6D1JL4Pek/Qy6D1JL4Pek3QySN6T9DLoPUkvg96T9DLoPUkvg+QMdjLoPUkvg96T9DLoPUkvg96T9DLoPUkng+w9SS+D3pP0Mug9SS+D3pP0MkjOYCeD3pOoDJbbhzpS4bxi0HuSXga9J+ll8DQ9SWS6zj39m3aVT9OYHEqjnKY7OZbG07Qox9J4mj7lWBpP06wcSyM5jSNoPE3bciyNp+ldjqXxNA3MsTR6FzOERu9iRtCYvYsZQqN3MUNo9C5mCI3exQyhkZzGETR6FzOERu9ihtDoXcwQGr2LGUKjdzEjaDzP13KPpdG7mCE0ehczhEbvYobQSE7jCBq9ixlCo3cx30Mj334IdflnljWN3sUModG7mCE0ehczgsbzfCH5WBq9ixlCo3cxQ2j0LmYIjeQ0jqDRu5ghNHrd+F003jWD8jLj1zSG5Twfi92VR+E7HnPY4NG9egyPbtZjeHS3HsOj2/UYHv2t4xge/bXjGB69fhzDo794HMLjeb77ezCPyP3MDQZnKsrcMbwxE6V+dfWXlSJ3HGNXitwTjF0pPc1KkevqsStFrnzHrhS5Nh27UuTqcexKp9Z3FG/n2tAd9peVfkYz91uyKpoAhSZCoUlQaAgKDUOhmepPxNfDqAKXomiZ+mO2C/psGn0xjb5aRj/3G4DD0QfT6KNp9Mk0ejKNnk2jN+21ybTXJtNem0x7LZn2WjLttWTaa8m01879ltFw9Ka9lkx7LZn2WjLttWTaa9m017Jpr2XTXsumvXbuNzoeRK/8nP3lP5pGj+y1Onpkr9XRI3utjh7Za1X0guy1Onpkr9XRI3utjh7Za3X00HqvZZ4EWXPUXzhmZM3R0SNrjo4eWXN09Miao6Mn0+iR63sdPbLe6+iR63sdPXJ9r6Kv0OgTvaGntIEeulJQ0IcFulJQ0UNXCip66EpBRQ9dKajoyTR66EpBRQ9dKajooSsFFb1lrw2Laa8Npr02mPbaYNprg2mvnZtYfBT9W/ThspIt9NBeq6KH9loVPbTXquihvVZFD+21GvoI7bUqemivVdFDe62KHtprVfSmvTaa9lrolKSO3rTXJj8b57vOxtFq9eRnfY7h0c/6HMOjn/U5hkdyHofw6Gd9juHRz/ocw6Of9TmGRz/rcwyPftbnEB7J+5kxPHo/M4ZH72fG8Oj9zBgeyXkcwqP3M2N49H7mu3jU3uOS9zNjePR+ZgyP3s8M4ZG9nxnDo/czY3j0fmYMj97PjOGRnMchPHo/M4ZH72fG8Oj9zBgevZ8Zw6P3M0N47D1ZJtIVjxzwtqr3ZJmD0ZNp9GwavZhGn02jL6bRV8voe09UOhh9MI3etNdm017be6LSwehNe2027bXZtNdmaK/VupMM7bUa+gLttSp6aK9V0UN7rYoe2mtV9NBeq6KH9loVPbTXquihvVZFb9pri2mvraa9tpr22tqp90upV/QhBQV9KjW8Xp1qeEMT6RUMI4ERJDAZCUxBAlNxwMTek0zHgglIYCISmIQEBkiB4wKkwHEBUuC4AClwXIAUOIaZOiNBbtXS25EtsVyxzNxMkm4XE29gYSAsAoQlA2Hp3UhyhyUqWHK+FuM535XunF+xVBwsvUfXDcUSgLBEICwJCEun7oa3PX3xk04sDIRFgLBkICwFCEvFwdJ7hNxQLAEISwTCkoCwAOluAtLdBKS7CUh3E5DuJiDdJSDdJSDdJSDdJSDdJSDdJSDdJSDdJSDdJQzd3Xi5l+Uapkll4+UeYYj048AZQ9EbgGPIfwNwDK9oAI5hLA3AMVyoATiGZTUAx/C3BuAYZtgA3KpzslXnFKvOKVadU6w6p1h1zt747nHArTqnWHVOseqcYtU5xapzZqvOma06Z7bqnNmqc/aGcY8DbtU5s1XnzFadM1t1zmzVOYtV5yxWnbNYdc5i1Tl7o7XHAbfqnMWqcxarzlmsOmex6pzVqnNWq85ZrTpnteqcvSHl44Bbdc5q1TmrVeessM5ZKN2Ac14Dh3XOj4GnBdY5NeDIJ05QvT7mYeGUv7r+C3rk05109MinO+noyTR65NOddPTIpzvp6JFPd9LRI5/upKNHPt1JRR+QT3fS0Zv22mDaa4Npr+09iuJg9Ka9Npj22mDaa4Nprw2mvTaa9tpo2mujaa+Npr229/iRg9Gb9tpo2mujaa+Npr02Inst397BXv6ZZY0+IXutjh7Za3X0yF6ro0f2Wh09stfq6JG9VkeP7LU6emSv1dEje62KnqD1/q5SkJcZV+iRNUf4Dn0OG+ihv0qioof+KomKHvqrJCp66K+SqOihv0qioWfor5Ko6KG/SqKih/4CmIoe+gtgKvpOr71MdEV//731F/Rf5ued55ed5887z192nr/uO3/v8SHq/GHn+TufH7ptMKHKyu6N4fYR0Bjo7RDu68Fxqff0gcFoChSaioSmN/w/GE2AQhOh0CQoNASFhqHQQGlxhtLiDKXFGUqLC5QWFygtLlBaXKC0uEBpcYHS4gKlxQVKiwuUFhcoLa5QWlyhtLhCaXGF0uIKpcUVSosrlBZXKC2uUFpckbSYFiQtpgVJi2lB0mJakLSYFiQtpgVJi2lB0mJakLSYFiQtpgVKiwOUFgcoLQ5QWhygtDhAaXGA0uIApcUBSosDlBYHKC2OUFocobQ4QmlxhNLiCKXFEUqLI5QWRygtjlBaHKG0OEFpcYLS4gSlxQlKixOUFicoLU5QWpygtDhBaXGC0mKC0mKC0mKC0mKC0mKC0mKC0mKC0mKC0mKC0mKC0mKG0mKG0mKG0mKG0mKG0mKG0mKG0mKG0mKG0mKG0mKB0mKB0mKB0mKB0mKB0mKB0mKo3B1B5e4IKndHULk7gsrdEVTujqBydwSVuyOo3B1B5e4IKndHULk7gsrdEVTujqBydwSVuyOo3B1B5e4IKndHULk7gsrdEVTujqBydwSVuyOo3B1B5e4IKndHULk7gsrdEVTujqBydwSVuyOo3B1B5e4YKnfHULk7hsrdMVTujhckLWao3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwyVu2Oo3B1D5e4YKnfHULk7hsrdMVTujqFydwKVuxOo3J1A5e4EKncnC5IWC1TuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULk7gcrdCVTuTqBydwKVuxOo3J1A5e4EKncnULm7DJW7y1C5uwyVu8tQubu8IGlxhsrdZajcXYbK3WWo3F2enLsL4YYmpa/QPHb1Z+yTU3pjsQfD2KNh7MkwdjKMnQ1jF8PYs2HsxTB2w74aDftqNOyr0bCvRsO+OjkpOha7YV+Nhn01GvbVaNhXo2FfTYZ9NRn21WTYV5NhX52c+h2L3bCvJsO+mgz7ajLsq8mwr5JhXyXDvkq4vhqypNerQ65FuZolLa9Xs7xg/RBJWPL16ssFUbk63y7OmTY4xPV3OxySc9jNIW69Y4dD3LrLDoe49Z8dDnHrUDsc4tbDZjhk3LrcDoe4/YEdDr1P6efQ+5R+Dsk57ObQ+5R+Dr1P6efQ+5R+Dr1P6efQ+5RuDsX7lH4OvU/p59D7lH4OvU/p55Ccw24OvU/p59D7lB4O19emLFdGUglva4z0Srg3NZMJ9w5oMuHeLs0lPHtvNZlwb8QmE+5d22TCvcWbTDg54XMJ9+ZxMuHeaU4m3DvNyYR7pzmZcO805xJevNOcTLh3mpMJ905zMuHeaU4mnJzwuYR7pzmZcO80JxPuneZkwr3TnEy4d5pzCa/eaU4m3DvNyYR7pzmZcO80BxNeKN0If7niPeHkhM8l3DvNyYQ/aacZ+frFixCraFfXGq+4F7mjPPLmHybVfPvT5JS/uv4L60/abh7M+pP2nAez/qSN56Gsl+VJu8+DWX/SFvRg1p+0Dz2Y9SdtRg9mnZz1A1h/0rb0YNa9Nz2Cde9Nj2Dde9MjWPfe9ADWgb/IembWvTc9gnXvTY9g3XvTI1gnZ/0A1r03PYJ1702PYN170yNY9970CNa9Nz2AdeCvmp+Zde9Nj2Dde9MjWPfe9AjWyVkfzjrfflt6+WeWDda9Nz2Cde9Nj2Dde9MjWPfe9AjWvTc9gPXkvekRrHtvegTr3psewbr3pkew7vX6DqzfvRGQlxlXrHsNM5514TvWc1izTl7DHMG61zBHsO41zBGsew1zBOvkrB/Aur9fP4J1r9ePYN3frx/Bur9fP4L18/SmN9CcqahI3niMUr+6+jMvfJ7ucSwv5+nvxvJyng5sLC/n6ZHG8kLOyyYv5+kzxvJynk5gLC/AtXpZypWXmqp2tf7LQgaukIevFbguHb1WAa41h68VuH4cvlbgmnD4WoHrvOFrpSdaK3A9NnytwDXW8LU+Ud0kT1Q3yRPVTfmJ6qb8RHVTfqK6KT9R3ZTpidb6RHUT8tfqh6/1ieom5G+0D1/rE9VNyF8mH77WJ6qbkL/HPXytT1Q3IX+Fevhan6huQv728oNrVZNHyJ89Hr7W89RN+lrPUzepa0X+zu7wtZ6nbtLXep66SV/reeomfa30RGs9T92kr/VE/qpkhyvyd94eXKv2W/SK/HW14Ws9jw7raz2PDutrPY8O62s9T/+qr/U8/au+1vP4q77W8/Sv6lqRv4Y0eq3IJ5g9utZEb2ultLHWE9WI6lpPVCOqaz1RjaiulZ5orSeqEdW1nqhGVNd6ohpRXeuJakR1rSeqEbW1Ip+aNnytT1Q3IZ8QNnytT1Q3IZ+G9eha4/K21rS11hPVTepaT1Q3qWs9Ud2krvVEdZO61hPVTdpakc8LGr7WE9VN6lpPVDepaz1R3aSulZ5orU9UNyGfkzN8rU9UNyGfkWL3dEitu0Q+reXErPtp7kew7qe5H8E6OesHsO6nuR/Bup/mfgTrfpr7Eaz7ae5HsO5fGjuAdeRzqE7MuvemR7DuvekRrHtvegTr5KwfwLr3pkew7r3pDqxrf6uBfJrciVn33vQI1r03PYB15LP+Tsy696ZHsO696RGse296BOvkrB/AuvemR7DuvekRrHtvegTr3psewbr3pgew3nvuZqQrHjngjWnvSZoHoyfT6Nk0ejGNPptGX0yjr3bRx2VZTKMPptEb9toLesNee0Fv2Gsv6A177QW9Ya+9oDfstRf00F77cXdyQQ/ttRr6AO21Knpor1XRQ3utih7aa1X00F6roof2WhU9tNeq6KG9VkVv2muDaa+Npr02mvba2Kn3S6lX9CEFBb0EuS317U18LPSKhWdioesBGyJpA4sAYclAWAoQloqDpfe8/KFYAhCWOBNLul1MvIElAWEhICwMhEWAsGQgLAUIS8XBQgsQlgCEBUh3CUh3CUh3CUh3CUh3CUh3t89DTKVef4KUargre66jctOo0jSqtozaPg9QHRWaRm2yoTSD24dCKH9a22caaINiy6DUMohbiNh8AoVvbw0kbgzKLYNKy6DaMGg7VaW0EtuhIG1QbBmUWgZRyyBuGSQtg3LDA7v9a1ptUG0YVFu2e23Z7rVlu9eW7b79G0FtELcMkpZBLU9EbXkiasMTEZalZVBoGRRbBm0XBjFdf22cYn57mxu3So96K2kui337rfHmq1yRG5qc7y/9AiYjgSlzwdSr7uVAazB1MpjrD9nzvZe/gtn+UcFRYMJUMPn2U/l8XxFcwUQkMGkumFv1XJb1btr+C/kdwVz/wqjEsAbDU8GUdH2Ay9YfkxwFZkP0tv/2OyXmK5hU0z2YL6NK06htTUtUPxq1/besl1Hhw1GhaVRsGbXd/1604bquC8t3AZ5XI97uf0OkW+wnSliN2u5/1VGhaVRsGpWaRtH2qMy3UXXN4fZ5xuqobeY53P7OmcMa4XZjr44KTaNi06jUNGqbebnJURBZ1qO4aZQ0jcpNo0rTqNoyavu9gDoqNI2KTaNS06imZ6M0PRul6dkoTc9GaXo2StOzUZuejdr0bNSmZ6N+49ko13dhF+2L61HUNIqbRknTqNw0qjSNqg2j4rI0jdr+U6Z4G0UU1qNS0yhqGsVNo6RpVG4aVZpG1ZZR2+2zOio0jWp6NkLTsxGano3wjWfjFqUPlJf1KGkalZtGlaZRtWVUXJpGhaZRsWlUahpFTaOano3Y9GzEpmcjNj0bsenZSC0dR0yhaVRsGpWaRm0zv8gbHZe/e70b9/qyIm7/mOjSH9ydlLFxu9oyavsHOuqo0DRqm/xSbm956sLrUalpFDWN4qZR0jQqN40qTaNqy6jtj/6qo0LTqKZng5ueDW56Nrjp2eCmZ4Obng1ueja46dnYfkF3qdnf8g9pY1RoGhWbRqWmUZvMv7zGvI6KJX4l2Vu5DqpvEs8pryV++/tB429Tp9xm+53h+NuEObeJc26T5tyG5tyG59xG5txmjgrkOSqQ56hAmaMCZY4KlDkqUOaoQJmjAmWOCpQ5KlDmqECZowJljgrUOSpQ56hAnaMCdY4K1DkqUOeoQB2iAvz2F/YLs2zcJs+5TZlzmzrjNmlZ5twmzLlNnHObNOc2NOc2POc2U1QghTGPwJ2myUveaXWbIaRpb5hTkDm3yXNuU+bcpk65TVzm3CbMuU2cc5s05zY05zZjtqdygGGKec5typzb1Cm3Scuc24Q5t4lzbpPm3Ibm3Ibn3GaOCqQ5KpDmqECaowI0RwVojgrQGBVQDjNLlObchubchufcRubcJs+5TZlzmzrlNrzMuU2Yc5s5KsBzVIDnqADPUYFvnCJyy0nS3cuEzyms1bVSr7/nyPx2g5eY1+pSkuu0HJf7Sz9D+cbRJIdACThQIg6UhAOFcKAwDhSZCIXj9VKW/PGlYcnhJkPlLm/7+uOotP3jKAvAi1Xg1Sjw7b9nKrcMdLkD8zqGvhH4WW6HFb28OluPSk2jqGkUN43a/g3ox8Fp+kbgRxtVmkbVllHfCPxoo0LTqNg0KjWNoqZR3DSq6dkITc9GaHo2QtOzEZuejdj0bGy//P9Ya74R3FnC26uStDEqN40qTaNqy6hvhGm0UaFpVJNepya9Tk16nZr0evvFqzoqN40qTaNqy6hvZH2W23FRFyuP61GhaVRsGpWaRlHTKG4aJU2j9Gdja1TTs0FNz8Y3sj7aqNA0qkk3uEk3uEk3uEk3uEk3uEk3uOnZ4KZnQ5qeDWl6NqTp2ZCmP2Vp+lOWpj9lefhP+T+Xf/vfH//5849//uWn3y9jXv7Pf/36lz9+/u3X13/94//+8eX/uVz8/w==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":1,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"dapp_payload::DAppPayload"},"visibility":"private"},{"name":"user_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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/xjy6tLV/UcL1WUQq2KD/NHCJhZuPOvzHdYcKnX/CWImLhdqviLkZsLV+icLZuLKkJtvd16utHzmJJrDqywZh6tKwTi8ZMk4/DndIvCfLRiHv4TcOLi6/wIxDu5C/ouFTSzceNbnO6w5VOq+GmIcrhJqvibkxsHVerUF4/DXkBsHd17+avnMSTSH11oyDtem2/8Z/ovCn+H/TbiHkmmW/pZuxyxdl24R+DoLZun6kJslV/f1STJL0cQe51qPVf2jw2uFc6Sc7xtCfoG6B90NFi7QG0N+gbqab7Sg+++WLj133PhfAVHnxPacKfb49RZMj3K//yPk697N4T8s5PAGYQ5vghRayjvn5pDfE+6c3GzhvLzF0nl5S7q9H/fGcqHeQ8r19E9Le0idy3+KvXXsUf965ATdd46dycLi8l8WirT2vrm+o85B3+G2b/e1b/O1m/vaJb52M1+72Ncu8rULfe1bfe1/+dr/9LVv8bVv9rVv8rX/4Wv/3de+0de+wde+3te+ztf+m699ra/9V1/7Gl/7al/7L772n33tq3ztK33tK3ztP/na351wqP2tr/2Nr/21r/2Vr/2lr73X1/7C1/7c1/7M1/7U1/7E1/7Y1/7I197ja3/oa3/ga7/va+/2td/ztd/1td/xtd/2tXf52m/52m/62m/42q/72q/52q/62jt97Vd87Q51D7Xb+9rtfO22vnYbX/txX7u1r/2Yr93K137U127paz/ia7fwtR/2tR/ytR/0tR/wte/3te/zte/1te/xte/2te/yte/0te/wtW/3tW/ztZv72iW+djNfu9jXLvK13fMt1p5xyqH2TF97lq8929ee42vP9bXn+drzfe0FvvZCX3uRr73Y117iay/1tZf52st97RW+9kpfe5WvvdrXXuNrr/W11/na633tDb72Rl97k6+92dfe4mtv9bW3+drv+drv+trv+Npv+9q7fO23fO03fe03fO3Xfe3XfO1Xfe2dvvYrvvbLvvZLvvaLvvbXvvZXvvaXvvZeX/sLX/tzX/szX/tTX/sTX/tjX/sjX3uPr/2hr/2Br/2+r73ba/dPO/jcmm7uSRNFJopNNDNRYqK5idtM3G7iDhN3mrjLxN0m7jFxr4n7TNxv4gETD5p4yMTDJlqYeMRESxOPmmhl4jETrU08bqKNibYm2plob6KDiY4mOpnobKKLia4m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","debug_symbols":"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","brillig_names":["pack_arguments_array_oracle_wrapper","call_private_function_internal","unpack_returns","get_note_internal","decompose_hint","get_key_validation_request","notify_nullified_note_oracle_wrapper","notify_created_note_oracle_wrapper","get_public_keys_and_partial_address","random","lt_32_hint","lte_16_hint","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","debug_log_oracle_wrapper","get_public_data_witness","notify_set_min_revertible_side_effect_counter_oracle_wrapper","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","directive_invert","directive_integer_quotient"]},{"name":"is_initialized","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"subscriber","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["is_initialized"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000be5b3a47"},{"kind":"string","value":"TransparentNote"},{"fields":[{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"secret_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000008c1acdbf"},{"kind":"string","value":"TokenNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"amount","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000b6a7f5ef"},{"kind":"string","value":"SubscriptionNote"},{"fields":[{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"expiry_block_number","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"remaining_txs","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"minters","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"total_supply","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"pending_shields","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"public_balances","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}},{"name":"symbol","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}],"kind":"struct"}},{"name":"name","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}],"kind":"struct"}},{"name":"decimals","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AppSubscription"}},{"name":"fields","value":{"fields":[{"name":"target_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"subscription_token_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"subscription_recipient_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"subscription_price","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"subscriptions","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}},{"name":"fee_juice_limit_per_tx","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":1,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"dapp_payload::DAppPayload"}},{"name":"user_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AppSubscription::entrypoint_parameters"}}],"kind":"struct","path":"AppSubscription::entrypoint_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"subscription_recipient_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"subscription_token_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"subscription_price","type":{"kind":"field"}},{"name":"fee_juice_limit_per_tx","type":{"kind":"field"}}],"kind":"struct","path":"AppSubscription::constructor_parameters"}}],"kind":"struct","path":"AppSubscription::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"subscriber","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nonce","type":{"kind":"field"}},{"name":"expiry_block_number","type":{"kind":"field"}},{"name":"tx_count","type":{"kind":"field"}}],"kind":"struct","path":"AppSubscription::subscribe_parameters"}}],"kind":"struct","path":"AppSubscription::subscribe_abi"}]}},"file_map":{"101":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"103":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"108":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"109":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"114":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"},"116":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"120":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"139":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe}, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\nimpl<T, Context> Storage<T> for PrivateMutable<T, Context> {}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note, let N: u32> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:initialize\n    pub fn initialize(self, note: &mut Note) -> NoteEmission<Note> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(self, new_note: &mut Note) -> NoteEmission<Note> {\n        let (prev_note, note_hash_for_read_request): (Note, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(self.context, prev_note, note_hash_for_read_request);\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace(self, note: &mut Note) -> NoteEmission<Note> {\n        // `check_nullifier_exists` is an unconstrained function - we can constrain a true value by providing an\n        // inclusion proof of the nullifier, but cannot constrain a false value since a non-inclusion proof would only\n        // be valid if done in public.\n        // Ultimately, this is not an issue ginen that we'll either:\n        //  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        //    nullifier, or\n        //  - replace the current value, which would fail if it was not initialized since we wouldn't be able to produce\n        //    an inclusion proof for the current note\n        // This means that an honest oracle will assist the prover to produce a valid proof, while a malicious oracle\n        // (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note(self) -> NoteEmission<Note> {\n        let mut (note, note_hash_for_read_request) = get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, &mut note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note, let N: u32> PrivateMutable<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note(self) -> Note {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"142":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr","source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize},\n};\n\n// Just like PublicImmutable but with the ability to read from private functions.\npub struct SharedImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // Intended to be only called once.\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read_public(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> SharedImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read_private(self) -> T {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"},"147":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"},"154":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: Header,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index,\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n                == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path)\n                ,\n                \"Proving public value inclusion failed\",\n            );\n\n            // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n            // we have two scenarios:\n            // 1. The tree entry is initialized, and the value is the same as the one in the witness\n            // 2. The entry was never initialized, and the value is default zero (the default)\n            // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n            let preimage = witness.leaf_preimage;\n\n            let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n            let is_next_greater_than =\n                full_field_less_than(public_data_tree_index, preimage.next_slot);\n            let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n            let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n            let value = if is_in_range {\n                0\n            } else {\n                assert_eq(\n                    preimage.slot,\n                    public_data_tree_index,\n                    \"Public data tree index doesn't match witness\",\n                );\n                preimage.value\n            };\n\n            value\n        }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"164":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"165":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"166":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n"},"177":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"178":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"184":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::storage_read,\n};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"190":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"234":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"274":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"284":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"313":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"333":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot: Field,\n    value: Field,\n    next_slot: Field,\n    next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"339":{"path":"/usr/src/noir-projects/noir-contracts/contracts/router_contract/src/utils.nr","source":"use aztec::protocol_types::constants::ROUTER_ADDRESS;\nuse aztec::context::private_context::PrivateContext;\nuse crate::Router;\n\n// docs:start:helper_router_functions\n/// Asserts that the current timestamp in the enqueued public call enqueued by `check_timestamp` satisfies\n/// the `operation` with respect to the `value. Preserves privacy by performing the check via the router contract.\n/// This conceals an address of the calling contract by setting `context.msg_sender` to the router contract address.\npub fn privately_check_timestamp(operation: u8, value: u64, context: &mut PrivateContext) {\n    Router::at(ROUTER_ADDRESS).check_timestamp(operation, value).call(context);\n}\n\n/// Asserts that the current block number in the enqueued public call enqueued by `check_block_number` satisfies\n/// the `operation` with respect to the `value. Preserves privacy by performing the check via the router contract.\n/// This conceals an address of the calling contract by setting `context.msg_sender` to the router contract address.\npub fn privately_check_block_number(operation: u8, value: Field, context: &mut PrivateContext) {\n    // docs:start:enqueueing\n    Router::at(ROUTER_ADDRESS).check_block_number(operation, value).call(context);\n    // docs:end:enqueueing\n}\n// docs:end:helper_router_functions\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"340":{"path":"/usr/src/noir-projects/noir-contracts/contracts/router_contract/src/main.nr","source":"mod test;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n/// The purpose of this contract is to perform a check in public without revealing what contract enqued the public\n/// call. This is achieved by having a private function on this contract that enques the public call and hence\n/// the `msg_sender` in the public call is the address of this contract.\n#[aztec]\ncontract Router {\n    use aztec::{macros::functions::{private, public, view, internal}, utils::comparison::compare};\n\n    // docs:start:check_timestamp\n    /// Asserts that the current timestamp in the enqueued public call satisfies the `operation` with respect\n    /// to the `value.\n    #[private]\n    fn check_timestamp(operation: u8, value: u64) {\n        Router::at(context.this_address())._check_timestamp(operation, value).enqueue_view(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    #[view]\n    fn _check_timestamp(operation: u8, value: u64) {\n        let lhs_field = context.timestamp() as Field;\n        let rhs_field = value as Field;\n        assert(compare(lhs_field, operation, rhs_field), \"Timestamp mismatch.\");\n    }\n    // docs:end:check_timestamp\n\n    /// Asserts that the current block number in the enqueued public call satisfies the `operation` with respect\n    /// to the `value.\n    #[private]\n    fn check_block_number(operation: u8, value: Field) {\n        Router::at(context.this_address())._check_block_number(operation, value).enqueue_view(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    #[view]\n    fn _check_block_number(operation: u8, value: Field) {\n        assert(compare(context.block_number(), operation, value), \"Block number mismatch.\");\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"353":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/main.nr","source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateContext, PrivateCallInterface}, hash::compute_secret_hash,\n        oracle::random::random,\n        prelude::{\n            NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress,\n            FunctionSelector,\n        },\n        encrypted_logs::{\n            encrypted_note_emission::{\n                encode_and_encrypt_note, encode_and_encrypt_note_unconstrained,\n                encrypt_and_emit_partial_log,\n            }, encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n        }, keys::getters::get_public_keys,\n        macros::{\n            storage::storage, events::event,\n            functions::{initializer, private, view, public, internal},\n        }, utils::comparison::Comparator, protocol_types::{point::Point, traits::Serialize},\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::{\n        transparent_note::TransparentNote, token_note::TokenNote, balance_set::BalanceSet,\n    };\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[event]\n    #[derive(Serialize)]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<TokenNote, Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote, Context>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: SharedImmutable<FieldCompressedString, Context>,\n        name: SharedImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n    // docs:start:mint_public\n    #[public]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n    // docs:start:mint_private\n    #[public]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[private]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        let caller_keys = get_public_keys(caller);\n        storage.balances.at(caller).add(caller_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, caller_keys.ovpk_m, caller_keys.ivpk_m, caller),\n        );\n        Token::at(context.this_address())\n            .assert_minter_and_mint(context.msg_sender(), amount)\n            .enqueue(&mut context);\n    }\n    #[public]\n    #[internal]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n    // docs:start:shield\n    #[public]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n    // docs:start:transfer_public\n    #[public]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n    // docs:start:redeem_shield\n    #[private]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let secret_hash = compute_secret_hash(secret);\n        // Pop 1 note (set_limit(1)) which has an amount stored in a field with index 0 (select(0, amount)) and\n        // a secret_hash stored in a field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options\n            .select(TransparentNote::properties().amount, Comparator.EQ, amount)\n            .select(TransparentNote::properties().secret_hash, Comparator.EQ, secret_hash)\n            .set_limit(1);\n        let notes = storage.pending_shields.pop_notes(options);\n        assert(notes.len() == 1, \"note not popped\");\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n        storage.balances.at(to).add(to_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, to_keys.ivpk_m, to),\n        );\n    }\n    // docs:end:redeem_shield\n    // docs:start:unshield\n    #[private]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                from_keys.ivpk_m,\n                from,\n            ),\n        );\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_from`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(\n                &mut context,\n                from_keys.ovpk_m,\n                to_keys.ivpk_m,\n                to,\n            ),\n        );\n    }\n    // docs:end:transfer\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n    // docs:start:transfer_from\n    #[private]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n        let from_keys = get_public_keys(from);\n        let to_keys = get_public_keys(to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            from_keys.ivpk_m,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to_keys.npk_m, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from_keys.ovpk_m,\n            to_keys.ivpk_m,\n            to,\n        ));\n    }\n    // docs:end:transfer_from\n    // docs:start:burn\n    #[private]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let from_keys = get_public_keys(from);\n        storage.balances.at(from).sub(from_keys.npk_m, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from_keys.ovpk_m, from_keys.ivpk_m, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n    /// We need to use different randomness for the user and for the fee payer notes because if the randomness values\n    /// were the same we could fingerprint the user by doing the following:\n    ///      1) randomness_influence = fee_payer_point - G_npk * fee_payer_npk =\n    ///                              = (G_npk * fee_payer_npk + G_rnd * randomness + G_slot * fee_payer_slot)\n    ///                                - G_npk * fee_payer_npk - G_slot * fee_payer_slot =\n    ///                              = G_rnd * randomness\n    ///      2) user_fingerprint = user_point - randomness_influence =\n    ///                          = (G_npk * user_npk + G_rnd * randomness + G_slot * user_slot) - G_rnd * randomness =\n    ///                          = G_npk * user_npk + G_slot * user_slot\n    ///      3) Then the second time the user would use this fee paying contract we would recover the same fingerprint\n    ///         and link that the 2 transactions were made by the same user. Given that it's expected that only\n    ///         a limited set of fee paying contracts will be used and they will be known, searching for fingerprints\n    ///         by trying different fee payers is a feasible attack.\n    ///\n    /// Note 1: fee_payer_npk is part of the fee_payer address preimage derivation, and is assumed to be known. So\n    //          if we have a known set of fee payer contract addresses getting fee_payer_npk and fee_payer_slot is\n    //          trivial (slot is derived in a `Map<...>` as a hash of balances map slot and a fee payer address).\n    /// Note 2: fee_payer_point and user_point above are public information because they are passed as args to\n    ///         the public `complete_refund(...)` function.\n    // docs:start:setup_refund\n    #[private]\n    fn setup_refund(\n        fee_payer: AztecAddress, // Address of the entity which will receive the fee note.\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        funded_amount: Field, // The amount the user funded the fee payer with (represents fee limit).\n    ) {\n        // 1. This function is called by fee paying contract (fee_payer) when setting up a refund so we need to support\n        // the authwit flow here and check that the user really permitted fee_payer to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Get all the relevant keys\n        let fee_payer_keys = get_public_keys(fee_payer);\n        let user_keys = get_public_keys(user);\n\n        let fee_payer_npk_m_hash = fee_payer_keys.npk_m.hash();\n        let user_npk_m_hash = user_keys.npk_m.hash();\n\n        // 3. Deduct the funded amount from the user's balance - this is a maximum fee a user is willing to pay\n        // (called fee limit in aztec spec). The difference between fee limit and the actual tx fee will be refunded\n        // to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(funded_amount),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(user).add(user_keys.npk_m, change).emit(\n            encode_and_encrypt_note_unconstrained(\n                &mut context,\n                user_keys.ovpk_m,\n                user_keys.ivpk_m,\n                user,\n            ),\n        );\n\n        // 4. Now we get the partial payloads\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n        let fee_payer_randomness = unsafe { random() };\n        let user_randomness = unsafe { random() };\n\n        let fee_payer_setup_payload = TokenNote::setup_payload().new(\n            fee_payer_npk_m_hash,\n            fee_payer_randomness,\n            storage.balances.at(fee_payer).set.storage_slot,\n        );\n\n        let user_setup_payload = TokenNote::setup_payload().new(\n            user_npk_m_hash,\n            user_randomness,\n            storage.balances.at(user).set.storage_slot,\n        );\n\n        // 5. We encrypt and emit the partial note log\n        encrypt_and_emit_partial_log(\n            &mut context,\n            fee_payer_setup_payload.log_plaintext,\n            fee_payer_keys,\n            fee_payer,\n        );\n        encrypt_and_emit_partial_log(\n            &mut context,\n            user_setup_payload.log_plaintext,\n            user_keys,\n            user,\n        );\n\n        // 6. We convert the hiding points to standard `Point` type as we cannot pass `TokenNoteHidingPoint` type\n        // as an argument to a function due to macro limitations (the `TokenNoteHidingPoint` type is macro generated\n        // and hence is not resolved soon enough by the compiler).\n        let fee_payer_point = fee_payer_setup_payload.hiding_point;\n        let user_point = user_setup_payload.hiding_point;\n\n        // 7. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime {\n                FunctionSelector::from_signature(\n                    \"complete_refund((Field,Field,bool),(Field,Field,bool),Field)\",\n                )\n            },\n            [\n                fee_payer_point.x,\n                fee_payer_point.y,\n                fee_payer_point.is_infinite as Field,\n                user_point.x,\n                user_point.y,\n                user_point.is_infinite as Field,\n                funded_amount,\n            ],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#7728): even though the funded_amount should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn complete_refund(fee_payer_point: Point, user_point: Point, funded_amount: Field) {\n        // TODO(#7728): Remove the next line\n        let funded_amount = U128::from_integer(funded_amount);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(funded_amount >= tx_fee, \"funded amount not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and tx fee.\n        let refund_amount = funded_amount - tx_fee;\n\n        // 3. We construct the note finalization payloads with the correct amounts and hiding points to get the note\n        // hashes and unencrypted logs.\n        let fee_payer_finalization_payload =\n            TokenNote::finalization_payload().new(fee_payer_point, tx_fee);\n        let user_finalization_payload =\n            TokenNote::finalization_payload().new(user_point, refund_amount);\n\n        // 4. We emit the `tx_fee` and `refund_amount` as unencrypted event such that the `NoteProcessor` can use it\n        // to reconstruct the note.\n        context.emit_unencrypted_log(fee_payer_finalization_payload.log);\n        context.emit_unencrypted_log(user_finalization_payload.log);\n\n        // 5. At last we emit the note hashes.\n        context.push_note_hash(fee_payer_finalization_payload.note_hash);\n        context.push_note_hash(user_finalization_payload.note_hash);\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"},"355":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/token_note.nr","source":"use dep::aztec::{\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, note::utils::compute_note_hash_for_nullify, oracle::random::random,\n    keys::getters::get_nsk_app, macros::notes::partial_note,\n};\n\ntrait OwnedNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self;\n    fn get_amount(self) -> U128;\n}\n\n// docs:start:TokenNote\n#[partial_note(quote {amount})]\npub struct TokenNote {\n    // The amount of tokens in the note\n    amount: U128,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:TokenNote\n\nimpl NullifiableNote for TokenNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for TokenNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl OwnedNote for TokenNote {\n    fn new(amount: U128, owner_npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { amount, npk_m_hash: owner_npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n\n    fn get_amount(self) -> U128 {\n        self.amount\n    }\n}\n"},"357":{"path":"/usr/src/noir-projects/noir-contracts/contracts/token_contract/src/types/transparent_note.nr","source":"// docs:start:token_types_all\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator,\n    }, macros::notes::note,\n};\n\nuse dep::std::mem::zeroed;\n\n// Transparent note represents a note that is created in the clear (public execution), but can only be spent by those\n// that know the preimage of the \"secret_hash\" (the secret). This is typically used when shielding a token balance.\n// Owner of the tokens provides a \"secret_hash\" as an argument to the public \"shield\" function and then the tokens\n// can be redeemed in private by presenting the preimage of the \"secret_hash\" (the secret).\n#[note]\npub struct TransparentNote {\n    amount: Field,\n    secret_hash: Field,\n}\n\nimpl NullifiableNote for TransparentNote {\n    // Computing a nullifier in a transparent note is not guarded by making secret a part of the nullifier preimage (as\n    // is common in other cases) and instead is guarded by the functionality of \"redeem_shield\" function. There we do\n    // the following:\n    //      1) We pass the secret as an argument to the function and use it to compute a secret hash,\n    //      2) we fetch a note via the \"get_notes\" oracle which accepts the secret hash as an argument,\n    //      3) the \"get_notes\" oracle constrains that the secret hash in the returned note matches the one computed in\n    //         circuit.\n    // This achieves that the note can only be spent by the party that knows the secret.\n    fn compute_nullifier(\n        self,\n        _context: &mut PrivateContext,\n        _note_hash_for_nullify: Field,\n    ) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        // compute_nullifier ignores both of its parameters so we can reuse it here\n        self.compute_nullifier(zeroed(), zeroed())\n    }\n}\n\nimpl TransparentNote {\n    // CONSTRUCTORS\n    pub fn new(amount: Field, secret_hash: Field) -> Self {\n        TransparentNote { amount, secret_hash, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for TransparentNote {\n    fn eq(self, other: Self) -> bool {\n        (self.amount == other.amount) & (self.secret_hash == other.secret_hash)\n    }\n}\n\n// docs:end:token_types_all\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"70":{"path":"/usr/src/noir-projects/noir-contracts/contracts/app_subscription_contract/src/main.nr","source":"mod subscription_note;\nmod dapp_payload;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract AppSubscription {\n    use crate::{dapp_payload::DAppPayload, subscription_note::SubscriptionNote};\n\n    use aztec::{\n        prelude::{AztecAddress, Map, PrivateMutable, SharedImmutable},\n        keys::getters::get_public_keys, protocol_types::constants::MAX_FIELD_VALUE,\n        utils::comparison::Comparator,\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        macros::{storage::storage, functions::{public, initializer, private}},\n    };\n    use authwit::auth::assert_current_call_valid_authwit;\n    use token::Token;\n    use router::utils::privately_check_block_number;\n\n    #[storage]\n    struct Storage<Context> {\n        // The following is only needed in private but we use ShareImmutable here instead of PrivateImmutable because\n        // the value can be publicly known and SharedImmutable provides us with a better devex here because we don't\n        // have to bother with sharing the note between pixies of users.\n        target_address: SharedImmutable<AztecAddress, Context>,\n        subscription_token_address: SharedImmutable<AztecAddress, Context>,\n        subscription_recipient_address: SharedImmutable<AztecAddress, Context>,\n        subscription_price: SharedImmutable<Field, Context>,\n        subscriptions: Map<AztecAddress, PrivateMutable<SubscriptionNote, Context>, Context>,\n        fee_juice_limit_per_tx: SharedImmutable<Field, Context>,\n    }\n\n    global SUBSCRIPTION_DURATION_IN_BLOCKS = 5;\n    global SUBSCRIPTION_TXS = 5;\n\n    #[private]\n    fn entrypoint(payload: DAppPayload, user_address: AztecAddress) {\n        // Default msg_sender for entrypoints is now Fr.max_value rather than 0 addr (see #7190 & #7404)\n        assert(context.msg_sender().to_field() == MAX_FIELD_VALUE);\n        assert_current_call_valid_authwit(&mut context, user_address);\n\n        let mut note = storage.subscriptions.at(user_address).get_note().note;\n        assert(note.remaining_txs as u64 > 0, \"you're out of txs\");\n\n        note.remaining_txs -= 1;\n\n        // We are emitting both the outgoing and the incoming logs to the subscriber here because passing a separate\n        // outgoing_viewer arg to entrypoint function is impractical and the outgoing are not so valuable here.\n        let keys = get_public_keys(user_address);\n        storage.subscriptions.at(user_address).replace(&mut note).emit(encode_and_encrypt_note(\n            &mut context,\n            keys.ovpk_m,\n            keys.ivpk_m,\n            user_address,\n        ));\n\n        context.set_as_fee_payer();\n\n        // TODO(palla/gas) Assert fee_juice_limit_per_tx is less than this tx gas_limit\n        let _gas_limit = storage.fee_juice_limit_per_tx.read_private();\n\n        context.end_setup();\n\n        // We check that the note is not expired. We do that via the router contract to conceal which contract\n        // is performing the check.\n        privately_check_block_number(Comparator.LT, note.expiry_block_number, &mut context);\n\n        payload.execute_calls(&mut context, storage.target_address.read_private());\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(\n        target_address: AztecAddress,\n        subscription_recipient_address: AztecAddress,\n        subscription_token_address: AztecAddress,\n        subscription_price: Field,\n        fee_juice_limit_per_tx: Field,\n    ) {\n        storage.target_address.initialize(target_address);\n        storage.subscription_token_address.initialize(subscription_token_address);\n        storage.subscription_recipient_address.initialize(subscription_recipient_address);\n        storage.subscription_price.initialize(subscription_price);\n        storage.fee_juice_limit_per_tx.initialize(fee_juice_limit_per_tx);\n    }\n\n    #[private]\n    fn subscribe(\n        subscriber: AztecAddress,\n        nonce: Field,\n        expiry_block_number: Field,\n        tx_count: Field,\n    ) {\n        assert(tx_count as u64 <= SUBSCRIPTION_TXS as u64);\n\n        Token::at(storage.subscription_token_address.read_private())\n            .transfer_from(\n                context.msg_sender(),\n                storage.subscription_recipient_address.read_private(),\n                storage.subscription_price.read_private(),\n                nonce,\n            )\n            .call(&mut context);\n\n        // Assert that the `current_block_number > expiry_block_number - SUBSCRIPTION_DURATION_IN_BLOCKS`.\n        // --> We do that via the router contract to conceal which contract is performing the check.\n        privately_check_block_number(\n            Comparator.GT,\n            expiry_block_number - SUBSCRIPTION_DURATION_IN_BLOCKS,\n            &mut context,\n        );\n\n        let subscriber_keys = get_public_keys(subscriber);\n        let msg_sender_ovpk_m = get_public_keys(context.msg_sender()).ovpk_m;\n\n        let mut subscription_note =\n            SubscriptionNote::new(subscriber_keys.npk_m.hash(), expiry_block_number, tx_count);\n        storage.subscriptions.at(subscriber).initialize_or_replace(&mut subscription_note).emit(\n            encode_and_encrypt_note(\n                &mut context,\n                msg_sender_ovpk_m,\n                subscriber_keys.ivpk_m,\n                subscriber,\n            ),\n        );\n    }\n\n    unconstrained fn is_initialized(subscriber: AztecAddress) -> pub bool {\n        storage.subscriptions.at(subscriber).is_initialized()\n    }\n}\n"},"71":{"path":"/usr/src/noir-projects/noir-contracts/contracts/app_subscription_contract/src/subscription_note.nr","source":"use dep::aztec::{\n    hash::poseidon2_hash_with_separator, note::utils::compute_note_hash_for_nullify,\n    keys::getters::get_nsk_app, oracle::random::random,\n    prelude::{PrivateContext, NoteHeader, NullifiableNote},\n    protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER, macros::notes::note,\n};\n\n#[note]\npub struct SubscriptionNote {\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    expiry_block_number: Field,\n    remaining_txs: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NullifiableNote for SubscriptionNote {\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl SubscriptionNote {\n    pub fn new(npk_m_hash: Field, expiry_block_number: Field, remaining_txs: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self {\n            npk_m_hash,\n            expiry_block_number,\n            remaining_txs,\n            randomness,\n            header: NoteHeader::empty(),\n        }\n    }\n}\n"},"72":{"path":"/usr/src/noir-projects/noir-contracts/contracts/app_subscription_contract/src/dapp_payload.nr","source":"use dep::aztec::prelude::{PrivateContext, AztecAddress};\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\n\nuse dep::authwit::entrypoint::function_call::FunctionCall;\n\nglobal DAPP_MAX_CALLS: u32 = 1;\n// FUNCTION_CALL_SIZE * DAPP_MAX_CALLS + 1\nglobal DAPP_PAYLOAD_SIZE: u32 = 6;\n// FUNCTION_CALL_SIZE_IN_BYTES * DAPP_MAX_CALLS + 32\nglobal DAPP_PAYLOAD_SIZE_IN_BYTES: u32 = 130;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct DAppPayload {\n    function_calls: [FunctionCall; DAPP_MAX_CALLS],\n    nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<DAPP_PAYLOAD_SIZE> for DAppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; DAPP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, DAPP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for DAppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl DAppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; DAPP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, DAPP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..DAPP_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext, target_address: AztecAddress) {\n        for i in 0..DAPP_MAX_CALLS {\n            let call = self.function_calls[i];\n            // whitelist the calls that the user can do only go to the expected Dapp contract\n            assert(call.target_address == target_address);\n            if call.is_public {\n                context.call_public_function_with_packed_args(\n                    call.target_address,\n                    call.function_selector,\n                    call.args_hash,\n                    call.is_static,\n                );\n            } else {\n                let _result = context.call_private_function_with_packed_args(\n                    call.target_address,\n                    call.function_selector,\n                    call.args_hash,\n                    call.is_static,\n                );\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"73":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, CANONICAL_AUTH_REGISTRY_ADDRESS,\n    }, hash::poseidon2_hash_with_separator,\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let result: Field = context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n            [on_behalf_of.to_field(), inner_hash].as_slice(),\n            GasOpts::default(),\n        )\n        .deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n            [message_hash, authorize as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n            [context.this_address().to_field(), reject as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"93":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"96":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"97":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice,\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage {\n            slot: fields[1],\n            value: fields[2],\n            next_index: fields[3] as u32,\n            next_slot: fields[4],\n        },\n        path: arr_copy_slice(\n            fields,\n            [0; PUBLIC_DATA_TREE_HEIGHT],\n            1 + LEAF_PREIMAGE_LENGTH,\n        ),\n    }\n}\n"},"98":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
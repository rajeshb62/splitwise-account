{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"AvmTest","functions":[{"name":"create_different_nullifier_in_nested_call","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"nestedAddress","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAo4AIBFAAAiAFYxAgACJAIAAQQAOAIEBSoIAQIAAAECASQCBAEEKg4EAioIAQYAAAECASQCBAEIJAIEAgoAOAgKCSoIAQcAEAEJASQDBAEHACgHAgkqDggJJAIEAgkAOAcJCCoMCAkmAgDZfQyKAAoqDgoJKg4HBiQCBAAHKgwHAyAAJQo4AwcIIQIAQwAIIAAoKg0CAyoNBgIqCAEEJAIEAwUAEAEFASQDBAEEACgEAgUqDAUGKQIAMGROcuExoCm4UEW2gYFYXSgz6Eh5uXCRQ+H1k/AAAAAAByoOBwYAKAYCBioOBwYmAgDVRBsNAAUAKAQCBgAoAgIKKg0KCQAoCgIIKggBCgAAAQIBJAMEAQoAKAoCDDY/lQAGAAEACAAJAAwAAAALAAUkAgIBAQo4CwECIQIAQgACOQEAACMKOAMHCCECAEYACDkBAAAqDQIIKg0GCQAoCAIKKwQACYADJQAEAAGABCIAWysIgAUACysIgAYADCoOBQwqDQsIACgIAggqDggLKg4KAioOCwYqDAQDIAAlJQAEeACABA0AAACABIADIQAAWoADOQEAACMBAIADAAKABysBgAeABwEAgAeABIAIJQAEAAKACgEAgAiACoAJKwAAAYAFAQAAAYAJAAElAQQAAYAFAQCABQACgAkrAoAIgAklAAQAAoAKAQCAA4AKgAklAAQAAoALAQCABYALgAolAAQAAIAMDQCADIAHgA0XAIANgA0hAABzgA0BAIAJgAyADisBgA6ACwEAgAqADIAOKwKAC4AOAQCADAACgAwgAGoBAIAKgAeABiMrABjKGMo=","debug_symbols":"1ZvtasIwFIbvJb/7I1/nJPFWxpCqVQqlitbBEO99bdd2Ol0D+2NeBDH6Rp4TjA+ctBexKVbn3bKst/uTWLxdRLVf5025r9vR5ZqJ1bGsqnK3vH1byO5JqT5/OuR1Nzw1+bERC0WSbCaKetO/dtx+x7asCrEw7K/ZQ954p4e48cFNaeXpSdp5K4e0ayfepd8zofRzJGX8hNQ+7pC6aeZ/0+wfCxDczTQXWQAmS0OcyZmfkoJ6ktZsxuXS7GR0ucIQ9tJPWa1tj0/Y+IyN77DxPTZ+gMbXEhtfYeNrbHyDjY9tXY1tXY1tXY1tXY1tXY1tXYNtXYNtXYNtXYNtXZP8H6diNfIrbqHHNPedAZv83lVseeJn+Zs/+c0b4X/F7nVybBZpb2KtJW+1Gn//1qm7dFeAQS/AohdA6AUwegEOvQCPXkAAL4AkegEKvQB0ExO6iQndxIRuYkI3MaGbmNBNTOgmZnQTM7qJ+RUmDjSmdWD3gGTSQ7LpIVF6SOD9OU7+ZCPCn/zRxjy/A+iPzvID9Edn+ZM/3Zjv77rkjzci/BacP/nLCiL8yV9XEOEH8O8sP4B/Z/kB/DvH78HPJz34+aQH96+H9u+1HX3kxzJfVcVw38H2XK9vbkNoPg/fn7ThLw==","brillig_names":["create_different_nullifier_in_nested_call"],"assert_messages":{"65":"Nested call failed!","69":"Index out of bounds","89":"Stack too deep"}},{"name":"elliptic_curve_add","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"lhs","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"private"},{"name":"rhs","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"public"}},"bytecode":"JAAEAQIlAASATAABJAAEAwAkAgQGByQCBAAIHxgACAAHgEMdAAGARYBFHQABgEiASCsIgEMAASsIgEQAAisIgEUAAysIgEYABCsIgEcABSsIgEgABiIAEysEAAGASSsEAAKASisEAAOASzgAgEkAAyIAZgo4AQQKCjgCBQsEOAoLDBYMCw0EOAoNCxwMAAoNADgBDQ4qCAENJAIEBA8AEAEPASQDBAENACgNAg8/P8AADgACAAoABAAFAAYADyQCBAAOACgNAhAAOBAOESoNEQ8kAgQBEAAoDQISADgSEBMqDRMRKggBDQAAAQIBKggBEgAAAQIBKggBEwAAAQIBKg4PDSoOERIqDgoTKggBFCQCBAQVABABFQEkAwQBFAAoFAIVPz/AAAEAAgADAAEAAgADABUAKBQCFgA4Fg4XKg0XFQAoFAIWADgWEBcqDRcOIQIARAAMIABAKgwPByoMEQgqDAoJIABJJAIBAAoqDBUHKgwOCCoMCgkgAEkqDgcNKg4IEioOCRMhAgBOAAMgAFIqDgQNKg4FEioOBhMgAFIhAgBUAAYgAFgqDgENKg4CEioOAxMgAFgWDAMBFgwGAgQ4AQIEBDgLBAEqDQ0CKg0SBAQ4AwYFEjgBBQMqDgINKg4EEioOAxMqDAIBKgwEAiMlAAR4AIAEDQAAAIAEgAMhAABqgAM5AQAAIysAGMoYyg==","debug_symbols":"1dpda8IwFAbg/5JrL/J5kvhXxpD6SaFU0ToY4n9fz2arS0dvBuHNjRg9yINNzpvS3MR2t74eVnW7P17E8u0mmuOm6upj249u94VYn+umqQ+r14+F5Bctv+svp6rl4aWrzp1YKopyIXbttn/rpex/YV83O7E0FO6LabW0Y7X0aqzW9o9ip6J9FDut7Gvx+0JolZujLY0copSjs3PiyDHGpxyDxbG5OcYPxc4qnXJcbo71YeA4OZk7lJ1D9ORMLpbPzSGvBo7/vdCnxZ7MYPcUTGoPBdtjuXYjC7argu26YLvBtkc/2L1Sqd0WbHcF26lgO3aueu1Gu4mpHTtX5+3YuTprt9i5Om8HylXmAEUlc4DSjzlAgcYcoIxiDlDsMAcoSZgDFA7MAer3Pcdlb+FBjZzg9H+26E4VbNcF203Bdluw3RVsJ2z73K2R8wXbQ8H2CG2fvb0g7Fydt2Pn6qzdA2UTc4DihjlACcIcoObEHKB+03MCUAthDtZUDlhTOQDtb5iDtbIC1sqKuVcWKT3sjUlR+kg7quwcaZ+ckHI0FsdgcXK3QdJq2COTdunpjOiy/zvRPTmTqUxYHI/FCUCcez/6qM51tW52j+N1+2u7eTlt132efr7pi78A","brillig_names":["elliptic_curve_add"],"assert_messages":{"105":"Stack too deep"}},{"name":"get_sender","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgEAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc9LCsMgEAbgu8w6C4OPpLlKKUETDYJoUFMo4t2rbVpSmo34z3wMMwlmKbZl1Fa5AMM1gXETj9rZklJuQHhtjF7GYxlQfVr08mHltsYQuY8wXDqKG5B2rt+uLROUNhIGzPrc/GmCcL9rggj76ranJ5pR8tGMMvyjb7nEO/eaCyP33dVmp8Mp8bG+OwU/AQ==","brillig_names":["get_sender"],"assert_messages":{"15":"Stack too deep"}},{"name":"get_transaction_fee","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgMAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc9RCsMgDAbgu+S5D8qctb3KGEVbLYJoUTsY4t2nm7CO9UX8k4+QJFik2NdJW+UCjLcExs08amdLSrkD4bUxep2OZUD1wejtw8ZtjSFyH2EcBkI6kHapX9qXCUobCeOFstz9aUIRappQ/NWYXU807VnfNGUY/+h7LvHBvebCyLa72u18OCU+t0+n4Bc=","brillig_names":["get_transaction_fee"],"assert_messages":{"15":"Stack too deep"}},{"name":"test_get_contract_instance_raw","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiAJYeAgAAASoIAQIkAgQSAwAQAQMBJAMEAQIAKAICAzMOAAAAAQAAAAMkAgQAAQAoAgIEADgEAQUqDQUDJAIAAQEKOAMBBCECABgABDkBAAAkAgQBAQAoAgIEADgEAQUqDQUDJQIAASMAAQo4AwEEIQIAIAAEOQEAACQCBAIBACgCAgQAOAQBBSoNBQMlAgAEVgABCjgDAQQhAgAoAAQ5AQAAJAIEAwEAKAICBAA4BAEFKg0FAyUCAAeJAAEKOAMBBCECADAABDkBAAAkAgQEAQAoAgIEADgEAQUqDQUDJgIAABAREgABCjgDAQQhAgA4AAQ5AQAAJAIEBQEAKAICBAA4BAEFKg0FAyYCAAATFBUAAQo4AwEEIQIAQAAEOQEAACQCBAYBACgCAgQAOAQBBSoNBQMmAgAAFhcYAAEKOAMBBCECAEgABDkBAAAkAgQHAQAoAgIEADgEAQUqDQUDJAIAAAEKOAMBBCECAFAABDkBAAAkAgQIAwAoAgIFADgFAwYqDQYEJgIAABkgIQADCjgEAwUhAgBYAAU5AQAAJAIECQMAKAICBQA4BQMGKg0GBCYCAAAiIyQAAwo4BAMFIQIAYAAFOQEAACQCBAoDACgCAgUAOAUDBioNBgQKOAQBAyECAGcAAzkBAAAkAgQLAwAoAgIFADgFAwYqDQYEJgIAACUmJwADCjgEAwUhAgBvAAU5AQAAJAIEDAMAKAICBQA4BQMGKg0GBCYCAAAoKTAAAwo4BAMFIQIAdwAFOQEAACQCBA0DACgCAgUAOAUDBioNBgQKOAQBAyECAH4AAzkBAAAkAgQOAwAoAgIFADgFAwYqDQYEJgIAADEyMwADCjgEAwUhAgCGAAU5AQAAJAIEDwMAKAICBQA4BQMGKg0GBCYCAAA0NTYAAwo4BAMFIQIAjgAFOQEAACQCBBADACgCAgUAOAUDBioNBgQKOAQBAiECAJUAAjkBAAAjJQAEeACABA0AAACABIADIQAAmoADOQEAACMrABjKGMo=","debug_symbols":"tdnbamJRDAbgd9nXXqxTTn2VYSi2tUUQW1o7MIjvPtrRZSWRRX/wpnRrvrCJce0Qt9PT4uHz5X65fn79mO5+bafV6+N8s3xd76+2u9n08L5crZYv999fntLhj32Ff7zN14erj838fTPdaWWbTYv10+FftX2C5+VqMd1V1t3MRVdjOkZXk9ajs1IQzU3zMZqbyUX079mUU3xDtfUbsjK4ISU5BZv2WLOv/PnG+cuN89cb5283zk83zs9hfjI+EU50kf+ABEGKIANQSUOUi0MZQQVBFUFxn3FNHVVziBDECBIE6RA1dcgAVBOCMoLijmA+f7jiGrZWBDUEEYJ4iLQ5JAhSBBmAWtwRksoJSc4OZQQVBFUEtSEqySFCECNIEBR3hFTtqIlDBiBKCMoIKkNE7rCkiqCGIELQlY6QPnqIskOCIEWQAYjTEJl7AHBGUEFQRVDcEZr7YanFPQCYEMQIEgTpEFX3JWQDkCQEZQTFHaFEHbF7qElFUEMQIYiHSNzgK4IgRZABSK90hPUhUc0dlpoRVBBUEdRGyPzwoYQgRpAgKO4IK31xY9UdlmoAsoSgjKAyROQGKqsIaggiBMUdYdyHDxNfCEGQIsgAlFMaKj995JQhVSAVdoWldFozWcrNqwYpghRDSoaqBNVQSBmi4gXuUOVYtbMiX4142TpUFVINUjRUHFSDISWQUkhd6Q09K/PVKAlSGVIFUnWk9geSVw1SBKm4N/a17aomrwRSCilDVLzSvFDNVyPeaQ5VgVSFVNwbmc9KgmoQpBhSAikdKg2qYYhqCVIZUnFvlNRVyb4a8X5zqBqkCFI8Vn7Si3ecQ6U/Vrv95Z/5+3L+sFocf7R+/lw/fvsNe/P37f87++B/","brillig_names":["test_get_contract_instance_raw"],"assert_messages":{"153":"Stack too deep"}},{"name":"get_chain_id","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgQAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc/hCoMgEAfwd7nPfbBpJr7KGKGlIYiG2mBI7z5rMhrri9zf+3HcZZiUXOfBOO0j8HsG60eRjHcl5a0BGYy1Zh7O34D2p0WHj4twe4xJhAS8RQjfGlBuOmrCygxtrAKOaan/PKE9rpxQhr+6Zd2Fpqzrq6asJz/6sZX4FMEIaVXdXq9uPB2TXsunU/Ab","brillig_names":["get_chain_id"],"assert_messages":{"15":"Stack too deep"}},{"name":"get_version","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgUAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc9LCsMgEAbgu8w6i5iHJl6llKCJBkE0qCkU8e41qZSUdiP+Mx/DTIRF8H2dlJHWA71F0HZmQVmTU0wVcKe0Vut0LUN9PKg+vd+YOaIPzAWgqEaoqUCY5fw3JM+QSgugLR5S9eM70pLCO9Lhj0ZD/0fjEY1F47Htv/Q95fhgTjGuRdle7ma+HBOe27uT8Qs=","brillig_names":["get_version"],"assert_messages":{"15":"Stack too deep"}},{"name":"get_fee_per_da_gas","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgkAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc/RCoMgFAbgdznXXehaZr7KGKGlIYiG2mCI7z5rMhrbjfjrdw7nJJil2JZRW+UCsFsC4yYetbMlpdyA8NoYvYznZ0D7gdHhw8rtHkPkPgLD6EpwA9LOx522pYfSRgJrCc3Nj+9QiyrvSulHY9r90T0eSNX9BQ9f+p5LfHCvuTCyTq82O52Wic/1/VPwCw==","brillig_names":["get_fee_per_da_gas"],"assert_messages":{"15":"Stack too deep"}},{"name":"return_oracle","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAA8AKAECAiUCBIBDAAMkAgQDBCsEAAKAAysEAAOABCsEAASABSIAMDgAgEMAAyIAOyoIAQEkAgQEAgAQAQIBJAMEAQEAKAECAioMAgMkAgABBCoOBAMAKAMCAyQCAAIFKg4FAwAoAwIDJAIAAwYqDgYDACgBAgI4AwACAAMkAgAGASoIAQIkAgQEAwAQAQMBJAMEAQIAKAICAyoMAwQkAgAEBSoOBQQAKAQCBCQCAAUGKg4GBAAoBAIEKg4BBCoMAgEjJQAEAACABw0AgAeABYAIFwCACIAIIQAAOoAIAQCAA4AHgAkrAYAJgAYBAIAEgAeACSsCgAaACQEAgAcAAoAHIAAxIyUABHgAgAQNAAAAgASAAyEAAD+AAzkBAAAjKwAYyhjK","debug_symbols":"tZXNCoQgFIXf5a5bpE6lvcowhJWFIBZlA0P47mPzRzDrsxGPHu63+rg79abdxsb6YVqpvu7kpk4HO/mU9phRu1jn7Nicnyk/Dla++uus/RHXoJdAdZULlZHx/XFVVZowWGeoFqWM2V9bKv5tS1Vcfm0mi3jLiFV4hMQjFBzBczyC4REcjxB4xAWPKPAIvN0cbzfH283xdgu83QJtd0zxrherW2c+q2XYfHfaNOExv39S+Qk=","brillig_names":["return_oracle"],"assert_messages":{"62":"Stack too deep"}},{"name":"get_args_hash","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_a","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"_fields","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3dbtpKFIXfhetczM+emT15laOjirRphYRIldAjHUV599oUMI093mIJyWa2b6rS+HNZix37y8SY99W356dfP75sdt9f3laP/7yvti9f1/vNy6559P7xsHp63Wy3mx9fLv95Zdo/fDhs//ZzvWsfvu3Xr/vVo7U2hIfV8+7b4e8pNvv4vtk+rx595I+H3vZEIR03J2J/3tpyGNjaxmxOO0/GCPtmtnTcmjmEv/b978PKx3sPkO49AN97gHznAcjcewB77wHcvQfwcw/gXXbHrb0Pudt3tEP7NpRPT8Wa4FO3dzf0XKKPx63j5bZ06IaWbordzN4fJuxm9moyYTezt54Ju5m9UE3Yzexdbbpuwuw1cMJuZm+YE3Yze3mdsJvFi8vd0NJNsZvFi8vdLF5c7mbx4nI32r04nZ5KTPZzN9q9eKSbqN2Lx7rR7sVj3Wj34rFutHvxWDekqZs2sCrZbQOrMtg2sCotbQOrcs02sCqBbAInVVbYBlalem1gVf7WBlYlZW1g0hZYm2klbaaVtJlW0mZaSZtpsTbTYm2mxdpMi7WZFpO2wNpMi7WZFmszLdZmWqzNtLI208raTCtrM62szbQyaQuszbSyNtPK2kwrV2dagXwXOMRe4OpMSwhsTXWqJSauzrXExNXJlpi4OtsSE5O6xNX5lpi4OuESE1dnXGJibcrVxKku8YVVR5P7ias7VsdwkfjyQuLBi47Htz80VN2x/cqGUjp/06T8+cJsa6s7Edy2nurOGretp7pTzJX1MJ/enGezCb16qlsDuGk9rroFg9vWU53N3Lae6pYibltPdesWt62HlnrG6tFuzUI92q1ZqEe7NQv1LNY8Ws9izWP1+MWaR+tZrHm0nsWaR+tZrHm0HlrqGatHuTU74057d8b361FuzVI9yq1Zqke5NUv1KLdmoZ75fyDEtPUot2apHuXWLNWj3JqleurzHk9dPeT/queQuD6VkRLXZydS4vqEQ0hc36cJiInr0wIpcX1neilxfSdvZ7rEfiAxqUtc38KUlLg+55IS1+dcUuL6nEtKXJ9zCYnru1O9mLg+55IS1+dcUmJ1zlXfHeDFxOqcq757wEuJCzefZeITxrFbPHTmz3pg4Q6urnt3m4u9t1oU7oIqQIxAGYAKd7QUoOFTnUvneXGZe5BDoOHKgz2/vsH2n15CIEagDECFW1sJ0HDlzXCfoBhND3II5BGIECggUESghECMQPl6yBXuwCFAFoEcAnkEIgQKCBQRKCEQIxAyEbYwEey6k6brQRaBHAJ5BCIECggUESgh0PCLS+ffK1qiz8dyV3j/nABZBHII5BGIECggUESghECMQMhEeGQiPDIRheuIO3dvfgfcOxoVrq4VIEKggEARgRICMQJlACpc9yRAFoGQiSBkIgiZCEImgpCJIODHBkeMQMCPDS4YBBr8n5jykeHgPyOFVT0TXPcjdehBHoEIgQICFVY4XD4vcCTuQQmBGIEyAJU+9WscsgjkEMgjECFQQCBkIhIyEQmZiIRMBCMTwchEDH9oxOhhpfCxC8Z2Vzn4PpQQiBEoA1BhJUeALAIhB+WMHJQzclDOyEG5sJIjQAmBGIHy9ZAvrOSYeP5uMux6kEUgh0AegQiBAgJFBJInYgBi5MVFJqKwkiNAFoEcAnkEIgQKCBQRKCEQMhEWmQiHTIRDJsIhE+GQF9chL65DXlx39Yv70Tz6b/26WT9tn98apv3ir93X/eZld3y4///nn680G/8G","brillig_names":["get_args_hash"],"assert_messages":{"295":"Array index out of bounds","311":"Array index out of bounds","327":"attempt to add with overflow","149":"Array index out of bounds","194":"Array index out of bounds","213":"attempt to add with overflow","172":"Stack too deep","303":"Array index out of bounds","166":"attempt to add with overflow"}},{"name":"emit_unencrypted_log","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"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","debug_symbols":"zZ3dTuNIEIXfJddcVFd1d1XzKqvVCGaYUSQURsCstEK8+4YfO5lpEi62fXxuECGdfF+Cz0nbju2nzbeb618/vmx33+8eNpd/PW1u775ePW7vdvtbT88Xm+v77e3t9seX4z9v5OVHex3+8PNq93Lr4fHq/nFzmZJmudjc7L69/l5j/xTft7c3m0t7+b0bHzKNDi3z2BTlg7Hmmt4Hm1ubR6u0578vNknYhBKbkLIJGZtQZhMqbEKVTcjZhIJNiK2pla2pla2pla2pla2pla2pla2pla2pdYWmDp2E9o/rhIJNqJEJmbAJJTYhZRMyNqHMJlTYhCqbEFtTG1tTG1tTF7xQ6EFI7U+hii/Gluok1KwXMjahzCZU2IRGF6Pl34ReEL48IpZHtMURLssj0vIIXR5hyyPy8oiyPGL5dPvy6fbl0+3LpzuWT3csn+4Ykm73NiP8kw8wb+bvg725dULGJpTZhAqb0IlWMqmzkB0tegMmQZbmzWaW9GgSlF+FnE0o2IQamVATNqHEJqRsQsYmlNmECpsQW1M3tqZubE3d2Jo6CVtVJ2Hr6iRsZZ2Era2TsNV1Era+TmWFrFnMRrn1RissRzXPRm690ejlqF9LTqUAGBXAcAAjAIy2PKMKgJEADAUwDMAA5LwCcl4BOa+AnFdAzisg5z4k5wO3pyVPdEZKZ2R0Rif6Kethu2xu/olR0cm/6NHY8v7N7QJgVADDAYwAMNryjFM7moYyEoChAIYBGICcByDnAch5AHIegJzHkJxXmVZk69G6/sRoAmCkxRmWhvw/qpWJYbVj6JDXEXX6QA//gHGir4r4zChW/s/c004dJDKUkQGMAmBUAMMBjAAw2vKMU0c6DGUkAAOQcwPk3AA5N0DODZBzA+TchuR84BqqWWMzykJnlOiMhqzT1HmuUz13c52cAYwCYFQAwwGMWJ5RhsyhXaZ5uov3jCHLVci0SzJUekYBMIYsVzG3QvvjverH7jdfTc/sR3tho775OJlPkPk0tI/KdGiXinU+Vch8EplPhvvMB96rau8Dz5fNY6194DMmX2e3d9S2PMMFwABsG3IFMAzAyABGATAqgOEABiDnDsh5AHIegJwHIOcByHnA56/a5sOUJXWfZ+FkPkHm07h8mqzpU3qfROajZD5G5pPJfAp8fn/4WnWR3qeS+TiZT5D5NCqfLELmk8h8dE2f1vsYmU/G+0zz1f2Gh94H389azvlUMh8n88H387ntZVkal08SMp9E5qNkPkbmM6R/zu6ry2lIp7hOr8Nztx8tqwAYCcAYsry628SI2jMMwMgARgEwKoDhAEYAGEM+G73ODO/zYQJgJABDAQwDMDKAUQCMCmA4gBEABiDnGZDzDMh5HjP/PPcdojzme3yfMDKAUQCMCmAEgNGWZxQBMBKAcWLZXe1cJ7mscD4Yn3dbWOTeqNIZOZ1R0Bk1NqMqdEaJzkhXNWrWG7GdeynXTGdU6IwqnZHTGQWdUWMzcqEzSnRGSmdE19lO19lO19lO19lO19lO19mBv9RdlPn8nVHiyOhtnTaUzsjojDKdUaEzqnRGTmcUqxrVD4wam1ETOqNEZ6R0RkZnlOmMCp1RpTNyOiO2zi6yQh8dDlWIo30osxE+a+evMVmE7aqXRSqdkbMZJWFbshM+a03t8B5pb6R0RkZnlOmMCp3RCn1kh/T/ti/73cjpjILOqLEZqdAZJTojpTNiu256Ubo5pNLNIZVuDql0c0gNOqPGZmRCZ5TojJTOiK6zja6zja6zja6zja6zjauzn/c3/7m6315d39487B/0cu+v3dfH7d3u/ebjvz/f7tkP/g8=","brillig_names":["emit_unencrypted_log"],"assert_messages":{"544":"Stack too deep","413":"attempt to add with overflow","445":"attempt to add with overflow","477":"attempt to add with overflow","538":"attempt to add with overflow","398":"Array index out of bounds","526":"Array index out of bounds","389":"attempt to subtract with overflow","514":"attempt to add with overflow","371":"Array index out of bounds","432":"Array index out of bounds","458":"Array index out of bounds","519":"Array index out of bounds","484":"Array index out of bounds","382":"attempt to add with overflow","507":"attempt to add with overflow","466":"Array index out of bounds","425":"Array index out of bounds","393":"attempt to subtract with overflow","451":"attempt to add with overflow"}},{"name":"get_block_number","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgYAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc9RCsMgDAbgu+S5D7q1znqVMYq2WgTRonYwxLtPt250rC/in3yEJMEkxToP2ioXgF0TGDfyqJ0tKeUGhNfG6HnYlwHVB6OXDwu3NYbIfQSGEe5JA9JO9X/CpMxQ2khgZ0Jz8+dbirqNtxT3X41pd6BJTz/6ghD50bdc4p17zYWR2/ZqtePumPhY3p2Cnw==","brillig_names":["get_block_number"],"assert_messages":{"15":"Stack too deep"}},{"name":"read_storage_list","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAA8AKAECAiUCBIBDAAMkAgQCBCsEAAKAAysEAAOABCsEAASABSIAUDgAgEMAAiIAWyoIAQIkAgQDAwAQAQMBJAMEAQIAKAICAyoMAwQkAgAABSoOBQQAKAQCBCoOBQQqDQIDACgDAgMqDgMCKggBAwAAAQIBKg4CAyQCBAICJAIAAgQkAgQBBSQCBAAGKgwGASAAJgw4AQIHIQIAOgAHIAApKg0DAQAoAQIDADgDBgQqDQQCACgBAgQAOAQFBioNBgMqCAEBJAIEAwQAEAEEASQDBAEBACgBAgQqDAQFKg4CBQAoBQIFKg4DBSMqDQMHHAwAAQgAOAQICSwMAAkACCQCBAIKDDgBCgshAgBCAAs5AQAAKwQAB4ADJQAEAAOABCIAYCsIgAUACQAoCQIKADgKAQsqDggLADgBBQcOOAEHCCECAE0ACDkBAAAqDgkDKgwHASAAJiUABAAAgAcNAIAHgAWACBcAgAiACCEAAFqACAEAgAOAB4AJKwGACYAGAQCABIAHgAkrAoAGgAkBAIAHAAKAByAAUSMlAAR4AIAEDQAAAIAEgAMhAABfgAM5AQAAIysBgAOABgsAgAYAAoAHIQAAZIAHIABmKwCAA4AFIAB0KwAAAYAFAQAAAYAEAAElAAQAAIAJDQCACYAEgAoXAIAKgAohAABygAoBAIADgAmACysBgAuACAEAgAWACYALKwKACIALAQCACQACgAkgAGklAQQAAYAFIAB0IysAGMoYyg==","debug_symbols":"1drNjoIwFAXgd+naRdvb9hZfZTIxqGhICBrFSSbGd58yA/iDgeXcszGtnpBPRE9tuKptsb7sV2W9O5zV8uOqqsMmb8pDnWbX20KtT2VVlfvV49NKtw8m/ObPx7xup+cmPzVqaV1mFqqot2nodUxH2JVVoZYU0niUNjq6Lm2Mzoa0IfMm7YOzXdqHQPd09O/SFLlPU4xP6c+FMozNj9j8DJpvNTbfYPMtNp+w+Q6b77H52K1rsVvXYreuxW5dwm5dwm5dkn7tO9MfOw39K99JP/uO9MCnMOL/w5rHDpdD4DjDp+HkkzVPjhZPyHiHjPfC8Tb0eKIRPiDjGRjvsX/rvfR1jgvDJ+WYX/lB+jrHeTvFl9+02Z0/9z3JtO0lmfbjNyt9L2J6WRGk70XM8B02X/pexAxf+l7EDF/6XsQMX3xHT/PFd/Qkn8V39DQf+98wY7cuY7cuY7cuY7cuY7cuI7fuLU2/8lOZr6uiu0Fid6k3D/dLNN/Hv1dS+Ac=","brillig_names":["read_storage_list"],"assert_messages":{"76":"attempt to add with overflow","65":"Array index out of bounds","94":"Stack too deep"}},{"name":"set_opcode_u64","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAwnAgUQAAAAAAAAAAABIyUABHgAgAQNAAAAgASAAyEAABCAAzkBAAAjKwAYyhjK","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ==","brillig_names":["set_opcode_u64"],"assert_messages":{"15":"Stack too deep"}},{"name":"nested_static_call_to_add","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAsrBAABgEU4AIBFAAEiAHYeAgAABCoIAQUAAAECASQCBAEGKg4GBSoIAQcAAAECASYCAKpjSKEACCQCBAEKJAIEAgwAOAoMCyoIAQkAEAELASQDBAEJACgJAgsqDgoLJAIEAgsAOAkLCioMCgsqDggLKg4JByQCBAAIJAIBAQkkAgQCCioMCAMgACYMOAMKCyECAEgACyAAKSoNBQEqDQcCKggBAyQCBAMFABABBQEkAwQBAwAoAwIFKgwFBikCADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAAAcqDgcGACgGAgYqDgcGJgIA1UQbDQAFACgDAgYAKAICCyoNCwoAKAsCCSoIAQskAgQCDAAQAQwBJAMEAQsAKAsCDTc/lQAGAAQACQAKAA0AAQAMAAUkAgIBAQo4DAECIQIARAACOQEAAAAoCwICADgCCAMqDQMBIww4AwoLIQIASwALOQEAACQCBAIMJAIEAg4AOAwODSoIAQsAEAENASQDBAELACgLAg0qDgwNJAIEAg0AOAsNDCoMDA0qDgENACgNAg0qDgINACgLAg0qDQ0NDDgDDQ4hAgBeAA45AQAAJAIEAg4AOAsODQA4DQMOKg0ODCoNBQsqDQcNACgLAg4rBAANgAMlAAQAAYAEIgB7KwiABQAPKwiABgAQKg4MECoNDwsAKAsCCyoOCw8qDg4FKg4PBwA4AwYLDjgDCwwhAgB0AAw5AQAAKgwLAyAAJiUABHgAgAQNAAAAgASAAyEAAHqAAzkBAAAjAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAAk4ANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIACKAQCACoAHgAYjKwAYyhjK","debug_symbols":"1ZzRbuIwEEX/Jc88eMb2eIZfWa2q0EIVKQoV0JVWiH/fkE0C3bLOS6X6viASRuFc5OgQj+Vz9bLdvL8+Nd1uf6zWP85Vu3+uT82+64/Ol1W1OTRt27w+3Z+u3PWFeKg/vtXd9fB4qg+nak3Bi66qbfcyvFftr7Fr2m217s9fVp/qvUkcy72lMFeTxgfVEpTGagmWPlT/XFXk/4MUZUYKLAtIkXhKEEn87UuMHgXwc7X3IgsBktpYrO720zCHAT9g40dsfMHGT9j4io1v0PjssPEJG5+x8bGty9jWZWzrMrZ1Gdu6jG1dxraux7aux7aux7auL/7WJaGJn4Rvj/YyPKuH4kcPSZhRRNy//MUPnwX+7/jXFkKY+OPd1NBjfpU4TQ1pIv5QfQ0Q0ANE9ACCHiChB1D0AAYeIDr0AIQegNEDoJs4ops4ops4ops4ops4ops4optY0E0s6CYWdBMLuonlO0wsbrq4F9JPSLE8JCkPKZWH9DVGY5sGbPRkC0jESf10ddb7+oe3AwfisZwD01zNzoYIBh8hOfwIADOluZnqVHx/e4E/gPMX3+Fe4C++xb3AX3yPe4EfvFOWiu9y5/m1+Db3Aj9ApzLLD+5fBfevgvtXwf2r4P5VcP8quH8V3L8G7l8D96+B+9fA/Wvg/jVw/xq4fw3cvwbuXwP3LzkAAeeWipIDX6tLDnyxLjkAB+cDAEg4HwDAwvkAABrOBwDwcD4AgIjzAQBMnA1A6CYmdBMTuonL32NkKQC6icvfZyQX4NIf/aoPTb1pt+MeO7v37vluy53T77e/n/TFfwA=","brillig_names":["nested_static_call_to_add"],"assert_messages":{"67":"Nested static call failed!","93":"Array index out of bounds","74":"Index out of bounds","121":"Stack too deep","115":"attempt to add with overflow"}},{"name":"add_storage_map","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["add_storage_map"],"assert_messages":{"349":"Array index out of bounds","145":"Stack too deep","37":"Storage slot 0 not allowed. Storage slots must start from 1.","357":"Array index out of bounds","127":"Array index out of bounds","415":"attempt to add with overflow","275":"attempt to add with overflow","80":"Storage slot 0 not allowed. Storage slots must start from 1.","109":"Array index out of bounds","138":"attempt to add with overflow","68":"attempt to add with overflow","257":"Array index out of bounds","117":"attempt to add with overflow","341":"Array index out of bounds","373":"attempt to add with overflow","396":"Array index out of bounds"}},{"name":"assert_nullifier_exists","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiABAeAgAAAjA4AAEAAgADJAIBAQEhAgAPAAM5AQAAIyUABHgAgAQNAAAAgASAAyEAABSAAzkBAAAjKwAYyhjK","debug_symbols":"nZJbCoMwEEX3Mt9+OOapWymlxCeBEMVHoYh7b9KqKLYI/oSZ5NxwQmaEvEiH6qFtWXeQ3EYwdaZ6XVvXjVMAaauN0dVjuw2hXzD88F2jrG+7XrU9JBgRKQMobO5rGkp3R6lNAQnhrj7wJOZsxkks6EqjZD9oTiXONKex2NH3ABD/KLFoVSKCnyhhxOIFJ8hOlIQgy3uFkHhQis6VKOJOycfItRi9EJtc+1StVqkp5l8vB5tthqB/Nd8TB78B","brillig_names":["assert_nullifier_exists"],"assert_messages":{"14":"Nullifier doesn't exist!","19":"Stack too deep"}},{"name":"set_opcode_really_big_field","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAwpAgASNFZ4kKvN7xI0VniQq83vEjRWeJCrze8SNFZ4kKvN7wABIyUABHgAgAQNAAAAgASAAyEAABCAAzkBAAAjKwAYyhjK","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ==","brillig_names":["set_opcode_really_big_field"],"assert_messages":{"15":"Stack too deep"}},{"name":"pedersen_hash","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7dzdTiJBEEDhd5lrL7qruqu6fJXNxqCiISFgBDfZGN99B9dB4hC4G0+CNwakJcdSvzQ/7Wt3P799ebxZrB7Wm+7612u3XN/Ntov1qr/2+nbV3T4vlsvF483hp7u0+6D6vn7zNFvtrm62s+dtd50t0lU3X933Fz2l/h4eFst5d63W3q7Gq0uLYXUV36+WOLbYpe3verfic/Hvq04LK6eycoyV46ycxsoJVE5JrJzMyhFWDkvlwlK5sFQuLJULS+XCUrmwVK4slStL5cpSubJUriyVK0vlylK5slSuk6vcUhkWt6JfcwKVY4mVk1k5wspRVk5h5VRWjrFynJXDUtlYKjtLZWep7CyVnaWys1R2lsrOUtlZKjtLZWep3FgqN5bKjaVyY6ncWCrnyX+XJaXhrvuLedSjk/eY7Hu8jnqm/nlJzvv5ZEmjngrrMViPw3oarCdYPZFgPRnWI7AehfXAfA6YzwHzOWA+B8znYPncb9FgPSyfJbF8lsTyWdLkPkvZ90jUUc/kPmvKQ4/mMuoxWI/DehqsJ1g9OcF6MqxHYD0K6ymwHpjPGeZzhvmcYT5nmM8C81lgPgvMZ4H5LDCfBeazwHwWmM8C81lgPivMZ4X5rDCfFeazwnzW6X0u+9dPNWTUY7Aeh/U0WE+wekqC9WRYj8B6FNZTYD3f6/Po+fBisB5n9VTW+6Nk8uOK/Ss4uu+p4x6B9Sisp8B6KqzHYD0O65l8f5ikfvbI6cXaPx77WKzidnpxuA0V6aBZ6pG1ZkOxuR8ufZ9J/Mzk60wsXeZMYjjx64ePhT9mki90Jj7MRNpoJnKRM/E6vAneTUYz0Z+ZjGZSLnMmMTy51tLY2HqhMxm+vyZ5NBO7yJk0HYxtR/52/NJncmR/wt7Hah0Wq8bXQ1Ji7A2nljgR7+ydoZZ8Kp69hTsTz95rnYmfflOUPw/iyeiJ08mPs5/rqbAeg/U4rKfBeoLV8w0HgU/3ZFiPwHpgPjeYzw3mc4P53GA+N5jPDeZzwHwOmM8B8zlgPgfM54D5HDCfA+ZzwHwOls+aWD5rYvmsieWzJpbPmlg+a2L5rNMflE7e9j3RRj0O62mwnmD1TH9Q+kxPhvUIrEdhPQXWU2E9MJ8zzOcM8znDfBaYzwLzWWA+C8xngfksMJ8F5rPAfBaYzwLzWWE+K8xnhfmsMJ8V5rPCfFaYzwrzWWE+K8znAvO5wHwuMJ8L6x/d6/QHpc/0VFiPwXoc1tNgPcHq+YaD5Kd7MqxHYD0wnyvM5wrzucJ8rjCfK8znCvPZYD4bzGeD+Wwwnw3ms8F8NpjPBvPZYD4bzGeH+ewwnx3ms8N8dpjPDvPZYT47zGcn+fzWX/sze17MbpfzTf81uxtfVnfbxXr1cXX79+n/Lf3ifw==","brillig_names":["pedersen_hash"],"assert_messages":{"384":"Stack too deep","189":"Array index out of bounds","317":"Array index out of bounds","346":"Array index out of bounds","378":"attempt to add with overflow","369":"Array index out of bounds","299":"Array index out of bounds","328":"Array index out of bounds","229":"Array index out of bounds","357":"Array index out of bounds","220":"Array index out of bounds","284":"Array index out of bounds","313":"attempt to multiply with overflow","339":"Array index out of bounds","365":"attempt to add with overflow","295":"attempt to add with overflow","324":"attempt to add with overflow","254":"Array index out of bounds","280":"attempt to multiply with overflow","210":"Array index out of bounds","335":"attempt to add with overflow","198":"Array index out of bounds"}},{"name":"inner_helper_with_failed_assertion","is_unconstrained":false,"custom_attributes":[],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/33OQQrCMBAF0BS8hZt4g0xmppnZeQgvkNAJDRQLRu8vYtFV+zZ/8+H/wf0Nbt91SwwjkaVogJBD1CIciMsoIMDCUxREE5KkRVNQIDSorFjD12fj5I7t/ThveZtb97l3ezzbevd9Xl/L5Gtuy+XXfQP4jlSZ2AAAAA==","debug_symbols":"TYxLCoQwEAXv0msXMwyOmquISEcTaWg6kkRBgnc3fhbuXr2CSjAavUw9iXUBVJuA3YCRnGRK8LmuMKOcFCL6CKpsqrIAI+M5m+9egCU2oH7/eu8yaU/MNPXvUr5X9ISazYN2keFl4zbfJicO","brillig_names":[]},{"name":"u128_from_integer_overflow","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAorBAABgEMrBAACgEQ4AIBDAAIiAIgqCAECAAABAgEkAgABAyoOAwIkAgQhBCoIAQUkAgQhBgAQAQYBJAMEAQUAKAUCBioMBgckAgEACCoOCAcAKAcCByoOCAcAKAcCByoOCAcAKAcCByoOCAcAKAcCByoOCAcAKAcCByoOCAcAKAcCByoOCAcAKAcCByQCAQEJKg4JBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IBwAoBwIHKg4IByQCBCAGJAIEAQckAgACCioMBwEgAFwMOAEECyECAG0ACyAAXyoNAgEcDAABAigCAP////////////////////8AAw44AgMEIQIAZQAEOQEAABwMBQEDHAwAAwICOAECAygCAAAAAAAAAAABAAAAAAAAAAAAAQg4AwEEKgwCASoMBAIjKg0CCyoNAgwEOAsMDQI4BgELDjgBBgwhAgB0AAw5AQAAJAIEIA4MOAsODyECAHgADzkBAAAAKAUCDgA4DgsPKg0PDBwMAAwLBDgNCgwEOAsMDgI4AwsMBDgMDQsAOA4LDCoODAIAOAEHCw44AQsMIQIAhgAMOQEAACoMCwEgAFwlAAR4AIAEDQAAAIAEgAMhAACMgAM5AQAAIysAGMoYyg==","debug_symbols":"zdjbisIwEAbgd8m1F5nJcXyVZZGqVQqlitaFRXz3ja6NpXHZmxnojST2p9/QdtLDVW3r9WW/arrd4ayWH1fVHjZV3xy6NLveFmp9atq22a/Gfyt9/wF45M/HqrtPz3116tXSedALVXfbxzCmPeyatlZL49O4SHuN8EynIeY0+tvnQgGKC0ZcsNICsRwlslkgPxUcgwDGDQIQTQX/TgBPgwBB638Eax0+09YGk9Pvwz4MWTLTYsKciolzKoZmVAxoPatqgKEap4dGT0MaV/MgUJ4wHISJmbC2ICwLkU+Fc6YgnDxB0qsugJYnOO7haS95ZYdQEMhy84iZGF1RA2HkCStPOHnCsxD+RbiCCPJElCdInEAtT4A8gfKEYSZc0RfI0t2OMuGLZRC5n6F9LAiW7g74ekwvDxRLdwf4+00AMEq/bACSOGG0PAHyBMoTRpa4pdlXdWqqdVs/P2nsLt1m9IWj/z7+bknhHw==","brillig_names":["u128_from_integer_overflow"],"assert_messages":{"115":"attempt to subtract with overflow","133":"attempt to add with overflow","119":"Array index out of bounds","100":"call to assert_max_bit_size","139":"Stack too deep"}},{"name":"modulo2","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"a","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMdAAWAQ4BDKwiAQwABIgALKwQAAYBEOACARAABIgAQHAwBAQMcDAUDAioMAgEjJQAEeACABA0AAACABIADIQAAFIADOQEAACMrABjKGMo=","debug_symbols":"lY7BCsMgEET/Zc8etIG09VdKCZpoWJA1qCkU8d+7aXLINZdl3+7MMBUmZ9d5QPIxg35VCHE0BSMx1SbAJgwB5+F8BrkNdfvr82Jow1xMKqBV/5QCHE283qXkBI/Bge76R3sLUN1lU2P8mITGBneU8iuNp47lu+wfFv8A","brillig_names":["modulo2"],"assert_messages":{"19":"Stack too deep"}},{"name":"set_opcode_u8","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAwkAgIIASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ==","brillig_names":["set_opcode_u8"],"assert_messages":{"15":"Stack too deep"}},{"name":"emit_nullifier_and_check","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiABExAgABHgIAAAIwOAABAAIAAyQCAQEBIQIAEAADOQEAACMlAAR4AIAEDQAAAIAEgAMhAAAVgAM5AQAAIysAGMoYyg==","debug_symbols":"nZLdioMwEEbfZa69cDJJJvFVlqXEVksgxKJ2YRHffWNXW/uH0JuQSc6Ek48Z4FCV5+POx7rpoPgaIDR71/smpmoYMyhbH4I/7tbHkE8L5he+O7k4lV3v2h4KFBoxgyoeLnui9EbtQwUFaTNmTzwZFjNOxvKVRqNe0GxkPtOcGu/o7wwQXytxTlclFptKVqtFybLcUNLSLP/V8uEDk5J4k5LmW0oWN5RQKLvghGorJSazpMQGn5ToTUpylZK0d0pTm/ysTX3QNqbyx7XelaGaB7E+x/1qLvvf0/9Ngv8A","brillig_names":["emit_nullifier_and_check"],"assert_messages":{"20":"Stack too deep","15":"Nullifier was just created, but its existence wasn't detected!"}},{"name":"keccak_f1600","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"data","type":{"kind":"array","length":25,"type":{"kind":"integer","sign":"unsigned","width":64}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":25,"type":{"kind":"integer","sign":"unsigned","width":64}},"visibility":"public"}},"bytecode":"JAAEAQIlAASAdQABJAAEAwAkAgQZAiQCBAADHxgAAwACgEMdAAWAQ4BDHQAFgESARB0ABYBFgEUdAAWARoBGHQAFgEeARx0ABYBIgEgdAAWASYBJHQAFgEqASh0ABYBLgEsdAAWATIBMHQAFgE2ATR0ABYBOgE4dAAWAT4BPHQAFgFCAUB0ABYBRgFEdAAWAUoBSHQAFgFOAUx0ABYBUgFQdAAWAVYBVHQAFgFaAVh0ABYBXgFcdAAWAWIBYHQAFgFmAWR0ABYBagFodAAWAW4BbJQIEgEMAASQCBBkDKggBAiQCBBoEABABBAEkAwQBAgAoAgIEKwQAAYADKwQABIAEKwQAA4AFIgA0KgwCASIAPwAoAQICJQIEgFwAAyQCBBkEKwQAAoADKwQAA4AEKwQABIAFIgA0OACAXAAZJQAEAACABw0AgAeABYAIFwCACIAIIQAAPoAIAQCAA4AHgAkrAYAJgAYBAIAEgAeACSsCgAaACQEAgAcAAoAHIAA1IyIASSoIAQIkAgQaAwAQAQMBJAMEAQIAKAECAwAoAgIEPg8ABAADKgwCASMlAAR4AIAEDQAAAIAEgAMhAABNgAM5AQAAIysAGMoYyg==","debug_symbols":"nZHBCsMgEET/Zc8eLG018VdKCZpoWBANagpF/PeaJodc42XZ2Z03l8kwabXOAzrjI4hXButHmdC7qnIhoAJai/NwPgPdBnv8/XGRbpMxyZBA3FhPCWg31ZVTWhMMWg3izrryJsCeLRBrgXgL1LVAfQPE6WWoVPmRAaWy+mjHrG48lZW+y/6p5h8=","brillig_names":["keccak_f1600"],"assert_messages":{"76":"Stack too deep"}},{"name":"u128_addition_overflow","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAorBAABgEMrBAACgEQ4AIBDAAIiAMcqCAECAAABAgEkAgAAAyoOAwIqCAEEAAABAgEqDgMEKggBAwAAAQIBJAIAAQUqDgUDJAICMAYkAgQAByQCAngIJAIEIgkkAgQQCiQCAkYLJAIAEAwqCAENJAIEIw4AEAEOASQDBAENACgNAg4qDA4PKg4GDwAoDwIPKg4IDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDwAoDwIPKg4LDyQCBAEOKgwHASAAaQw4AQoHIQIAowAHIABsKg4FAyQCBBEHJAIEIQoqDAcBIABxDDgBCgchAgCDAAcgAHQqDQIBKg0EAgA4AQUDHAwFAwQcDAAEAQI4AwEEKAIAAAAAAAAAAAEAAAAAAAAAAAADCDgEAwUAOAIFAxwMBQMEHAwABAIKOAIDBCECAIIABDkBAAAjKg0EBwI4CQEPDjgBCRAhAgCIABA5AQAAJAIEIhEMOA8REiECAIwAEjkBAAAAKA0CEQA4EQ8SKg0SECQCBBIRKggAEioMEBMAEAARACIAzCoEAAAqDBMPKg0DEAQ4DxARADgHEQ8qDg8EKg0DBwQ4BwwPKg4PAwA4AQ4HDjgBBw8hAgChAA85AQAAKgwHASAAcSoNAgcCOAkBDw44AQkQIQIAqAAQOQEAAAI4Dw4QDjgODxEhAgCsABE5AQAAJAIEIhEMOBAREiECALAAEjkBAAAAKA0CEQA4ERASKg0SDyQCBBIRKggAEioMDxMAEAARACIAzCoEAAAqDBMQKg0DDwQ4EA8RADgHEQ8qDg8CKg0DBwQ4BwwPKg4PAwA4AQ4HDjgBBw8hAgDFAA85AQAAKgwHASAAaSUABHgAgAQNAAAAgASAAyEAAMuAAzkBAAAjIgDHJAICOgMMOAEDBCECAPEABCAA0SQCAkEDDDgBAwQWDAQDJAICWgQMOAQBBRYMBQQEOAMEBRwMAgUDJAICIAQEOAQDBQA4AQUDDjgBAwQhAgDfAAQ5AQAAJAICYQEMOAMBBCQCAQABCjgEAQUhAgDlAAU5AQAAJAICZgQMOAQDBQo4BQEEIQIA6gAEOQEAACQCAlcBAjgDAQQOOAEDBSECAO8ABTkBAAAqDAQCIAD4JAICMAMCOAEDBA44AwEFIQIA9gAFOQEAACoMBAIgAPgcDAACASMrABjKGMo=","debug_symbols":"tdrfTtswFAbwd8l1L2yfP7Z5lWmaChRUqSoIyqQJ8e4LG3G7Hq+VrPPdoIb660+pc5o4J+/T/eb27fHHdv/w9DrdfHufdk9368P2aT9vvX+sptuX7W63ffxx+u8pfP6J8c/41+f1/nPz9bB+OUw3QiWtps3+fn7JxPMnPGx3m+mGtHyszOgUo3yNnl9qGz0P/r6aYoILBBcYLoiHQLUJHM4FhQsZLhQPQY/zoGYeKlpIAS5E+LcUPA5XynkhKFdDeMy1RF0IifmccPnhEOZGsNkLl6pTKguhbPfCo+y0LqNTDmSI7lxEreErFHMIVwgJslS2hGyJ6kG0vZAYkjkRBTwRHYhI3Ai2RHIhqBESDUF4gj2IfJyLyoYQB2I+Hy1ESpZQPJE9CAmNUHNSTQVPVDhBEf5jTh6XslLbBY4GM91EeILxhOAJdSHoSIghMp4oeKLCCQ54IuKJhCdcqjvzkbArVcYTgicUT2Q8UfBEhRMS8ER0JqJZX4hLdWu5RBCeYDzhUd2XV6yCXxRLxhMFT1Q4oQFPeNTF5ZtF6lEXnNoF5+nohRA8oXgi44niTRRDVDiRA56IeCK5EHQkTOllwhOMJwRPKJ7IeKLgCZfqDu1qkDt9pIAnIp5IeILwBOMJwROKJ7I3YS7Vikd1Uy2XiAonasATLtXd+heJi2mR1IQnCE8wnhA8oWgi9VvqqUqr16psQjoS6lYghbL0ymnudJyGOvtSjo31ks6rI8UAFyJcSA4CtRkvTEYguMBwQTzmQY6COVr7T1D8KxQTyv1Qji3EpgL7TzlcC/2nmJQuhFIYCcWRUBoJ9Q/M+f5EC2VTL/2O/rWQjIR0JJRHQmUk1D8i5vlbQolMHVEYCcWRUBoJ0Uiof0SkHFqoBBOSkZCOhPJIqAyE+s3LVEtbBddqvr1+O/JaiEZCPBKSkVDph2i5t0t01pD4mLd+rl+269vd5uth5oe3/d3Js82HX89/35kH/wY=","brillig_names":["u128_addition_overflow"],"assert_messages":{"160":"attempt to add with overflow","202":"Stack too deep","135":"attempt to subtract with overflow","167":"attempt to subtract with overflow","129":"attempt to add with overflow","196":"attempt to add with overflow","171":"attempt to subtract with overflow","139":"Array index out of bounds","222":"attempt to add with overflow","238":"attempt to subtract with overflow","175":"Array index out of bounds","245":"attempt to subtract with overflow"}},{"name":"assertion_failure","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiAA8kAgQCASoIAAIAEAABACIAFCoEAAAjJQAEeACABA0AAACABIADIQAAE4ADOQEAACMiAA8kAgQCASoIAAIAEAABACIAGyoEAAAjIgAPJAIBAAEkAgEBAgo4AQIDIQIAIQADOQEAACMrABjKGMo=","debug_symbols":"ndPNCoMwDAfwd8nZQz/WuvgqY0jVKoVSRetgiO++unkQ9LJcSv9tfiGXLNDYau5KF9p+guKxgO9rE10fUlrWDKrRee+68vgMbDvwWz4NJmxpimaMUHCNLAMbmnTNGUsNWuctFFLf12cGnFEQpyBBQZKAxOV4muW4I825OiFBQZKCbhSkKOh+hRTmakcKkZ8QEpBkFMQpSPyN1hRfZnSm8nZfonYO9WGn4nv4/aTiDw==","brillig_names":["assertion_failure"],"assert_messages":{"32":"This assertion should fail!","18":"Stack too deep"}},{"name":"debug_logging","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiAP0kAgQAAiQCBAIEADgCBAMqCAEBABABAwEkAwQBAQAoAQIDKg4CAyQCBAIDADgBAwIkAgJ4AiQCAnQDJAICagQqCAEFJAIECgYAEAEGASQDBAEFACgFAgYqDAYHKg4EBwAoBwIHJAICdQgqDggHACgHAgckAgJzCSoOCQcAKAcCByoOAwcAKAcCByQCAiAKKg4KBwAoBwIHKg4DBwAoBwIHJAICZQsqDgsHACgHAgcqDgIHACgHAgcqDgMHJAIEAAYAKAUCBwAoAQIOKg0ODQAoDgIMOzsABwAJAAwADSQCAAQCJAIAAQQkAgJ9BSQCAjoHJAICbwgkAgQEDSQCBAIPADgNDw4qCAEMABABDgEkAwQBDAAoDAIOKg4NDiQCBAIOADgMDg0qDA0OKg4EDgAoDgIOJAIAAg8qDg8OACgOAg4kAgADECoOEA4AKA4CDioOAg4qCAENJAIEDA4AEAEOASQDBAENACgNAg4qDA4RKg4JEQAoEQIRKg4LEQAoEQIRJAICYxIqDhIRACgRAhEqDggRACgRAhEkAgJuEyoOExEAKBECESQCAmQUKg4UEQAoEQIRKg4HEQAoEQIRKg4KEQAoEQIRJAICexUqDhURACgRAhEkAgIxFioOFhEAKBECESoOBREkAgQEDgAoDQIRACgMAhkqDRkYACgZAhc7OwARAAsAFwAYKggBDSQCBBARABABEQEkAwQBDQAoDQIRKgwRFiQCAncXKg4XFgAoFgIWJAICaBgqDhgWACgWAhYqDggWACgWAhYkAgJsGSoOGRYAKBYCFioOCxYAKBYCFioOChYAKBYCFiQCAmEaKg4aFgAoFgIWJAICchsqDhsWACgWAhYqDhsWACgWAhYqDhoWACgWAhYkAgJ5HCoOHBYAKBYCFioOBxYAKBYCFioOChYAKBYCFioOFRYAKBYCFioOBRYAKA0CEQAoDAIeKg0eHQAoHgIWOzsAEQAPABYAHSQCAi0CJAICaQQkAgJmBSQCAgoHKggBDCQCBCUNABABDQEkAwQBDAAoDAINKgwNDioOAw4AKA4CDioOGg4AKA4CDiQCAmIPKg4PDgAoDgIOKg4JDgAoDgIOKg4KDgAoDgIOKg4aDgAoDgIOKg4TDgAoDgIOKg4UDgAoDgIOKg4KDgAoDgIOKg4TDgAoDgIOKg4LDgAoDgIOKg4XDgAoDgIOKg4ZDgAoDgIOKg4EDgAoDgIOKg4TDgAoDgIOKg4LDgAoDgIOKg4JDgAoDgIOKg4HDgAoDgIOJAICCRAqDhAOACgOAg4qDgIOACgOAg4qDgoOACgOAg4qDgUOACgOAg4qDgQOACgOAg4qDhsOACgOAg4qDgkOACgOAg4qDgMOACgOAg4qDgcOACgOAg4qDhAOACgOAg4qDgIOACgOAg4qDgoOACgOAg4qDgkOACgOAg4qDgsOACgOAg4qDhIOACgOAg4qDggOACgOAg4qDhMOACgOAg4qDhQOACgMAg0AKAECFSoNFREAKBUCDjs7AA0AJAAOABEjJQAEeACABA0AAACABIADIQABAYADOQEAACMrABjKGMo=","debug_symbols":"1dvLSltRGIbhe9ljB+s/rJO3UorEI4EQRWOhiPfepFWx2OCktN87EXeydvhG7zNaT8vl1fnjzdl6e337sJx+eVo2txer3fp2u396ej5Zzu/Xm8365uz9x0s5/Jk/jz/crbaHp4fd6n63nDZv5WS52l7u/w2L/Q9crzdXy2m08Xzy4bT18XLYy7uzh/c+nO1jvpwdnp+cnfl6do7+29mvJ4sV6nCjDnfq8KAOT+rwSh3eqMM7dfigDqfK6VQ5nSqnU+V0qpxOldOpcjpVTqfK6VQ5nSpnUOUMqpxBlTOocgZVzqDKGVQ5gypnUOUMqpxJlTOpciZVzqTKmVQ5kypnUuVMqpxJlTOpclaqnJUqZ6XKWalyVqqc9c9yhsfb8Dk/Gf73xjSlMV1pzFAaM4XGtKI0xpTGuNKYUBqTSmOUCtyUCtyUCtyUCtyUCtyVCtyVCtyVCtyVCtyVCtyVCtyVCtyVCtyVCtyVCjyUCjyUCjyUCjyUCjyUCjyUCjyUCjyUCjyUCjyUCjyVCjyVCjyVCjyVCjyVCjyVCjyVCjyVCjyVCjyVCmxFKcFWlBpsRSnCVpQqbEUpw1aUOmxFKcRWlEpsRSnFVqRabFItNqkWm1SLTarFJtVik2qxSbXYpFp85Ap2lteXWo5/uGYqrTlyWfp/rTGpNS61JqTWpNSaKrWmSa3pUmukWuxSLQ6pFodUi0OqxSHV4pBqcUi1OKRaHFItDqkWh1SLU6rFKdXilGpxSrU4pVqcUi1OqRanVItTqsUp1eIq1eIq1eIq1eIq1eIq1eIq1eIq1eIq1eIq1eIq1eIm1eIm1eIm1eIm1eIjl+pyvq2pQ/IKtB25gUdY3rDLO3b5wC6f1OVHrhgSlht2uWOXB3Y51tCONbRjDe1YQzvW0I41dGANHVhDB9bQgTV0YA0dWEMH1tCBNXRgDR1YQyfW0Ik1dGINnVhDJ9bQiTV0Yg2dWEMn1tBJNdQL1VAvVEO9UA31QjXUC9VQL1RDvVAN9UI11AvVUC9YQw1rqGENNayhhjXUsIYa1lDDGmpYQw1rqGENdayhjjXUsYY61lDHGupYQx1rqGMNdayhjjU0sIYG1tDAGhpYQwNraGANDayhgTU0sIYG1tDEGppYQxNraGINTayhiTU0sYYm1tDEGppYQyvW0Mo09Hn/+G11v16db64e9q8cvn3cXuzWt9uXx933u1/f7A//AA==","brillig_names":["debug_logging"],"assert_messages":{"256":"Stack too deep"}},{"name":"get_fee_per_l2_gas","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAggAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc9LCsMgEAbgu8w6C23NQ69SStBEgyAa1BSKePeaVEpKuxH/mY9hJsEsxbaM2ioXgN0SGDfxqJ0tKeUGhNfG6GU8lwHtD0aHDyu3ewyR+wgMo2s3NCDtfPwpKjOUNhJYqefmxxNKaOWEdu1H46H9o3t8wVX3mJAvfc8lPrjXXBhZt1ebnU7HxOf67hT8Ag==","brillig_names":["get_fee_per_l2_gas"],"assert_messages":{"15":"Stack too deep"}},{"name":"get_l2_gas_left","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgsAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc9RCsMgDAbgu+S5D9phFa8yRtFWiyBa1A6GePfZTkbH+iL+yUdIMsxKbstonPYR+D2D9ZNIxruaculABmOtWcZzGdD+YHT4uAq3x5hESMAxIgR3oNx8/CmqM7SxCvhtYKX786SixgnG7KsxIxea9gNrmvbsVz9KjU8RjJBWte315qbTMem1fjoVvwE=","brillig_names":["get_l2_gas_left"],"assert_messages":{"15":"Stack too deep"}},{"name":"l1_to_l2_msg_exists","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"msg_hash","type":{"kind":"field"},"visibility":"private"},{"name":"msg_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAsrBAABgEU4AIBFAAEiAA8yOAABAAIAAyoMAwEjJQAEeACABA0AAACABIADIQAAE4ADOQEAACMrABjKGMo=","debug_symbols":"bc/hCoMgEAfwd7nPfehWmfUqY4SWhiAaaoMhvvustdHYvoj/ux/HXYRJ8HUelJHWQ3+NoO3IgrImp5gK4E5prebhXIZye/Cye78ws0UfmAvQY4WkLUCYaf93dZ4hlRbQV4Sm4teXHXlzrPGjkTZ/NC1Jc2iK2H7pW8rxzpxiXItje7ma8XRMeCyvTsZP","brillig_names":["l1_to_l2_msg_exists"],"assert_messages":{"18":"Stack too deep"}},{"name":"set_storage_map","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMdAASARIBEKwiAQwABKwiARAACIgAMKwQAAYBFOACARQABIgBFJAIABAQkAgQHBioIAAcqDAQIKgwBCQAQAAYAIgBKKgQAACoMCAUkAgAABgo4BQYHJAIBAAYKOAcGCCECABwACDkBAAAcDAACBiQCBAACJAIEAQcqDAIDIAAhCjgDAgghAgAuAAggACQkAgQFAyoIAAUqDAQGKgwBBwAQAAMAIgBKKgQAACoMBgIqDAIBIxwMAAMIADgFCAkqCAEIJAIEAgoAEAEKASQDBAEIACgIAgoqDAoLKg4GCyQCBAELDDgDCwwhAgA7AAw5AQAAACgIAgsAOAsDDCoNDAotDAAKAAkAOAMHCA44AwgJIQIAQwAJOQEAACoMCAMgACElAAR4AIAEDQAAAIAEgAMhAABJgAM5AQAAIyIARSoIAQQkAgQEBQAQAQUBJAMEAQQAKAQCBSoMBQYkAgAAByoOBwYAKAYCBioOBwYAKAYCBioOBwYqDQQFACgFAgUqDgUEKg0EBQAoBQIFKg4FBCoNBAUAKAUCBSoOBQQqDQQFACgFAgUqDgUEKggBBQAAAQIBKg4EBSoIAQQkAgQFBgAQAQYBJAMEAQQAKAQCBioMBggqDgcIACgIAggqDgcIACgIAggqDgcIACgIAggoAgAAAAAAAAAAAgAAAAAAAAAAAAkqDgkIKg0EBgAoBgIGKg4GBCoIAQYAAAECASoOBAYqCAEEAAABAgEkAgQAByoOBwQqCAEIAAABAgEkAgEACSoOCQgkAgQCCiQCBAELKgwHAyAAhgw4AwoMIQIAqQAMIACJKg0IAQo4AQkCIQIAjQACOQEAACQCBAkBKggACSoMBQoqDAYLKgwEDCoMCA0AEAABACIAzSoEAAAqDQUBKg0GAioNBAMqDgEFKg4CBioOAwQkAgEBAyoOAwgAKAICBAA4BAcFKg0FAyoNAQQCKAQCBCoOBAEqDQIBAigBAgEqDgECKgwDASMMOAMKDCECAKwADCAAxyoIAQwkAgQDDQAQAQ0BJAMEAQwAKAwCDSoMDQ4qDgEOACgOAg4qDgIOJAIEAg4MOAMODyECALkADzkBAAAAKAwCDgA4DgMPKg0PDSQCBA4MKggADioMBQ8qDAYQKgwEESoMCBIqDA0TABAADAAiARoqBAAAIADHADgDCwwOOAMMDSECAMsADTkBAAAqDAwDIACGIgBFJAIEAwYkAgQBByQCBAAIKgwIBSAA0ww4BQYIIQIA6wAIIADWKg0BBSoNAwYqDQQHKg0CCCQCBAQJKggBCiQCBAULABABCwEkAwQBCgAoCAILJAIEBAwAKAoCDTwPAAsADSoNCggAKAgCCCoOCAoqDgUBKg4KAioOBgMqDgcEIyoNAwgMOAUICSECAO8ACSABFCoNAQgqDQIJKg0DCioNBAsqDQIMJAIEBA4MOAUODyECAPgADzkBAAAAKAwCDgA4DgUPKg0PDSoNAQwkAgQDDww4BQ8QIQIBAAAQOQEAAAAoDAIPADgPBRAqDRAOADgNDgwkAgQEDgw4BQ4PIQIBCAAPOQEAACsEAAmAAyUABAAFgAQiAWkrCIAFAA0AKA0CDgA4DgUPKg4MDyoOCAEqDg0CKg4KAyoOCwQgARQAOAUHCA44BQgJIQIBGAAJOQEAACoMCAUgANMiAEUqDQQGJAIBAAcKOAYHCCECASAACDkBAAAqDQMGJAIEAwcKOAYHCCQCBAEGIQIBRwAIIAEmKg0BByoNAggqDQMJKg0ECioNAwskAgQDDQw4Cw0OIQIBLwAOOQEAACsEAAeAAyUABAAEgAQiAWkrCIAFAAwAKAwCDQA4DQsOKg4FDioODAEqDggCKg4JAyoOCgQqDQEFKg0CByoNBAgqDQMJADgJBgoOOAkKCyECAUIACzkBAAAqDgUBKg4HAioOCgMqDggEIAFoJAIECAcqCAAIKgwBCSoMAgoqDAMLKgwEDAAQAAcAIgDNKgQAACoNAQcqDQIIKg0DCSoNBAokAgQACysEAAeAAyUABAAEgAQiAWkrCIAFAAwAKAwCDQA4DQsOKg4FDioODAEqDggCKg4JAyoOCgQqDQEFKg0CByoNBAgqDgUBKg4HAioOBgMqDggEIAFoIysBgAOABgsAgAYAAoAHIQABbYAHIAFvKwCAA4AFIAF9KwAAAYAFAQAAAYAEAAElAAQAAIAJDQCACYAEgAoXAIAKgAohAAF7gAoBAIADgAmACysBgAuACAEAgAWACYALKwKACIALAQCACQACgAkgAXIlAQQAAYAFIAF9IysAGMoYyg==","debug_symbols":"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","brillig_names":["set_storage_map"],"assert_messages":{"58":"Array index out of bounds","202":"attempt to add with overflow","247":"Array index out of bounds","263":"Array index out of bounds","279":"attempt to add with overflow","27":"Storage slot 0 not allowed. Storage slots must start from 1.","72":"Stack too deep","184":"Array index out of bounds","66":"attempt to add with overflow","255":"Array index out of bounds","302":"Array index out of bounds","321":"attempt to add with overflow"}},{"name":"send_l2_to_l1_msg","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"},{"name":"content","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAo4AIBFAAAiAA01DAABAAIjJQAEeACABA0AAACABIADIQAAEYADOQEAACMrABjKGMo=","debug_symbols":"bc9RCsMgDAbgu+S5D412RbzKGEVbLYJoUTsY0rvPdsI61hfJbz5CkmFScp0H47SPwO8ZrB9FMt6VlLcGZDDWmnk4f0O7P4iHj4twe4xJhAQcKcW+AeWmo6aszNDGKuC0L/WfJxSxckK7r0Z2u9CMtG3VjHTdj35sJT5FMEJaVbfXqxtPx6TX8ukU/AY=","brillig_names":["send_l2_to_l1_msg"],"assert_messages":{"16":"Stack too deep"}},{"name":"read_storage_single","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiADwqCAECJAIEAgMAEAEDASQDBAECACgCAgMqDAMEJAIAAAUqDgUEKg0CAwAoAwIDKg4DAioIAQMAAAECASoOAgMkAgQAAiQCAAEEJAIEAQUqDAIBIAAdCjgBAgYhAgAmAAYgACAqDQMBACgBAgQAOAQCBSoNBQMqDAMBIyoNAwYcDAABBwA4BAcILAwACAAHJAIEAQkMOAEJCiECAC4ACjkBAAArBAAGgAMlAAQAAoAEIgBBKwiABQAIACgIAgkAOAkBCioOBwoAOAEFBg44AQYHIQIAOQAHOQEAACoOCAMqDAYBIAAdJQAEeACABA0AAACABIADIQAAQIADOQEAACMrAYADgAYLAIAGAAKAByEAAEWAByAARysAgAOABSAAVSsAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQAAU4AKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIABKJQEEAAGABSAAVSMrABjKGMo=","debug_symbols":"1ZnBioMwEIbfJWcPyWQmxr7KshTb2iKIFrULi/juq7tqu7WYY2cukuhP/IKJX0I6dcoOt8s+L89Vo3YfnSqqY9rmVTnUuj5Shzovivyyf7yt9Hgx+jffXNNyrDZtWrdqB9q6SGXlaSwSDS2c8yJTO+t8H63SRnuc0sboZEkba16kySFMaXLO3tOeXqWtj+e09f5f+jNSxsjGB9n4VjY+ysYn2fhONn4sG9/Lxk9E44Ns64Js64Js64Js6wL3qYtmbnso0jO+5T540OoF37oV/hsGDyzDwcU+gA9o5s4CglnSMLxnxEfZ+CQbn/uiITB12f953PKtMI6f8ZH7ogEJtvC5LxrQJnf80ExJNMwkiaZ1Z2VbArkvMQL4KBuf+8Y+gM99Yx/A576xD+Czd/Q2PntHb+ITe0dv4/N39Ca+bOuSbOuSbOuSbOuSbOuSZOv2Q/UrrfP0UGTTiev5Vh4fDmDb7+vfkyH8Aw==","brillig_names":["read_storage_single"],"assert_messages":{"56":"attempt to add with overflow","45":"Array index out of bounds","63":"Stack too deep"}},{"name":"set_opcode_small_field","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAwoAgASNFZ4kKvN7xI0VniQq83vAAEjJQAEeACABA0AAACABIADIQAAEIADOQEAACMrABjKGMo=","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ==","brillig_names":["set_opcode_small_field"],"assert_messages":{"15":"Stack too deep"}},{"name":"test_get_contract_instance","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiAOQeAgAAEioIARMkAgQSFAAQARQBJAMEARMAKBMCFDMOAAAAEgAAABQqDRMSACgSAhIqDhITKggBEgAAAQIBKggBFAAAAQIBKg0TFQAoFQIVKg4VEyQCBAAVACgTAhcAOBcVGCoNGBYqDhMSJAIEARMqDhMUJAIAABcKOBYXGCQCAQEWIQIAzgAYIAAmKggBGQAAAQIBKggBGiQCBBEbABABGwEkAwQBGgAoGgIbJAIEEBwAOBwbHCoMGx0MOB0cHhYMHh4hAgA2AB4qDhcdACgdAh0gADAqDhoZKg0aGwAoGwIbKg4bGiQCBBAbKgwVGCAAPQw4GBscIQIArgAcIABAKg0SGCoNFBwAOBwbHQ44HB0eIQIARgAeOQEAACoOGBIqDh0UKg0ZEioNGBQCKBQCFCoOFBgqDRoUAigUAhQqDhQaACgSAhcAOBcVGSoNGRQAKBICFwA4FxMZKg0ZFSQCBAITACgSAhkAOBkTGioNGhckAgQDEwAoEgIaADgaExsqDRsZJAIEBBMAKBICGwA4GxMcKg0cGiQCBAUTACgSAhwAOBwTHSoNHRskAgQGEwAoEgIdADgdEx4qDR4cJAIEBxMAKBICHgA4HhMfKg0fHSQCBAgTACgSAh8AOB8TICoNIB4kAgQJEwAoEgIgADggEyEqDSEfJAIEChMAKBICIQA4IRMiKg0iICQCBAsTACgSAiIAOCITIyoNIyEkAgQMEwAoEgIjADgjEyQqDSQiJAIEDRMAKBICJAA4JBMlKg0lIyQCBA4TACgSAiUAOCUTJioNJiQkAgQPEwAoEgImADgmEycqDSclHAwBHBMcDAATEhwMARITHAwBHxwcDAAcEhwMARIcHAwBIh8cDAAfEhwMARIfHAwBJSIcDAAiEhwMARIiKg0YEgIoEgISKg4SGCoMFgEqDBQCKgwVAyoMFwQqDBkFKgwaBioMGwcqDBMIKgwdCSoMHgoqDBwLKgwgDCoMIQ0qDB8OKgwjDyoMJBAqDCIRIADhKg0ZHCoNEh0qDRQeADgeGB8OOB4fICECALUAIDkBAAAkAgQRIAw4HyAhIQIAuQAhOQEAAAAoHQIgADggHyEqDSEeJAIEEB8MOBgfICECAMAAIDkBAAArBAAcgAMlAAQAEYAEIgDpKwiABQAdACgdAh8AOB8YICoOHiAAOBgTHA44GBweIQIAywAeOQEAACoOHRkqDBwYIAA9JAIBABIqDBIBKgwXAioMFwMqDBcEKgwXBSoMFwYqDBcHKgwSCCoMFwkqDBcKKgwSCyoMFwwqDBcNKgwSDioMFw8qDBcQKgwSESAA4SECAOMAATkBAAAjJQAEeACABA0AAACABIADIQAA6IADOQEAACMrAYADgAYLAIAGAAKAByEAAO2AByAA7ysAgAOABSAA/SsAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQAA+4AKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIADyJQEEAAGABSAA/SMrABjKGMo=","debug_symbols":"3Z3bTuMwEIbfJddc2OMZH3iV1QqVoypVBXFYaYV4921L47a4eISUsv9wg1qY2p8rnG+cTJzX4frm8uXuYr68vX8azn+9Dov7q9nz/H65evf6djZcPs4Xi/ndxf6vB7f+UTbhTw+z5frd0/Ps8Xk4L4HC2XCzvF6/5LBq4Ha+uBnOQ8xvZ010KFG20aEkrtE+y5HoyNlvoyOXdBD9+2zw7igQlbQDigqQZ6FttOciNbqUI8FZxpZzyfuhaxiPBENIMAEJhpFgBAkmTgHDbgcTP/aQTt5DPnkP5dQ9kDt5D/7kPdDJe5jioCKexx6ElKlDVUXB+RoqeQPDSDCCBBO/G4bH/ILiLmEIbpMwUIKiyVA0BYkmuO+mSWPLVEJD46FoCIpmkgNxiJWGPx7qA5+8hylmYnS1h0is5GFUxjyM+eAbPRLra84m7bdfrJKzM0vuzZKTWfJglpzNkotZ8miWPJklN+tQNutQMetQMetQMetQMetQMetQMetQMetQMevQiHxUlDRe55PEDTnyDJU8xsreVY+RHHmG9smRZ2jkkSLG9v8ceYb2yZGz3D45cpbbJU/IWW6fHPl43idHznL75MhZbp8c2aF9cmSH9snNOjSZdWgy69D07Q79dLVwpOGU6yW9tFcsFyiu2bMzzO4NsxMye+bacJbSsAfD7GyYXZDZC431Pn7F0bBHw+zJMHs2zA7t1ZJqHWLJ4SN7gfaqwg7tVYUd2qsKO7JXydWCcnJRGnZkr2rsyF7V2JG9qrEje5VcDpV9r858ZEf2qsaO7FWF3TtksarwyGYlX4t/yVNq4ZHVqsJDu1WDh5arBg9tV7+73cBLbuGh9arBQ/tVg4cWrAYPbVifYoXPzVkm76ENq8FjG1aBxzasAg9tWHJjMK1et/DQhtXgoQ2rwUMbVoOHNiyFXOGFWnhow2rw0IZV4AnasBo8tGGpnmElytzCQxtWg8c2rAKPbVgFHtqwwdWzrMG3J50I2rAaPLRhNXhow2rw0IYNoZ50CtwuwAO0YTV4aMNq8NCG1eChDRtiXYCH3C5GJtkQ47/BYxtWgcc2rAKPbdhSFyPs28VIwDasAo9t2D48YxtWgYc2rPN1McJ0KKk2mn0cm2af96PT+1ChfTztULHrpyYdKv+coYYyrkOYfWiHil2dNelQsYu5Jh0qdu3Xl4Yaa9Mcw5G5il0qNulQsSvLphyqYNehfWmomccyfM6xnavyg7Ilbag/KFvShoqTLW1wGAsHJ+tY40DfBN7dAsZD3wWuoCPfBq6gQ98H7uvzOyi26NA3gvfRoXdT6aJn6O1U+ujQ+6m4HXpq0aE3VOmjQ++o0kdHtqmCDr2nSh8delOVPjq0TfvoyDbtbmTnM7JN++gF2aYKOvRuk310ZJsq6Mg2VdCRbaqgm93l0xfotWkfHdmmCrpdmxazNiVn1qbkzNqUnFmbkjNrU/qk1DzE3eN0kxygbz4Vv/ypt9XbP7PH+exycbN9xu/ty/Jq75G/z38f3v+yCv4H","brillig_names":["test_get_contract_instance"],"assert_messages":{"184":"Array index out of bounds","69":"attempt to add with overflow","202":"attempt to add with overflow","191":"Array index out of bounds","180":"attempt to add with overflow","226":"Contract instance not found!","231":"Stack too deep"}},{"name":"pedersen_hash_with_index","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"5d3dSiNBEEDhd5lrL7qruqu6fJVlWeIvgRBF48IivvuObiZmHYk3fUTijSTaeKbULzPGxjwOF5dnD9e/luurm/vh9MfjsLo5X2yWN+vx3uPTyXB2t1ytlte/9t89pOc3qi/r728X6+e795vF3WY4zRbpZLhcX4w3PaXxM1wtV5fDqVp7Opmvdmm71RK71ePNnyeDFrxQ8YLhBccLDS8EXSgJL2S8IHgBN11w0wU3XXDTBTddcNMFN11x0xU3XXHTFTddcdMVN11x0xU3XXuYbqlMq1vRt4WgC5bwQsYLghcULxS8UPGC4QXHC7hpw007btpx046bdty046YdN+24acdNO27acdMNN91w0w033XDTDTede3yrJaVp9XgzzxLaI2GyS3idJTp8oSTn3RRZ0ixR+YTxCecTjU8EnojEJzKfED6hfILXHbzu4HUHrzt43YHrHs9SfCLzCeETyid66JayS0jUWaKHbk15Smgus4TxCecTjU8EnsiJT2Q+IXxC+UThE7zuzOvOvO7M6868buF1C69beN3C6xZet/C6hdctvG7hdQuvW3ndyutWXrfyupXXrV10l91zgxoySxifcD7R+ETgiZL4ROYTwieUTxQ+0V337Ff7YnzC8UTF/wojPXa7jc/V6C5R5wnhE8onCp+ofML4hPOJHme9JPU18d9j1HyxjtdV28UqbocXh9t0GGnvMKS+s9YstmvNfX/py5jxLca0dDRjxrRT0/evabdj5uMZ06cxpc3GlGMZ0+u0Q8JNZmPq9xizHM2YMf3C2dL8Iagez5jTITfJszHtWMZsOj0EtXd+aP0Ix3znvPnpV0Fap8Wq8XbPmNinX65oiQPH4+nzjycfOp78xY5HvtjxdDml5tcNgTJ75qHHbuiPEpVPGJ9wPtH4ROCJPhtlDycynxA+wetuvO7G62687sbrbrzuxusOXnfwuoPXHbzu4HUHrzt43cHrDl534Lo1JT6R+YTwCeUThU9UPtFFt7ddItos4Xyi8YnAE122+36QyHxC+ITyicInKp/gdWded+Z1Z1638LqF1y28buF1C69beN3C6xZet/C6hdetvG7ldSuvW3ndyutWXrfyupXXrbxu5XUXXnfhdRded8H/RYZ22e77QaLyCeMTzicanwg80WfT8uFE5hPCJ3jdlddded2V11153ZXXXXndxus2Xrfxuo3Xbbxu43Ubr9t43cbrNl6387qd1+28bud1O6/bed3O63Zet8O6n8Z7vxd3y8XZ6nL7IixXD+vzvddk2fy5/feRcfFf","brillig_names":["pedersen_hash_with_index"],"assert_messages":{"384":"Stack too deep","189":"Array index out of bounds","317":"Array index out of bounds","346":"Array index out of bounds","378":"attempt to add with overflow","369":"Array index out of bounds","299":"Array index out of bounds","328":"Array index out of bounds","229":"Array index out of bounds","357":"Array index out of bounds","220":"Array index out of bounds","284":"Array index out of bounds","313":"attempt to multiply with overflow","339":"Array index out of bounds","365":"attempt to add with overflow","295":"attempt to add with overflow","324":"attempt to add with overflow","254":"Array index out of bounds","280":"attempt to multiply with overflow","210":"Array index out of bounds","335":"attempt to add with overflow","198":"Array index out of bounds"}},{"name":"get_timestamp","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgcAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc9LCsMgEAbgu8w6C20emlyllKCJBkE0qCkU8e41qZSUZiP+Mx/DTIRZ8G0ZlZHWw3CPoO3EgrImp5gq4E5prZbxXAa0Pxgd3q/M7NEH5gIMGN0oqkCY+fj3JM+QSgsY6o6m6s83lNSFN5Q2X41pe6EJanHRBHX9j36kHJ/MKca1KNvLzUynY8Jr/XQyfgM=","brillig_names":["get_timestamp"],"assert_messages":{"15":"Stack too deep"}},{"name":"nested_call_to_add","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAsrBAABgEU4AIBFAAEiAHYeAgAABCoIAQUAAAECASQCBAEGKg4GBSoIAQcAAAECASYCAKpjSKEACCQCBAEKJAIEAgwAOAoMCyoIAQkAEAELASQDBAEJACgJAgsqDgoLJAIEAgsAOAkLCioMCgsqDggLKg4JByQCBAAIJAIBAQkkAgQCCioMCAMgACYMOAMKCyECAEgACyAAKSoNBQEqDQcCKggBAyQCBAMFABABBQEkAwQBAwAoAwIFKgwFBikCADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAAAcqDgcGACgGAgYqDgcGJgIA1UQbDQAFACgDAgYAKAICCyoNCwoAKAsCCSoIAQskAgQCDAAQAQwBJAMEAQsAKAsCDTY/lQAGAAQACQAKAA0AAQAMAAUkAgIBAQo4DAECIQIARAACOQEAAAAoCwICADgCCAMqDQMBIww4AwoLIQIASwALOQEAACQCBAIMJAIEAg4AOAwODSoIAQsAEAENASQDBAELACgLAg0qDgwNJAIEAg0AOAsNDCoMDA0qDgENACgNAg0qDgINACgLAg0qDQ0NDDgDDQ4hAgBeAA45AQAAJAIEAg4AOAsODQA4DQMOKg0ODCoNBQsqDQcNACgLAg4rBAANgAMlAAQAAYAEIgB7KwiABQAPKwiABgAQKg4MECoNDwsAKAsCCyoOCw8qDg4FKg4PBwA4AwYLDjgDCwwhAgB0AAw5AQAAKgwLAyAAJiUABHgAgAQNAAAAgASAAyEAAHqAAzkBAAAjAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAAk4ANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIACKAQCACoAHgAYjKwAYyhjK","debug_symbols":"1ZzRauMwEEX/xc950Iyk0Ux+ZVlK0ibFYJySpAtLyL+v47Xd7LaVXgrVfQlxMsjngs2xNUKX5mm3fX1+aPv94dSsf1ya7vC4ObeHfji6XFfN9th2Xfv8cP9z424fxGP96WXT3w5P583x3KwpuJRWza5/Gr9bGsbYt92uWXvR6+pdvTeJU7m3FJZq0vhBtQSlqVrC3di36p+rhvwnSMs5KJCPBaSgbj5JULa3kxh9UM3ieapmSa4QIKlNxep0qWUOI37Axo/Y+IKNn7DxFRvfoPHZYeMTNj5j42Nbl7Gty9jWZWzrMrZ1Gdu6jG1dj21dj21dj21dX/2tS0IzPwm/vdrL+K4eqr96SIIs/OL+56/+8inwf8dTW3Ju5lefCvwaeB5bQ6J/qm8BAnqAiB5A0AMk9ACKHsDAA0SHHoDQAzB6AHQTR3QTR3QTR3QTR3QTR3QTR3QTC7qJBd3Egm5iQTexfIeJLc6Ds8m7NRkS60OS+pBSfUhfYzSTBck0FpCIk/p5dFaywu3AgZYJseHOWKrZ2RjB4CMkhx8BYKY0N1Odqu9vF/gDOH/1He4Cf/Ut7gJ/9T3uAj94pyxV3+XO82v1be4CP0CnMssP7l8F96+C+1fB/avg/lVw/yq4fxXcvwbuXwP3r4H718D9a+D+NXD/Grh/Ddy/Bu5fA/cvOQAB55aKkgNfq0sOfLEuOQAH5wMASDgfAMDC+QAAGs4HAPBwPgCAiPMBAEycDUDoJiZ0ExO6ievfY6QUAN3E9e8zkgtwHY5+bY7tZtvtpj129q/9492WO+ffL3//GYr/AA==","brillig_names":["nested_call_to_add"],"assert_messages":{"67":"Nested call failed!","93":"Array index out of bounds","74":"Index out of bounds","121":"Stack too deep","115":"attempt to add with overflow"}},{"name":"enqueue_public_from_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"3VXRboMwDPyXPPMQJ3Hi9FemqYKWVpEQVEAnTYh/X2BNtg401K1bJV6QTc747myUju3z7HzcuvJQNWzz1LGi2qWtq0qfdQzk+K45peWQNm1at2wD2vKE5eXeh4bzPmEHV+RsIzX1yQQtrYILWlpjIhpI988JA/X3LXC2BSoyoQciwkITNCQucCT+qYmFOTQF/howYj104KPvwofARD5aLPABQhk88rGiK5OmeOFBQa6PCSammjWIoAeIsKBU+LqVAiek7DwpNBhJaYVLpJQKG4hK4y/WVfD78IlwRMH/e9IC1iBCPEDE9+vqs6x2ReGO26ubgw8POf97AY+ugKAv2ybt7TWK/6AGbq3xCYyX4qwqtGF0Bu2HRxzHQrFCO3z2ktYuzYp8GPlweC53YQN82r6e3k88+A0=","brillig_names":["pack_arguments_oracle_wrapper","enqueue_public_function_call_internal","pack_arguments_oracle_wrapper"]},{"name":"read_storage_map","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["read_storage_map"],"assert_messages":{"240":"Array index out of bounds","256":"Array index out of bounds","272":"attempt to add with overflow","196":"Stack too deep","190":"attempt to add with overflow","142":"Array index out of bounds","107":"Storage slot 0 not allowed. Storage slots must start from 1.","248":"Array index out of bounds","335":"attempt to add with overflow","172":"Array index out of bounds","153":"attempt to add with overflow","316":"Array index out of bounds"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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DBwYKggBGSQCBAIaABABGgEkAwQBGQAoGQIaKgwaGyoOGBskAgQbGioIABsqDBkcABAAGgAiF/gqBAAAIAehJgIAFsVrwwAYCjgBGBkhAgelABkgB9IqCAEYJAIECxkAEAEZASQDBAEYACgYAhkfPAAEABQAGSoNGBkAKBkCGSoOGRgqCAEZAAABAgEqDhgZKggBGAAAAQIBKg4FGCQCBBwbKggAHCoMGR0qDBgeKgwRHwAQABsAIhzSKgQAACoMHRokAgQbGCoIABsqDBocABAAGAAiH4IqBAAAKgwcESQCBBoZKggAGioMERsAEAAZACIenCoEAAAqDBsYJAIEGREqCAAZKgwYGgAQABEAIh8GKgQAACAH0iYCAJ8b6Y8AEQo4AREYIQIH1gAYIAgDKggBESQCBAsYABABGAEkAwQBEQAoEQIYHzwABAAUABgqDREYACgYAhgqDhgRKggBGAAAAQIBKg4RGCoIAREAAAECASoOBREkAgQbGioIABsqDBgcKgwRHSoMFh4AEAAaACIfCioEAAAqDBwZJAIEGhgqCAAaKgwZGwAQABgAIiDwKgQAACoMGxEqCAEYJAIEAhkAEAEZASQDBAEYACgYAhkqDBkaKg4RGiQCBBoZKggAGioMGBsAEAAZACIX+CoEAAAgCAMmAgDCoiPuABEKOAERGCECCAcAGCAINCoIAREkAgQLGAAQARgBJAMEAREAKBECGB88AAQAFAAYKg0RGAAoGAIYKg4YESoIARgAAAECASoOERgqCAERAAABAgEqDgURJAIEGxoqCAAbKgwYHCoMER0qDBYeABAAGgAiHwoqBAAAKgwcGSQCBBoWKggAGioMGRsAEAAWACIiRCoEAAAqDBsRKggBFiQCBAIYABABGAEkAwQBFgAoFgIYKgwYGSoOERkkAgQZGCoIABkqDBYaABAAGAAiF/gqBAAAIAg0JgIAjkpTcwARCjgBERYhAgg4ABYgCEQkAgQYESoIABgAEAARACIjmCoEAAAkAgQYESoIABgqDAIZABAAEQAiF8YqBAAAIAhEJgIAhX4RuAARCjgBERYhAghIABYgCFQkAgQYESoIABgAEAARACIkJioEAAAkAgQYESoIABgqDAIZABAAEQAiF8YqBAAAIAhUJgIAdVBbOgARCjgBERYhAghYABYgCGwkAgQYFioIABgAEAAW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AhgqDhgXJAIEGRgqCAAZKgwEGioMBxsqDA8cABAAGAAiKRUqBAAAKgwaFyQCBBoZKggAGioMFxsAEAAZACIpUSoEAAAqDBsYJAIEGhkqCAAaKgwEGyoMBxwqDA8dABAAGQAiKRUqBAAAKgwbFyQCBBkHKggAGSoMFxoAEAAHACIpuioEAAAqDBoEKggBByQCBBMIABABCAEkAwQBBwAoBwIIKgwIDyoOCg8AKA8CDyoODg8AKA8CDyoOFg8AKA8CDyQCAl8XKg4XDwAoDwIPKg4KDwAoDwIPKg4WDwAoDwIPKg4BDwAoDwIPKg4RDwAoDwIPJAICYRkqDhkPACgPAg8kAgJnGioOGg8AKA8CDyoODg8AKA8CDyoOFw8AKA8CDyoOCg8AKA8CDyQCAmkbKg4bDwAoDwIPKg4NDwAoDwIPKg4aDwAoDwIPKg4QDwAoDwIPKg4ODyQCBBwIKggAHCoMBx0AEAAIACIqIioEAAAkAgAeByQCBBwIKggAHCoMBx0AEAAIACIXryoEAAAqCAEHJAIEEQgAEAEIASQDBAEHACgHAggqDAgPKg4KDwAoDwIPKg4ODwAoDwIPKg4WDwAoDwIPKg4XDwAoDwIPKg4KDwAoDwIPKg4WDwAoDwIPKg4BDwAoDwIPKg4RDwAoDwIPKg4ZDwAoDwIPKg4aDwAoDwIPKg4ODwAoDwIPKg4XDwAoDwIPKg4QDwAoDwIPKg4bDwAoDwIPKg4KDwAoDwIPKg4WDyQCBBwIKggAHCoMBx0AEAAIACIqNCoEAAAkAgAoByQCADIIJAIEHA8qCAAcKgwHHSoMCB4AEAAPACIYMCoEAAAkAgJkByoIAQgkAgQSDwAQAQ8BJAMEAQgAKAgCDyoMDxwqDhEcACgcAhwqDg4cACgcAhwqDhkcACgcAhwqDgccACgcAhwqDhccACgcAhwqDgocACgcAhwqDhYcACgcAhwqDgEcACgcAhwqDhEcACgcAhwqDhkcACgcAhwqDhocACgcAhwqDg4cACgcAhwqDhccACgcAhwqDhAcACgcAhwqDhscACgcAhwqDgocACgcAhwqDhYcJAIEHA8qCAAcKgwIHQAQAA8AIipGKgQAAB4CAAAIJAIEPA8kAgQeHSoIAB4qDAgfKgwPIAAQAB0AIhi0KgQAACoMHxwqCAEIJAIEEA8AEAEPASQDBAEIACgIAg8qDA8dKg4ZHQAoHQIdKg4HHQAoHQIdKg4HHQAoHQIdKg4XHQAoHQIdKg4KHQAoHQIdKg4WHQAoHQIdKg4BHQAoHQIdKg4RHQAoHQIdKg4ZHQAoHQIdKg4aHQAoHQIdKg4OHQAoHQIdKg4XHQAoHQIdJAICbR4qDh4dACgdAh0qDhkdACgdAh0kAgJwHyoOHx0kAgQgDyoIACAqDAghABAADwAiKlgqBAAAHgIAAAgkAgQgHSoIACAqDAghKgwUIgAQAB0AIhjtKgQAACoMIQ8qCAEIJAIEERQAEAEUASQDBAEIACgIAhQqDBQdKg4RHQAoHQIdKg4OHQAoHQIdKg4ZHQAoHQIdKg4HHQAoHQIdKg4XHQAoHQIdKg4KHQAoHQIdKg4WHQAoHQIdKg4BHQAoHQIdKg4RHQAoHQIdKg4ZHQAoHQIdKg4aHQAoHQIdKg4OHQAoHQIdKg4XHQAoHQIdKg4eHQAoHQIdKg4ZHQAoHQIdKg4fHSQCBCAUKggAICoMCCEAEAAUACIqNCoEAAAeAgAACCQCBCAdKggAICoMCCEAEAAdACIZqCoEAAAqDCEUJAICaAgqCAEdJAIEDCAAEAEgASQDBAEdACgdAiAqDCAhKg4VIQAoIQIhKg4OIQAoIQIhKg4GIQAoIQIhKg4GIQAoIQIhKg4ZIQAoIQIhKg4VIQAoIQIhKg4XIQAoIQIhKg4IIQAoIQIhKg4ZIQAoIQIhKg4KIQAoIQIhKg4IISQCBCEgKggAISoMHSIAEAAgACIqaioEAAAkAgQhICoIACEqDAQiABAAIAAiHP4qBAAAKgwiHSQCAjUgJAICNiEqCAEiJAIEDCMAEAEjASQDBAEiACgiAiMqDCMkKg4KJAAoJAIkKg4IJAAoJAIkKg4ZJAAoJAIkJAICMiUqDiUkACgkAiQqDiAkACgkAiQqDiEkACgkAiQqDhckACgkAiQqDggkACgkAiQqDhkkACgkAiQqDgokACgkAiQqDggkJAIEJiMqCAAmKgwiJwAQACMAIipqKgQAACQCBCYhKggAJioMBCcAEAAhACIfgioEAAAqDCcgKggBBCQCBA8hABABIQEkAwQBBAAoBAIhKgwhIioOHyIAKCICIioOASIAKCICIioOCiIAKCICIioODiIAKCICIioOGyIAKCICIioOByIAKCICIioOASIAKCICIioODSIAKCICIioOJSIAKCICIioOFyIAKCICIioOCCIAKCICIioOGSIAKCICIioOCiIAKCICIioOCCIkAgQAIiQCBAIkADgiJCMqCAEhABABIwEkAwQBIQAoIQIjKg4iIyQCBAIjADghIyIAKAQCIgAoIQImKg0mJAAoJgIjOzsAIgAOACMAJCQCBCYiKggAJioMGCcAEAAiACIfNioEAAAqDCcEKggBIiQCBA4jABABIwEkAwQBIgAoIgIjKgwjJCoOHyQAKCQCJCoODiQAKCQCJCoOByQAKCQCJCoODiQAKCQCJCoOESQAKCQCJCoOCiQAKCQCJCoODiQAKCQCJCoODSQAKCQCJCoOFyQAKCQCJCoOCCQAKCQCJCoOGSQAKCQCJCoOCiQAKCQCJCoOCCQkAgQmIyoIACYqDCInABAAIwAiKnwqBAAAJAIEJiMqCAAmKgwYJwAQACMAIiDwKgQAACoMJyIqCAEjJAIEGSQAEAEkASQDBAEjACgjAiQqDCQmKg4fJgAoJgImKg4OJgAoJgImKg4HJgAoJgImKg4OJgAoJgImKg4RJgAoJgImKg4KJgAoJgImKg4OJgAoJgImKg4NJgAoJgImKg4XJgAoJgImKg4IJgAoJgImKg4ZJgAoJgImKg4KJgAoJgImKg4IJgAoJgImKg4XJgAoJgImKg4LJgAoJgImKg4bJgAoJgImKg4WJgAoJgImKg4IJgAoJgImKg4XJgAoJgImKg4bJgAoJgImKg4NJgAoJgImKg4HJgAoJgImKg4OJgAoJgImKg4TJgAoIwIkACghAigqDSgnACgoAiY7OwAkABgAJgAnJAIEJiQqCAAmKgwYJwAQACQAIiJEKgQAACoMJyMqCAEYJAIEGyQAEAEkASQDBAEYACgYAiQqDCQmKg4WJgAoJgImKg4OJgAoJgImKg4KJgAoJgImKg4WJgAoJgImKg4XJgAoJgImKg4aJgAoJgImKg4OJgAoJgImKg4WJgAoJgImKg4XJgAoJgImKg4GJgAoJgImKg4BJgAoJgImKg4NJgAoJgImKg4WJgAoJgImKg4RJgAoJgImKg4ZJgAoJgImKg4GJgAoJgImKg4WJgAoJgImKg4XJgAoJgImKg4bJgAoJgImKg4NJgAoJgImKg4KJgAoJgImKg4WJgAoJgImKg4ZJgAoJgImKg4NJgAoJgImKg4GJgAoJgImKg4OJgAoGAIkACghAigqDSgnACgoAiY7OwAkABoAJgAnJAIEJhgqCAAmABAAGAAiJCYqBAAAKggBGCQCBAwkABABJAEkAwQBGAAoGAIkKgwkJioOGiYAKCYCJioODiYAKCYCJioOFiYAKCYCJioOFyYAKCYCJioOGSYAKCYCJioOByYAKCYCJioOByYAKCYCJioOESYAKCYCJioODiYAKCYCJioOCiYAKCYCJioOCiYkAgQmJCoIACYqDBgnABAAJAAiKmoqBAAAJAIEJiQqCAAmABAAJAAiJQIqBAAAKgwnGCoIASQkAgQLJgAQASYBJAMEASQAKCQCJioMJicqDhonACgnAicqDg4nACgnAicqDhYnACgnAicqDhcnACgnAicqDgonACgnAicqDg4nACgnAicqDg0nACgnAicqDgcnACgnAicqDg4nACgnAicqDhEnACgkAiYAKCECKSoNKSgAKCkCJzs7ACYACgAnACgkAgQnJioIACcAEAAmACIlBSoEAAAqDCgkJAICdSYkAgJmJyoIASgkAgQWKQAQASkBJAMEASgAKCgCKSoMKSoqDhoqACgqAioqDg4qACgqAioqDhYqACgqAioqDhcqACgqAioqDicqACgqAioqDiYqACgqAioqDg0qACgqAioqDgYqACgqAioqDhYqACgqAioqDhsqACgqAioqDgEqACgqAioqDg0qACgqAioqDhcqACgqAioqDgoqACgqAioqDg4qACgqAioqDhAqACgqAioqDg4qACgqAioqDgYqACgqAioqDhYqACgqAioqDgEqACgqAioqDhEqACgoAikAKCECLCoNLCsAKCwCKjs7ACkAFQAqACskAgQqKSoIACoAEAApACIlCCoEAAAqDCsoKggBKSQCBBQqABABKgEkAwQBKQAoKQIqKgwqKyoOGisAKCsCKyoODisAKCsCKyoOFisAKCsCKyoOFysAKCsCKyoOFisAKCsCKyoOESsAKCsCKyoOGSsAKCsCKyoODSsAKCsCKyoOCisAKCsCKyoOGSsAKCsCKyoOBisAKCsCKyoOFisAKCsCKyoOGysAKCsCKyoOASsAKCsCKyoODSsAKCsCKyoOFysAKCsCKyoOJysAKCsCKyoODisAKCsCKyoODiskAgQrKioIACsqDCksABAAKgAiKo4qBAAAJAIEKyoq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NAAoNAI0JAICeTUqDjU0ACg0AjQqDh80ACg0AjQqDhY0ACg0AjQqDg40ACg0AjQqDgc0ACg0AjQqDhc0ACg0AjQqDhA0ACg0AjQqDgE0ACg0AjQqDho0ACgyAjMAKCECNyoNNzYAKDcCNDs7ADMAFAA0ADYkAgQyHyoIADIAEAAfACIl5SoEAAAqCAEfJAIEETIAEAEyASQDBAEfACgfAjIqDDIzKg4NMwAoMwIzKg4BMwAoMwIzKg4WMwAoMwIzKg4OMwAoMwIzKg4XMwAoMwIzKg4IMwAoMwIzKg4ZMwAoMwIzKg4KMwAoMwIzKg4IMwAoMwIzKg4XMwAoMwIzKg4OMwAoMwIzKg4TMwAoMwIzKg4bMwAoMwIzKg4KMwAoMwIzKg4WMwAoMwIzKg4KMyQCBDMyKggAMyoMHzQAEAAyACIqNCoEAAAuOAAJAAwAHyoIATIkAgQOMwAQATMBJAMEATIAKDICMyoMMzQqDg00ACg0AjQqDg40ACg0AjQqDgs0ACg0AjQqDhc0ACg0AjQqDg00ACg0AjQqDgE0ACg0AjQqDhY0ACg0AjQqDg40ACg0AjQqDhc0ACg0AjQqDgg0ACg0AjQqDhk0ACg0AjQqDgo0ACg0AjQqDgg0JAIENDMqCAA0KgwyNQAQADMAIip8KgQAACQCBDIIKggAMioMCTMAEAAIACInnioEAAAqCAEIJAIEDjIAEAEyASQDBAEIACgIAjIqDDIzKg4NMwAoMwIzKg4OMwAoMwIzKg4LMwAoMwIzKg4XMwAoMwIzKg4NMwAoMwIzKg4mMwAoMwIzKg4QMwAoMwIzKg4QMwAoMwIzKg4bMwAoMwIzKg4nMwAoMwIzKg4bMwAoMwIzKg4OMwAoMwIzKg4RMyQCBDMyKggAMyoMCDQAEAAyACIqfCoEAAAkAgQyCCoIADIqDAkzABAACAAiJ6EqBAAAKggBCCQCBBEyABABMgEkAwQBCAAoCAIyKgwyMyoODTMAKDMCMyoOJjMAKDMCMyoOEDMAKDMCMyoOEDMAKDMCMyoOGzMAKDMCMyoOJzMAKDMCMyoOGzMAKDMCMyoODjMAKDMCMyoOETMAKDMCMyoOFzMAKDMCMyoODjMAKDMCMyoOEzMAKDMCMyoOGzMAKDMCMyoOCjMAKDMCMyoOFjMAKDMCMyoOCjMkAgQzMioIADMqDAg0ABAAMgAiKjQqBAAAJAIEMiYqCAAyKgwJMwAQACYAIiekKgQAACoMMwgqCAEmJAIEFCcAEAEnASQDBAEmACgmAicqDCcyKg4QMgAoMgIyJAICMTMqDjMyACgyAjIqDhcyACgyAjIqDhYyACgyAjIqDgEyACgyAjIqDhcyACgyAjIqDhAyACgyAjIqDiUyACgyAjIqDhcyACgyAjIqDh4yACgyAjIqDgoyACgyAjIqDhoyACgyAjIqDhcyACgyAjIqDg4yACgyAjIqDhMyACgyAjIqDhsyACgyAjIqDgoyACgyAjIqDhYyACgyAjIqDgoyJAIENCcqCAA0KgwmNQAQACcAIiqOKgQAADI4AAkADAATKggBJiQCBBInABABJwEkAwQBJgAoJgInKgwnMioOCjIAKDICMioODjIAKDICMioODTIAKDICMioOBzIAKDICMioOFzIAKDICMioOEDIAKDICMioOJTIAKDICMioOFzIAKDICMioOFjIAKDICMioOATIAKDICMioOFzIAKDICMioOEDIAKDICMioOMzIAKDICMioOFzIAKDICMioOHjIAKDICMioOCjIAKDICMioOGjIkAgQ0JyoIADQqDCY1ABAAJwAiKkYqBAAAJQIAICAAGiQCBDIeKggAMioMGjMqDAk0ABAAHgAiJ6kqBAAAKggBGiQCBBMeABABHgEkAwQBGgAoGgIeKgweJSoODSUAKCUCJSoODiUAKCUCJSoOCiUAKCUCJSoOFiUAKCUCJSoODiUAKCUCJSoOByUAKCUCJSoOFyUAKCUCJSoOBiUAKCUCJSoOGSUAKCUCJSoOECUAKCUCJSoOECUAKCUCJSoOFyUAKCUCJSoOFiUAKCUCJSoOASUAKCUCJSoOFyUAKCUCJSoOGSUAKCUCJSoOByUAKCUCJSoOByUkAgQyHioIADIqDBozABAAHgAiKiIqBAAAJAIEMh4qCAAyKgwJMyoMDDQAEAAeACIoICoEAAAqDDMaKggBHiQCBBolABABJQEkAwQBHgAoHgIlKgwlJioODSYAKCYCJioODiYAKCYCJioOCiYAKCYCJioOFiYAKCYCJioODiYAKCYCJioOByYAKCYCJioOFyYAKCYCJioOCiYAKCYCJioOFiYAKCYCJioOGSYAKCYCJioOFiYAKCYCJioOGyYAKCYCJioOBiYAKCYCJioOFyYA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AQAAKg4JBSoMCAQgGVIiF48kAgAEBAo4AQQFJAIEAAQhAhmhAAUgGYgkAgATBgo4AQYHIQIZmgAHIBmMJAIAfAYKOAEGByECGZAABzkBAAAAKAICBgA4BgQHKg0HARwMAAECKQIAAAAAAAAAAAAAAAAA//////////////////////////8ABA44AgQGIQIZmAAGOQEAACoMAQUgGZ8AKAICBgA4BgQHKg0HASoMAQUgGZ8qDAUDIBmmACgCAgUAOAUEBioNBgEqDAEDIBmmKgwDASMiF48kAgAEAiQCBAUEKggABSoMAgYqDAEHABAABAAiKwMqBAAAKgwGAyQCAAABCjgDAQIkAgEABAo4AgQFIQIZuAAFOQEAACUCAAHJAAIkAgQHBioIAAcqDAQIKgwBCSoMAgoqDAMLABAABgAiF8oqBAAAKgwIBSQCBAYCKggABioMBQcAEAACACIYqioEAAAqDAcBIyIXjyoIAQUAAAECASoOAwUqDQMGACgGAgYqDgYDJAIEAQYkAgQAByoMBwQgGdYKOAQHCCECGeYACCAZ2SoNAQQqDQIHADgHBggOOAcICSECGd8ACTkBAAAqDgQBKg4IAioNBQEqDQMCAigCAgIqDgIDIyoNBQgqDQEJKg0CCgA4CgQLDjgKCwwhAhntAAw5AQAAJAIEBAwMOAsMDSECGfEADTkBAAAAKAkCDAA4DAsNKg0NCiQCBAELDDgECwwhAhn4AAw5AQAAKwQACIADJQAEAAKABCIqqysIgAUACQAoCQILADgLBAwqDgoMADgEBggOOAQICiECGgMACjkBAAAqDgkFKgwIBCAZ1iIXjxwMAAECKAIA/////////////////////wADDjgCAwQhAhoMAAQ5AQAAHAwFAQMcDAADAgI4AQIDKAIAAAAAAAAAAAEAAAAAAAAAAAABCDgDAQQqDAIBKgwEAiMiF48AOAEDBRwMBQUDHAwAAwECOAUBAygCAAAAAAAAAAABAAAAAAAAAAAABQg4AwUGADgCBAMAOAMGAhwMBQIEHAwABAMKOAMCBCECGiIABDkBAAAqDAMCIyIXjyQCBAACACgBAgQAOAQCBSoNBQMcDAUDAhwMAAIBHAwFAQIqDAIBIyIXjyoIAQUAAAECASQCAAAGKggBByQCBAQIABABCAEkAwQBBwAoBwIIKgwICSoO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","debug_symbols":"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P2827efNpnTebErnzaZ03mxK582mdN5sSufNpnTebErnzaZ03mxK582mfN5sur/s15h4kz7GRPqRcqiWHK4lR2rJ0VpyrJYcryUnaskZpeR8cBvYb5NTKypLragstaKy1IrKUisqS62oLLWistSKylIrKmutqKy1orLWispaKyprraistaKy1orKWisqa62orLWistWKylYrKlutqGy1orLVispWKypbrahstaKy1YrKVisqe62o7LWisteKyl4rKnutqOy1orLXispeKyp7rajstaJy1IrKUSsqR62oHLWictSKylErKketqBy1onLUispRKyqPWlF51IrKo1ZUHrWi8gf7xqXdUSaRKUdrybFacryWnKglZxSS4+2D/dK/TU6vJYdqyeFacipF5ZucSlH5JqdSVL7JqRSVb3IqReWbnFpRudeKyr1WVO61onKvFZV7rajca0XlXisq91pRudeKyr1WVKZaUZlqRWWqFZWpVlSmWlGZakVlqhWVqVZUplpRmWpFZa4VlblWVOZaUZlrRWWuFZW5VlTmWlGZa0VlrhWVuVZU/mBvn4xNjkbJ3dk36f280um80vm80uW80vW80u280v280uO80sdppet5s6meN5vqebOpnjeb6nmzqZ43m+p5s6meN5vqebOpnjeb2nmzqZ03m9p5s6mdN5vaebOpnTeb2nmzqZ03m9p5s6mdN5v6ebOpnzeb+nmzqZ83m/p5s6mfN5v6ebOpnzeb+nmzqZ83m8Z5s2mcN5vGebNpnDebxnmzaZw3m8Z5s2mcN5vGebNpnDebjvNm03HebDrOm03HebPpOG82HefNpuO82XScN5uO82bTcdps2ttps2lvp82mvZ02m/Z22mza22mzaW+nzaa9nTab9nbabNrbabNpb+fNpv282bSfN5v282bTft5s2s+bTft5s2k/bzbt582m/bzZtJ83m9J5symdN5vSebMpnTeb0nmzKZ03m9J5symdN5vun+4i3e+3vAv1vsGojTdYx2CEwRiDCQZTDGYYzDFYYLABwfZPmxAS22AmO7COwQiDMQYTDKYYzDCYY7DAYAOCKTZKFBslio0SxUaJYqNEPxglLhtsxC+wf/7S0z9JLIPEM0gig2QkkFjLIOkZJJRBwgkkfoCf3KZQ+tvTt3/So6Bq+kYyjiBx30jCnkmiZZD0DBLKIJGEHz70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","brillig_names":["public_dispatch"],"assert_messages":{"8704":"attempt to multiply with overflow","10106":"attempt to add with overflow","8948":"Array index out of bounds","7601":"Array index out of bounds","5797":"attempt to subtract with overflow","11295":"attempt to add with overflow","10515":"Nested static call failed!","7821":"Array index out of bounds","11137":"attempt to add with overflow","5883":"attempt to add with overflow","7608":"Array index out of bounds","5670":"attempt to add with overflow","8608":"Array index out of bounds","6292":"Array index out of bounds","11412":"Array index out of bounds","9096":"attempt to add with overflow","7268":"attempt to add with overflow","7780":"attempt to add with overflow","6622":"attempt to add with overflow","6299":"Array index out of bounds","9048":"Array index out of bounds","11285":"Array index out of bounds","8402":"attempt to add with overflow","9426":"attempt to add with overflow","5708":"Array index out of bounds","10127":"Array index out of bounds","10962":"attempt to add with overflow","8323":"attempt to multiply with overflow","5952":"Array index out of bounds","10237":"attempt to add with overflow","11340":"Array index out of bounds","11419":"Array index out of bounds","8756":"attempt to add with overflow","11237":"attempt to subtract with overflow","8354":"attempt to add with overflow","9055":"attempt to add with overflow","5715":"Array index out of bounds","8708":"Array index out of bounds","10433":"Nested static call failed!","6526":"attempt to add with overflow","7739":"attempt to add with overflow","6636":"attempt to add with overflow","5801":"Array index out of bounds","8361":"attempt to add with overflow","7715":"Index out of bounds","10086":"Array index out of bounds","5533":"Array index out of bounds","1626":"attempt to add with overflow","6667":"call to assert_max_bit_size","8715":"attempt to add with overflow","11141":"Array index out of bounds","7344":"attempt to add with overflow","8045":"Array index out of bounds","10093":"Array index out of bounds","5540":"Array index out of bounds","8289":"attempt to subtract with overflow","5918":"attempt to multiply with overflow","5595":"Array index out of bounds","7832":"attempt to add with overflow","11093":"attempt to add with overflow","6162":"attempt to add with overflow","7375":"attempt to add with overflow","9100":"Array index out of bounds","6217":"Array index out of bounds","6406":"Storage slot 0 not allowed. Storage slots must start from 1.","9612":"Array index out of bounds","11148":"Array index out of bounds","5815":"attempt to add with overflow","7351":"attempt to add with overflow","10667":"Array index out of bounds","7650":"attempt to multiply with overflow","10210":"Index out of bounds","2908":"Nullifier was just created, but its existence wasn't detected!","5468":"attempt to add with overflow","9430":"Array index out of bounds","8327":"attempt to subtract with overflow","11265":"attempt to add with overflow","5822":"attempt to subtract with overflow","8760":"Array index out of bounds","6121":"Array index out of bounds","6310":"attempt to add with overflow","5987":"Array index out of bounds","7657":"Index out of bounds","9059":"Array index out of bounds","9437":"Array index out of bounds","10138":"attempt to add with overflow","11430":"attempt to add with overflow","10059":"Array index out of bounds","5695":"attempt to add with overflow","9011":"attempt to multiply with overflow","5616":"attempt to add with overflow","6640":"Array index out of bounds","9066":"attempt to add with overflow","5994":"Array index out of bounds","7908":"attempt to add with overflow","8365":"Array index out of bounds","5726":"attempt to add with overflow","6427":"attempt to add with overflow","8719":"Array index out of bounds","7884":"Array index out of bounds","7750":"attempt to multiply with overflow","7939":"attempt to add with overflow","5757":"attempt to add with overflow","5946":"attempt to add with overflow","6647":"Array index out of bounds","7671":"Array index out of bounds","8372":"Array index out of bounds","5678":"Array index out of bounds","7915":"attempt to add with overflow","5733":"Array index out of bounds","5922":"Array index out of bounds","8293":"Array index out of bounds","5788":"attempt to add with overflow","8671":"attempt to multiply with overflow","1558":"Values are not equal","8726":"attempt to add with overflow","5764":"attempt to add with overflow","5685":"Array index out of bounds","6764":"attempt to add with overflow","10348":"Nested call failed!","5606":"attempt to add with overflow","7654":"attempt to add with overflow","5472":"Array index out of bounds","10537":"attempt to add with overflow","8410":"Array index out of bounds","6551":"call to assert_max_bit_size","11159":"attempt to add with overflow","11348":"Array index out of bounds","11372":"attempt to add with overflow","8331":"attempt to subtract with overflow","5826":"Array index out of bounds","8063":"attempt to add with overflow","10678":"attempt to add with overflow","10032":"Array index out of bounds","2541":"attempt to add with overflow","11245":"Array index out of bounds","5479":"Array index out of bounds","8417":"Array index out of bounds","7582":"attempt to add with overflow","7637":"Array index out of bounds","8149":"Array index out of bounds","9472":"Contract instance not found!","3194":"Nested call failed!","9015":"Array index out of bounds","5620":"Array index out of bounds","6132":"attempt to add with overflow","9070":"Array index out of bounds","10551":"attempt to add with overflow","8936":"Array index out of bounds","9448":"attempt to add with overflow","7321":"Array index out of bounds","10771":"Array index out of bounds","8967":"Array index out of bounds","5572":"attempt to add with overflow","7620":"attempt to add with overflow","5627":"Array index out of bounds","9077":"Array index out of bounds","8675":"Array index out of bounds","8730":"Array index out of bounds","5847":"attempt to add with overflow","8596":"Array index out of bounds","6225":"attempt to add with overflow","6658":"attempt to add with overflow","7682":"attempt to add with overflow","3452":"Nested call failed!","7225":"Array index out of bounds","8627":"Array index out of bounds","6768":"Array index out of bounds","5933":"attempt to add with overflow","6689":"attempt to add with overflow","5854":"attempt to subtract with overflow","7201":"attempt to add with overflow","8737":"Array index out of bounds","8335":"Array index out of bounds","11273":"attempt to multiply with overflow","6775":"Array index out of bounds","2868":"Nullifier doesn't exist!","7720":"Array index out of bounds","1820":"attempt to add with overflow","8342":"Array index out of bounds","5459":"attempt to add with overflow","5648":"attempt to add with overflow","6349":"Storage slot 0 not allowed. Storage slots must start from 1.","1662":"Calldata copy failed","10043":"attempt to add with overflow","10555":"Array index out of bounds","5490":"attempt to add with overflow","8428":"attempt to add with overflow","7593":"attempt to multiply with overflow","6490":"attempt to add with overflow","10074":"attempt to add with overflow","5521":"attempt to add with overflow","6734":"attempt to add with overflow","5899":"Array index out of bounds","7246":"attempt to add with overflow","5442":"Array index out of bounds","9026":"attempt to add with overflow","7356":"Array index out of bounds","5497":"Array index out of bounds","10050":"attempt to subtract with overflow","10562":"Array index out of bounds","5552":"attempt to add with overflow","7789":"attempt to add with overflow","10215":"Array index out of bounds","10782":"attempt to add with overflow","5528":"attempt to add with overflow","5638":"attempt to add with overflow","7363":"Array index out of bounds","6016":"Array index out of bounds","9088":"Array index out of bounds","10112":"attempt to add with overflow","6583":"Storage slot 0 not allowed. Storage slots must start from 1.","5937":"Array index out of bounds","7662":"Array index out of bounds","8686":"attempt to add with overflow","6504":"attempt to add with overflow","5858":"attempt to subtract with overflow","2463":"timestamp does not match","3676":"Nested call failed!","9631":"attempt to add with overflow","10978":"attempt to subtract with overflow","11356":"Array index out of bounds","11277":"attempt to subtract with overflow","10119":"Array index out of bounds","7236":"attempt to add with overflow","8748":"Array index out of bounds","10985":"attempt to subtract with overflow","9315":"attempt to add with overflow","8992":"Array index out of bounds","5975":"attempt to add with overflow","5652":"Array index out of bounds","6274":"attempt to add with overflow","6786":"attempt to add with overflow","11394":"attempt to add with overflow","6006":"attempt to add with overflow","7920":"Array index out of bounds","7597":"attempt to add with overflow","6439":"Storage slot 0 not allowed. Storage slots must start from 1.","5982":"attempt to add with overflow","5659":"Array index out of bounds","7707":"attempt to add with overflow","9109":"attempt to add with overflow","7250":"Array index out of bounds","8652":"Array index out of bounds","5769":"Array index out of bounds","9030":"Array index out of bounds","10054":"attempt to subtract with overflow","8384":"attempt to add with overflow","7927":"Array index out of bounds","7793":"Array index out of bounds","3563":"Nested call failed!","8927":"Array index out of bounds","7257":"Array index out of bounds","5776":"Array index out of bounds","9549":"Unexpected selector!","6288":"attempt to add with overflow","6154":"Array index out of bounds","8391":"Array index out of bounds","8769":"attempt to add with overflow","8958":"Array index out of bounds","10573":"attempt to add with overflow","8312":"attempt to add with overflow","11408":"attempt to add with overflow","8690":"Array index out of bounds","11439":"This assertion should fail!","6508":"Array index out of bounds","5862":"Array index out of bounds","9044":"attempt to multiply with overflow","11281":"attempt to add with overflow","6027":"attempt to add with overflow","5704":"attempt to add with overflow","7563":"Array index out of bounds","8587":"Array index out of bounds","7807":"attempt to add with overflow","11257":"attempt to add with overflow","6515":"Array index out of bounds","7728":"Array index out of bounds","11123":"attempt to add with overflow","8618":"Array index out of bounds","8161":"attempt to add with overflow","6034":"Stack too deep","7814":"Array index out of bounds","11075":"Array index out of bounds"}},{"name":"set_opcode_u32","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAwmAgRAAAAAAAEjJQAEeACABA0AAACABIADIQAAEIADOQEAACMrABjKGMo=","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ==","brillig_names":["set_opcode_u32"],"assert_messages":{"15":"Stack too deep"}},{"name":"assert_calldata_copy","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"args","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQDAiQCBAADHxgAAwACgEMlAgSAQwABJAIEAwMqCAECJAIEBAQAEAEEASQDBAECACgCAgQrBAABgAMrBAAEgAQrBAADgAUiABQqDAIBIgAfOACARgAAJQAEAACABw0AgAeABYAIFwCACIAIIQAAHoAIAQCAA4AHgAkrAYAJgAYBAIAEgAeACSsCgAaACQEAgAcAAoAHIAAVIyIATiQCBAADJAIEAwQqCAEFJAIEBAYAEAEGASQDBAEFACgFAgYfPAADAAQABioIAQYAAAECASQCAQEHKg4HBiQCBAEIKgwDAiAALww4AgQDIQIANgADIAAyKg0GASECADUAATkBAAAjKg0GAyQCBAMKDDgCCgshAgA7AAs5AQAAACgFAgoAOAoCCyoNCwkkAgQDCww4AgsMIQIAQgAMOQEAAAAoAQILADgLAgwqDQwKCjgJCgsEOAMLCSoOCQYAOAIIAw44AgMJIQIATAAJOQEAACoMAwIgAC8lAAR4AIAEDQAAAIAEgAMhAABSgAM5AQAAIysAGMoYyg==","debug_symbols":"tdffaoMwFAbwd8m1F+bvOfFVxijaagmIFrWDIb77dKvV2bGxze9GPPolv5AQQnpxyrPr+RCqom5F8tSLsj6mXairseqHSGRNKMtwPqw/i3h6aPWeby9pNZVtlzadSBxbF4m8Oo2vXtLYQxHKXCTa8RA9pJmluaWZrb2nJdvhORJa4wmDJyyecHiC8ATjCQ8nTPwl4bW5E8b8QHyXngiJJxSe0HiC/k9IpjktmZe0mwAb7wF4PwNe+Q3w66WeGqm/NDLoubI7AD5e5kq6DeDQAKEBRgMeDLgYDUg0oPYAVLxsad4AGg0YNGDRgEMDhAYYDey+k9cnz2OW3NwxEX0eCqEPQZJoQKEBjQYMGrBQYBiLl7QJaVbmt6tnca2Oq5to93r5+DOG3wA=","brillig_names":["assert_calldata_copy"],"assert_messages":{"58":"Array index out of bounds","52":"Calldata copy failed","65":"Array index out of bounds","81":"Stack too deep","75":"attempt to add with overflow"}},{"name":"pedersen_commit","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"public"}},"bytecode":"JAAEAQIlAASASAABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAA0rBAABgEUrBAACgEYrBAADgEc4AIBFAAMiAKAkAgAABCoIAQUkAgQFBgAQAQYBJAMEAQUAKAUCBioMBgcqDgQHACgHAgcqDgQHACgHAgcqDgQHACgHAgcqDgQHKg0FBgAoBgIGKg4GBSoIAQYAAAECASoOBQYkAgQCBCgCAAAAAAAAAAABAAAAAAAAAAAABSQCBAEHKQIAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACCQCBAAJKgwJAyAAKQw4AwQKIQIAWgAKIAAsKg0GASQCAQACKQIAIDxAI2nosrwsOCe8gqJ40yxR3Jq5XlXOFWbotiW3vOcAAykCAAVc2lPngfPu3XYLosSMbTbSoGFUTD0z52EAvUxl6JdIAAUpAgAr8lUl1KYvElI1VVndSWtouk1upl9LZpuz2nPEJFXwowAGKQIAKDkeiZ1kB+QClPql5VYatHLkPqXVTBU0O5pHy3qA7QkACCoIAQokAgQHCwAQAQsBJAMEAQoAKAoCCyoMCwwqDgUMACgMAgwqDggMACgMAgwqDgIMACgMAgwqDgMMACgMAgwqDgYMACgMAgwqDgIMKggBCyQCBAQMABABDAEkAwQBCwAoCgIMJAIEBg0AKAECDiQCBAQPACgLAhBA9wAMAA4AEAANACgLAgIAOAIJAyoNAwEAKAsCAwA4AwcFKg0FAgAoCwIFADgFBAYqDQYDHAwBAwUcDAAFBBwMAQQDIyoNBgoqCAELJAIEAwwAEAEMASQDBAELACgLAgwqDAwNKg4BDQAoDQINKg4CDSQCBAINDDgDDQ4hAgBoAA45AQAAACgLAg0AOA0DDioNDgwcDAUMDRwMAA0LAjgMCw0IOA0FDhwMBQ4PHAwADw0COA4NDwg4DwUOBDgNBQ8AOA8LDQQ4CA4LADgNCw8KOAwPCyECAHoACzkBAAAEOAMECyQCBAAPCjgPBAwhAgCCAAwGOAsEEQo4EQMQIQIAggAQOQEAACQCBAQPDDgLDxAhAgCGABA5AQAAKwQACoADJQAEAAWABCIApSsIgAUADAAoDAIPADgPCxAqDg0QADgLBwoOOAsKDSECAJEADTkBAAAkAgQEDQw4Cg0PIQIAlQAPOQEAAAAoDAINADgNCg8qDg4PKgwMCyoOCwYAOAMHCg44AwoLIQIAngALOQEAACoMCgMgACklAAR4AIAEDQAAAIAEgAMhAACkgAM5AQAAIysBgAOABgsAgAYAAoAHIQAAqYAHIACrKwCAA4AFIAC5KwAAAYAFAQAAAYAEAAElAAQAAIAJDQCACYAEgAoXAIAKgAohAAC3gAoBAIADgAmACysBgAuACAEAgAWACYALKwKACIALAQCACQACgAkgAK4lAQQAAYAFIAC5IysAGMoYyg==","debug_symbols":"5ZzRbuJADEX/Jc88zNhje6a/slpV0EKFhKACutIK8e8LtAkoqeAlN2ulLxW0Fue66rkkkHKoXuezj7fn5Xqx2VVPvw7VavMy3S8369O9w3FSzbbL1Wr59nz77Sqcv8R0md+9T9fnu7v9dLuvniSwTar5+vV8s5TTIyyWq3n1xJqPk850DKJf06eb1kxTOf6eVFHgBIUTDE7IcEJBEyjACRFOIDiB4QS40wR3muBOE9xpgjtNcKcZ7jTDnWa40wx3OvXyW8qxIWRqE/poDRKpCUwdQh+twZQbgqZbQneYTeuH5hz5OpwucdRXHPMVJ/uKU1zFkeArTvQVh3zFYV9xkq84vlpZfLWy+Gpl8dXK4quV1Vcrq69WVl+trL5aWX21svpqZfXVyuqrldVXK6uvVjZfrWy+Wtl8tbL5amXz1crmq5XNVyvb4K2cEzdxbl8y+4yTfcUpruLkwVs5KzVxTNtxoq845CvO4K2cS/1SMZcg7TjJVxzxFUf/Z5xOK2fzFSe7ilN6eX/r3vsqpY9mo1hPRyJpEwhOYDghwQkCJyicYHBChhMKmhBDwCMiHkF4BOMRCY8QPELxiD7cjqVcEfrgiZG4OT8gezBc7HpxQgjXWflmVrUOoWa3o5c1889Ys4xmzVIfa1lM7TVjGM+adWSj3FkzjmVNk1SvqdRZk37GmjyaNZtTmxw6FdTLpd1O1gz1mhQ7a8pY1sxN5PzNH62OcM3u82Yc/CiIm0sWmQu3j8ri4IcrnMq9PGX4PPFOHgrO8kRneXp5Ss3NiUMs2kEwHpHwCMEjFI8wPCLjEQWO6OX/Ch4gIh6Bt5vxdjPebsbbzXi7GW834+1mvN0Jb3fC253wdie83Qlvd8LbnfB2J7zdCW93wtsteLsFb7fg7Ra83YK3W/B2C95uAdt9PN37M90up7PV/OtTFxYf65ebD2HY/33//Mlp+B8=","brillig_names":["pedersen_commit"],"assert_messages":{"144":"attempt to add with overflow","133":"Array index out of bounds","157":"attempt to add with overflow","103":"Array index out of bounds","148":"Array index out of bounds","129":"attempt to multiply with overflow","163":"Stack too deep"}},{"name":"get_function_selector","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiABokAgQAASQCBAECKggBAyQCBAIEABABBAEkAwQBAwAoAwIEHzwAAQACAAQAKAMCBAA4BAEFKg0FAhwMBAIDHAwAAwEcDAQBAioMAgEjJQAEeACABA0AAACABIADIQAAHoADOQEAACMrABjKGMo=","debug_symbols":"zZVNCsIwEEbvMusukslPx15FRFJtJRBSaasgpXe31aoVBTcWZhMyySPfg8BMB/siPx22PpZVA9m6g1DtXOurOFRdn0Be+xD8YTs/BjEuUtz45ujiWDatq1vIVmRsAkXcj9sUhxdKHwrIlKU++aA1GjXRGme0JPOFJpJ6oomMeaM3CUjJTQi5CSluQpqbkOEmZLkJpdyE6A9CSsqHkEL7EbFaPALF8hF/6Y+Er4j0x89ZoglOhXiyiPqmg7x0FCOdfijPrvYuD8U0iMtT3M3mcns53m8G+Ao=","brillig_names":["get_function_selector"],"assert_messages":{"29":"Stack too deep"}},{"name":"check_selector","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiABwkAgQAASQCBAECKggBAyQCBAIEABABBAEkAwQBAwAoAwIEHzwAAQACAAQAKAMCBAA4BAEFKg0FAhwMBAIDHAwAAwEcDAQBAiYCBNq3lLEAAQo4AQIDIQIAGwADOQEAACMlAAR4AIAEDQAAAIAEgAMhAAAggAM5AQAAIysAGMoYyg==","debug_symbols":"zZbdqoMwDIDfpddeNOmP0Vc5HEbddBRKHeoOHMR3nzr3xwYDGSM3pWm/NB8UQnqxK4vjfuNjVbci/+lFqLeu83Uco35IRNH4EPx+c38s5LRkM94eXJyitnNNJ3KQGWaJKONu3mszPlH5UIpcWRqSJ16jUQuuMcUrDWRe0ESgF5rImAf6NxEg+SkBPyXkp6T4KWl+SoafkuWnlH5ESQFclBTapyL0jSLZF4rgh3om4a1I+uYHLdECp1JeWUQ9CwE3IeQm9L5bggT7IDSl6XVpZl2aXZE2jOGfa7wrQrnMH9Uxbu/Gke7/cL4Z4RM=","brillig_names":["check_selector"],"assert_messages":{"26":"Unexpected selector!","31":"Stack too deep"}},{"name":"nullifier_exists","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiAA8eAgAAAjA4AAEAAgADKgwDASMlAAR4AIAEDQAAAIAEgAMhAAATgAM5AQAAIysAGMoYyg==","debug_symbols":"hZDdCoMwDEbfJddeLK32x1cZQ6pWKZQqWgdDfPdVp5sywZuSrzmEk4xQ6nyoM+Oqpof0PoJtCuVN40Iapwjyzlhr6mz/Dbf5QVz4vlVujr1XnYcUCSEiAu3KpY5FmFEZqyGlLNR/PJUsWXEqefylUSQnNIsFrjSLJT/QjwiQnCuhJD8lZBdKSBK54RSTCyXO6bYv5wKPSlOIT9UZlVu9HrQaXLG7r3+1n06A3w==","brillig_names":["nullifier_exists"],"assert_messages":{"18":"Stack too deep"}},{"name":"add_args_return","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAsrBAABgEU4AIBFAAEiAA8AOAECAyoMAwEjJQAEeACABA0AAACABIADIQAAE4ADOQEAACMrABjKGMo=","debug_symbols":"TY3BCsMwDEP/xece0g26Lb8yRnHapBiMU5J0MEL+fe7WQy/GTxJShdm7bRlJQsxgnxU4TlgoilJtHbhEzLSMZxnMfvrLL59XlB1zwVTA9sPDdOBl1vdmjDYEYg/2Otzbqym+MRE69kd/2GQ6zZXP+nc0/AU=","brillig_names":["add_args_return"],"assert_messages":{"18":"Stack too deep"}},{"name":"note_hash_exists","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"note_hash","type":{"kind":"field"},"visibility":"private"},{"name":"leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAsrBAABgEU4AIBFAAEiAA8uOAABAAIAAyoMAwEjJQAEeACABA0AAACABIADIQAAE4ADOQEAACMrABjKGMo=","debug_symbols":"bc9LCsMgEAbgu8w6i5rGR7xKKUETDYJoUFMokrvXpFJS2o3M73wMMxkmJdd5ME77CPyWwfpRJONdSXlrQAZjrZmH8zdc9ge1h4+LcHuMSYQEHCGCuwaUm46asjJDG6uAX0mpf3zftVX3DH0sYviPpRixiikm3Ze+byU+RDBCWlV316sbT6ek5/LuFPwC","brillig_names":["note_hash_exists"],"assert_messages":{"18":"Stack too deep"}},{"name":"create_same_nullifier_in_nested_call","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"nestedAddress","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAo4AIBFAAAiAFQxAgACKggBBAAAAQIBJAIEAQUqDgUEKggBBgAAAQIBJgIA2X0MigAHJAIEAQkkAgQCCwA4CQsKKggBCAAQAQoBJAMEAQgAKAgCCioOCQokAgQCCgA4CAoJKgwJCioOBwoqDggGJAIEAAcqDAcDIAAjCjgDBwghAgBBAAggACYqDQQCKg0GAykCADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAAAQqCAEFJAIEAwYAEAEGASQDBAEFACgFAgYqDAYHKg4EBwAoBwIHKg4EByYCANVEGw0ABgAoBQIHACgDAgoqDQoJACgKAggqCAEKAAABAgEkAwQBCgAoCgIMNj+VAAcAAQAIAAkADAAAAAsABiQCAgEBCjgLAQIhAgBAAAI5AQAAIwo4AwcIIQIARAAIOQEAACoNBAgqDQYJACgIAgorBAAJgAMlAAQAAYAEIgBZKwiABQALKwiABgAMKg4CDCoNCwgAKAgCCCoOCAsqDgoEKg4LBioMBQMgACMlAAR4AIAEDQAAAIAEgAMhAABYgAM5AQAAIwEAgAMAAoAHKwGAB4AHAQCAB4AEgAglAAQAAoAKAQCACIAKgAkrAAABgAUBAAABgAkAASUBBAABgAUBAIAFAAKACSsCgAiACSUABAACgAoBAIADgAqACSUABAACgAsBAIAFgAuACiUABAAAgAwNAIAMgAeADRcAgA2ADSEAAHGADQEAgAmADIAOKwGADoALAQCACoAMgA4rAoALgA4BAIAMAAKADCAAaAEAgAqAB4AGIysAGMoYyg==","debug_symbols":"1ZvdboJAEIXfZa+5YGZ39sdXaRqDioaEoFFs0hjfvUgFtVr20j03xtUjfpO4fmEGTmpVLo6bedWstwc1+ziperss2mrbdKvTOVOLfVXX1WZ+/7LKLw9Eff6wK5rL8tAW+1bNyHjiTJXNqn+uTXeMdVWXaqatP2dPee3dENc+uDFNXl6knTf5Ne26Dz6kPzNF/A+SyIgUiCJIVswQt+L07UsCvUiz1UMBbF0eLSBcwz73Y5bZ9PgaG99g4ws2vsXGd9j4Hhs/QONzjo1P2PjY1mVs6zK2dRnbuoxtXca2LmNbl7Gtq7Gtq7Gtq5P/4yRLAz9ZvjUCbH+urpPfu2SNHflt/pc/+c07zW/esXtdPrRv2OtYs8cbpuH3bxw9pC8FEHoBjF6ARi/AoBcg6AVY9AIcegEevYAAXoCgm1jQTSzoJhZ0Ewu6iQXdxIJuYkE3saCbWNBNbN9h4jAenIN1T0iUHhKnh6TTQwLvz9nkJxsR/uRHGxF+gP7oJD9Af3SK3yU/3Zju77rkxxsR/uSvKojwJ39ZQYTfgPMD+HeSH8C/k/wA/p3kB59POvD5pAf3r4f277lbfRX7qljU5fVOgPWxWd7dGNB+737f6cI/","brillig_names":["create_same_nullifier_in_nested_call"],"assert_messages":{"87":"Stack too deep","63":"Nested call failed!","67":"Index out of bounds"}},{"name":"add_u128","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"a","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"private"},{"name":"b","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"},"visibility":"public"}},"bytecode":"JAAEAQIlAASASQABJAAEAwAkAgQEBSQCBAAGHxgABgAFgEMrCIBDAAErCIBEAAIrCIBFAAMrCIBGAAQiAA4rBAABgEcrBAACgEg4AIBHAAIiAB4AOAEDBRwMBQUDHAwAAwECOAUBAygCAAAAAAAAAAABAAAAAAAAAAAABQg4AwUGADgCBAMAOAMGAhwMBQIEHAwABAMKOAMCBCECABwABDkBAAAqDAMCIyUABHgAgAQNAAAAgASAAyEAACKAAzkBAAAjKwAYyhjK","debug_symbols":"tdTRCsIgFAbgdznXuzjq1LlXiQhXWwjiYltBjL17VsuGu9Ub8eiPHyieGS5tc7+ejOv6EerDDLY/68n0zlfzUkAzGGvN9bRdBnwPhH/y4027dzlOepigJkJhAa27+KlE9Cd0xrZQM1EtxS7Nkas1zVGykPbhYwFEpBAU/QkEaSzI7EKVQCCsDEK5E1QSgQWBk0igmF0gKQT5f4dKxAJNLKgyFlgCgZJwS5TuhDK7kOJPU45BEBgLIrsg8wqLrx56MLqx7doku7s7b3rm9Lx9d3z4BQ==","brillig_names":["add_u128"],"assert_messages":{"33":"Stack too deep","27":"attempt to add with overflow"}},{"name":"keccak_hash","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["keccak_hash"],"assert_messages":{"288":"Array index out of bounds","189":"Array index out of bounds","346":"Array index out of bounds","227":"Array index out of bounds","276":"attempt to multiply with overflow","308":"attempt to add with overflow","433":"attempt to add with overflow","465":"Stack too deep","354":"Array index out of bounds","223":"attempt to add with overflow","415":"attempt to add with overflow","447":"Array index out of bounds","246":"attempt to add with overflow","406":"attempt to add with overflow","208":"attempt to add with overflow","333":"attempt to add with overflow","234":"Array index out of bounds","263":"Array index out of bounds","365":"attempt to add with overflow","458":"attempt to add with overflow","219":"attempt to multiply with overflow","280":"attempt to add with overflow","283":"Index out of bounds","341":"Index out of bounds","376":"attempt to multiply with overflow","440":"Array index out of bounds","297":"Array index out of bounds","419":"Array index out of bounds"}},{"name":"set_storage_list","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"a","type":{"kind":"field"},"visibility":"private"},{"name":"b","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAo4AIBFAAAiAC4kAgACBCQCBAIFJAIEAQYkAgQAByoMBwMgABEMOAMFByECABUAByAAFCMcDAADBwA4BAcIKggBByQCBAMJABABCQEkAwQBBwAoBwIJKgwJCioOAQoAKAoCCioOAgokAgQCCgw4AwoLIQIAJAALOQEAAAAoBwIKADgKAwsqDQsJLQwACQAIADgDBgcOOAMHCCECACwACDkBAAAqDAcDIAARJQAEeACABA0AAACABIADIQAAMoADOQEAACMrABjKGMo=","debug_symbols":"1ZjBioMwEED/JWcPSSaJib+yLEVbLQHRonZhEf99za5rW9Km15mLOPqIz4sPM7NTXV3PB981/ciKj5m1/bGcfN+t07xkrBp82/rz4f4y4+Eg8l9+vJRdGMepHCZWSDB5xuruFE6tXldofFuzAoxdsogW0tiNFtKpnRYgntCG8/+1DZfuRofnRLTOndtobTl/oD8zJgVyfavUrq9VpC+x60uX0gfs+trs+kZH+oq2vqatb2jrY/9wvtG3tPUdaX3gtPXRVzetj766aX3a1QXa1QXa1QXa1QXa1QXa1QX01RX6pm/e0E4AbLQTefRzo9A3+vXLBn30jU7ro290Wh99oxP6yzp+lYMvq7beNpCaa3e820+avi9/d1b4Bw==","brillig_names":["set_storage_list"],"assert_messages":{"35":"Array index out of bounds","49":"Stack too deep","43":"attempt to add with overflow"}},{"name":"set_storage_single","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"a","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiACokAgABAyQCBAAEJAIEAQUqDAQCIAAPCjgCBAYhAgATAAYgABIjHAwAAgYAOAMGByoIAQYkAgQCCAAQAQgBJAMEAQYAKAYCCCoMCAkqDgEJJAIEAQkMOAIJCiECACAACjkBAAAAKAYCCQA4CQIKKg0KCC0MAAgABwA4AgUGDjgCBgchAgAoAAc5AQAAKgwGAiAADyUABHgAgAQNAAAAgASAAyEAAC6AAzkBAAAjKwAYyhjK","debug_symbols":"1ZjRboMgFED/hWcfgAsI/sqyNNpqQ0KwUbtkMf77dHO2my19vffFePXEHF84hJGd6up6PvjYtD0r3kYW2mM5+DbO0zhlrOp8CP58uH/M+HIR+pvvL2Vcxn4ou4EVwimZsTqellsj5y80PtSsAGOnbE9LY39p6dRGCxAPaMN5vtKGS3ejrX5A69y5ldaW8z/0e8aEQ65vldr0tfqvLzl2felS+gK7vjabvtE7fUlbH2jrK9r62BfOF/qGtn5OW9/S1kdf3aQ+oK9uWp92dYF2dYF2dYF2dQF9dYW+6ZsXtBMAK+1EvtteA/pGP//ZRR99o9P66Bud1kff6IT+NI8fZefLKtTrEUZzjce7E43h8/LzZoa/AA==","brillig_names":["set_storage_single"],"assert_messages":{"31":"Array index out of bounds","45":"Stack too deep","39":"attempt to add with overflow"}},{"name":"assert_timestamp","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"expected_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMdAAWAQ4BDKwiAQwABIgAKOACARAAAIgAQHgIHAAIKOAIBAyECAA8AAzkBAAAjJQAEeACABA0AAACABIADIQAAFIADOQEAACMrABjKGMo=","debug_symbols":"nZDRCoQgEEX/ZZ590LS0fmVZwspCEIuyhSX699VWotjtpZdh7sy5w2UWaFQ1d6W2bT9B8VjA9LV0urdeLSuCatTG6K48jgGHQsjGT4O0QU5Ojg4KgnmaIVC22XpO/Y1WGwUFzcSKfngmOI04E4LtNBHpH5rjlESa4yw/0U8EJLmIlCd7JJGcIwUbvWdjN2yrly85alkZFV/czrY+fNy9h+/Gwx8=","brillig_names":["assert_timestamp"],"assert_messages":{"14":"timestamp does not match","19":"Stack too deep"}},{"name":"bulk_testing","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"args_field","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"args_u8","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null},"bytecode":"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ESMAKCMCIyoOCSMAKCMCIyoOCyMAKCMCIyoOEyMAKCMCIyoOGCMAKCMCIyoOECMkAgQuICoIAC4qDB8vABAAIAAiDr4qBAAAHgIHAB8qCAEgJAIEEyMAEAEjASQDBAEgACggAiMqDCMkKg4KJAAoJAIkKg4RJAAoJAIkKg4LJAAoJAIkKg4SJAAoJAIkKg4WJAAoJAIkKg4RJAAoJAIkKg4RJAAoJAIkKg4SJAAoJAIkKg4QJAAoJAIkKg4RJAAoJAIkKg4IJAAoJAIkKg4SJAAoJAIkKg4EJAAoJAIkKg4oJAAoJAIkKg4SJAAoJAIkKg4KJAAoJAIkKg4TJAAoJAIkKg4JJCQCBC4jKggALioMIC8AEAAjACINAioEAAAeAggAICoIASMkAgQTJAAQASQBJAMEASMAKCMCJCoMJCUqDgolACglAiUqDhElACglAiUqDgslACglAiUqDhIlACglAiUqDhYlACglAiUqDhElACglAiUqDhElACglAiUqDhIlACglAiUqDhAlACglAiUqDhElACglAiUqDgglACglAiUqDhIlACglAiUqDhklACglAiUqDhMlACglAiUqDhIlACglAiUqDgolACglAiUqDhMlACglAiUqDgklJAIELiQqCAAuKgwjLwAQACQAIg0CKgQAAB4CCQAjKggBJCQCBBAlABABJQEkAwQBJAAoJAIlKgwlJioOCiYAKCYCJioOESYAKCYCJioOCyYAKCYCJioOEiYAKCYCJioOBCYAKCYCJioOKCYAKCYCJioOEiYAKCYCJioOCiYAKCYCJioOEyYAKCYCJioOCSYAKCYCJioOEiYAKCYCJioOBCYAKCYCJioOESYAKCYCJioOFiYAKCYCJioOCyYkAgQuJSoIAC4qDCQvABAAJQAiDaYqBAAAHgILACQqCAElJAIEECYAEAEmASQDBAElACglAiYqDCYnKg4KJwAoJwInKg4RJwAoJwInKg4LJwAoJwInKg4SJwAoJwInKg4ZJwAoJwInKg4TJwAoJwInKg4SJwAoJwInKg4KJwAoJwInKg4TJwAoJwInKg4JJwAoJwInKg4SJwAoJwInKg4EJwAoJwInKg4RJwAoJwInKg4WJwAoJwInKg4LJyQCBC4mKggALioMJS8AEAAmACINpioEAAAeAgwAJSoIASYkAgQVJwAQAScBJAMEASYAKCYCJyoMJykqDhEpACgpAikqDhgpACgpAikqDhQpACgpAikqDgspACgpAikqDhIpACgpAikqDhwpACgpAikqDgwpACgpAikqDhEpACgpAikqDgwpACgpAikqDiEpACgpAikqDggpACgpAikkAgJ5KioOKikAKCkCKSoOECkAKCkCKSoOCykAKCkCKSoOESkAKCkCKSoOGSkAKCkCKSoOEikAKCkCKSoOBCkAKCkCKSoODSkAKCkCKSoOCikAKCYCJwAoGwIuKg0uKwAoLgIpOzsAJwAUACkAKyQCBC4QKggALgAQABAAIg++KgQAACoIARAkAgQRJgAQASYBJAMEARAAKBACJioMJicqDgwnACgnAicqDg0nACgnAicqDgsnACgnAicqDhEnACgnAicqDhInACgnAicqDiInACgnAicqDhMnACgnAicqDgknACgnAicqDiInACgnAicqDhInACgnAicqDhEnACgnAicqDi0nACgnAicqDhQnACgnAicqDgknACgnAicqDgsnACgnAicqDgknJAIELiYqCAAuKgwQLwAQACYAIg0tKgQAAC44AA4ABwAQKggBJiQCBA4nABABJwEkAwQBJgAoJgInKgwnKSoODCkAKCkCKSoOESkAKCkCKSoOLCkAKCkCKSoOEikAKCkCKSoODCkAKCkCKSoODSkAKCkCKSoOCykAKCkCKSoOESkAKCkCKSoOEikAKCkCKSoOIikAKCkCKSoOEykAKCkCKSoOCSkAKCkCKSoOIikkAgQuJyoIAC4qDCYvABAAJwAiDr4qBAAALwIADioIASIkAgQOJgAQASYBJAMEASIAKCICJioMJicqDgwnACgnAicqDhEnACgnAicqDiwnACgnAicqDhInACgnAicqDgwnACgnAicqDhwnACgnAicqDgQnACgnAicqDgQnACgnAicqDhQnACgnAicqDhYnACgnAicqDhQnACgnAicqDhEnACgnAicqDggnJAIELiYqCAAuKgwiLwAQACYAIg6+KgQAADECAA4qCAEiJAIEESYAEAEmASQDBAEiACgiAiYqDCYnKg4MJwAoJwInKg4cJwAoJwInKg4EJwAoJwInKg4EJwAoJwInKg4UJwAoJwInKg4WJwAoJwInKg4UJwAoJwInKg4RJwAoJwInKg4IJwAoJwInKg4SJwAoJwInKg4RJwAoJwInKg4tJwAoJwInKg4UJwAoJwInKg4JJwAoJwInKg4LJwAoJwInKg4JJyQCBC4mKggALioMIi8AEAAmACINLSoEAAAeAgAACDA4AA4ACAAWJAICMQgqCAEcJAIEFCIAEAEiASQDBAEcACgcAiIqDCImKg4EJgAoJgImKg4IJgAoJgImKg4SJgAoJgImKg4LJgAoJgImKg4NJgAoJgImKg4SJgAoJgImKg4EJgAoJgImKg4oJgAoJgImKg4SJgAoJgImKg4YJgAoJgImKg4JJgAoJgImKg4KJgAoJgImKg4SJgAoJgImKg4RJgAoJgImKg4tJgAoJgImKg4UJgAoJgImKg4JJgAoJgImKg4LJgAoJgImKg4JJiQCBC4iKggALioMHC8AEAAiACIPrCoEAAAyOAAOAAcAHCoIASIkAgQSJgAQASYBJAMEASIAKCICJioMJicqDgknACgnAicqDhEnACgnAicqDgwnACgnAicqDhknACgnAicqDhInACgnAicqDgQnACgnAicqDignACgnAicqDhInACgnAicqDgsnACgnAicqDg0nACgnAicqDhInACgnAicqDgQnACgnAicqDggnACgnAicqDhInACgnAicqDhgnACgnAicqDgknACgnAicqDgonJAIEKSYqCAApKgwiKgAQACYAIg0/KgQAACUCACAgAAg1DAAIAA4qCAEIJAIEEwoAEAEKASQDBAEIACgIAgoqDAoYKg4MGAAoGAIYKg4RGAAoGAIYKg4JGAAoGAIYKg4LGAAoGAIYKg4RGAAoGAIYKg4ZGAAoGAIYKg4SGAAoGAIYKg4hGAAoGAIYKg4TGAAoGAIYKg4EGAAoGAIYKg4EGAAoGAIYKg4SGAAoGAIYKg4LGAAoGAIYKg4NGAAoGAIYKg4SGAAoGAIYKg4TGAAoGAIYKg4ZGAAoGAIYKg4ZGCQCBCYKKggAJioMCCcAEAAKACINAioEAAAeAgAACCYCAKpjSKEACiQCBAEiJAIEAicAOCInJioIARgAEAEmASQDBAEYACgYAiYqDiImJAIEAiYAOBgmIioMIiYqDgomJAIEAiYkAgQCKAA4JignKggBIgAQAScBJAMEASIAKCICJyoOJickAgQCJwA4IicmKgwmJyoODicAKCcCJyoOByckAgQpKCoIACkqDA8qKgwYKyoMFywqDCIt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","debug_symbols":"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","brillig_names":["bulk_testing"],"assert_messages":{"2816":"Array index out of bounds","3328":"Stack too deep","4541":"Array index out of bounds","3127":"attempt to add with overflow","1457":"Array index out of bounds","2670":"attempt to add with overflow","4529":"attempt to add with overflow","3036":"Array index out of bounds","275":"Storage slot 0 not allowed. Storage slots must start from 1.","3280":"attempt to add with overflow","397":"Storage slot 0 not allowed. Storage slots must start from 1.","4560":"attempt to add with overflow","2823":"Array index out of bounds","4548":"Array index out of bounds","385":"attempt to add with overflow","3201":"Array index out of bounds","4536":"attempt to add with overflow","3055":"attempt to add with overflow","3110":"Array index out of bounds","2842":"attempt to add with overflow","3287":"Array index out of bounds","2641":"attempt to add with overflow","4488":"Array index out of bounds","3074":"Array index out of bounds","3964":"attempt to add with overflow","3696":"attempt to add with overflow","2794":"Array index out of bounds","3294":"Array index out of bounds","2715":"Array index out of bounds","3550":"Array index out of bounds","3093":"attempt to add with overflow","3672":"attempt to add with overflow","2703":"Array index out of bounds","3660":"Array index out of bounds","3081":"Array index out of bounds","3002":"attempt to add with overflow","2935":"Array index out of bounds","4404":"attempt to add with overflow","2801":"attempt to add with overflow","4794":"attempt to add with overflow","2923":"attempt to multiply with overflow","2600":"Array index out of bounds","4770":"Array index out of bounds","4447":"Array index out of bounds","3155":"attempt to add with overflow","4435":"attempt to add with overflow","2954":"attempt to add with overflow","4612":"attempt to add with overflow","2942":"Array index out of bounds","3710":"attempt to add with overflow","4411":"attempt to subtract with overflow","3253":"attempt to add with overflow","370":"Storage slot 0 not allowed. Storage slots must start from 1.","2674":"Array index out of bounds","492":"Storage slot 0 not allowed. Storage slots must start from 1.","1449":"Array index out of bounds","4454":"Array index out of bounds","2772":"attempt to add with overflow","3473":"Array index out of bounds","2961":"attempt to add with overflow","3028":"attempt to add with overflow","2882":"attempt to add with overflow","2626":"attempt to multiply with overflow","1212":"Array index out of bounds","2681":"attempt to add with overflow","3193":"Array index out of bounds","4473":"attempt to add with overflow","1200":"Array index out of bounds","3370":"attempt to add with overflow","1188":"Array index out of bounds","2724":"attempt to add with overflow","2846":"Array index out of bounds","1176":"Array index out of bounds","2645":"Array index out of bounds","2834":"Array index out of bounds","3212":"attempt to add with overflow","2889":"attempt to subtract with overflow","3968":"Array index out of bounds","4480":"Array index out of bounds","3066":"attempt to multiply with overflow","3322":"attempt to add with overflow","3188":"Index out of bounds","3700":"Array index out of bounds","4590":"Array index out of bounds","2731":"Array index out of bounds","3688":"attempt to multiply with overflow","1439":"Array index out of bounds","793":"attempt to add with overflow","4499":"attempt to add with overflow","781":"Array index out of bounds","3853":"attempt to add with overflow","3975":"Array index out of bounds","3652":"attempt to subtract with overflow","4420":"Array index out of bounds","3262":"attempt to add with overflow","2805":"Array index out of bounds","2927":"attempt to subtract with overflow","3305":"attempt to add with overflow","3561":"attempt to add with overflow","2659":"attempt to multiply with overflow","4585":"Index out of bounds","4506":"Array index out of bounds","4762":"Array index out of bounds","1221":"Array index out of bounds","2757":"attempt to multiply with overflow","3135":"Array index out of bounds","2812":"attempt to add with overflow","1465":"Array index out of bounds","4415":"attempt to subtract with overflow","3123":"attempt to multiply with overflow","2855":"attempt to add with overflow","4635":"Array index out of bounds","2776":"Array index out of bounds","2965":"Array index out of bounds","2630":"Array index out of bounds","2685":"Array index out of bounds","3130":"Index out of bounds","4654":"attempt to add with overflow","2984":"attempt to add with overflow","2594":"Nested static call failed!","3362":"Array index out of bounds","2972":"Array index out of bounds","2893":"Array index out of bounds","2692":"Array index out of bounds","3070":"attempt to add with overflow","3314":"Array index out of bounds","2991":"Array index out of bounds","3180":"attempt to add with overflow","3692":"attempt to subtract with overflow","2790":"attempt to multiply with overflow","3491":"attempt to add with overflow","3680":"attempt to add with overflow","2912":"attempt to add with overflow","4393":"Array index out of bounds","1431":"Array index out of bounds","2711":"attempt to add with overflow","3223":"attempt to multiply with overflow","3144":"Array index out of bounds","3010":"Array index out of bounds","3266":"Array index out of bounds","2931":"attempt to subtract with overflow","2864":"Array index out of bounds","4467":"attempt to add with overflow","2474":"Nested call failed!","2663":"Array index out of bounds","4010":"Contract instance not found!","4778":"Array index out of bounds","3986":"attempt to add with overflow","2761":"Array index out of bounds","3017":"Array index out of bounds"}},{"name":"assert_same","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAsrBAABgEU4AIBFAAEiABEKOAECAyECAA8AAzkBAAAkAgABASMlAAR4AIAEDQAAAIAEgAMhAAAVgAM5AQAAIysAGMoYyg==","debug_symbols":"nY/BCsMgEET/Zc8emlps6q+UEjTRsCBrUFMo4r9X2xxyTS7Lvt2ZgckwGb3OA5L1EeQzg/OjSuipUi4MdEDncB72Z7i00V1/+rgoahiTCgmkED1nYGhq6+NeEyw6A5KLvrwYdPyM6XbYVCq+VUClndma2JXGXbH0Wf6fKv4C","brillig_names":["assert_same"],"assert_messages":{"20":"Stack too deep","14":"Values are not equal"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnNaoNAFEDhd5m1C43O/cmrlBI00SCIBjWFIr57J20ogazPRubq9ey+1Wzh0jb366kfu2kJx48tDNO5XvtpTNO2Z6GZ+2Hor6fX1yF/PKrqd3+51eNjXNZ6XsOxVM9CO17Syar0f9cPbTqL7dnbrh6eq6r/m9H3zyxUEWwL2FawbWDbuXbMwXYBtg9guwTboMsIuoygywi6jKDLCLoU0KWALgV0KaBLAV0K6FJAlwK6FNClgC4VdKmgSwVdKuhSQZcKulTQpYIuFXSpoEsDXRro0kCXBro00KWBLg10aaBLA10a6NJBlw66dNClgy4ddOmgSwddOujSQZcOuizynIwXZPxAxksyXpHxSMaFjCsZNzJOCi1IoQUptMCE7mn6que+bob2eQfS3cfzy5XI+n37+5KWfwA=","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"variable_base_msm","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAsrBAABgEMrBAACgEQrBAADgEU4AIBDAAMiAE0kAgAUASoIAQIkAgQHAwAQAQMBJAMEAQIAKAICAyoMAwQkAgABBSoOBQQAKAQCBCkCAAAAAAAAAAACzxNedQakXWMtJw1F8RgSlIM/xI2CPycsAAYqDgYEACgEAgQkAgEAByoOBwQAKAQCBCoOBQQAKAQCBCoOBgQAKAQCBCoOBwQqCAEDJAIEBQQAEAEEASQDBAEDACgDAgQqDAQIJAIAAwkqDgkIACgIAggkAgAACioOCggAKAgCCCoOAQgAKAgCCCoOCggqCAEEJAIEBAgAEAEIASQDBAEEACgCAggkAgQGCwAoAwIMJAIEBA0AKAQCDkD3AAgADAAOAAskAgQAAQAoBAIDADgDAQUqDQUCJAIEAQEAKAQCBQA4BQEGKg0GAyQCBAIBACgEAgYAOAYBByoNBwUcDAEFBBwMAAQBHAwBAQQqDAIBKgwDAioMBAMjJQAEeACABA0AAACABIADIQAAUYADOQEAACMrABjKGMo=","debug_symbols":"tdjBboJAEIDhd9kzB3Znhl18laYxqGhICBrFJo3h3YstVaJX/gthYMJ/+jjsze3qzfWwbrr98eJWHzfXHrdV3xy7cboNmducm7ZtDuv5Y5ffLz787l9OVXcfL3117t1KUxEyV3e78bbMbfzCvmlrt5IiDdnbtsQiTtuSvDy2gw6fmfOCFxQvGF4o8ELECwkvlHQh5HjB4wXcdMBNB9x0wE0H3HTATQfcdMBNC25acNOCmxbctOCmBTctuGnBTQtuWnDTiptW3LTiphU3rbhpxU0rblpx04qbVty04aYNN224acNNG27acNOGmzbctC1hOqk8ChZfCyVdKHK84PHCEqaf25Ji8VoQvKB4wfDCEqZT6f8L8+2pEPFCwgslXYj5woW3P1/0eCGwhWGcvqpzU23aejqE31+77exMvv8+/b0Zl38A","brillig_names":["variable_base_msm"],"assert_messages":{"80":"Stack too deep"}},{"name":"nullifier_collision","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiAA0xAgABMQIAASMlAAR4AIAEDQAAAIAEgAMhAAARgAM5AQAAIysAGMoYyg==","debug_symbols":"vZBBDoMgEEXvMmsWICroVZrGoKIhIWgEmzSEuxctbWzq2s1k/sybyc/30Mt2HRtlhslCffOgp044NZmofEDQLkprNTbHMeCtELzzdhZmk9aJxUFNsqogCKTp957R+GNQWkJNSx7QH085yxJOecW+NOHFCc14jhPN4uEPfUdAyKklirPyY4ninF9nKUT5EIsSrZYp0GE13SFf95zfmwi/AA==","brillig_names":["nullifier_collision"],"assert_messages":{"16":"Stack too deep"}},{"name":"nested_call_to_add_with_gas","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"},{"name":"l2_gas","type":{"kind":"field"},"visibility":"private"},{"name":"da_gas","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASASAABJAAEAwAkAgQEBSQCBAAGHxgABgAFgEMrCIBDAAErCIBEAAIrCIBFAAMrCIBGAAQiAA0rBAABgEc4AIBHAAEiAHceAgAABioIAQcAAAECASQCBAEIKg4IByoIAQkAAAECASYCAKpjSKEACiQCBAEMJAIEAg4AOAwODSoIAQsAEAENASQDBAELACgLAg0qDgwNJAIEAg0AOAsNDCoMDA0qDgoNKg4LCSQCBAAKJAIBAQskAgQCDCoMCgUgACgMOAUMDSECAEkADSAAKyoNBwEqDQkCJgIA1UQbDQAFKggBByQCBAMIABABCAEkAwQBBwAoBwIIKgwICSoOAwkAKAkCCSoOBAkAKAcCCAAoAgIMKg0MCwAoDAIJKggBDCQCBAINABABDQEkAwQBDAAoDAIONj+VAAgABgAJAAsADgABAA0ABSQCAgEBCjgNAQIhAgBFAAI5AQAAACgMAgIAOAIKAyoNAwEjDDgFDA0hAgBMAA05AQAAJAIEAg4kAgQCEAA4DhAPKggBDQAQAQ8BJAMEAQ0AKA0CDyoODg8kAgQCDwA4DQ8OKgwODyoOAQ8AKA8CDyoOAg8AKA0CDyoNDw8MOAUPECECAF8AEDkBAAAkAgQCEAA4DRAPADgPBRAqDRAOKg0HDSoNCQ8AKA0CECsEAA+AAyUABAABgAQiAHwrCIAFABErCIAGABIqDg4SKg0RDQAoDQINKg4NESoOEAcqDhEJADgFCA0OOAUNDiECAHUADjkBAAAqDA0FIAAoJQAEeACABA0AAACABIADIQAAe4ADOQEAACMBAIADAAKABysBgAeABwEAgAeABIAIJQAEAAKACgEAgAiACoAJKwAAAYAFAQAAAYAJAAElAQQAAYAFAQCABQACgAkrAoAIgAklAAQAAoAKAQCAA4AKgAklAAQAAoALAQCABYALgAolAAQAAIAMDQCADIAHgA0XAIANgA0hAACUgA0BAIAJgAyADisBgA6ACwEAgAqADIAOKwKAC4AOAQCADAACgAwgAIsBAIAKgAeABiMrABjKGMo=","debug_symbols":"1ZzBauswEEX/xessNCN5NJNfeTyK0ybFYJySpA8eIf9eO7WdlLbSplDdTYiTQT4XLI7tETpXT9vN6/ND2+/2x2r951x1+8fm1O774eh8WVWbQ9t17fPD/c+VGz8oXOuPL00/Hh5PzeFUrclHDqtq2z9dv4cwjLFru2219qKX1ad6b1JP5d7irZq0/qJagtJULcHih+q/q4rqb5CIFyQVl0EK6uaTBGW7ncToi2oWPw/OEl0mQFSbitXpUsscrviCjR+x8RUb36Dx2WHjEzY+Y+N7bPyAjY9tXca2LmNbl7Gty9jW9djW9djW9djW9djW9djWDcVPXRKa+Un49mgv12f1UPzVQxJk4b8jmfiLv3wy/L9x1xadm/nVxwy/Bp7H1hDpQ/UYQNADRPQAih7AwAPUDj0AoQdg9AAePUBAD4Bu4hrdxDW6iWt0E9foJhZ0Ewu6iQXdxIJuYkE3sfyGia2eF0CwyaclDSLlIcXykLQ8pJ8xmsmCZOMlnUQijurn0VnJMtOBwwLDw8xYqtnZGCE6/AiEHwHgRWnqRW8M4PzFt7cz/MX3tzP8xTe4M/zFd7gz/MW3uNP8Ct4o0+Kb3Bn+4rvcGX5w/yq4fxXcvwruXwX3r4L7V8H9a+D+NXD/Grh/Ddy/Bu5fA/evgfvXwP1r4P41cP+SAxcwOQADp5ZakgNQcDoA+GJdcgASTgcAsHA6AICG0wEAPJwOACDidAAAEycDEICJ0wHQTUzoJiZ0ExO6icvfZCQXANrEl+HoX3Nom023nfao2b32j3db1pz+v7z/MxS/AQ==","brillig_names":["nested_call_to_add_with_gas"],"assert_messages":{"122":"Stack too deep","68":"Nested call failed!","116":"attempt to add with overflow","94":"Array index out of bounds","75":"Index out of bounds"}},{"name":"get_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgAAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc/hCoMgEAfwd7nPfSgs015ljNDSEERDbTDEd59uMhrri/i/+3HcRVgFP7ZZGWk9TLcI2i4sKGtyiqkB7pTWapvPZWjL07Vv73dmSvSBuQATxRg1IMxavgTlCVJpARPCJDV/GlE8VI3o2H91R4YLjXvSVY17Ov7oe8rxwZxiXIu6uzzMcjolPPdPJ+MX","brillig_names":["get_address"],"assert_messages":{"15":"Stack too deep"}},{"name":"sha256_hash","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["sha256_hash"],"assert_messages":{"384":"attempt to add with overflow","317":"Array index out of bounds","305":"attempt to multiply with overflow","366":"attempt to add with overflow","488":"attempt to subtract with overflow","354":"Array index out of bounds","546":"attempt to add with overflow","275":"Array index out of bounds","336":"attempt to add with overflow","528":"attempt to subtract with overflow","324":"Array index out of bounds","516":"attempt to add with overflow","309":"attempt to subtract with overflow","373":"Array index out of bounds","294":"attempt to add with overflow","410":"attempt to add with overflow","343":"attempt to add with overflow","532":"attempt to add with overflow","392":"Array index out of bounds","508":"attempt to add with overflow","313":"attempt to subtract with overflow","496":"Array index out of bounds","417":"Stack too deep","347":"Array index out of bounds","536":"Array index out of bounds","143":"attempt to add with overflow","524":"attempt to multiply with overflow","271":"attempt to subtract with overflow","399":"Array index out of bounds","131":"Array index out of bounds"}},{"name":"poseidon2_hash","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"1Z3bTttAFEX/xc88zDlzO8OvVFUVrooUBQShUoX499ptYlCcyYj9EO15qZp2Fiwlx3vHYwfeh7v7m7fHX+vtw9PrcP3jfdg83a5266ft+Oj942q4eVlvNuvHX1//eXDTH97/W//6vNpOD193q5fdcC2puKvhfns3/jU7N36Fh/Xmfrj2yT6uFqt9kf3i4PVzbTixVL0L+7XqtbE4+bRfm3z+uvTn1eBDp96xU+/UqXfu1Ns69S59egfXqbd06q2denfal6HTvgyd9mXotC9Dp30ZmPsyHyRSlmNv5r484x2Z+/KcN3NfnvNm7stz3sx9ec6bpi8nGZoSnGRomm2SoamrSYamgyYZmmIZZRJNW0wyNBUwydDk+iRDE9aTDFMCJ6YETkwJnJgSODElcGJK4MyUwJkpgTNTAmemBM5MCZyZEjgzJXBmSuDMlMCZKYGNKYGNKYGNKYGNKYGNKYGNKYGNKYGNKYHLpY+m8CkT47HMhWfGtBxkLHh48WSeeM0lZz9blOOty5K7NbduzQuxudnhupkUd3yEinP9qku/6tqvuu9XPfSrTtykLXXmKm2oM3dpQ525TBvq/bap9Num0m+bSr9tKv22qfTbptJvmwpxm6pTPSx2fqlO3KYtdeI2bakTt2lDXYnbtKVO3KYtdeI2bakTt2lLnbhNW+qX3v+et+LU2/HGrfgLh0aQQ11r0LCwESobpbLxVDaByiZS2SQqmwvnTXBz+gVZpN+lP6rZsClMNpf+WGXDRqhslMrGU9kEKptIZZOobKjSL1ClX6RKv0iVfqfvqLdwOCmxuHhjX7m728XD9xmvNC2/TwGgyt3SDUgQ6HQJyHxyNm6a2QLyCBQQKCJQQqCMQIZABYAqd282IEEgZCIMmQhDJsKQiTBkIgyZCCvfjpVSOdglzMetX0IegQICRQRKCJQRCAnlAoSyOodAgkCKQB6BAgJFBKpMRJqPJme6gDICGQIVAKpcbG9AgkCKQO2JOAEhEyHIRFQuJDagjECGQEhGKJIRimSEIhmhSEYoMhGKTIQiE6HIRCgyER55cT3y4nrkxfXIi+uBNzla2XHUMN+hrEkWUAGgyv5dAxIEUgQ6/ZRrjjNUFs9eZW+pAZ1+yqPMJ89RlnoFgCqbBg1IEEgRqLJP6OfXKSW3gAICRQRKCJQRyBCoAFDtp2echwSBFIGQiUjIRCRkIhIyEQmZiIRMREImIiMTkZGJqH063vRz03DxHrb2KfbzUECgiEAJgTICGQIVAKpsNYX5vo3xksoiyytbTQ3II1BAoIhACYEyAhkCFQCq7FA1IGQiCjIRBZmIyl5YiHmG8iKNKnthDSghUEYgQ6DyfchX9sIakCCQIpBHoIBAEYESAmUEMgQCThu8OAQSBPr2acPH+Oj36mW9utnc738jwcPb9vbLLyjY/Xn+/z/j4r8=","brillig_names":["poseidon2_hash"],"assert_messages":{"256":"Array index out of bounds","157":"Stack too deep","217":"Array index out of bounds","151":"attempt to add with overflow","209":"Array index out of bounds","133":"Array index out of bounds","233":"attempt to add with overflow","201":"Array index out of bounds","275":"attempt to add with overflow"}},{"name":"new_nullifier","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiAAwxAgABIyUABHgAgAQNAAAAgASAAyEAABCAAzkBAAAjKwAYyhjK","debug_symbols":"bc/RCoMgFAbgdznXXWhu03qVMUJLQxANtcEQ333WZDTWjfjrdw7nJJikWOdBW+UC9PcExo08amdLSrkB4bUxeh6Oz4C2A6Pdh4XbLYbIfYQetwh1DUg77XeCSw+ljYSe3Fhu/jxhtK2csI5+NWbXE03ZBVVNS+GPfuQSn9xrLoys06vVjodl4mv5/BT8Bg==","brillig_names":["new_nullifier"],"assert_messages":{"15":"Stack too deep"}},{"name":"to_radix_le","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"input","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}},"bytecode":"JAAEAQIlAASATgABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiABAAKAECAiUCBIBEAAMkAgQKBCsEAAKAAysEAAOABCsEAASABSIAGjgAgEQACiIAJSQCBAICKggBAyQCBAsEABABBAEkAwQBAwAoAwIEQToAAQAEAAIACgAqDAMBIyUABAAAgAcNAIAHgAWACBcAgAiACCEAACSACAEAgAOAB4AJKwGACYAGAQCABIAHgAkrAoAGgAkBAIAHAAKAByAAGyMlAAR4AIAEDQAAAIAEgAMhAAApgAM5AQAAIysAGMoYyg==","debug_symbols":"tZLPCoQgEIffZc4e1KisV1mWsNIQRENtYRHffXX/EXT2Msxv5mO+y0RYxXxskzLSehhvEbRdeFDW5BQTgtkprdU2nceASyH9m/c7NyX6wF2Ase27FoEwa2kZzRek0gLGpmMJXWnMyI/Gw/CnaZfuCAirbhhqGyiubiDVDbS6oalrSDk9uFN81uL72PIwy+nPw3P/bDL8Ag==","brillig_names":["to_radix_le"],"assert_messages":{"40":"Stack too deep"}},{"name":"elliptic_curve_add_and_double","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAsrBAABgEMrBAACgEQrBAADgEU4AIBDAAMiAC8kAgABASkCAAAAAAAAAAACzxNedQakXWMtJw1F8RgSlIM/xI2CPycsAAIkAgEAAyQCBAgHKggACCoMAQkqDAIKKgwDCyoMAQwqDAINKgwDDgAQAAcAIgA0KgQAACoMCQQqDAoFKgwLBiQCBAsKKggACyoMAQwqDAINKgwDDioMBA8qDAUQKgwGEQAQAAoAIgA0KgQAACoMDAcqDA0IKgwOCSoMBwEqDAgCKgwJAyMlAAR4AIAEDQAAAIAEgAMhAAAzgAM5AQAAIyIALwo4AQQKCjgCBQsEOAoLDBYMCw0EOAoNCxwMAAoNADgBDQ4qCAENJAIEBA8AEAEPASQDBAENACgNAg8/P8AADgACAAoABAAFAAYADyQCBAAOACgNAhAAOBAOESoNEQ8kAgQBEAAoDQISADgSEBMqDRMRKggBDQAAAQIBKggBEgAAAQIBKggBEwAAAQIBKg4PDSoOERIqDgoTKggBFCQCBAQVABABFQEkAwQBFAAoFAIVPz/AAAEAAgADAAEAAgADABUAKBQCFgA4Fg4XKg0XFQAoFAIWADgWEBcqDRcOIQIAZQAMIABhKgwPByoMEQgqDAoJIABqJAIBAAoqDBUHKgwOCCoMCgkgAGoqDgcNKg4IEioOCRMhAgBvAAMgAHMqDgQNKg4FEioOBhMgAHMhAgB1AAYgAHkqDgENKg4CEioOAxMgAHkWDAMBFgwGAgQ4AQIEBDgLBAEqDQ0CKg0SBAQ4AwYFEjgBBQMqDgINKg4EEioOAxMqDAIBKgwEAiMrABjKGMo=","debug_symbols":"zZrBjtpADIbfJWcOY4/HnuFVqmoFu7CKhMIK2EoV4t0LlASadPfgxMgXRMA/3wfzM8khx+pttfx8f6mb9XZfzX8cq832dXGot8356HiaVctdvdnU7y+PL1fh8gB4nd9/LJrL4f6w2B2qOZHArFo1b9enfP6Edb1ZVfPI+fRzVkHUhEgTSpoQa0KiCWVNqChCGDQh0IQ0jUBNI1DTCNQ0AjWNQE0jUNMI/KIRJbehFEo/FIMmBJoQakJREyJNKGlCrAmJJpQ1IU0jSNMI0jSCNI1I/20EBAq3EASBLoR0mg2GExS6DScEehy+AGg8AIk7AHMfkCYAlA4Qo/QBbA2Q8YAo7XAiwD4gjweQtDVKKQzWoEwAYL4D+j8Rh/EA7rb7JP/WdDgsHFsb4Rz7NuDKBl3ZRFc25MomubLhZ9sUaW0EoG8jrmyyK5viyUaevRcLps4mlr4NuLJBVzbRlY3pXnwBJGsAWwPEGpCtAcUYkIM1AKwBaA2Y4G+foQPkhGMuMzK5skmubNiVjbiyya5syrNtvrsEK8GVDbiywSfbfHvRU6IrG/JkA8F0+7sSxJyQrQkA5gQ0J0RzgvlKg/1KF2sCmncJzbuE47vEgO25noFlQKAJCIHuhDwgJHMCmxPG/+MYoT2TMyYeEPIE36GkO2G40sWaEIM5AUwJp/PRr8WuXiw3q9udK+vP5vXhRpbD74+/75yH/wA=","brillig_names":["elliptic_curve_add_and_double"],"assert_messages":{"50":"Stack too deep"}},{"name":"helper_with_failed_assertion","is_unconstrained":false,"custom_attributes":[],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"H4sIAAAAAAAA/33OQQrCMBAF0BS8hZt4g0xmppnZeQgvkNAJDRQLRu8vYtFV+zZ/8+H/wf0Nbt91SwwjkaVogJBD1CIciMsoIMDCUxREE5KkRVNQIDSorFjD12fj5I7t/ThveZtb97l3ezzbevd9Xl/L5Gtuy+XXfQP4jlSZ2AAAAA==","debug_symbols":"ZY1BCsMgEEXvMmsXkWJSvUopQRMNAzIGNYUiuXunbRYp3c37/zG/wezdtoxIIRUwtwYxTbZiIqYG3Scqq6U3lWpzBdN3gxbgaeZTSrULCBg9mEt/3cWfrfSgDltpLX/sO5PLGCMu43mX44fNaF30B4aNplNbn+u34Rcv","brillig_names":[]},{"name":"set_read_storage_single","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"a","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARQABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAorBAABgEQ4AIBEAAEiAGQqCAEDAAABAgEkAgEABCoOBAMqCAEDAAABAgEkAgAABCoOBAMqCAEDAAABAgEkAgACBSoOBQMkAgQBAyQCAAEFJAIEAAYqDAYCIAAcCjgCBgchAgBNAAcgAB8qCAECJAIEAgcAEAEHASQDBAECACgCAgcqDAcIKg4ECCoNAgcAKAcCByoOBwIqCAEHAAABAgEqDgIHKgwGASAALgo4AQYCIQIANwACIAAxKg0HAQAoAQIDADgDBgQqDQQCKgwCASMqDQcCHAwAAQQAOAUECCwMAAgABCQCBAEJDDgBCQohAgA/AAo5AQAAKwQAAoADJQAEAAKABCIAaSsIgAUACAAoCAIJADgJAQoqDgQKADgBAwIOOAECBCECAEoABDkBAAAqDggHKgwCASAALhwMAAIHADgFBwgqCAEHJAIEAgkAEAEJASQDBAEHACgHAgkqDAkKKg4BCiQCBAEKDDgCCgshAgBaAAs5AQAAACgHAgoAOAoCCyoNCwktDAAJAAgAOAIDBw44AgcIIQIAYgAIOQEAACoMBwIgABwlAAR4AIAEDQAAAIAEgAMhAABogAM5AQAAIysBgAOABgsAgAYAAoAHIQAAbYAHIABvKwCAA4AFIAB9KwAAAYAFAQAAAYAEAAElAAQAAIAJDQCACYAEgAoXAIAKgAohAAB7gAoBAIADgAmACysBgAuACAEAgAWACYALKwKACIALAQCACQACgAkgAHIlAQQAAYAFIAB9IysAGMoYyg==","debug_symbols":"1drBbuIwEAbgd8mZgz0eezy8ympVhRaqSFGogK60Qrz7OlsSaENtyZfOXFACM8kXCP4Nybl52W7eX5+6Ybc/Nutf56bfP7enbj+ktfNl1WwOXd93r0/3TzdmfLD2f/3xrR3G1eOpPZyatQ1sVs12eEmLZEzawq7rt83ahXj5vWos1DS5miasafI1TaGmiWqaYk0TVzSBqWmqOSOg5oyAh28EgKNrE4CnT02r5S4gxGkXwDhXW2cfVAdjpm0HA3yrjv5BtSfma7WPd/yxOvGdfcwnM/Mjl/gm4sS3hgt8HxAmUAiuxHdxOti0GBd80M13uvmom+9184NuPunmR918Vs1Ho5uvO3VRd+qi7tRF6eM+2mnbadEv+NJHHnRm5rvwle9/YOSB+XQIFAt8QDsdLCDYuRrSfka+1c0H3XzpM878V9eLH3nC/Fkh0YIvfcaJHnJ86TNOdHzjl74pbGCSsPHLg9WdEkH6/LTAlz4/LfClz08LfOnz0wIfdfPFZ3SeLz6j83zxGZ3ny8/oLF936pLu1CXdqUu6U5d0py7pTl0i4ZdRI86/jKPHBV/6VeAInOOzdL4PMz8s/peIRjff6uaDbr7TzUfdfK+bH3Tzxaduni8+dfN83anLulOXdacu605dFp+61t/4oVDN1rlrNVtaTK9ZfEZ/f7AjX3xG5/niMzrPF5/RGf4lrf5pD1276bfX2/h378Pz3V39p79vH6+k4n8=","brillig_names":["set_read_storage_single"],"assert_messages":{"89":"Array index out of bounds","103":"Stack too deep","97":"attempt to add with overflow","73":"attempt to add with overflow","62":"Array index out of bounds"}},{"name":"get_da_gas_left","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAweAgwAASMlAAR4AIAEDQAAAIAEgAMhAAAQgAM5AQAAIysAGMoYyg==","debug_symbols":"bc9RCsMgDAbgu+S5DxWxul5ljKKtFkG0qB0M8e7TToawvYh/8hGSBJsU575oq1yA+Z7AuJVH7WxJKQ8gvDZG70tfhrE+aLx8OLitMUTuI8xonDAbQNrt+hNaZihtJMx4Ynn48QTRqXGC2O2rESN/NMWYNk1xN7vqRy7xyb3mwsi2vTrt2h0TX8enU/Ab","brillig_names":["get_da_gas_left"],"assert_messages":{"15":"Stack too deep"}},{"name":"new_note_hash","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"note_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQBAiQCBAADHxgAAwACgEMrCIBDAAEiAAk4AIBEAAAiAAwvAgABIyUABHgAgAQNAAAAgASAAyEAABCAAzkBAAAjKwAYyhjK","debug_symbols":"bc9RCsMgDAbgu+S5D3VSdV5ljKKtFkG0qB0M8e6znYyO7UX8k4+QZJiV3JbROO0j8FsG6yeRjHc15dKBDMZas4znMvT7g/rDx1W4PcYkQgKOEMOsA+Xm40/6OkMbq4Bjwkr34zGlqHFMr+SjERv+aEouuGlKhuFL30uNDxGMkFa17fXmptMx6bm+OxW/AA==","brillig_names":["new_note_hash"],"assert_messages":{"15":"Stack too deep"}},{"name":"set_opcode_big_field","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAAwpAgAAAAAAAAAAAAAAAAAAAACZEjRWeJCrze8SNFZ4kKvN7wABIyUABHgAgAQNAAAAgASAAyEAABCAAzkBAAAjKwAYyhjK","debug_symbols":"XclRCoAgDIDhu+y5E3SVCFFTGYwtTIMYu3tBPYSP//8pbCn04pCzHDAvCiTRNxR+Sm2CUJEIixv26Sv6QOnL3Dn+tF37K7baDQ==","brillig_names":["set_opcode_big_field"],"assert_messages":{"15":"Stack too deep"}},{"name":"nested_call_to_assert_same","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"arg_a","type":{"kind":"field"},"visibility":"private"},{"name":"arg_b","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQCAyQCBAAEHxgABAADgEMrCIBDAAErCIBEAAIiAAsrBAABgEU4AIBFAAEiAHYeAgAABCoIAQUAAAECASQCBAEGKg4GBSoIAQcAAAECASYCABFPzugACCQCBAEKJAIEAgwAOAoMCyoIAQkAEAELASQDBAEJACgJAgsqDgoLJAIEAgsAOAkLCioMCgsqDggLKg4JByQCBAAIJAIBAQkkAgQCCioMCAMgACYMOAMKCyECAEgACyAAKSoNBQEqDQcCKggBAyQCBAMFABABBQEkAwQBAwAoAwIFKgwFBikCADBkTnLhMaApuFBFtoGBWF0oM+hIeblwkUPh9ZPwAAAAAAcqDgcGACgGAgYqDgcGJgIA1UQbDQAFACgDAgYAKAICCyoNCwoAKAsCCSoIAQskAgQCDAAQAQwBJAMEAQsAKAsCDTY/lQAGAAQACQAKAA0AAQAMAAUkAgIBAQo4DAECIQIARAACOQEAAAAoCwICADgCCAMqDQMBIww4AwoLIQIASwALOQEAACQCBAIMJAIEAg4AOAwODSoIAQsAEAENASQDBAELACgLAg0qDgwNJAIEAg0AOAsNDCoMDA0qDgENACgNAg0qDgINACgLAg0qDQ0NDDgDDQ4hAgBeAA45AQAAJAIEAg4AOAsODQA4DQMOKg0ODCoNBQsqDQcNACgLAg4rBAANgAMlAAQAAYAEIgB7KwiABQAPKwiABgAQKg4MECoNDwsAKAsCCyoOCw8qDg4FKg4PBwA4AwYLDjgDCwwhAgB0AAw5AQAAKgwLAyAAJiUABHgAgAQNAAAAgASAAyEAAHqAAzkBAAAjAQCAAwACgAcrAYAHgAcBAIAHgASACCUABAACgAoBAIAIgAqACSsAAAGABQEAAAGACQABJQEEAAGABQEAgAUAAoAJKwKACIAJJQAEAAKACgEAgAOACoAJJQAEAAKACwEAgAWAC4AKJQAEAACADA0AgAyAB4ANFwCADYANIQAAk4ANAQCACYAMgA4rAYAOgAsBAIAKgAyADisCgAuADgEAgAwAAoAMIACKAQCACoAHgAYjKwAYyhjK","debug_symbols":"1ZzNauswEIXfxessNCNpNJNXuVyK0ybFYJySpBcuIe9eJ42d/kqbQnU2IU4G+Ttg89kaoWPzsF49P951w2a7b5Z/jk2/vW8P3XYYj46nRbPadX3fPd69/blx5w/iS/3+qR3Oh/tDuzs0S4pstGjWw8P5uycax9h0/bpZetHT4lO9N4nXcm8pzNWk8YtqCToNLsHSu+q/i4b8N0jJbkghFpCCuukkQdluJzH6oprF87WaJblCgKQTiTqda5nDBT9g40dsfMHGT9j4io1v0PjssPEJG5+x8bGty9jWZWzrMrZ1Gdu6jG1dxraux7aux7aux7aur/7WJaEZRfj2ai+Xd/VQ/dVDEmTmF/eRv/rLp8D/G09tybmJX30q8GvgaWwNid5VnwME9AARPYCgB0joARQ9gIEHiA49AKEHYPQA6CaO6CaO6CaO6CaO6CaO6CaO6CYWdBMLuokF3cSCbmL5DRNbnFZwsMmnNRkS60OS+pBSfUg/YzSTGck0FpCIk/ppdFaywu3AgeYJsfHOmKvZ2SWCwUdIDj8CwExpbqY6Vd/fLvAHcP7qO9wF/upb3AX+6nvcBX7wTlmqvsud59fq29wFfoBOZZYf3L8K7l8F96+C+1fB/avg/lVw/yq4fw3cvwbuXwP3r4H718D9a+D+NXD/Grh/Ddy/Bu5fcgACzi0VJQe+Vpcc+GJdcgAOzgcAkHA+AICF8wEANJwPAODhfAAAEecDAJg4G4DQTUzoJiZ0E9e/x0gpALqJ699nJBfgNB79a3ddu+rX1z12Ns/D/Zstdw7/n17/GYtfAA==","brillig_names":["nested_call_to_assert_same"],"assert_messages":{"67":"Nested call failed!","93":"Array index out of bounds","74":"Index out of bounds","121":"Stack too deep","115":"attempt to add with overflow"}},{"name":"nested_static_call_to_set_storage","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JAAEAQIlAASAQwABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAg4AIBDAAAiAFMeAgAAAioIAQMAAAECASQCBAEEKg4EAyoIAQUAAAECASQCBAEHJAIEAgkAOAcJCCoIAQYAEAEIASQDBAEGACgGAggqDgcIJAIEAggAOAYIByoMBwgmAgCE8X5vAAkqDgkIKg4GBSQCABQGJAIEAAcqDAcBIAAiCjgBBwghAgBAAAggACUqDQMBKg0FAyoIAQQkAgQDBQAQAQUBJAMEAQQAKAQCBSoMBQYpAgAwZE5y4TGgKbhQRbaBgVhdKDPoSHm5cJFD4fWT8AAAAAAHKg4HBgAoBgIGKg4HBiYCANVEGw0ABQAoBAIGACgDAgoqDQoJACgKAggqCAEKAAABAgEkAwQBCgAoCgIMNz+VAAYAAgAIAAkADAAAAAsABSQCAgEBCjgLAQIhAgA/AAI5AQAAIwo4AQcIIQIAQwAIOQEAACoNAwgqDQUJACgIAgorBAAJgAMlAAQAAYAEIgBYKwiABQALKwiABgAMKg4GDCoNCwgAKAgCCCoOCAsqDgoDKg4LBSoMBAEgACIlAAR4AIAEDQAAAIAEgAMhAABXgAM5AQAAIwEAgAMAAoAHKwGAB4AHAQCAB4AEgAglAAQAAoAKAQCACIAKgAkrAAABgAUBAAABgAkAASUBBAABgAUBAIAFAAKACSsCgAiACSUABAACgAoBAIADgAqACSUABAACgAsBAIAFgAuACiUABAAAgAwNAIAMgAeADRcAgA2ADSEAAHCADQEAgAmADIAOKwGADoALAQCACoAMgA4rAoALgA4BAIAMAAKADCAAZwEAgAqAB4AGIysAGMoYyg==","debug_symbols":"1ZvbasJAEIbfZa+9yMzuzE58lVJKrAcCIYqHQhHfvdEaT7XZS/e/EaM/7vfD4kd2yN5NZ5Pd4qNu58uNG7/tXbP8rLb1su2u9oeRm6zrpqkXH7cfu+L4Up7im1XVHq8222q9dWMKyn7kZu309D747ifmdTNzY692GP3J+1LlHPdlDJc0mTxJazA6pzWU8S79PnJU/INEdEW6WeQ5khoV/SIW5LpISc8KeLa+gFdNFIhWnsNW2CXLHE74hI3P2PgeGz9g4ws2vmLjR2x8w8YvofEZ27qMbV3Gti5jW5exrcvY1mVs6zK2dRnbuoxtXZ/9Pw8p9fykfCXR0726z37zkwa98GvxyJ/97k/wv2L7hxB6fjFL8JtKfzRkkfgu3RUIBXoBQi/A6AU8eoGAXkDQCyh6gYhewNALoJtY0E0s6CYWdBMLuokF3cSCbmJBN7Ggm1jQTSyvMLEW/V26V7JHJC3yQ6L8kDg/pIB9PqfZjwYS/NnPBhL8AOejg/wA56OD/NmPB4bPd2P2U/kEf/Zj+QR/9nP5BH/2g/kEP4B/B/kB/DvID+DfQX7w+WQEn09GcP8atH8P3dVXta6rSTM7Pwgw37WfN88FbL9Xv9904R8=","brillig_names":["nested_static_call_to_set_storage"],"assert_messages":{"66":"Index out of bounds","86":"Stack too deep","62":"Nested static call failed!"}}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AvmTest"}},{"name":"fields","value":{"fields":[{"name":"single","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"list","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"map","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::variable_base_msm_parameters"}},{"name":"return_type","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"AvmTest::variable_base_msm_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_sender_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AvmTest::get_sender_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"lhs","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"rhs","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"AvmTest::elliptic_curve_add_parameters"}},{"name":"return_type","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"AvmTest::elliptic_curve_add_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::set_opcode_u32_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AvmTest::set_opcode_u32_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::assertion_failure_parameters"}}],"kind":"struct","path":"AvmTest::assertion_failure_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nullifier_exists_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AvmTest::nullifier_exists_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nullifier_collision_parameters"}}],"kind":"struct","path":"AvmTest::nullifier_collision_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::sha256_hash_parameters"}},{"name":"return_type","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::sha256_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AvmTest::set_storage_map_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_storage_map_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::nested_static_call_to_set_storage_parameters"}}],"kind":"struct","path":"AvmTest::nested_static_call_to_set_storage_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"note_hash","type":{"kind":"field"}},{"name":"leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::note_hash_exists_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AvmTest::note_hash_exists_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_function_selector_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}}],"kind":"struct","path":"AvmTest::get_function_selector_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::debug_logging_parameters"}}],"kind":"struct","path":"AvmTest::debug_logging_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_block_number_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_block_number_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nestedAddress","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::create_same_nullifier_in_nested_call_parameters"}}],"kind":"struct","path":"AvmTest::create_same_nullifier_in_nested_call_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::test_get_contract_instance_parameters"}}],"kind":"struct","path":"AvmTest::test_get_contract_instance_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::emit_unencrypted_log_parameters"}}],"kind":"struct","path":"AvmTest::emit_unencrypted_log_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_a","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"_fields","type":{"kind":"array","length":3,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::get_args_hash_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_args_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::return_oracle_parameters"}},{"name":"return_type","type":{"kind":"array","length":3,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::return_oracle_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_fee_per_da_gas_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_fee_per_da_gas_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}},{"name":"b","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"AvmTest::add_u128_parameters"}},{"name":"return_type","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"AvmTest::add_u128_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::elliptic_curve_add_and_double_parameters"}},{"name":"return_type","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"AvmTest::elliptic_curve_add_and_double_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::modulo2_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::modulo2_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::emit_nullifier_and_check_parameters"}}],"kind":"struct","path":"AvmTest::emit_nullifier_and_check_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_fee_per_l2_gas_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_fee_per_l2_gas_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nestedAddress","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::create_different_nullifier_in_nested_call_parameters"}}],"kind":"struct","path":"AvmTest::create_different_nullifier_in_nested_call_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_storage_single_parameters"}}],"kind":"struct","path":"AvmTest::set_storage_single_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_address_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AvmTest::get_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::pedersen_hash_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::pedersen_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::poseidon2_hash_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::poseidon2_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::read_storage_single_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::read_storage_single_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::keccak_hash_parameters"}},{"name":"return_type","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::keccak_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::set_opcode_big_field_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_opcode_big_field_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_da_gas_left_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_da_gas_left_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_version_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_version_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::test_get_contract_instance_raw_parameters"}}],"kind":"struct","path":"AvmTest::test_get_contract_instance_raw_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_timestamp_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::get_timestamp_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"args","type":{"kind":"array","length":3,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::assert_calldata_copy_parameters"}}],"kind":"struct","path":"AvmTest::assert_calldata_copy_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::set_opcode_really_big_field_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_opcode_really_big_field_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::new_nullifier_parameters"}}],"kind":"struct","path":"AvmTest::new_nullifier_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::assert_same_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::assert_same_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_read_storage_single_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_read_storage_single_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_assert_same_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_assert_same_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::add_args_return_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::add_args_return_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"args_field","type":{"kind":"array","length":10,"type":{"kind":"field"}}},{"name":"args_u8","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::bulk_testing_parameters"}}],"kind":"struct","path":"AvmTest::bulk_testing_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::u128_from_integer_overflow_parameters"}},{"name":"return_type","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"AvmTest::u128_from_integer_overflow_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_l2_gas_left_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_l2_gas_left_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"expected_timestamp","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::assert_timestamp_parameters"}}],"kind":"struct","path":"AvmTest::assert_timestamp_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_add_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_add_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::set_opcode_u8_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":8}}],"kind":"struct","path":"AvmTest::set_opcode_u8_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::set_opcode_u64_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}],"kind":"struct","path":"AvmTest::set_opcode_u64_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"to","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AvmTest::add_storage_map_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::add_storage_map_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AvmTest::read_storage_map_parameters"}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AvmTest::read_storage_map_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_static_call_to_add_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_static_call_to_add_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"arg_a","type":{"kind":"field"}},{"name":"arg_b","type":{"kind":"field"}},{"name":"l2_gas","type":{"kind":"field"}},{"name":"da_gas","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_add_with_gas_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::nested_call_to_add_with_gas_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::read_storage_list_parameters"}},{"name":"return_type","type":{"kind":"array","length":2,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::read_storage_list_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::set_opcode_small_field_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_opcode_small_field_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_chain_id_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_chain_id_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":25,"type":{"kind":"integer","sign":"unsigned","width":64}}}],"kind":"struct","path":"AvmTest::keccak_f1600_parameters"}},{"name":"return_type","type":{"kind":"array","length":25,"type":{"kind":"integer","sign":"unsigned","width":64}}}],"kind":"struct","path":"AvmTest::keccak_f1600_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"a","type":{"kind":"field"}},{"name":"b","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::set_storage_list_parameters"}}],"kind":"struct","path":"AvmTest::set_storage_list_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"msg_hash","type":{"kind":"field"}},{"name":"msg_leaf_index","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::l1_to_l2_msg_exists_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AvmTest::l1_to_l2_msg_exists_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"data","type":{"kind":"array","length":10,"type":{"kind":"field"}}}],"kind":"struct","path":"AvmTest::pedersen_hash_with_index_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::pedersen_hash_with_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::send_l2_to_l1_msg_parameters"}}],"kind":"struct","path":"AvmTest::send_l2_to_l1_msg_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"nullifier","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::assert_nullifier_exists_parameters"}}],"kind":"struct","path":"AvmTest::assert_nullifier_exists_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::get_transaction_fee_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::get_transaction_fee_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::new_note_hash_parameters"}}],"kind":"struct","path":"AvmTest::new_note_hash_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::enqueue_public_from_private_parameters"}}],"kind":"struct","path":"AvmTest::enqueue_public_from_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::check_selector_parameters"}}],"kind":"struct","path":"AvmTest::check_selector_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::pedersen_commit_parameters"}},{"name":"return_type","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}}],"kind":"struct","path":"AvmTest::pedersen_commit_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmTest::u128_addition_overflow_parameters"}},{"name":"return_type","type":{"fields":[{"name":"lo","type":{"kind":"field"}},{"name":"hi","type":{"kind":"field"}}],"kind":"struct","path":"std::uint128::U128"}}],"kind":"struct","path":"AvmTest::u128_addition_overflow_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"input","type":{"kind":"field"}}],"kind":"struct","path":"AvmTest::to_radix_le_parameters"}},{"name":"return_type","type":{"kind":"array","length":10,"type":{"kind":"integer","sign":"unsigned","width":8}}}],"kind":"struct","path":"AvmTest::to_radix_le_abi"}]}},"file_map":{"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"11":{"path":"std/collections/vec.nr","source":"pub struct Vec<T> {\n    pub(crate) slice: [T],\n}\n// A mutable vector type implemented as a wrapper around immutable slices.\n// A separate type is technically not needed but helps differentiate which operations are mutable.\nimpl<T> Vec<T> {\n    pub fn new() -> Self {\n        Self { slice: &[] }\n    }\n\n    // Create a Vec containing each element from the given slice.\n    // Mutations to the resulting Vec will not affect the original slice.\n    pub fn from_slice(slice: [T]) -> Self {\n        Self { slice }\n    }\n\n    /// Get an element from the vector at the given index.\n    /// Panics if the given index\n    /// points beyond the end of the vector.\n    pub fn get(self, index: u32) -> T {\n        self.slice[index]\n    }\n\n    /// Write an element to the vector at the given index.\n    /// Panics if the given index points beyond the end of the vector (`self.len()`).\n    pub fn set(&mut self, index: u32, value: T) {\n        self.slice[index] = value;\n    }\n\n    /// Push a new element to the end of the vector, returning a\n    /// new vector with a length one greater than the\n    /// original unmodified vector.\n    pub fn push(&mut self, elem: T) {\n        self.slice = self.slice.push_back(elem);\n    }\n\n    /// Pop an element from the end of the given vector, returning\n    /// a new vector with a length of one less than the given vector,\n    /// as well as the popped element.\n    /// Panics if the given vector's length is zero.\n    pub fn pop(&mut self) -> T {\n        let (popped_slice, last_elem) = self.slice.pop_back();\n        self.slice = popped_slice;\n        last_elem\n    }\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    pub fn insert(&mut self, index: u32, elem: T) {\n        self.slice = self.slice.insert(index, elem);\n    }\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the removed element\n    pub fn remove(&mut self, index: u32) -> T {\n        let (new_slice, elem) = self.slice.remove(index);\n        self.slice = new_slice;\n        elem\n    }\n\n    /// Returns the number of elements in the vector\n    pub fn len(self) -> u32 {\n        self.slice.len()\n    }\n}\n\nmod tests {\n    use crate::collections::vec::Vec;\n\n    #[test]\n    fn set_updates_values_properly() {\n        let mut vec = Vec { slice: &[0, 0, 0, 0, 0] };\n\n        vec.set(0, 42);\n        assert_eq(vec.slice, &[42, 0, 0, 0, 0]);\n\n        vec.set(1, 43);\n        assert_eq(vec.slice, &[42, 43, 0, 0, 0]);\n\n        vec.set(2, 44);\n        assert_eq(vec.slice, &[42, 43, 44, 0, 0]);\n\n        vec.set(1, 10);\n        assert_eq(vec.slice, &[42, 10, 44, 0, 0]);\n\n        vec.set(0, 0);\n        assert_eq(vec.slice, &[0, 10, 44, 0, 0]);\n    }\n\n    #[test(should_fail)]\n    fn panics_when_writing_elements_past_end_of_vec() {\n        let mut vec = Vec::new();\n        vec.set(0, 42);\n\n        // Need to use println to avoid DIE removing the write operation.\n        crate::println(vec.get(0));\n    }\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"27":{"path":"std/hash/keccak.nr","source":"use crate::collections::vec::Vec;\nuse crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\nfn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n    let mut block_bytes = [0; BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let max_blocks_length = (BLOCK_SIZE_IN_BYTES * max_blocks);\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let num_limbs = max_blocks_length / WORD_SIZE;\n    let mut sliced_buffer = Vec::new();\n    for i in 0..num_limbs {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer.push(sliced as u64);\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer.get(j);\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer.get(i * LIMBS_PER_BLOCK + j);\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer.get(j);\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer.get(i * LIMBS_PER_BLOCK + j);\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        // \"hello world\"\n        let input = [72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33];\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n}\n"},"286":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"310":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\n\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"313":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"317":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"359":{"path":"/usr/src/noir-projects/aztec-nr/compressed-string/src/compressed_string.nr","source":"use dep::aztec::protocol_types::{utils::field::field_from_bytes, traits::{Serialize, Deserialize}};\n\n// The general Compressed String.\n// Compresses M bytes into N fields.\n// Can be used for longer strings that don't fit in a single field.\n// Each field can store 31 characters, so N should be M/31 rounded up.\npub struct CompressedString<let N: u32, let M: u32> {\n    value: [Field; N],\n}\n\nimpl<let N: u32, let M: u32> CompressedString<N, M> {\n    pub fn from_string(input_string: str<M>) -> Self {\n        let mut fields = [0; N];\n        let byts = input_string.as_bytes();\n\n        let mut r_index = 0 as u32;\n\n        for i in 0..N {\n            let mut temp = [0 as u8; 31];\n            for j in 0..31 {\n                if r_index < M {\n                    temp[j] = byts[r_index];\n                    r_index += 1;\n                }\n            }\n\n            fields[i] = field_from_bytes(temp, true);\n        }\n\n        Self { value: fields }\n    }\n\n    pub fn to_bytes(self) -> [u8; M] {\n        let mut result = [0; M];\n        let mut w_index = 0 as u32;\n        for i in 0..N {\n            let bytes: [u8; 31] = self.value[i].to_be_bytes();\n            for j in 0..31 {\n                if w_index < M {\n                    result[w_index] = bytes[j];\n                    w_index += 1;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let M: u32> Eq for CompressedString<N, M> {\n    fn eq(self, other: CompressedString<N, M>) -> bool {\n        self.value == other.value\n    }\n}\n\nimpl<let N: u32, let M: u32> Serialize<N> for CompressedString<N, M> {\n    fn serialize(self) -> [Field; N] {\n        self.value\n    }\n}\n\nimpl<let N: u32, let M: u32> Deserialize<N> for CompressedString<N, M> {\n    fn deserialize(input: [Field; N]) -> Self {\n        Self { value: input }\n    }\n}\n\n#[test]\nunconstrained fn test_short_string() {\n    let i = \"Hello world\";\n    let b = i.as_bytes();\n    let name: CompressedString<1, 11> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_long_string() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<4, 118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_long_string_work_with_too_many_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<5, 118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n\n#[test]\nunconstrained fn test_serde() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let name: CompressedString<5, 118> = CompressedString::from_string(i);\n\n    assert_eq(name, CompressedString::deserialize(name.serialize()));\n}\n\n#[test(should_fail)]\nunconstrained fn test_long_string_fail_with_too_few_fields() {\n    let i = \"Hello world. I'm setting up a very long text of blibbablubb such that we can see if works as planned for longer names.\";\n    let b = i.as_bytes();\n    let name: CompressedString<3, 118> = CompressedString::from_string(i);\n    let p = b == name.to_bytes();\n    assert(p, \"invalid recover\");\n}\n"},"368":{"path":"/usr/src/noir-projects/noir-contracts/contracts/avm_test_contract/src/main.nr","source":"use dep::aztec::protocol_types::traits::{Serialize, Deserialize};\n\npub struct Note {\n    a: Field,\n    b: Field,\n}\n\nimpl Serialize<2> for Note {\n    fn serialize(self) -> [Field; 2] {\n        [self.a, self.b]\n    }\n}\n\nimpl Deserialize<2> for Note {\n    fn deserialize(wire: [Field; 2]) -> Note {\n        Note { a: wire[0], b: wire[1] }\n    }\n}\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract AvmTest {\n    use crate::Note;\n\n    global big_field_128_bits: Field = 0x001234567890abcdef1234567890abcdef;\n    global big_field_136_bits: Field = 0x991234567890abcdef1234567890abcdef;\n    global big_field_254_bits: Field =\n        0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n\n    // Libs\n    use std::embedded_curve_ops::{multi_scalar_mul, EmbeddedCurvePoint};\n    use dep::aztec::protocol_types::constants::CONTRACT_INSTANCE_LENGTH;\n    use dep::aztec::prelude::Map;\n    use dep::aztec::state_vars::PublicMutable;\n    use dep::aztec::protocol_types::{\n        address::{AztecAddress, EthAddress}, point::Point, scalar::Scalar,\n    };\n    use dep::aztec::oracle::get_contract_instance::{\n        get_contract_instance_avm, get_contract_instance_internal_avm,\n    };\n    use dep::aztec::protocol_types::{\n        abis::function_selector::FunctionSelector, storage::map::derive_storage_slot_in_map,\n    };\n    use dep::compressed_string::CompressedString;\n    use dep::aztec::macros::{storage::storage, functions::{public, private}};\n    use dep::aztec::context::gas::GasOpts;\n\n    #[storage]\n    struct Storage<Context> {\n        single: PublicMutable<Field, Context>,\n        list: PublicMutable<Note, Context>,\n        map: Map<AztecAddress, PublicMutable<u32, Context>, Context>,\n    }\n\n    /************************************************************************\n     * Storage\n     ************************************************************************/\n    #[public]\n    fn set_storage_single(a: Field) {\n        storage.single.write(a);\n    }\n\n    #[public]\n    fn read_storage_single() -> Field {\n        storage.single.read()\n    }\n\n    // should still be able to use ` -> pub *` for return type even though macro forces `pub`\n    #[public]\n    fn set_read_storage_single(a: Field) -> pub Field {\n        storage.single.write(a);\n        storage.single.read()\n    }\n\n    #[public]\n    fn set_storage_list(a: Field, b: Field) {\n        storage.list.write(Note { a, b });\n    }\n\n    #[public]\n    fn read_storage_list() -> [Field; 2] {\n        let note: Note = storage.list.read();\n        note.serialize()\n    }\n\n    #[public]\n    fn set_storage_map(to: AztecAddress, amount: u32) -> Field {\n        storage.map.at(to).write(amount);\n        // returns storage slot for key\n        derive_storage_slot_in_map(storage.map.storage_slot, to)\n    }\n\n    #[public]\n    fn add_storage_map(to: AztecAddress, amount: u32) -> Field {\n        let new_balance = storage.map.at(to).read().add(amount);\n        storage.map.at(to).write(new_balance);\n        // returns storage slot for key\n        derive_storage_slot_in_map(storage.map.storage_slot, to)\n    }\n\n    #[public]\n    fn read_storage_map(address: AztecAddress) -> u32 {\n        storage.map.at(address).read()\n    }\n\n    #[public]\n    fn add_args_return(arg_a: Field, arg_b: Field) -> Field {\n        arg_a + arg_b\n    }\n\n    /************************************************************************\n     * General Opcodes\n     ************************************************************************/\n    #[public]\n    fn set_opcode_u8() -> u8 {\n        8 as u8\n    }\n\n    #[public]\n    fn set_opcode_u32() -> u32 {\n        1 << 30 as u8\n    }\n\n    #[public]\n    fn set_opcode_u64() -> u64 {\n        1 << 60 as u8\n    }\n\n    #[public]\n    fn set_opcode_small_field() -> Field {\n        big_field_128_bits\n    }\n\n    #[public]\n    fn set_opcode_big_field() -> Field {\n        big_field_136_bits\n    }\n\n    #[public]\n    fn set_opcode_really_big_field() -> Field {\n        big_field_254_bits\n    }\n\n    #[public]\n    fn add_u128(a: U128, b: U128) -> U128 {\n        a + b\n    }\n\n    #[public]\n    fn modulo2(a: u64) -> u64 {\n        a % 2\n    }\n\n    #[public]\n    fn elliptic_curve_add(lhs: Point, rhs: Point) -> Point {\n        lhs + rhs\n    }\n\n    #[public]\n    fn elliptic_curve_add_and_double() -> Point {\n        let g = Point {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860,\n            is_infinite: false,\n        };\n\n        let doubled = g + g;\n        let added = g + doubled;\n        added\n    }\n\n    #[public]\n    fn variable_base_msm() -> Point {\n        let g = Point {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860,\n            is_infinite: false,\n        };\n        let scalar = Scalar { lo: 3, hi: 0 };\n        let scalar2 = Scalar { lo: 20, hi: 0 };\n        let triple_g = multi_scalar_mul([g, g], [scalar, scalar2]);\n        triple_g\n    }\n\n    #[public]\n    fn pedersen_commit(x: Field, y: Field) -> EmbeddedCurvePoint {\n        let commitment = dep::std::hash::pedersen_commitment_with_separator([x, y], 20);\n        commitment\n    }\n\n    /************************************************************************\n     * Misc\n     ************************************************************************/\n\n    #[public]\n    fn u128_addition_overflow() -> U128 {\n        let max_u128: U128 = U128::from_hex(\"0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\");\n        let one: U128 = U128::from_integer(1);\n        max_u128 + one\n    }\n\n    #[public]\n    fn u128_from_integer_overflow() -> U128 {\n        let should_overflow: Field = 2.pow_32(128); // U128::max() + 1;\n        U128::from_integer(should_overflow)\n    }\n\n    #[public]\n    fn to_radix_le(input: Field) -> [u8; 10] {\n        input.to_le_radix( /*base=*/ 2)\n    }\n\n    // Helper functions to demonstrate an internal call stack in error messages\n    fn inner_helper_with_failed_assertion() {\n        let not_true = false;\n        assert(not_true == true, \"This assertion should fail!\");\n    }\n    fn helper_with_failed_assertion() {\n        inner_helper_with_failed_assertion();\n    }\n\n    #[public]\n    fn assertion_failure() {\n        helper_with_failed_assertion()\n    }\n\n    #[public]\n    fn debug_logging() {\n        dep::aztec::oracle::debug_log::debug_log(\"just text\");\n        dep::aztec::oracle::debug_log::debug_log_format(\"second: {1}\", [1, 2, 3, 4]);\n        dep::aztec::oracle::debug_log::debug_log_format(\"whole array: {}\", [1, 2, 3, 4]);\n        dep::aztec::oracle::debug_log::debug_log(\"tabs and newlines\\n\\t- first\\n\\t- second\");\n    }\n\n    #[public]\n    fn assert_same(arg_a: Field, arg_b: Field) -> pub Field {\n        assert(arg_a == arg_b, \"Values are not equal\");\n        1\n    }\n\n    #[public]\n    fn assert_calldata_copy(args: [Field; 3]) {\n        let offset = 0;\n        let cd: [Field; 3] = dep::aztec::context::public_context::calldata_copy(offset, 3);\n        assert(cd == args, \"Calldata copy failed\");\n    }\n\n    #[public]\n    fn return_oracle() -> [Field; 3] {\n        dep::aztec::context::public_context::avm_return([1, 2, 3]);\n        [4, 5, 6] // Should not get here.\n    }\n\n    /************************************************************************\n     * Hashing functions\n     ************************************************************************/\n    #[public]\n    fn keccak_hash(data: [u8; 10]) -> [u8; 32] {\n        std::hash::keccak256(data, data.len() as u32)\n    }\n\n    #[public]\n    fn keccak_f1600(data: [u64; 25]) -> [u64; 25] {\n        std::hash::keccak::keccakf1600(data)\n    }\n\n    #[public]\n    fn poseidon2_hash(data: [Field; 10]) -> Field {\n        std::hash::poseidon2::Poseidon2::hash(data, data.len())\n    }\n\n    #[public]\n    fn sha256_hash(data: [u8; 10]) -> [u8; 32] {\n        std::hash::sha256(data)\n    }\n\n    #[public]\n    fn pedersen_hash(data: [Field; 10]) -> Field {\n        std::hash::pedersen_hash(data)\n    }\n\n    #[public]\n    fn pedersen_hash_with_index(data: [Field; 10]) -> Field {\n        std::hash::pedersen_hash_with_separator(data, /*index=*/  20)\n    }\n\n    /************************************************************************\n     * Contract instance\n     ************************************************************************/\n    #[public]\n    fn test_get_contract_instance_raw() {\n        let fields = get_contract_instance_internal_avm(context.this_address());\n        // The values here should match those in `avm_simulator.test.ts>Contract>GETCONTRACTINSTANCE deserializes correctly`\n        assert(fields.len() == CONTRACT_INSTANCE_LENGTH + 1);\n        assert(fields[0] == 0x1);\n        assert(fields[1] == 0x123);\n        assert(fields[2] == 0x456);\n        assert(fields[3] == 0x789);\n        assert(fields[4] == 0x101112);\n        assert(fields[5] == 0x131415);\n        assert(fields[6] == 0x161718);\n        assert(fields[7] == 0x00);\n        assert(fields[8] == 0x192021);\n        assert(fields[9] == 0x222324);\n        assert(fields[10] == 0x00);\n        assert(fields[11] == 0x252627);\n        assert(fields[12] == 0x282930);\n        assert(fields[13] == 0x00);\n        assert(fields[14] == 0x313233);\n        assert(fields[15] == 0x343536);\n        assert(fields[16] == 0x00);\n    }\n\n    #[public]\n    fn test_get_contract_instance() {\n        let ci = get_contract_instance_avm(context.this_address());\n        assert(ci.is_some(), \"Contract instance not found!\");\n    }\n\n    /************************************************************************\n     * AvmContext functions\n     ************************************************************************/\n    #[public]\n    fn get_address() -> AztecAddress {\n        context.this_address()\n    }\n\n    #[public]\n    fn get_sender() -> AztecAddress {\n        context.msg_sender()\n    }\n\n    #[public]\n    fn get_function_selector() -> FunctionSelector {\n        context.selector()\n    }\n\n    #[public]\n    fn get_transaction_fee() -> Field {\n        context.transaction_fee()\n    }\n\n    #[public]\n    fn get_chain_id() -> Field {\n        context.chain_id()\n    }\n\n    #[public]\n    fn get_version() -> Field {\n        context.version()\n    }\n\n    #[public]\n    fn get_block_number() -> Field {\n        context.block_number()\n    }\n\n    #[public]\n    fn get_timestamp() -> u64 {\n        context.timestamp()\n    }\n\n    #[public]\n    fn get_fee_per_l2_gas() -> Field {\n        context.fee_per_l2_gas()\n    }\n\n    #[public]\n    fn get_fee_per_da_gas() -> Field {\n        context.fee_per_da_gas()\n    }\n\n    #[public]\n    fn get_l2_gas_left() -> Field {\n        context.l2_gas_left()\n    }\n\n    #[public]\n    fn get_da_gas_left() -> Field {\n        context.da_gas_left()\n    }\n\n    #[public]\n    fn assert_timestamp(expected_timestamp: u64) {\n        let timestamp = context.timestamp();\n        assert(timestamp == expected_timestamp, \"timestamp does not match\");\n    }\n\n    #[public]\n    fn check_selector() {\n        assert(\n            context.selector() == comptime { FunctionSelector::from_signature(\"check_selector()\") },\n            \"Unexpected selector!\",\n        );\n    }\n\n    #[public]\n    fn get_args_hash(_a: u8, _fields: [Field; 3]) -> Field {\n        context.get_args_hash()\n    }\n\n    #[public]\n    fn emit_unencrypted_log() {\n        context.emit_unencrypted_log( /*message=*/ [10, 20, 30]);\n        context.emit_unencrypted_log( /*message=*/ \"Hello, world!\");\n        let s: CompressedString<2, 44> =\n            CompressedString::from_string(\"A long time ago, in a galaxy far far away...\");\n        context.emit_unencrypted_log( /*message=*/ s);\n    }\n\n    #[public]\n    fn note_hash_exists(note_hash: Field, leaf_index: Field) -> bool {\n        context.note_hash_exists(note_hash, leaf_index)\n    }\n\n    // Use the standard context interface to emit a new note hash\n    #[public]\n    fn new_note_hash(note_hash: Field) {\n        context.push_note_hash(note_hash);\n    }\n\n    // Use the standard context interface to emit a new nullifier\n    #[public]\n    fn new_nullifier(nullifier: Field) {\n        context.push_nullifier(nullifier);\n    }\n\n    // Use the standard context interface to check for a nullifier\n    #[public]\n    fn nullifier_exists(nullifier: Field) -> bool {\n        context.nullifier_exists(nullifier, context.this_address())\n    }\n\n    #[public]\n    fn assert_nullifier_exists(nullifier: Field) {\n        assert(\n            context.nullifier_exists(nullifier, context.this_address()),\n            \"Nullifier doesn't exist!\",\n        );\n    }\n\n    // Use the standard context interface to emit a new nullifier\n    #[public]\n    fn emit_nullifier_and_check(nullifier: Field) {\n        context.push_nullifier(nullifier);\n        let exists = context.nullifier_exists(nullifier, context.this_address());\n        assert(exists, \"Nullifier was just created, but its existence wasn't detected!\");\n    }\n\n    // Create the same nullifier twice (shouldn't work!)\n    #[public]\n    fn nullifier_collision(nullifier: Field) {\n        context.push_nullifier(nullifier);\n        // Can't do this twice!\n        context.push_nullifier(nullifier);\n    }\n\n    #[public]\n    fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> bool {\n        context.l1_to_l2_msg_exists(msg_hash, msg_leaf_index)\n    }\n\n    #[public]\n    fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n        context.message_portal(recipient, content)\n    }\n\n    /************************************************************************\n     * Nested calls\n     ************************************************************************/\n    #[public]\n    fn nested_call_to_add_with_gas(\n        arg_a: Field,\n        arg_b: Field,\n        l2_gas: Field,\n        da_gas: Field,\n    ) -> pub Field {\n        AvmTest::at(context.this_address())\n            .add_args_return(arg_a, arg_b)\n            .with_gas(GasOpts::new(l2_gas, da_gas))\n            .call(&mut context)\n    }\n\n    // Use the `call_public_function` wrapper to initiate a nested call to the add function\n    #[public]\n    fn nested_call_to_add(arg_a: Field, arg_b: Field) -> pub Field {\n        AvmTest::at(context.this_address()).add_args_return(arg_a, arg_b).call(&mut context)\n    }\n\n    // Indirectly call_static the external call opcode to initiate a nested call to the add function\n    #[public]\n    fn nested_static_call_to_add(arg_a: Field, arg_b: Field) -> pub Field {\n        AvmTest::at(context.this_address()).add_args_return(arg_a, arg_b).view(&mut context)\n    }\n\n    // Indirectly call_static `set_storage_single`. Should revert since it's accessing storage.\n    #[public]\n    fn nested_static_call_to_set_storage() {\n        AvmTest::at(context.this_address()).set_storage_single(20).view(&mut context);\n    }\n\n    #[public]\n    fn create_same_nullifier_in_nested_call(nestedAddress: AztecAddress, nullifier: Field) {\n        context.push_nullifier(nullifier);\n        AvmTest::at(nestedAddress).new_nullifier(nullifier).call(&mut context);\n    }\n\n    #[public]\n    fn create_different_nullifier_in_nested_call(nestedAddress: AztecAddress, nullifier: Field) {\n        context.push_nullifier(nullifier);\n        AvmTest::at(nestedAddress).new_nullifier(nullifier + 1).call(&mut context);\n    }\n\n    #[public]\n    fn nested_call_to_assert_same(arg_a: Field, arg_b: Field) -> pub Field {\n        AvmTest::at(context.this_address()).assert_same(arg_a, arg_b).call(&mut context)\n    }\n\n    /**\n     * Enqueue a public call from private\n     */\n    #[private]\n    fn enqueue_public_from_private() {\n        AvmTest::at(context.this_address()).set_opcode_u8().enqueue_view(&mut context);\n        AvmTest::at(context.this_address()).set_read_storage_single(5).enqueue(&mut context);\n    }\n\n    /************************************************************************\n     * Bulk testing: exercise many functions in a single call.\n     * It only makes sense to call functions with side effects (or oracle\n     * calls - but not blackboxes!), since otherwise the whole call will\n     * be optimized away.\n     ************************************************************************/\n    #[public]\n    fn bulk_testing(args_field: [Field; 10], args_u8: [u8; 10]) {\n        dep::aztec::oracle::debug_log::debug_log(\"set_storage_single\");\n        set_storage_single(30);\n        dep::aztec::oracle::debug_log::debug_log(\"set_storage_list\");\n        set_storage_list(40, 50);\n        dep::aztec::oracle::debug_log::debug_log(\"read_storage_list\");\n        let _ = set_storage_map(context.this_address(), 60);\n        dep::aztec::oracle::debug_log::debug_log(\"add_storage_map\");\n        let _ = add_storage_map(context.this_address(), 10);\n        dep::aztec::oracle::debug_log::debug_log(\"read_storage_map\");\n        let _ = read_storage_map(context.this_address());\n        dep::aztec::oracle::debug_log::debug_log(\"keccak_hash\");\n        let _ = keccak_hash(args_u8);\n        dep::aztec::oracle::debug_log::debug_log(\"sha256_hash\");\n        let _ = sha256_hash(args_u8);\n        dep::aztec::oracle::debug_log::debug_log(\"poseidon2_hash\");\n        let _ = poseidon2_hash(args_field);\n        dep::aztec::oracle::debug_log::debug_log(\"pedersen_hash\");\n        let _ = pedersen_hash(args_field);\n        dep::aztec::oracle::debug_log::debug_log(\"pedersen_hash_with_index\");\n        let _ = pedersen_hash_with_index(args_field);\n        dep::aztec::oracle::debug_log::debug_log(\"test_get_contract_instance\");\n        test_get_contract_instance();\n        dep::aztec::oracle::debug_log::debug_log(\"get_address\");\n        let _ = get_address();\n        dep::aztec::oracle::debug_log::debug_log(\"get_sender\");\n        let _ = get_sender();\n        dep::aztec::oracle::debug_log::debug_log(\"get_function_selector\");\n        let _ = get_function_selector();\n        dep::aztec::oracle::debug_log::debug_log(\"get_transaction_fee\");\n        let _ = get_transaction_fee();\n        dep::aztec::oracle::debug_log::debug_log(\"get_chain_id\");\n        let _ = get_chain_id();\n        dep::aztec::oracle::debug_log::debug_log(\"get_version\");\n        let _ = get_version();\n        dep::aztec::oracle::debug_log::debug_log(\"get_block_number\");\n        let _ = get_block_number();\n        dep::aztec::oracle::debug_log::debug_log(\"get_timestamp\");\n        let _ = get_timestamp();\n        dep::aztec::oracle::debug_log::debug_log(\"get_fee_per_l2_gas\");\n        let _ = get_fee_per_l2_gas();\n        dep::aztec::oracle::debug_log::debug_log(\"get_fee_per_da_gas\");\n        let _ = get_fee_per_da_gas();\n        dep::aztec::oracle::debug_log::debug_log(\"get_l2_gas_left\");\n        let _ = get_l2_gas_left();\n        dep::aztec::oracle::debug_log::debug_log(\"get_da_gas_left\");\n        let _ = get_da_gas_left();\n        dep::aztec::oracle::debug_log::debug_log(\"emit_unencrypted_log\");\n        let _ = emit_unencrypted_log();\n        dep::aztec::oracle::debug_log::debug_log(\"note_hash_exists\");\n        let _ = note_hash_exists(1, 2);\n        dep::aztec::oracle::debug_log::debug_log(\"new_note_hash\");\n        let _ = new_note_hash(1);\n        dep::aztec::oracle::debug_log::debug_log(\"new_nullifier\");\n        let _ = new_nullifier(1);\n        dep::aztec::oracle::debug_log::debug_log(\"nullifier_exists\");\n        let _ = nullifier_exists(1);\n        dep::aztec::oracle::debug_log::debug_log(\"l1_to_l2_msg_exists\");\n        let _ = l1_to_l2_msg_exists(1, 2);\n        dep::aztec::oracle::debug_log::debug_log(\"send_l2_to_l1_msg\");\n        let _ = send_l2_to_l1_msg(EthAddress::from_field(0x2020), 1);\n        dep::aztec::oracle::debug_log::debug_log(\"nested_call_to_add\");\n        let _ = nested_call_to_add(1, 2);\n        dep::aztec::oracle::debug_log::debug_log(\"nested_static_call_to_add\");\n        let _ = nested_static_call_to_add(1, 2);\n    }\n}\n"},"55":{"path":"std/ops/arith.nr","source":"// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"65":{"path":"std/slice.nr","source":"use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                let ascii =\n                    ascii + 32 * (unsafe { U128::uconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
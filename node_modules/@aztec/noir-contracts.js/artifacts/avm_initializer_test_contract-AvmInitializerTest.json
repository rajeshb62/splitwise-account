{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"AvmInitializerTest","functions":[{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"480":"Initializer address is not the contract deployer","608":"attempt to add with overflow","474":"Initialization hash does not match","765":"Array index out of bounds","340":"attempt to add with overflow","497":"PublicImmutable already initialized","797":"attempt to add with overflow","683":"attempt to add with overflow","829":"attempt to add with overflow","133":"Stack too deep","322":"Array index out of bounds","773":"Array index out of bounds","208":"attempt to add with overflow","781":"Array index out of bounds","36":"Not initialized","318":"attempt to add with overflow","542":"Array index out of bounds","664":"Array index out of bounds","597":"Array index out of bounds","821":"Array index out of bounds","559":"attempt to add with overflow","329":"Array index out of bounds"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"512":"Array index out of bounds","669":"Array index out of bounds","419":"Array index out of bounds","81":"attempt to add with overflow","430":"attempt to add with overflow","613":"Array index out of bounds","645":"attempt to add with overflow","191":"attempt to add with overflow","677":"attempt to add with overflow","531":"attempt to add with overflow","621":"Array index out of bounds","202":"Array index out of bounds","353":"Initializer address is not the contract deployer","446":"Array index out of bounds","347":"Initialization hash does not match","379":"PublicImmutable already initialized","213":"attempt to add with overflow","469":"Stack too deep","463":"attempt to add with overflow","629":"Array index out of bounds","195":"Array index out of bounds"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnBaoNAEIDhd9mzBze6Mzt5lVKCJhoWRIOaQhHfvZs2lEDO/0V2dPxv32k3d+na+/WUxn5a3PFjc8N0btY0jXna9sK1cxqGdD29vnbl41HXv/vLrRkf47I28+qOVV24brzkg+W/+zR0+Si6F2+benhuqv5vBts/C1cHrCxYWbFyxMpGlUOJlT1WPmDlCitjBgNmMGAGA2YwYAYDZlAwg4IZFMygYAYFMyiYQcEMCmZQMIOCGVTMoGIGFTOomEHFDCpmUDGDihlUzKBiBiNmMGIGI2YwYgYjZjBiBiNmMGIGI2YwYgYNM2iYQcMMGmbQMIOGGTTMoGEGDTNomEFfllzac+kDl664dM2lA5cWLq1cOnJpTqPnNHpOo4c07nn6aubUtEP3vHno7+P55SJi/b79fcnLPw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"read_storage_immutable","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAASARAABJAAEAwAkAgQAASQCBAACHxgAAgABgEMiAAkrBAABgEM4AIBDAAEiAEIeAgAAAh4CAAADMDgAAgADAAQkAgEBAiECABAABDkBAAAkAgAAAioIAQMkAgQCBAAQAQQBJAMEAQMAKAMCBCoMBAUqDgIFKg0DBAAoBAIEKg4EAyoIAQQAAAECASoOAwQkAgABAiQCBAEDJAIEAAUqDAUBIAAjCjgBBQYhAgAsAAYgACYqDQQBACgBAgMAOAMFBCoNBAIqDAIBIyoNBAYcDAABBwA4AgcILAwACAAHJAIEAQkMOAEJCiECADQACjkBAAArBAAGgAMlAAQAAoAEIgBHKwiABQAIACgIAgkAOAkBCioOBwoAOAEDBg44AQYHIQIAPwAHOQEAACoOCAQqDAYBIAAjJQAEeACABA0AAACABIADIQAARoADOQEAACMrAYADgAYLAIAGAAKAByEAAEuAByAATSsAgAOABSAAWysAAAGABQEAAAGABAABJQAEAACACQ0AgAmABIAKFwCACoAKIQAAWYAKAQCAA4AJgAsrAYALgAgBAIAFgAmACysCgAiACwEAgAkAAoAJIABQJQEEAAGABSAAWyMrABjKGMo=","debug_symbols":"1ZrdjsIgEEbfhWsvYBgG8FU2G1O1miZNNVo32RjffdvdUn/alItVw9wY0RM4FvBjmp7FOl+etoui2uyOYv5xFuVuldXFrmpa58tMLA9FWRbbxe3HQrYvSv7yx31Wtc1jnR1qMVfk5Uzk1bp5a6VsetgUZS7mmuxlNqC9MR3srelZ5dQIqz0FWHuLN7QZoQmd6mhCb+/oz5lQ6v/ySmoItDTwVn14wrX3qrdXsYuvwPhA6zt6zN5a7Tra2ra/B3v9XHtzb9+OgC8fwbx8BBobgSisOXIY6R9kv71AuquNQj1CG8LQtSHSkSk22tlAa+cGU2w5yzvO8p6xPEjO8oqzPHCW15zlkbO84SzPOWGBc8IC54QFzgmr096wqDDQ+FBmtPJpLxvUspfXNJB/+7KBfiGQdRF5QBVEAOFasoH0rTxKzvKKszwy3rCY+L8N9fOEdnCTBdM+HqCBKfm0jweo/VU+tkO8hLDIvDTDn8o5FTDtw8S0vEm7XI/Ip12uR+TTLtcj8mmX6xH5xPN4Wj7xPJ6WTzyPp+VTz+NJec4JazgnLHFOWOKcsMQ5YYlvwl6a5ld2KLJlmXfPIGxO1ermkYT6e//3TQP/AA==","brillig_names":["read_storage_immutable"],"assert_messages":{"69":"Stack too deep","15":"Not initialized","62":"attempt to add with overflow","51":"Array index out of bounds"}}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AvmInitializerTest"}},{"name":"fields","value":{"fields":[{"name":"immutable","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmInitializerTest::constructor_parameters"}}],"kind":"struct","path":"AvmInitializerTest::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AvmInitializerTest::read_storage_immutable_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AvmInitializerTest::read_storage_immutable_abi"}]}},"file_map":{"143":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr","source":"use crate::{context::{PublicContext, UnconstrainedContext}, state_vars::storage::Storage};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize},\n};\n\n// Just like SharedImmutable but without the ability to read from private functions.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context> Storage<T> for PublicImmutable<T, Context> {}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"181":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"204":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"224":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"326":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"327":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"367":{"path":"/usr/src/noir-projects/noir-contracts/contracts/avm_initializer_test_contract/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract AvmInitializerTest {\n    // Libs\n    use dep::aztec::{\n        state_vars::PublicImmutable, macros::{storage::storage, functions::{initializer, public}},\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        immutable: PublicImmutable<Field, Context>,\n    }\n\n    /************************************************************************\n     * Storage\n     ************************************************************************/\n    #[public]\n    #[initializer]\n    fn constructor() {\n        storage.immutable.initialize(42);\n    }\n\n    #[public]\n    fn read_storage_immutable() -> pub Field {\n        storage.immutable.read()\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"99":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"}}}
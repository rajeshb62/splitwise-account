import { MAX_NOTE_HASH_READ_REQUESTS_PER_TX, } from '../constants.gen.js';
import { siloNoteHash } from '../hash/index.js';
import { NoteHashReadRequestHintsBuilder, PendingReadHint, ReadRequestResetStates, ReadRequestState, } from '../structs/index.js';
import { countAccumulatedItems, getNonEmptyItems } from '../utils/index.js';
import { ScopedValueCache } from './scoped_value_cache.js';
export function isValidNoteHashReadRequest(readRequest, noteHash) {
    return (noteHash.value.equals(readRequest.value) &&
        noteHash.contractAddress.equals(readRequest.contractAddress) &&
        readRequest.counter > noteHash.counter);
}
export function getNoteHashReadRequestResetStates(noteHashReadRequests, noteHashes, futureNoteHashes) {
    const resetStates = ReadRequestResetStates.empty(MAX_NOTE_HASH_READ_REQUESTS_PER_TX);
    const noteHashMap = new Map();
    getNonEmptyItems(noteHashes).forEach((noteHash, index) => {
        const value = noteHash.value.toBigInt();
        const arr = noteHashMap.get(value) ?? [];
        arr.push({ noteHash, index });
        noteHashMap.set(value, arr);
    });
    const futureNoteHashMap = new ScopedValueCache(futureNoteHashes);
    const numReadRequests = countAccumulatedItems(noteHashReadRequests);
    for (let i = 0; i < numReadRequests; ++i) {
        const readRequest = noteHashReadRequests[i];
        const pendingNoteHash = noteHashMap
            .get(readRequest.value.toBigInt())
            ?.find(n => isValidNoteHashReadRequest(readRequest, n.noteHash));
        if (pendingNoteHash !== undefined) {
            resetStates.states[i] = ReadRequestState.PENDING;
            resetStates.pendingReadHints.push(new PendingReadHint(i, pendingNoteHash.index));
        }
        else if (!futureNoteHashMap
            .get(readRequest)
            .find(futureNoteHash => isValidNoteHashReadRequest(readRequest, futureNoteHash))) {
            resetStates.states[i] = ReadRequestState.SETTLED;
        }
    }
    return resetStates;
}
export async function buildNoteHashReadRequestHintsFromResetStates(oracle, noteHashReadRequests, noteHashes, resetStates, noteHashLeafIndexMap, maxPending = MAX_NOTE_HASH_READ_REQUESTS_PER_TX, maxSettled = MAX_NOTE_HASH_READ_REQUESTS_PER_TX) {
    const builder = new NoteHashReadRequestHintsBuilder(maxPending, maxSettled);
    resetStates.pendingReadHints.forEach(hint => {
        builder.addPendingReadRequest(hint.readRequestIndex, hint.pendingValueIndex);
    });
    for (let i = 0; i < resetStates.states.length; i++) {
        if (resetStates.states[i] === ReadRequestState.SETTLED) {
            const readRequest = noteHashReadRequests[i];
            const siloedValue = siloNoteHash(readRequest.contractAddress, readRequest.value);
            const leafIndex = noteHashLeafIndexMap.get(siloedValue.toBigInt());
            if (leafIndex === undefined) {
                throw new Error('Read request is reading an unknown note hash.');
            }
            const membershipWitness = await oracle.getNoteHashMembershipWitness(leafIndex);
            builder.addSettledReadRequest(i, membershipWitness, siloedValue);
        }
    }
    const noteHashMap = new Map();
    getNonEmptyItems(noteHashes).forEach((noteHash, index) => {
        const value = noteHash.value.toBigInt();
        const arr = noteHashMap.get(value) ?? [];
        arr.push({ noteHash, index });
        noteHashMap.set(value, arr);
    });
    return builder.toHints();
}
export async function buildNoteHashReadRequestHints(oracle, noteHashReadRequests, noteHashes, noteHashLeafIndexMap, futureNoteHashes, maxPending = MAX_NOTE_HASH_READ_REQUESTS_PER_TX, maxSettled = MAX_NOTE_HASH_READ_REQUESTS_PER_TX) {
    const resetStates = getNoteHashReadRequestResetStates(noteHashReadRequests, noteHashes, futureNoteHashes);
    return await buildNoteHashReadRequestHintsFromResetStates(oracle, noteHashReadRequests, noteHashes, resetStates, noteHashLeafIndexMap, maxPending, maxSettled);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGRfbm90ZV9oYXNoX3JlYWRfcmVxdWVzdF9oaW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oaW50cy9idWlsZF9ub3RlX2hhc2hfcmVhZF9yZXF1ZXN0X2hpbnRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFFTCxrQ0FBa0MsR0FFbkMsTUFBTSxxQkFBcUIsQ0FBQztBQUM3QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDaEQsT0FBTyxFQUVMLCtCQUErQixFQUMvQixlQUFlLEVBQ2Ysc0JBQXNCLEVBQ3RCLGdCQUFnQixHQUdqQixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzVFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRTNELE1BQU0sVUFBVSwwQkFBMEIsQ0FBQyxXQUE4QixFQUFFLFFBQXdCO0lBQ2pHLE9BQU8sQ0FDTCxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO1FBQ3hDLFFBQVEsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxlQUFlLENBQUM7UUFDNUQsV0FBVyxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUN2QyxDQUFDO0FBQ0osQ0FBQztBQUVELE1BQU0sVUFBVSxpQ0FBaUMsQ0FDL0Msb0JBQXlGLEVBQ3pGLFVBQWdFLEVBQ2hFLGdCQUFrQztJQUVsQyxNQUFNLFdBQVcsR0FBRyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztJQUVyRixNQUFNLFdBQVcsR0FBK0QsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUMxRixnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLEVB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
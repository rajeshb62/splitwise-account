import { PrivateKernelResetDimensions, privateKernelResetDimensionNames, } from '../structs/index.js';
function isDefined(value) {
    return value !== undefined;
}
function computeCost(dimensions, config) {
    return privateKernelResetDimensionNames.reduce((accum, name) => accum + dimensions[name] * config.dimensions[name].cost, 0);
}
function getSize(dimensions) {
    return privateKernelResetDimensionNames.reduce((accum, name) => accum + dimensions[name], 0);
}
function getRemainder(requestedDimensions, foundDimensions) {
    const remainder = PrivateKernelResetDimensions.empty();
    let remainingDimensions = 0;
    privateKernelResetDimensionNames.forEach(name => {
        if (requestedDimensions[name] > foundDimensions[name]) {
            remainingDimensions++;
            remainder[name] = requestedDimensions[name] - foundDimensions[name];
        }
    });
    return remainingDimensions ? remainder : undefined;
}
function pickFromValues(targetValue, values) {
    // Find the min value in `values` that's greater than or equal to `targetValue`.
    const minGte = values.reduce((prev, curr) => (curr >= targetValue && (prev === undefined || curr < prev) ? curr : prev), undefined);
    // If no such value is found, returns the max value.
    return minGte ?? Math.max(...values);
}
function pickCheapest(options) {
    return options.reduce((prev, curr) => (curr.cost < prev.cost ? curr : prev), options[0]);
}
function pickSmallestRemainder(options) {
    const optionsWithSize = options
        .filter(o => o.remainder)
        .map(option => ({ option, size: getSize(option.remainder) }));
    return optionsWithSize.reduce((prev, curr) => (curr.size < prev.size ? curr : prev), optionsWithSize[0])?.option;
}
function pickBestOption(options) {
    const optionsResetAll = options.filter(opt => !opt.remainder);
    const optionsResetPartial = options.filter(opt => opt.remainder);
    // The best option is the cheapest one that can reset all dimensions.
    // If no such option exists, find one that can reset the most data.
    return pickCheapest(optionsResetAll) || pickSmallestRemainder(optionsResetPartial);
}
function findVariant(requestedDimensions, config, isQualified) {
    const variant = PrivateKernelResetDimensions.empty();
    privateKernelResetDimensionNames.forEach(name => {
        variant[name] = pickFromValues(requestedDimensions[name], config.dimensions[name].variants);
    });
    if (!isQualified(variant)) {
        return;
    }
    return {
        dimensions: variant,
        cost: computeCost(variant, config),
        remainder: getRemainder(requestedDimensions, variant),
    };
}
function findStandalone(requestedDimensions, config, isQualified) {
    const needsReset = privateKernelResetDimensionNames.filter(name => requestedDimensions[name] > 0);
    if (needsReset.length !== 1) {
        // At the moment, we only use standalone to reset one dimension when it's about to overflow.
        return;
    }
    const name = needsReset[0];
    const value = pickFromValues(requestedDimensions[name], config.dimensions[name].standalone);
    if (!value) {
        return;
    }
    const dimensions = PrivateKernelResetDimensions.from({ [name]: value });
    if (!isQualified(dimensions)) {
        return;
    }
    return {
        dimensions,
        cost: computeCost(dimensions, config),
        remainder: getRemainder(requestedDimensions, dimensions),
    };
}
function findSpecialCase(requestedDimensions, config, isQualified) {
    const specialCases = config.specialCases.map(PrivateKernelResetDimensions.fromValues);
    const options = specialCases.filter(isQualified).map(dimensions => ({
        dimensions,
        cost: computeCost(dimensions, config),
        remainder: getRemainder(requestedDimensions, dimensions),
    }));
    return pickBestOption(options);
}
export function findPrivateKernelResetDimensions(requestedDimensions, config, isInner = false, allowRemainder = false) {
    const requestedValues = requestedDimensions.toValues();
    const isEnough = allowRemainder
        ? () => true
        : (dimensions) => dimensions.toValues().every((v, i) => v >= requestedValues[i]);
    const isQualified = !isInner
        ? isEnough
        : // If isInner is true, it's a reset to prevent overflow. The following must be zero because siloing can't be done at the moment.
            (dimensions) => dimensions.NOTE_HASH_SILOING_AMOUNT === 0 &&
                dimensions.NULLIFIER_SILOING_AMOUNT === 0 &&
                dimensions.ENCRYPTED_LOG_SILOING_AMOUNT === 0 &&
                isEnough(dimensions);
    const options = [
        findVariant(requestedDimensions, config, isQualified),
        findStandalone(requestedDimensions, config, isQualified),
        findSpecialCase(requestedDimensions, config, isQualified),
    ].filter(isDefined);
    if (!options.length) {
        throw new Error(`Cannot find an option for dimension: ${requestedDimensions.toValues()}`);
    }
    return pickBestOption(options).dimensions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZF9wcml2YXRlX2tlcm5lbF9yZXNldF9kaW1lbnNpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2hpbnRzL2ZpbmRfcHJpdmF0ZV9rZXJuZWxfcmVzZXRfZGltZW5zaW9ucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsNEJBQTRCLEVBRTVCLGdDQUFnQyxHQUNqQyxNQUFNLHFCQUFxQixDQUFDO0FBUTdCLFNBQVMsU0FBUyxDQUFJLEtBQW9CO0lBQ3hDLE9BQU8sS0FBSyxLQUFLLFNBQVMsQ0FBQztBQUM3QixDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsVUFBd0MsRUFBRSxNQUEwQztJQUN2RyxPQUFPLGdDQUFnQyxDQUFDLE1BQU0sQ0FDNUMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUN4RSxDQUFDLENBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLE9BQU8sQ0FBQyxVQUF3QztJQUN2RCxPQUFPLGdDQUFnQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDL0YsQ0FBQztBQUVELFNBQVMsWUFBWSxDQUNuQixtQkFBaUQsRUFDakQsZUFBNkM7SUFFN0MsTUFBTSxTQUFTLEdBQUcsNEJBQTRCLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDdkQsSUFBSSxtQkFBbUIsR0FBRyxDQUFDLENBQUM7SUFDNUIsZ0NBQWdDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQzlDLElBQUksbUJBQW1CLENBQUMsSUFBSSxDQUFDLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7WUFD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
import { AztecAddress } from '@aztec/foundation/aztec-address';
import { poseidon2HashWithSeparator, sha512ToGrumpkinScalar } from '@aztec/foundation/crypto';
import { GrumpkinScalar } from '@aztec/foundation/fields';
import { Grumpkin } from '../barretenberg/crypto/grumpkin/index.js';
import { GeneratorIndex } from '../constants.gen.js';
import { PublicKeys } from '../types/public_keys.js';
import { getKeyGenerator } from './utils.js';
export function computeAppNullifierSecretKey(masterNullifierSecretKey, app) {
    return computeAppSecretKey(masterNullifierSecretKey, app, 'n'); // 'n' is the key prefix for nullifier secret key
}
export function computeAppSecretKey(skM, app, keyPrefix) {
    const generator = getKeyGenerator(keyPrefix);
    return poseidon2HashWithSeparator([skM.hi, skM.lo, app], generator);
}
export function computeOvskApp(ovsk, app) {
    const ovskAppFr = computeAppSecretKey(ovsk, app, 'ov'); // 'ov' is the key prefix for outgoing viewing key
    // Here we are intentionally converting Fr (output of poseidon) to Fq. This is fine even though a distribution of
    // P = s * G will not be uniform because 2 * (q - r) / q is small.
    return GrumpkinScalar.fromBuffer(ovskAppFr.toBuffer());
}
export function deriveMasterNullifierSecretKey(secretKey) {
    return sha512ToGrumpkinScalar([secretKey, GeneratorIndex.NSK_M]);
}
export function deriveMasterIncomingViewingSecretKey(secretKey) {
    return sha512ToGrumpkinScalar([secretKey, GeneratorIndex.IVSK_M]);
}
export function deriveMasterOutgoingViewingSecretKey(secretKey) {
    return sha512ToGrumpkinScalar([secretKey, GeneratorIndex.OVSK_M]);
}
export function deriveSigningKey(secretKey) {
    // TODO(#5837): come up with a standard signing key derivation scheme instead of using ivsk_m as signing keys here
    return sha512ToGrumpkinScalar([secretKey, GeneratorIndex.IVSK_M]);
}
export function computeAddress(publicKeysHash, partialAddress) {
    const addressFr = poseidon2HashWithSeparator([publicKeysHash, partialAddress], GeneratorIndex.CONTRACT_ADDRESS_V1);
    return AztecAddress.fromField(addressFr);
}
export function derivePublicKeyFromSecretKey(secretKey) {
    const curve = new Grumpkin();
    return curve.mul(curve.generator(), secretKey);
}
/**
 * Computes secret and public keys and public keys hash from a secret key.
 * @param secretKey - The secret key to derive keys from.
 * @returns The derived keys.
 */
export function deriveKeys(secretKey) {
    // First we derive master secret keys -  we use sha512 here because this derivation will never take place
    // in a circuit
    const masterNullifierSecretKey = deriveMasterNullifierSecretKey(secretKey);
    const masterIncomingViewingSecretKey = deriveMasterIncomingViewingSecretKey(secretKey);
    const masterOutgoingViewingSecretKey = deriveMasterOutgoingViewingSecretKey(secretKey);
    const masterTaggingSecretKey = sha512ToGrumpkinScalar([secretKey, GeneratorIndex.TSK_M]);
    // Then we derive master public keys
    const masterNullifierPublicKey = derivePublicKeyFromSecretKey(masterNullifierSecretKey);
    const masterIncomingViewingPublicKey = derivePublicKeyFromSecretKey(masterIncomingViewingSecretKey);
    const masterOutgoingViewingPublicKey = derivePublicKeyFromSecretKey(masterOutgoingViewingSecretKey);
    const masterTaggingPublicKey = derivePublicKeyFromSecretKey(masterTaggingSecretKey);
    // We hash the public keys to get the public keys hash
    const publicKeys = new PublicKeys(masterNullifierPublicKey, masterIncomingViewingPublicKey, masterOutgoingViewingPublicKey, masterTaggingPublicKey);
    return {
        masterNullifierSecretKey,
        masterIncomingViewingSecretKey,
        masterOutgoingViewingSecretKey,
        masterTaggingSecretKey,
        publicKeys,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVyaXZhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9rZXlzL2Rlcml2YXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQy9ELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzlGLE9BQU8sRUFBb0IsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFNUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFckQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUU3QyxNQUFNLFVBQVUsNEJBQTRCLENBQUMsd0JBQXdDLEVBQUUsR0FBaUI7SUFDdEcsT0FBTyxtQkFBbUIsQ0FBQyx3QkFBd0IsRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxpREFBaUQ7QUFDbkgsQ0FBQztBQUVELE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxHQUFtQixFQUFFLEdBQWlCLEVBQUUsU0FBb0I7SUFDOUYsTUFBTSxTQUFTLEdBQUcsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzdDLE9BQU8sMEJBQTBCLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDdEUsQ0FBQztBQUVELE1BQU0sVUFBVSxjQUFjLENBQUMsSUFBb0IsRUFBRSxHQUFpQjtJQUNwRSxNQUFNLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsa0RBQWtEO0lBQzFHLGlI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
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { EthAddress } from '@aztec/foundation/eth-address';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import { type FieldsOf } from '@aztec/foundation/types';
import { AZTEC_EPOCH_DURATION } from '../../constants.gen.js';
import { GlobalVariables } from '../global_variables.js';
import { AppendOnlyTreeSnapshot } from './append_only_tree_snapshot.js';
/**
 * Output of the block root and block merge rollup circuits.
 */
export declare class BlockRootOrBlockMergePublicInputs {
    /**
     * Archive tree immediately before this block range.
     */
    previousArchive: AppendOnlyTreeSnapshot;
    /**
     * Archive tree after adding this block range.
     */
    newArchive: AppendOnlyTreeSnapshot;
    /**
     * Identifier of the previous block before the range.
     */
    previousBlockHash: Fr;
    /**
     * Identifier of the last block in the range.
     */
    endBlockHash: Fr;
    /**
     * Global variables for the first block in the range.
     */
    startGlobalVariables: GlobalVariables;
    /**
     * Global variables for the last block in the range.
     */
    endGlobalVariables: GlobalVariables;
    /**
     * SHA256 hash of outhash. Used to make public inputs constant-sized (to then be unpacked on-chain).
     * Note: Truncated to 31 bytes to fit in Fr.
     */
    outHash: Fr;
    /**
     * The summed `transaction_fee`s and recipients of the constituent blocks.
     */
    fees: Tuple<FeeRecipient, typeof AZTEC_EPOCH_DURATION>;
    /**
     * Root of the verification key tree.
     */
    vkTreeRoot: Fr;
    /**
     * Root of the protocol contract tree.
     */
    protocolContractTreeRoot: Fr;
    /**
     * TODO(#7346): Temporarily added prover_id while we verify block-root proofs on L1
     */
    proverId: Fr;
    constructor(
    /**
     * Archive tree immediately before this block range.
     */
    previousArchive: AppendOnlyTreeSnapshot, 
    /**
     * Archive tree after adding this block range.
     */
    newArchive: AppendOnlyTreeSnapshot, 
    /**
     * Identifier of the previous block before the range.
     */
    previousBlockHash: Fr, 
    /**
     * Identifier of the last block in the range.
     */
    endBlockHash: Fr, 
    /**
     * Global variables for the first block in the range.
     */
    startGlobalVariables: GlobalVariables, 
    /**
     * Global variables for the last block in the range.
     */
    endGlobalVariables: GlobalVariables, 
    /**
     * SHA256 hash of outhash. Used to make public inputs constant-sized (to then be unpacked on-chain).
     * Note: Truncated to 31 bytes to fit in Fr.
     */
    outHash: Fr, 
    /**
     * The summed `transaction_fee`s and recipients of the constituent blocks.
     */
    fees: Tuple<FeeRecipient, typeof AZTEC_EPOCH_DURATION>, 
    /**
     * Root of the verification key tree.
     */
    vkTreeRoot: Fr, 
    /**
     * Root of the protocol contract tree.
     */
    protocolContractTreeRoot: Fr, 
    /**
     * TODO(#7346): Temporarily added prover_id while we verify block-root proofs on L1
     */
    proverId: Fr);
    /**
     * Deserializes from a buffer or reader.
     * @param buffer - Buffer or reader to read from.
     * @returns The deserialized public inputs.
     */
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootOrBlockMergePublicInputs;
    /**
     * Serialize this as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer;
    /**
     * Serialize this as a hex string.
     * @returns - The hex string.
     */
    toString(): string;
    /**
     * Deserializes from a hex string.
     * @param str - A hex string to deserialize from.
     * @returns A new BaseOrMergeRollupPublicInputs instance.
     */
    static fromString(str: string): BlockRootOrBlockMergePublicInputs;
}
export declare class FeeRecipient {
    recipient: EthAddress;
    value: Fr;
    constructor(recipient: EthAddress, value: Fr);
    static fromBuffer(buffer: Buffer | BufferReader): FeeRecipient;
    toBuffer(): Buffer;
    static getFields(fields: FieldsOf<FeeRecipient>): readonly [EthAddress, Fr];
    toFields(): Fr[];
    isEmpty(): boolean;
    toFriendlyJSON(): {
        recipient?: undefined;
        value?: undefined;
    } | {
        recipient: `0x${string}`;
        value: `0x${string}`;
    };
}
//# sourceMappingURL=block_root_or_block_merge_public_inputs.d.ts.map
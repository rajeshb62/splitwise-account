import { makeTuple } from '@aztec/foundation/array';
import { times } from '@aztec/foundation/collection';
import { Fq, Fr } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { HONK_VERIFICATION_KEY_LENGTH_IN_FIELDS } from '../constants.gen.js';
import { CircuitType } from './shared.js';
/**
 * Curve data.
 */
export class G1AffineElement {
    constructor(x, y) {
        this.x = typeof x === 'bigint' ? new Fq(x) : x;
        this.y = typeof y === 'bigint' ? new Fq(y) : y;
    }
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer() {
        return serializeToBuffer(this.x, this.y);
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer  or BufferReader to read from.
     * @returns The G1AffineElement.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new G1AffineElement(Fq.fromBuffer(reader), Fq.fromBuffer(reader));
    }
}
/**
 * Used store and serialize a key-value map of commitments where key is the name of the commitment and value is
 * the commitment itself. The name can be e.g. Q_1, Q_2, SIGMA_1 etc.
 */
export class CommitmentMap {
    constructor(
    /**
     * An object used to store the commitments.
     */
    record) {
        this.record = record;
    }
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer() {
        const values = Object.entries(this.record);
        return serializeToBuffer(values.length, ...values.flat());
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer or BufferReader to read from.
     * @returns The CommitmentMap.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new CommitmentMap(reader.readMap(G1AffineElement));
    }
}
// TODO: find better home for these constants
export const CIRCUIT_SIZE_INDEX = 0;
export const CIRCUIT_PUBLIC_INPUTS_INDEX = 1;
export const CIRCUIT_RECURSIVE_INDEX = 3;
/**
 * Provides a 'fields' representation of a circuit's verification key
 */
export class VerificationKeyAsFields {
    constructor(key, hash) {
        this.key = key;
        this.hash = hash;
    }
    get numPublicInputs() {
        return Number(this.key[CIRCUIT_PUBLIC_INPUTS_INDEX]);
    }
    get circuitSize() {
        return Number(this.key[CIRCUIT_SIZE_INDEX]);
    }
    get isRecursive() {
        return this.key[CIRCUIT_RECURSIVE_INDEX].equals(Fr.ONE);
    }
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer() {
        return serializeToBuffer(...this.toFields());
    }
    toFields() {
        return [this.key.length, ...this.key, this.hash];
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer to read from.
     * @returns The VerificationKeyAsFields.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new VerificationKeyAsFields(reader.readVector(Fr), reader.readObject(Fr));
    }
    /**
     * Builds a fake verification key that should be accepted by circuits.
     * @returns A fake verification key.
     */
    static makeFake(size, seed = 1) {
        return new VerificationKeyAsFields(makeTuple(size, Fr.random, seed), Fr.random());
    }
    static makeFakeHonk(seed = 1) {
        return new VerificationKeyAsFields(makeTuple(HONK_VERIFICATION_KEY_LENGTH_IN_FIELDS, Fr.random, seed), Fr.random());
    }
    /**
     * Builds an 'empty' verification key
     * @returns An 'empty' verification key
     */
    static makeEmpty(size) {
        return new VerificationKeyAsFields(makeTuple(size, Fr.zero), Fr.zero());
    }
}
export class VerificationKey {
    constructor(
    /**
     * For Plonk, this is equivalent to the proving system used to prove and verify.
     */
    circuitType, 
    /**
     * The number of gates in this circuit.
     */
    circuitSize, 
    /**
     * The number of public inputs in this circuit.
     */
    numPublicInputs, 
    /**
     * The commitments for this circuit.
     */
    commitments, 
    /**
     * Contains a recursive proof?
     */
    containsRecursiveProof, 
    /**
     * Recursion stack.
     */
    recursiveProofPublicInputIndices) {
        this.circuitType = circuitType;
        this.circuitSize = circuitSize;
        this.numPublicInputs = numPublicInputs;
        this.commitments = commitments;
        this.containsRecursiveProof = containsRecursiveProof;
        this.recursiveProofPublicInputIndices = recursiveProofPublicInputIndices;
    }
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer() {
        return serializeToBuffer(this.circuitType, this.circuitSize, this.numPublicInputs, new CommitmentMap(this.commitments), this.containsRecursiveProof, serializeToBuffer(this.recursiveProofPublicInputIndices.length, this.recursiveProofPublicInputIndices));
    }
    /**
     * Deserializes class from a buffer.
     * @returns A VerificationKey instance.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new VerificationKey(reader.readNumber(), reader.readNumber(), reader.readNumber(), reader.readObject(CommitmentMap).record, reader.readBoolean(), reader.readNumberVector());
    }
    /**
     * Builds a fake verification key that should be accepted by circuits.
     * @returns A fake verification key.
     */
    static makeFake() {
        return new VerificationKey(CircuitType.ULTRA, // This is entirely arbitrary
        2048, 116, {}, // Empty set of commitments
        false, times(16, i => i));
    }
}
export class VerificationKeyData {
    constructor(keyAsFields, keyAsBytes) {
        this.keyAsFields = keyAsFields;
        this.keyAsBytes = keyAsBytes;
    }
    get numPublicInputs() {
        return this.keyAsFields.numPublicInputs;
    }
    get circuitSize() {
        return this.keyAsFields.circuitSize;
    }
    get isRecursive() {
        return this.keyAsFields.isRecursive;
    }
    static makeFakeHonk() {
        return new VerificationKeyData(VerificationKeyAsFields.makeFakeHonk(), VerificationKey.makeFake().toBuffer());
    }
    static makeFake(len = HONK_VERIFICATION_KEY_LENGTH_IN_FIELDS) {
        return new VerificationKeyData(VerificationKeyAsFields.makeFake(len), VerificationKey.makeFake().toBuffer());
    }
    /**
     * Serialize as a buffer.
     * @returns The buffer.
     */
    toBuffer() {
        return serializeToBuffer(this.keyAsFields, this.keyAsBytes.length, this.keyAsBytes);
    }
    toString() {
        return this.toBuffer().toString('hex');
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const verificationKeyAsFields = reader.readObject(VerificationKeyAsFields);
        const length = reader.readNumber();
        const bytes = reader.readBytes(length);
        return new VerificationKeyData(verificationKeyAsFields, bytes);
    }
    static fromString(str) {
        return VerificationKeyData.fromBuffer(Buffer.from(str, 'hex'));
    }
    clone() {
        return VerificationKeyData.fromBuffer(this.toBuffer());
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyaWZpY2F0aW9uX2tleS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdHJ1Y3RzL3ZlcmlmaWNhdGlvbl9rZXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxZQUFZLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUU5RSxPQUFPLEVBQUUsc0NBQXNDLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUM3RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBRTFDOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGVBQWU7SUFVMUIsWUFBWSxDQUFjLEVBQUUsQ0FBYztRQUN4QyxJQUFJLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvQyxJQUFJLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBQ0Q7OztPQUdHO0lBQ0gsUUFBUTtRQUNOLE9BQU8saUJBQWlCLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQTZCO1FBQzdDLE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENB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
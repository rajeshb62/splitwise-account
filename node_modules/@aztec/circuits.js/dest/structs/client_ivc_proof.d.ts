/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { BufferReader } from '@aztec/foundation/serialize';
/**
 * TODO(https://github.com/AztecProtocol/aztec-packages/issues/7370) refactory this to
 * eventually we read all these VKs from the data tree instead of passing them
 */
export declare class ClientIvcProof {
    instVkBuffer: Buffer;
    pgAccBuffer: Buffer;
    clientIvcProofBuffer: Buffer;
    translatorVkBuffer: Buffer;
    eccVkBuffer: Buffer;
    constructor(instVkBuffer: Buffer, pgAccBuffer: Buffer, clientIvcProofBuffer: Buffer, translatorVkBuffer: Buffer, eccVkBuffer: Buffer);
    isEmpty(): boolean;
    static empty(): ClientIvcProof;
    /**
     * TODO(#7371): eventually remove client_ivc_prove_output_all_msgpack and properly handle these accumulators and VKs
     * Create a ClientIvcProof from the result of client_ivc_prove_output_all or client_ivc_prove_output_all_msgpack
     * @param directory the directory of results
     * @returns the encapsulated client ivc proof
     */
    static readFromOutputDirectory(directory: string): Promise<ClientIvcProof>;
    /**
     * TODO(#7371): eventually remove client_ivc_prove_output_all_msgpack and properly handle these accumulators and VKs
     * Serialize a ClientIvcProof to the files expected by prove_tube
     *
     * Example usage:
     *  await runInDirectory(bbWorkingDirectory, async (dir: string) => {
     *    await privateTx.clientIvcProof!.writeToOutputDirectory(bbWorkingDirectory);
     *    const result = await generateTubeProof(bbPath, dir, logger.info)
     *    expect(result.status).toBe(BB_RESULT.SUCCESS)
     *  });
     * @param proof the ClientIvcProof from readFromOutputDirectory
     * @param directory the directory of results
     */
    writeToOutputDirectory(directory: string): Promise<void>;
    static fromBuffer(buffer: Buffer | BufferReader): ClientIvcProof;
    toBuffer(): Buffer;
}
//# sourceMappingURL=client_ivc_proof.d.ts.map
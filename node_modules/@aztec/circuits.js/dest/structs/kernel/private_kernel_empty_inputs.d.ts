/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Fr } from '@aztec/foundation/fields';
import { type FieldsOf } from '@aztec/foundation/types';
import { type RECURSIVE_PROOF_LENGTH } from '../../constants.gen.js';
import { Header } from '../header.js';
import { type RecursiveProof } from '../recursive_proof.js';
import { type VerificationKeyAsFields } from '../verification_key.js';
export declare class PrivateKernelEmptyInputData {
    readonly header: Header;
    readonly chainId: Fr;
    readonly version: Fr;
    readonly vkTreeRoot: Fr;
    readonly protocolContractTreeRoot: Fr;
    constructor(header: Header, chainId: Fr, version: Fr, vkTreeRoot: Fr, protocolContractTreeRoot: Fr);
    toBuffer(): Buffer;
    toString(): string;
    static fromBuffer(buf: Buffer): PrivateKernelEmptyInputData;
    static fromString(str: string): PrivateKernelEmptyInputData;
    static from(fields: FieldsOf<PrivateKernelEmptyInputData>): PrivateKernelEmptyInputData;
}
export declare class PrivateKernelEmptyInputs {
    readonly emptyNested: EmptyNestedData;
    readonly header: Header;
    readonly chainId: Fr;
    readonly version: Fr;
    readonly vkTreeRoot: Fr;
    readonly protocolContractTreeRoot: Fr;
    constructor(emptyNested: EmptyNestedData, header: Header, chainId: Fr, version: Fr, vkTreeRoot: Fr, protocolContractTreeRoot: Fr);
    toBuffer(): Buffer;
    static from(fields: FieldsOf<PrivateKernelEmptyInputs>): PrivateKernelEmptyInputs;
}
export declare class EmptyNestedCircuitInputs {
    toBuffer(): Buffer;
}
export declare class EmptyNestedData {
    readonly proof: RecursiveProof<typeof RECURSIVE_PROOF_LENGTH>;
    readonly vk: VerificationKeyAsFields;
    constructor(proof: RecursiveProof<typeof RECURSIVE_PROOF_LENGTH>, vk: VerificationKeyAsFields);
    toBuffer(): Buffer;
}
//# sourceMappingURL=private_kernel_empty_inputs.d.ts.map
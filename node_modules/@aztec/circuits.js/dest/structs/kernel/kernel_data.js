import { makeTuple } from '@aztec/foundation/array';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { RECURSIVE_PROOF_LENGTH, VK_TREE_HEIGHT } from '../../constants.gen.js';
import { RecursiveProof, makeEmptyRecursiveProof } from '../recursive_proof.js';
import { VerificationKeyData } from '../verification_key.js';
import { KernelCircuitPublicInputs } from './kernel_circuit_public_inputs.js';
// TODO: less ambiguous name
export class KernelData {
    constructor(
    /**
     * Public inputs of the previous kernel.
     */
    publicInputs, 
    /**
     * The previous kernel's proof (may be a tube proof or public kernel proof).
     */
    proof, 
    /**
     * Verification key of the previous kernel.
     */
    vk, 
    /**
     * Index of the previous kernel's vk in a tree of vks.
     */
    vkIndex, 
    /**
     * Sibling path of the previous kernel's vk in a tree of vks.
     */
    vkPath) {
        this.publicInputs = publicInputs;
        this.proof = proof;
        this.vk = vk;
        this.vkIndex = vkIndex;
        this.vkPath = vkPath;
    }
    static empty() {
        return new this(KernelCircuitPublicInputs.empty(), makeEmptyRecursiveProof(RECURSIVE_PROOF_LENGTH), VerificationKeyData.makeFakeHonk(), 0, makeTuple(VK_TREE_HEIGHT, Fr.zero));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new this(reader.readObject(KernelCircuitPublicInputs), RecursiveProof.fromBuffer(reader, RECURSIVE_PROOF_LENGTH), reader.readObject(VerificationKeyData), reader.readNumber(), reader.readArray(VK_TREE_HEIGHT, Fr));
    }
    toBuffer() {
        return serializeToBuffer(this.publicInputs, this.proof, this.vk, this.vkIndex, this.vkPath);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2VybmVsX2RhdGEuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvc3RydWN0cy9rZXJuZWwva2VybmVsX2RhdGEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsWUFBWSxFQUFjLGlCQUFpQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFMUYsT0FBTyxFQUFFLHNCQUFzQixFQUFFLGNBQWMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ2hGLE9BQU8sRUFBRSxjQUFjLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVoRixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM3RCxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUU5RSw0QkFBNEI7QUFDNUIsTUFBTSxPQUFPLFVBQVU7SUFDckI7SUFDRTs7T0FFRztJQUNJLFlBQXVDO0lBQzlDOztPQUVHO0lBQ0ksS0FBb0Q7SUFDM0Q7O09BRUc7SUFDSSxFQUF1QjtJQUM5Qjs7T0FFRztJQUNJLE9BQWU7SUFDdEI7O09BRUc7SUFDSSxNQUF3QztRQWhCeEMsaUJBQVksR0FBWixZQUFZLENBQTJCO1FBSXZDLFVBQUssR0FBTCxLQUFLLENBQStDO1FBSXBELE9BQUUsR0FBRixFQUFFLENBQXFCO1FBSXZCLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFJZixXQUFNLEdBQU4sTUFBTSxDQUFrQztJQUM5QyxDQUFDO0lBRUosTUFBTSxDQUFDLEtBQUs7UUFDVixPQUFPLElBQUksSUFBSSxDQUNiLHlCQUF5QixDQUFDLEtBQUssRUFBRSxFQUNqQyx1QkFBdUIsQ0FBQyxzQkFBc0IsQ0FBQyxFQUMvQyxtQkFBbUIsQ0FBQyxZQUFZLEVBQUUsRUFDbEMsQ0FBQyxFQUNELFNBQVMsQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUNuQyxDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBNkI7UUFDN0MsTUFBTSxNQUFNLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QyxPQUFPLElBQUksSUFBSSxDQUNiLE1BQU0sQ0FBQyxVQUFVLENBQUMseUJBQXlCLENBQUMsRUFDNUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsc0JBQXNCLENBQUMsRUFDekQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsQ0FBQyxFQUN0QyxNQUFNLENBQUMsVUFBVSxFQUFFLEVBQ25CLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLEVBQUUsQ0FBQyxDQUNyQyxDQUFDO0lBQ0osQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLGlCQUFpQixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlGLENBQUM7Q0FDRiJ9
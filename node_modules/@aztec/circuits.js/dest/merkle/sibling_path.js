import { pedersenHash } from '@aztec/foundation/crypto';
/** Computes the expected root of a merkle tree given a leaf and its sibling path. */
export function computeRootFromSiblingPath(leaf, siblingPath, index, hasher = (left, right) => pedersenHash([left, right]).toBuffer()) {
    let result = leaf;
    for (const sibling of siblingPath) {
        result = index & 1 ? hasher(sibling, result) : hasher(result, sibling);
        index >>= 1;
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2libGluZ19wYXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21lcmtsZS9zaWJsaW5nX3BhdGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXhELHFGQUFxRjtBQUNyRixNQUFNLFVBQVUsMEJBQTBCLENBQ3hDLElBQVksRUFDWixXQUFxQixFQUNyQixLQUFhLEVBQ2IsU0FBUyxDQUFDLElBQVksRUFBRSxLQUFhLEVBQUUsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRTtJQUVoRixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUM7SUFDbEIsS0FBSyxNQUFNLE9BQU8sSUFBSSxXQUFXLEVBQUUsQ0FBQztRQUNsQyxNQUFNLEdBQUcsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN2RSxLQUFLLEtBQUssQ0FBQyxDQUFDO0lBQ2QsQ0FBQztJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMifQ==
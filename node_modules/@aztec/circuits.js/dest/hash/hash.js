import { pedersenHashBuffer, poseidon2HashWithSeparator, sha256Trunc } from '@aztec/foundation/crypto';
import { Fr } from '@aztec/foundation/fields';
import { numToUInt8, numToUInt16BE, numToUInt32BE } from '@aztec/foundation/serialize';
import { GeneratorIndex } from '../constants.gen.js';
import { VerificationKey } from '../structs/verification_key.js';
/**
 * Computes a hash of a given verification key.
 * @param vkBuf - The verification key.
 * @returns The hash of the verification key.
 */
export function hashVK(vkBuf) {
    const vk = VerificationKey.fromBuffer(vkBuf);
    const toHash = Buffer.concat([
        numToUInt8(vk.circuitType),
        numToUInt16BE(5), // fr::coset_generator(0)?
        numToUInt32BE(vk.circuitSize),
        numToUInt32BE(vk.numPublicInputs),
        ...Object.values(vk.commitments)
            .map(e => [e.y.toBuffer(), e.x.toBuffer()])
            .flat(),
        // Montgomery form of fr::one()? Not sure. But if so, why?
        Buffer.from('1418144d5b080fcac24cdb7649bdadf246a6cb2426e324bedb94fb05118f023a', 'hex'),
    ]);
    return pedersenHashBuffer(toHash);
}
/**
 * Computes a note hash nonce, which will be used to create a unique note hash.
 * @param nullifierZero - The first nullifier in the tx.
 * @param noteHashIndex - The index of the note hash.
 * @returns A note hash nonce.
 */
export function computeNoteHashNonce(nullifierZero, noteHashIndex) {
    return poseidon2HashWithSeparator([nullifierZero, noteHashIndex], GeneratorIndex.NOTE_HASH_NONCE);
}
/**
 * Computes a siloed note hash, given the contract address and the note hash itself.
 * A siloed note hash effectively namespaces a note hash to a specific contract.
 * @param contract - The contract address
 * @param uniqueNoteHash - The unique note hash to silo.
 * @returns A siloed note hash.
 */
export function siloNoteHash(contract, uniqueNoteHash) {
    return poseidon2HashWithSeparator([contract, uniqueNoteHash], GeneratorIndex.SILOED_NOTE_HASH);
}
/**
 * Computes a unique note hash.
 * @dev Includes a nonce which contains data that guarantees the resulting note hash will be unique.
 * @param nonce - A nonce (typically derived from tx hash and note hash index in the tx).
 * @param noteHash - A note hash.
 * @returns A unique note hash.
 */
export function computeUniqueNoteHash(nonce, noteHash) {
    return poseidon2HashWithSeparator([nonce, noteHash], GeneratorIndex.UNIQUE_NOTE_HASH);
}
/**
 * Computes a siloed nullifier, given the contract address and the inner nullifier.
 * A siloed nullifier effectively namespaces a nullifier to a specific contract.
 * @param contract - The contract address.
 * @param innerNullifier - The nullifier to silo.
 * @returns A siloed nullifier.
 */
export function siloNullifier(contract, innerNullifier) {
    return poseidon2HashWithSeparator([contract, innerNullifier], GeneratorIndex.OUTER_NULLIFIER);
}
/**
 * Computes a public data tree value ready for insertion.
 * @param value - Raw public data tree value to hash into a tree-insertion-ready value.
 * @returns Value hash into a tree-insertion-ready value.

 */
export function computePublicDataTreeValue(value) {
    return value;
}
/**
 * Computes a public data tree index from contract address and storage slot.
 * @param contractAddress - Contract where insertion is occurring.
 * @param storageSlot - Storage slot where insertion is occurring.
 * @returns Public data tree index computed from contract address and storage slot.

 */
export function computePublicDataTreeLeafSlot(contractAddress, storageSlot) {
    return poseidon2HashWithSeparator([contractAddress, storageSlot], GeneratorIndex.PUBLIC_LEAF_INDEX);
}
/**
 * Computes the hash of a list of arguments.
 * @param args - Arguments to hash.
 * @returns Pedersen hash of the arguments.
 */
export function computeVarArgsHash(args) {
    if (args.length === 0) {
        return Fr.ZERO;
    }
    return poseidon2HashWithSeparator(args, GeneratorIndex.FUNCTION_ARGS);
}
/**
 * Computes a hash of a secret.
 * @dev This function is used to generate secrets for the L1 to L2 message flow and for the TransparentNote.
 * @param secret - The secret to hash (could be generated however you want e.g. `Fr.random()`)
 * @returns The hash
 */
export function computeSecretHash(secret) {
    return poseidon2HashWithSeparator([secret], GeneratorIndex.SECRET_HASH);
}
export function computeL1ToL2MessageNullifier(contract, messageHash, secret, messageIndex) {
    const innerMessageNullifier = poseidon2HashWithSeparator([messageHash, secret, messageIndex], GeneratorIndex.MESSAGE_NULLIFIER);
    return siloNullifier(contract, innerMessageNullifier);
}
/**
 * Calculates a siloed hash of a scoped l2 to l1 message.
 * @returns Fr containing 248 bits of information of sha256 hash.
 */
export function siloL2ToL1Message(l2ToL1Message, version, chainId) {
    if (l2ToL1Message.contractAddress.isZero()) {
        return Fr.ZERO;
    }
    // Left-pad recipient to 32 bytes to match what the circuit is doing
    // TODO: Only hash 20 bytes for l2l1 recipient everywhere.
    const paddedRecipient = Buffer.alloc(32);
    l2ToL1Message.message.recipient.toBuffer().copy(paddedRecipient, 12);
    const preimage = Buffer.concat([
        l2ToL1Message.contractAddress.toBuffer(),
        version.toBuffer(),
        paddedRecipient,
        chainId.toBuffer(),
        l2ToL1Message.message.content.toBuffer(),
    ]);
    return Fr.fromBuffer(sha256Trunc(preimage));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9oYXNoL2hhc2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLGtCQUFrQixFQUFFLDBCQUEwQixFQUFFLFdBQVcsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3ZHLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM5QyxPQUFPLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUV2RixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFckQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRWpFOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsTUFBTSxDQUFDLEtBQWE7SUFDbEMsTUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QyxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQzNCLFVBQVUsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDO1FBQzFCLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRSwwQkFBMEI7UUFDNUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7UUFDN0IsYUFBYSxDQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUM7UUFDakMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7YUFDN0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQzthQUMxQyxJQUFJLEVBQUU7UUFDVCwwREFBMEQ7UUFDMUQsTUFBTSxDQUFDLElBQUksQ0FBQyxrRUFBa0UsRUFBRSxLQUFLLENBQUM7S0FDdkYs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
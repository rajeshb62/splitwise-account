import * as fs from 'fs';
import { dirname, join } from 'path';
import { fileURLToPath } from 'url';
const NOIR_CONSTANTS_FILE = '../../../../noir-projects/noir-protocol-circuits/crates/types/src/constants.nr';
const TS_CONSTANTS_FILE = '../constants.gen.ts';
const CPP_AZTEC_CONSTANTS_FILE = '../../../../barretenberg/cpp/src/barretenberg/vm/aztec_constants.hpp';
const PIL_AZTEC_CONSTANTS_FILE = '../../../../barretenberg/cpp/pil/avm/constants_gen.pil';
const SOLIDITY_CONSTANTS_FILE = '../../../../l1-contracts/src/core/libraries/ConstantsGen.sol';
// Whitelist of constants that will be copied to aztec_constants.hpp.
// We don't copy everything as just a handful are needed, and updating them breaks the cache and triggers expensive bb builds.
const CPP_CONSTANTS = [
    'TOTAL_FEES_LENGTH',
    'GAS_FEES_LENGTH',
    'GAS_LENGTH',
    'CONTENT_COMMITMENT_LENGTH',
    'GLOBAL_VARIABLES_LENGTH',
    'APPEND_ONLY_TREE_SNAPSHOT_LENGTH',
    'PARTIAL_STATE_REFERENCE_LENGTH',
    'STATE_REFERENCE_LENGTH',
    'HEADER_LENGTH',
    'CALL_CONTEXT_LENGTH',
    'PUBLIC_CONTEXT_INPUTS_LENGTH',
    'PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH',
    'READ_REQUEST_LENGTH',
    'MAX_NOTE_HASH_READ_REQUESTS_PER_CALL',
    'MAX_NULLIFIER_READ_REQUESTS_PER_CALL',
    'MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL',
    'MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL',
    'CONTRACT_STORAGE_UPDATE_REQUEST_LENGTH',
    'MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL',
    'CONTRACT_STORAGE_READ_LENGTH',
    'PUBLIC_INNER_CALL_REQUEST_LENGTH',
    'MAX_PUBLIC_DATA_READS_PER_CALL',
    'MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL',
    'NOTE_HASH_LENGTH',
    'MAX_NOTE_HASHES_PER_CALL',
    'NULLIFIER_LENGTH',
    'MAX_NULLIFIERS_PER_CALL',
    'L2_TO_L1_MESSAGE_LENGTH',
    'MAX_L2_TO_L1_MSGS_PER_CALL',
    'LOG_HASH_LENGTH',
    'MAX_UNENCRYPTED_LOGS_PER_CALL',
    'HEADER_LENGTH',
    'GLOBAL_VARIABLES_LENGTH',
    'AZTEC_ADDRESS_LENGTH',
    'START_NOTE_HASH_EXISTS_WRITE_OFFSET',
    'START_NULLIFIER_EXISTS_OFFSET',
    'START_NULLIFIER_NON_EXISTS_OFFSET',
    'START_L1_TO_L2_MSG_EXISTS_WRITE_OFFSET',
    'START_SSTORE_WRITE_OFFSET',
    'START_SLOAD_WRITE_OFFSET',
    'START_EMIT_NOTE_HASH_WRITE_OFFSET',
    'START_EMIT_NULLIFIER_WRITE_OFFSET',
    'START_EMIT_L2_TO_L1_MSG_WRITE_OFFSET',
    'START_EMIT_UNENCRYPTED_LOG_WRITE_OFFSET',
    'SENDER_KERNEL_INPUTS_COL_OFFSET',
    'ADDRESS_KERNEL_INPUTS_COL_OFFSET',
    'FUNCTION_SELECTOR_KERNEL_INPUTS_COL_OFFSET',
    'CHAIN_ID_KERNEL_INPUTS_COL_OFFSET',
    'VERSION_KERNEL_INPUTS_COL_OFFSET',
    'BLOCK_NUMBER_KERNEL_INPUTS_COL_OFFSET',
    'TIMESTAMP_KERNEL_INPUTS_COL_OFFSET',
    'FEE_PER_DA_GAS_KERNEL_INPUTS_COL_OFFSET',
    'FEE_PER_L2_GAS_KERNEL_INPUTS_COL_OFFSET',
    'IS_STATIC_CALL_KERNEL_INPUTS_COL_OFFSET',
    'DA_START_GAS_KERNEL_INPUTS_COL_OFFSET',
    'L2_START_GAS_KERNEL_INPUTS_COL_OFFSET',
    'DA_END_GAS_KERNEL_INPUTS_COL_OFFSET',
    'L2_END_GAS_KERNEL_INPUTS_COL_OFFSET',
    'TRANSACTION_FEE_KERNEL_INPUTS_COL_OFFSET',
    'MEM_TAG_U1',
    'MEM_TAG_U8',
    'MEM_TAG_U16',
    'MEM_TAG_U32',
    'MEM_TAG_U64',
    'MEM_TAG_U128',
    'MEM_TAG_FF',
    'MAX_L2_GAS_PER_ENQUEUED_CALL',
];
const CPP_GENERATORS = [];
const PIL_CONSTANTS = [
    'MAX_NOTE_HASH_READ_REQUESTS_PER_CALL',
    'MAX_NULLIFIER_READ_REQUESTS_PER_CALL',
    'MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL',
    'MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL',
    'MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL',
    'MAX_PUBLIC_DATA_READS_PER_CALL',
    'MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL',
    'MAX_NOTE_HASHES_PER_CALL',
    'MAX_NULLIFIERS_PER_CALL',
    'MAX_L2_TO_L1_MSGS_PER_CALL',
    'MAX_UNENCRYPTED_LOGS_PER_CALL',
    'START_NOTE_HASH_EXISTS_WRITE_OFFSET',
    'START_NULLIFIER_EXISTS_OFFSET',
    'START_NULLIFIER_NON_EXISTS_OFFSET',
    'START_L1_TO_L2_MSG_EXISTS_WRITE_OFFSET',
    'START_SSTORE_WRITE_OFFSET',
    'START_SLOAD_WRITE_OFFSET',
    'START_EMIT_NOTE_HASH_WRITE_OFFSET',
    'START_EMIT_NULLIFIER_WRITE_OFFSET',
    'START_EMIT_L2_TO_L1_MSG_WRITE_OFFSET',
    'START_EMIT_UNENCRYPTED_LOG_WRITE_OFFSET',
    'SENDER_KERNEL_INPUTS_COL_OFFSET',
    'ADDRESS_KERNEL_INPUTS_COL_OFFSET',
    'FUNCTION_SELECTOR_KERNEL_INPUTS_COL_OFFSET',
    'CHAIN_ID_KERNEL_INPUTS_COL_OFFSET',
    'VERSION_KERNEL_INPUTS_COL_OFFSET',
    'BLOCK_NUMBER_KERNEL_INPUTS_COL_OFFSET',
    'TIMESTAMP_KERNEL_INPUTS_COL_OFFSET',
    'FEE_PER_DA_GAS_KERNEL_INPUTS_COL_OFFSET',
    'FEE_PER_L2_GAS_KERNEL_INPUTS_COL_OFFSET',
    'IS_STATIC_CALL_KERNEL_INPUTS_COL_OFFSET',
    'DA_START_GAS_KERNEL_INPUTS_COL_OFFSET',
    'L2_START_GAS_KERNEL_INPUTS_COL_OFFSET',
    'DA_END_GAS_KERNEL_INPUTS_COL_OFFSET',
    'L2_END_GAS_KERNEL_INPUTS_COL_OFFSET',
    'TRANSACTION_FEE_KERNEL_INPUTS_COL_OFFSET',
    'MEM_TAG_U1',
    'MEM_TAG_U8',
    'MEM_TAG_U16',
    'MEM_TAG_U32',
    'MEM_TAG_U64',
    'MEM_TAG_U128',
    'MEM_TAG_FF',
];
/**
 * Processes a collection of constants and generates code to export them as TypeScript constants.
 *
 * @param constants - An object containing key-value pairs representing constants.
 * @returns A string containing code that exports the constants as TypeScript constants.
 */
function processConstantsTS(constants) {
    const code = [];
    Object.entries(constants).forEach(([key, value]) => {
        code.push(`export const ${key} = ${+value > Number.MAX_SAFE_INTEGER ? value + 'n' : value};`);
    });
    return code.join('\n');
}
/**
 * Processes a collection of constants and generates code to export them as cpp constants.
 * Required to ensure consistency between the constants used in pil and used in the vm witness generator.
 *
 * @param constants - An object containing key-value pairs representing constants.
 * @returns A string containing code that exports the constants as cpp constants.
 */
function processConstantsCpp(constants, generatorIndices) {
    const code = [];
    Object.entries(constants).forEach(([key, value]) => {
        if (CPP_CONSTANTS.includes(key) || key.startsWith('AVM_')) {
            // stringify large numbers
            code.push(`#define ${key} ${BigInt(value) > 2n ** 31n - 1n ? `"0x${BigInt(value).toString(16)}"` : value}`);
        }
    });
    Object.entries(generatorIndices).forEach(([key, value]) => {
        if (CPP_GENERATORS.includes(key)) {
            code.push(`#define GENERATOR_INDEX__${key} ${value}`);
        }
    });
    return code.join('\n');
}
/**
 * Processes a collection of constants and generates code to export them as PIL constants.
 * Required to ensure consistency between the constants used in pil and used in the vm witness generator.
 *
 * @param constants - An object containing key-value pairs representing constants.
 * @returns A string containing code that exports the constants as cpp constants.
 */
function processConstantsPil(constants) {
    const code = [];
    Object.entries(constants).forEach(([key, value]) => {
        if (PIL_CONSTANTS.includes(key)) {
            code.push(`    pol ${key} = ${value};`);
        }
    });
    return code.join('\n');
}
/**
 * Processes an enum and generates code to export it as a TypeScript enum.
 *
 * @param enumName - The name of the enum.
 * @param enumValues - An object containing key-value pairs representing enum values.
 * @returns A string containing code that exports the enum as a TypeScript enum.
 */
function processEnumTS(enumName, enumValues) {
    const code = [];
    code.push(`export enum ${enumName} {`);
    Object.entries(enumValues).forEach(([key, value]) => {
        code.push(`  ${key} = ${value},`);
    });
    code.push('}');
    return code.join('\n');
}
/**
 * Processes a collection of constants and generates code to export them as Solidity constants.
 *
 * @param constants - An object containing key-value pairs representing constants.
 * @param prefix - A prefix to add to the constant names.
 * @returns A string containing code that exports the constants as Noir constants.
 */
function processConstantsSolidity(constants, prefix = '') {
    const code = [];
    Object.entries(constants).forEach(([key, value]) => {
        if (!key.startsWith('AVM_')) {
            code.push(`  uint256 internal constant ${prefix}${key} = ${value};`);
        }
    });
    return code.join('\n');
}
/**
 * Generate the constants file in Typescript.
 */
function generateTypescriptConstants({ constants, generatorIndexEnum }, targetPath) {
    const result = [
        '/* eslint-disable */\n// GENERATED FILE - DO NOT EDIT, RUN yarn remake-constants',
        processConstantsTS(constants),
        processEnumTS('GeneratorIndex', generatorIndexEnum),
    ].join('\n');
    fs.writeFileSync(targetPath, result);
}
/**
 * Generate the constants file in C++.
 */
function generateCppConstants({ constants, generatorIndexEnum }, targetPath) {
    const resultCpp = `// GENERATED FILE - DO NOT EDIT, RUN yarn remake-constants in circuits.js
#pragma once

${processConstantsCpp(constants, generatorIndexEnum)}
`;
    fs.writeFileSync(targetPath, resultCpp);
}
/**
 * Generate the constants file in PIL.
 */
function generatePilConstants({ constants }, targetPath) {
    const resultPil = `// GENERATED FILE - DO NOT EDIT, RUN yarn remake-constants in circuits.js
namespace constants(256);
${processConstantsPil(constants)}
\n`;
    fs.writeFileSync(targetPath, resultPil);
}
/**
 * Generate the constants file in Solidity.
 */
function generateSolidityConstants({ constants }, targetPath) {
    const resultSolidity = `// GENERATED FILE - DO NOT EDIT, RUN yarn remake-constants in circuits.js
// SPDX-License-Identifier: Apache-2.0
// Copyright 2023 Aztec Labs.
pragma solidity >=0.8.27;

/**
 * @title Constants Library
 * @author Aztec Labs
 * @notice Library that contains constants used throughout the Aztec protocol
 */
library Constants {
  // Prime field modulus
  uint256 internal constant P =
    21888242871839275222246405745257275088548364400416034343698204186575808495617;

${processConstantsSolidity(constants)}
}\n`;
    fs.writeFileSync(targetPath, resultSolidity);
}
/**
 * Parse the content of the constants file in Noir.
 */
function parseNoirFile(fileContent) {
    const constantsExpressions = [];
    const generatorIndexEnum = {};
    const emptyExpression = () => ({ name: '', content: [] });
    let expression = emptyExpression();
    fileContent.split('\n').forEach(l => {
        const line = l.trim();
        if (!line) {
            // Empty line.
            return;
        }
        if (line.match(/^\/\/|^\s*\/?\*/)) {
            // Comment.
            return;
        }
        {
            const [, name, _type, value, end] = line.match(/global\s+(\w+)(\s*:\s*\w+)?\s*=\s*([^;]*)(;)?/) || [];
            if (name && value) {
                const [, indexName] = name.match(/GENERATOR_INDEX__(\w+)/) || [];
                if (indexName) {
                    // Generator index.
                    generatorIndexEnum[indexName] = +value;
                }
                else if (end) {
                    // A single line of expression.
                    constantsExpressions.push([name, value]);
                }
                else {
                    // The first line of an expression.
                    expression = { name, content: [value] };
                }
                return;
            }
            else if (name) {
                // This case happens if we have only a name, with the value being on the next line
                expression = { name, content: [] };
                return;
            }
        }
        if (expression.name) {
            // The expression continues...
            const [, content, end] = line.match(/\s*([^;]+)(;)?/) || [];
            expression.content.push(content);
            if (end) {
                // The last line of an expression.
                constantsExpressions.push([expression.name, expression.content.join('')]);
                expression = emptyExpression();
            }
            return;
        }
        if (!line.includes('use crate')) {
            // eslint-disable-next-line no-console
            console.warn(`Unknown content: ${line}`);
        }
    });
    const constants = evaluateExpressions(constantsExpressions);
    return { constants, generatorIndexEnum };
}
/**
 * Converts constants defined as expressions to constants with actual values.
 * @param expressions Ordered list of expressions of the type: "CONSTANT_NAME: expression".
 *   where the expression is a string that can be evaluated to a number.
 *   For example: "CONSTANT_NAME: 2 + 2" or "CONSTANT_NAME: CONSTANT_A * CONSTANT_B".
 * @returns Parsed expressions of the form: "CONSTANT_NAME: number_as_string".
 */
function evaluateExpressions(expressions) {
    const constants = {};
    const knownBigInts = ['AZTEC_EPOCH_DURATION', 'FEE_RECIPIENT_LENGTH'];
    // Create JS expressions. It is not as easy as just evaluating the expression!
    // We basically need to convert everything to BigInts, otherwise things don't fit.
    // However, (1) the bigints need to be initialized from strings; (2) everything needs to
    // be a bigint, even the actual constant values!
    const prelude = expressions
        .map(([name, rhs]) => {
        const guardedRhs = rhs
            // Remove 'as u8' and 'as u32' castings
            .replaceAll(' as u8', '')
            .replaceAll(' as u32', '')
            // Remove the 'AztecAddress::from_field(...)' pattern
            .replace(/AztecAddress::from_field\((0x[a-fA-F0-9]+|[0-9]+)\)/g, '$1')
            // We make some space around the parentheses, so that constant numbers are still split.
            .replace(/\(/g, '( ')
            .replace(/\)/g, ' )')
            // We also make some space around common operators
            .replace(/\+/g, ' + ')
            .replace(/(?<!\/)\*(?!\/)/, ' * ')
            // We split the expression into terms...
            .split(/\s+/)
            // ...and then we convert each term to a BigInt if it is a number.
            .map(term => (isNaN(+term) ? term : `BigInt('${term}')`))
            // .. also, we convert the known bigints to BigInts.
            .map(term => (knownBigInts.includes(term) ? `BigInt(${term})` : term))
            // We join the terms back together.
            .join(' ');
        return `var ${name} = ${guardedRhs};`;
    })
        .join('\n');
    // Extract each value from the expressions. Observe that this will still be a string,
    // so that we can then choose to express it as BigInt or Number depending on the size.
    for (const [name, _] of expressions) {
        constants[name] = eval(prelude + `; BigInt(${name}).toString()`);
    }
    return constants;
}
/**
 * Convert the Noir constants to TypeScript and Solidity.
 */
function main() {
    const __dirname = dirname(fileURLToPath(import.meta.url));
    const noirConstantsFile = join(__dirname, NOIR_CONSTANTS_FILE);
    const noirConstants = fs.readFileSync(noirConstantsFile, 'utf-8');
    const parsedContent = parseNoirFile(noirConstants);
    // Typescript
    const tsTargetPath = join(__dirname, TS_CONSTANTS_FILE);
    generateTypescriptConstants(parsedContent, tsTargetPath);
    // Cpp
    const cppTargetPath = join(__dirname, CPP_AZTEC_CONSTANTS_FILE);
    generateCppConstants(parsedContent, cppTargetPath);
    // PIL
    const pilTargetPath = join(__dirname, PIL_AZTEC_CONSTANTS_FILE);
    generatePilConstants(parsedContent, pilTargetPath);
    // Solidity
    const solidityTargetPath = join(__dirname, SOLIDITY_CONSTANTS_FILE);
    fs.mkdirSync(dirname(solidityTargetPath), { recursive: true });
    generateSolidityConstants(parsedContent, solidityTargetPath);
}
main();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RhbnRzLmluLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NjcmlwdHMvY29uc3RhbnRzLmluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxFQUFFLE1BQU0sSUFBSSxDQUFDO0FBQ3pCLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3JDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxLQUFLLENBQUM7QUFFcEMsTUFBTSxtQkFBbUIsR0FBRyxnRkFBZ0YsQ0FBQztBQUM3RyxNQUFNLGlCQUFpQixHQUFHLHFCQUFxQixDQUFDO0FBQ2hELE1BQU0sd0JBQXdCLEdBQUcsc0VBQXNFLENBQUM7QUFDeEcsTUFBTSx3QkFBd0IsR0FBRyx3REFBd0QsQ0FBQztBQUMxRixNQUFNLHVCQUF1QixHQUFHLDhEQUE4RCxDQUFDO0FBRS9GLHFFQUFxRTtBQUNyRSw4SEFBOEg7QUFDOUgsTUFBTSxhQUFhLEdBQUc7SUFDcEIsbUJBQW1CO0lBQ25CLGlCQUFpQjtJQUNqQixZQUFZO0lBQ1osMkJBQTJCO0lBQzNCLHlCQUF5QjtJQUN6QixrQ0FBa0M7SUFDbEMsZ0NBQWdDO0lBQ2hDLHdCQUF3QjtJQUN4QixlQUFlO0lBQ2YscUJBQXFCO0lBQ3JCLDhCQUE4QjtJQUM5QixxQ0FBcUM7SUFDckMscUJBQXFCO0lBQ3JCLHNDQUFzQztJQUN0QyxzQ0FBc0M7SUFDdEMsbURBQW1EO0lBQ25ELHlDQUF5QztJQUN6Qyx3Q0FBd0M7SUFDeEMsMENBQTBDO0lBQzFDLDhCQUE4QjtJQUM5QixrQ0FBa0M7SUFDbEMsZ0NBQWdDO0lBQ2hDLHVDQUF1QztJQUN2QyxrQkFBa0I7SUFDbEIsMEJBQTBCO0lBQzFCLGtCQUFrQjtJQUNsQix5QkFBeUI7SUFDekIseUJBQXlCO0lBQ3pCLDRCQUE0QjtJQUM1QixpQkFBaUI7SUFDakIsK0JBQStCO0lBQy9CLGVBQWU7SUFDZix5QkFBeUI7SUFDekIs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
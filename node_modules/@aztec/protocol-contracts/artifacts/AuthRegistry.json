{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"AuthRegistry","functions":[{"name":"_set_authorized","is_unconstrained":true,"custom_attributes":["public","internal"],"abi":{"error_types":{},"parameters":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAASARgABJAAEAwAkAgQDBCQCBAAFHxgABQAEgEMdAAGARYBFKwiAQwABKwiARAACKwiARQADIgAMOACARgAAIgBdHgIBAAUeAgAABgo4BQYHIQIAEgAHOQEAACoIAQUkAgQDBgAQAQYBJAMEAQUAKAUCBioMBgckAgACCCoOCAcAKAcCByoOAQckAgQJByoIAAkqDAUKABAABwAiAGIqBAAAKgwKBiQCAAABCjgGAQUkAgEABwo4BQcIIQIAKQAIOQEAACoIAQUkAgQDCAAQAQgBJAMEAQUAKAUCCCoMCAkqDgYJACgJAgkqDgIJJAIECgkqCAAKKgwFCwAQAAkAIgBiKgQAACoMCwgKOAgBAgo4AgcBIQIAPQABOQEAABwMAAMBJAIEAAIkAgQBAyoMAgQgAEIKOAQCBSECAEYABSAARSMcDAAEBQA4CAUGKggBBSQCBAIHABABBwEkAwQBBQAoBQIHKgwHCSoOAQkkAgQBCQw4BAkKIQIAUwAKOQEAAAAoBQIJADgJBAoqDQoHLQwABwAGADgEAwUOOAQFBiECAFsABjkBAAAqDAUEIABCJQAEeACABA0AAACABIADIQAAYYADOQEAACMiAF0kAgAAAyoIAQQkAgQEBQAQAQUBJAMEAQQAKAQCBSoMBQYqDgMGACgGAgYqDgMGACgGAgYqDgMGKg0EBQAoBQIFKg4FBCoNBAUAKAUCBSoOBQQqDQQFACgFAgUqDgUEKg0EBQAoBQIFKg4FBCoIAQUAAAECASoOBAUqCAEEJAIEBQYAEAEGASQDBAEEACgEAgYqDAYHKg4DBwAoBwIHKg4DBwAoBwIHKg4DBwAoBwIHKAIAAAAAAAAAAAIAAAAAAAAAAAAIKg4IByoNBAYAKAYCBioOBgQqCAEGAAABAgEqDgQGKggBAwAAAQIBJAIEAAQqDgQDKggBBwAAAQIBJAIBAAgqDggHJAIEAQkkAgQCCioMBAIgAJ4MOAIKCyECAMEACyAAoSoNBwEKOAEIAiECAKUAAjkBAAAkAgQIASoIAAgqDAUJKgwGCioMAwsqDAcMABAAAQAiANwqBAAAKg0FASoNBgIqDQMIKg4BBSoOAgYqDggDJAIBAQMqDgMHACgCAgUAOAUEBioNBgMqDQEEAigEAgQqDgQBKg0CAQIoAQIBKg4BAioMAwEjDDgCCgshAgDEAAsgANYkAgQCDAw4AgwNIQIAyAANOQEAAAAoAQIMADgMAg0qDQ0LJAIEDQwqCAANKgwFDioMBg8qDAMQKgwHESoMCxIAEAAMACIBKSoEAAAgANYAOAIJCw44AgsMIQIA2gAMOQEAACoMCwIgAJ4iAF0kAgQDBiQCBAEHJAIEAAgqDAgFIADiDDgFBgghAgD6AAggAOUqDQEFKg0DBioNBAcqDQIIJAIEBAkqCAEKJAIEBQsAEAELASQDBAEKACgIAgskAgQEDAAoCgINPA8ACwANKg0KCAAoCAIIKg4ICioOBQEqDgoCKg4GAyoOBwQjKg0DCAw4BQgJIQIA/gAJIAEjKg0BCCoNAgkqDQMKKg0ECyoNAgwkAgQEDgw4BQ4PIQIBBwAPOQEAAAAoDAIOADgOBQ8qDQ8NKg0BDCQCBAMPDDgFDxAhAgEPABA5AQAAACgMAg8AOA8FECoNEA4AOA0ODCQCBAQODDgFDg8hAgEXAA85AQAAKwQACYADJQAEAAWABCIBeCsIgAUADQAoDQIOADgOBQ8qDgwPKg4IASoODQIqDgoDKg4LBCABIwA4BQcIDjgFCAkhAgEnAAk5AQAAKgwIBSAA4iIAXSoNBAYkAgEABwo4BgcIIQIBLwAIOQEAACoNAwYkAgQDBwo4BgcIJAIEAQYhAgFWAAggATUqDQEHKg0CCCoNAwkqDQQKKg0DCyQCBAMNDDgLDQ4hAgE+AA45AQAAKwQAB4ADJQAEAASABCIBeCsIgAUADAAoDAINADgNCw4qDgUOKg4MASoOCAIqDgkDKg4KBCoNAQUqDQIHKg0ECCoNAwkAOAkGCg44CQoLIQIBUQALOQEAACoOBQEqDgcCKg4KAyoOCAQgAXckAgQIByoIAAgqDAEJKgwCCioMAwsqDAQMABAABwAiANwqBAAAKg0BByoNAggqDQMJKg0ECiQCBAALKwQAB4ADJQAEAASABCIBeCsIgAUADAAoDAINADgNCw4qDgUOKg4MASoOCAIqDgkDKg4KBCoNAQUqDQIHKg0ECCoOBQEqDgcCKg4GAyoOCAQgAXcjKwGAA4AGCwCABgACgAchAAF8gAcgAX4rAIADgAUgAYwrAAABgAUBAAABgAQAASUABAAAgAkNAIAJgASAChcAgAqACiEAAYqACgEAgAOACYALKwGAC4AIAQCABYAJgAsrAoAIgAsBAIAJAAKACSABgSUBBAABgAUgAYwjKwAYyhjK","debug_symbols":"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","brillig_names":["_set_authorized"],"assert_messages":{"96":"Stack too deep","317":"Array index out of bounds","90":"attempt to add with overflow","199":"Array index out of bounds","336":"attempt to add with overflow","17":"Function _set_authorized can only be called internally","270":"Array index out of bounds","278":"Array index out of bounds","40":"Storage slot 0 not allowed. Storage slots must start from 1.","82":"Array index out of bounds","60":"Storage slot 0 not allowed. Storage slots must start from 1.","217":"attempt to add with overflow","294":"attempt to add with overflow","262":"Array index out of bounds"}},{"name":"is_consumable","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["is_consumable"],"assert_messages":{"16":"Function is_consumable can only be called statically","96":"Array index out of bounds","301":"Array index out of bounds","39":"Storage slot 0 not allowed. Storage slots must start from 1.","317":"Array index out of bounds","333":"attempt to add with overflow","356":"Array index out of bounds","107":"attempt to add with overflow","59":"Storage slot 0 not allowed. Storage slots must start from 1.","235":"attempt to add with overflow","114":"Stack too deep","309":"Array index out of bounds","375":"attempt to add with overflow","217":"Array index out of bounds"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnBaoNAEIDhd9mzBze6Mzt5lVKCJhoWRIOaQhHfvZs2lEDO/0V2dPxv32k3d+na+/WUxn5a3PFjc8N0btY0jXna9sK1cxqGdD29vnbl41HXv/vLrRkf47I28+qOVV24brzkg+W/+zR0+ShhL9429fDcVP3fDLZ/Fq4OWFmwsmLliJWNKocSK3usfMDKFVbGDAbMYMAMBsxgwAwGzKBgBgUzKJhBwQwKZlAwg4IZFMygYAYFM6iYQcUMKmZQMYOKGVTMoGIGFTOomEHFDEbMYMQMRsxgxAxGzGDEDEbMYMQMRsxgxAwaZtAwg4YZNMygYQYNM2iYQcMMGmbQMIO+LLm059IHLl1x6ZpLBy4tXFq5dOTSnEbPafScRg9p3PP01cypaYfuefPQ38fzy0XE+n37+5KXfwA=","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"5Z3RjuTGrYbfZa99UWQVWay8ysFB4CROsIBhB7ZzgAPD757emWnNjFs9haL67yYxN8auV//fn1pFUi2R0u9f/vHD3/7zr79+/emfP//65S//8/uXH3/++/e/ff35p9Pffv/juy9/++Xrjz9+/ddf3/7vL+Xbf6g8bf/rv7//6dtff/3t+19++/KX2r778sNP/zj9YZzU//z64w+nP6r88b/ffSFaFNS6IvjuYkszOm9rJrJtTfZs37D2grVXrH3H2hvWfiwutba6mNvqYm68KqirgrYqkFWBrgr6qsBWBatHWlaPtKweaVk90rJ6pGX1SMvqkZbVIy1H8wWPczy39rpteTY3pPkAmmtBmhPSnJHmFWnekOaCND9a06mfzaVemHekuSHNB9C8F6Q5Ic0ZaX4wQklHedmWeil/Lhe9Ye0Fa69Y+461N6z9gNpbwdoT1p6x9kejtrRzeaKifbJ1K9Vetm6l6bsfYZdbq7Tz1ipa3239Df1oRihMG3qzydajnvdz2Ksz8dhzFn3Zlgu/+tIztuTE1pzYPSe25cQeKbFHyYlNObE5J3bNiZ2zSo6cVXLkrJIjZ5UcOavkyFklqdy1TJ5+TpydiZgm5HXU7YdFmThLl5dtZfA736e9pE+xl/wp9rJ+ir1sN9zLXu+XTyQptybl7km5LSn3yMlNJSk3JeXmpNw1KXfSeklJ6yUlrZeUtF5S0npJSesl37VefvQr44mGQtFwKJoaiqaFopFQNBqKpoeisVA0IxJNDZWLa6hcXEPl4hoqF9db5uLxnubJX8D+CvbvYH8D+w+sfytgfwL7M9i/gv2X4vdJIcsKXVb0ZYUtK1bnWWh5PoWWB1RIsNNgJAb2H1j/w2MeM38C+zPYf3XCiXQ5A+hyBtDlDKDLGUCXM4AuZ4C+PInbl3NGxzYuE3jegMADB9SRc0F0dOBg4t6h7gZ1R07vkRWoO0HdGepeoe4Ho/XD0SY62rM/cVeoe4e6G9QdOcdHo0DdsXNBNMD1dYDr6+HG5Jm/gP0V7N/B/gb2x071cSlg/6Px2+r5puHpWkObbH3TyTg+3N3Ztl9np92QydY3u5PKh/s1H8XdknJLUm5Nyt2TcltS7pGT+3AH5qO4KSl30npJSevl4Q7MR3EnrZeUtF5S0npJd62Xk94GphGJhksoGgpFw6FoaiiaFopGQtFoKJoeiiZULuZQubiGysU1VC6ut8zFetGxxLWC/RvYX8D+CvbvYH8D+w+sfytgfwL7r/as8fLzs3m565CXuw55ueuQl7sOebmHkJcfis2Cfbo9i4L9O9jfwP7YjkYGdzSyrnagsS5ngOWuQ17uOuTlrkNe7jrk5a5DXu465OWuQz764GSqr88arfZ6xlaJn/0J7M9gf2SHFB/tZ5y4C9Rdoe4d6m5Qd2Q3I0O7GRnazciGfNg5H+5m/Ni9Qd0F6q5Q9w51N6g7spuRx/IZ+Vg+oxrLZ1Rj+YxqrS/wSbF8RjWWz6jG8hnVWD6jAnfMVXDHXC0E9mewfwX7N7C/gP0V7N/B/gb2Pxi/XOz8SEimMusYvdnd6nq02+hh3JSUm5Ny16TcLSm3JOXWpNw9Kbcl5U5aLzlpveSk9ZKT1ktOWi+Pdlo9jPuu9XLSP1JZQ9H0UDQWimZEoqklFA2FouFQNDUUTQtFEyoX11C5uIbKxTVULq63zMV80RVWWwH7E9ifwf4V7N/A/gL2V7B/B/sb2P9w/HZ99ZcLfylgfwL7H41fpvOroJjr7Km3N32qRJWjuYG3/idmlRm79u0FWWp1xm5yvjmu1tsl+9G8w0Yb+9AZe69nmtbn3/ug8/eio8ol+9GcRts3eVoydbqC9TXEi72p0d8esrxT0Ns47ysVqW9eAc4v+Jobv+fGt9z4IzX+0aboR+NTbnzOjV9z47fc+Lmrruauupq76mruqqu5q27PXXV77qrbc1fdnrvqHh3zeTR+7qrbc1fdnrvq9txVt+euupa76lruqmu5q67lrrpHB/bA+NLqK77oJX7sqjvFj111p/ixq+4UP3bVneLHrroz/BG76k7xY1fdKX7sqjvFj111p/i5q+4InjjfnPNoGX/GbyV26Kq8we90iR87dKf4sUN3ih87dKf4sU+Yp/ixT5in+LFPmKf4sfP+FD/2CfMMn2KfME/xj1bdqlsj2+mn22Trmw1ntcND74/irkm5W1JuScqtSbl7Um5Lyj1ych8een8Ud9J6yUnrJSetl4eH3h/FnbRectJ6yXetlx+NS15ufbqe+7Jx+9PjyS63lX6eI5LB73yf9tI+xV6Oz7CXtXyKvbxhnT9d3rtbPqmclLsm5W5JuSUptybl7km5LSn3yMndSlLupPWyJa2XLWm9PPzAjkdxJ62XLWm9bHetl5PHCLVmoWhGJBopoWgoFA2HoqmhaFooGglFo6FoQuViCZWLJVQu1lC5WG+Zi/n9owCf/BnsX8H+DewvYH8F+3ewv4H9B9a/F7D/0fg9ncVv/pevVG6HJ/tn/kfjt20v6GGhfrffPodn7h/FLUm5NSl3T8ptSblHTu7Dk/RL3I+6Y3t44D7HXvKn2Mv6Kfay3XAva7tfPpGk3JqUuyfltqTcIyf3KEm5KSk3J+WuSbmT1suRtF6OpPVyJK2XI2m9HDnrpZS71svJ3RIpFIqGQ9HUUDQtFI2EotFQND0UjYWiGZFoKFQuplC5mELlYgqVi+mWuVgu7oEKCdhfwf4d7G9g/4H15wL2J7A/g/0r2H8pfp8UsqzQZUVfVtiyYqwq1iYvnxS0rOBlRV1WLB/zunzM6/Ixr8vHvC4fwbZ8BI/OeZjReVszee3oe3kZoBydx5j6C9hfwf4d7G9g/4H1l+UVLcs5SZZzkiznJFnOSbKck2Q5J8lyTpLlOnS0g9no3IRn8qYHrzy7H+1InrgT1P3guZXx+UqltXbpXqHuDeouUHeFuneou0HdB9L9aD/xxB0aq0d7iSfuFereoO4CdVeoe4e6G9QdGqsGjdWjvZQTd2hdNWhdPdqzN3GH1lWD1lWD1lWDxqpBz4EH9Bx4QOvqgNbVAa2rR/uFJu7QujqgsTqgsTqg58ADWVe1FKg7Qd0Z6l6h7g3qjoxVLQp171B3g7oj66pSgboT1P1grJJu99Wo/2kO5cm/gv0b2F/A/gr272B/A/sPrP/R++5TfwL7A+P3cutWqr1s3Up7ffXbt7swl1vr6a7Sy9Yqb+biX+7ZKNd7stehsjn3NmNvdn4mgbbRL9nBeYfBeYfBeefo88S/La9tpfXZ64hu1outR58Q/jDukZP76FO8H8ZNSbk5KXdNyt2ScktSbk3KnbRe1qT1siatly1pvWxJ62VLWi/bXevlg55coke7RpPspXyKvdRPsZe3rPOm98snlpR75OSWkpSbknJzUu6alLsl5Zak3JqUO2m9lKT1UpLWS01aLzVpvdSk9VLvWi8nTw3Qo9MxN6aRUDQaiqaHorFQNCMSTS+haCgUDYeiCZWLe6hc3EPl4h4qF/cb5uLTZ73b+snfwP4D628F7E9gfwb7V7B/A/sL2F/B/qtPE1CzZcXqM1F0lGUFLSt4WdGWFbKswD77Qwf22R/98KzMzJ/A/gz2r2D/1TXaiywrdFnRlxW2rFjNMp3KsoKWFbysOLhCRM6N3tJfz9e4jGf3BnUXqDty/rFTh7ob1B05/9i5QN0J6s5Q9wp1b1B35PxjZ4W6d6i7Qd2R84+9Fqg7Qd0Z6o6dfuxHu8un/gL2V7B/B/sb2B87/dhbAfsT2J/B/nedUBRu5+IprO9/Z11ufTp4561PnHzxq6yBc0MD54YGzg2HOzEbbU2h7X5vi+mHOzEfxT1ych/uxHwUNyXl5qTcNSl3S8otSbk1KXfSeilJ66UkrZeatF5q0nqpSeul3rVeTnpK+uFOzNvSSCgaDUXTQ9FYKJoRiaaXUDQUioZD0YTKxT1ULu6hcnEPlYv7LXOxvJ/ZfvI3sP/A+lsB+xPYn8H+FezfwP4C9lew/8H4/bh3Zrlrsy93bfblrs2+3LXZl7s2+6jLirasWO6hG8s9dGO5h24sH/OxesytlGUFLyvqsgL7BkArHexvYH9sF7BRAfsT2H95jdLyGqW2rJBlhS4r+rLClhXLWYaXs8zhZz3X7f4/VXutp5X42Z/B/hXsf/Bs7MPeQmOBuivUvUPdDeqO7AO2WqDuBHVnqDvynUV2tLNw4i5Qd4W6d6i7Qd2RfcDWCtR99XebteUzqrZ8RrXWZfekWD6jastnVG35jKotn1G15TMqwXabmhDYn8H+FezfwP4C9lewfwf7G9gf2y1uCozfnWuLt+yGNgXnBgXnBgXnhsP9D6Oc35fTBttk65t1kdjhTolHcWtS7p6U25Jyj5zch3s/HsVNSbk5KXdNyp20Xvak9bInrZc9ab3sSetlT1ov7a718kFvvzCjT7GX/Cn2sn6KvWw33Msm98snkpRbk3L3pNyWlHvk5B4lKTcl5eak3DUpd9J6OZLWy5G0Xo6k9XIkrZcjZ70c5a71cjLvNAqFouFQNDUUTQtFI6FoNBRND0VjoWhGJBoKlYspVC6mULmYQuViumUu1vczy0/+AvZXsH8H+xvYf2D9uYD9CezPYP8K9j8Yvx9OCQ9e7YcerMuKvqywZcVqP/SoZVlBywpeVtRlRVtWLB/zunzM6/IxPzod0flly963LeV5kR8djfjImnDWjLOuOOuGsxacteKsO87acNa4aBRcNAouGgUXjYKLRsFFo+CiUXDRKLhoFFw0Ci4aFReNiotGxUWj4qJRcdGouGhUXDQqLhoVF42Ki8aOi8aOi8aOi8aOi8aOi8aOi8aOi8aOi8aOi8aOi0bDRaPhotFw0Wi4aDRcNBouGg0XjYaLRsNFo+GiceCiceCiceCiceCiceCiceCiceCiceCiceCiccCikUopQG8CejPQuwK9G9BbgN4K9D4YOkz9PKrCtdbZ1kVt27zYm3vtve7fmN9Ivt2kf2PP8sI/cvMf7Ul5OD8l5+fk/DU5f0vOL8n5NTl/T86fvP5S8vrLyesvJ6+/nLz+cvL6e7Q37uH8yesvJ6+/nLz+cvD6y+WVv+7xB6+/M/4avP5O+YPX3yl/8Po75Q9ef6f8wevvlD94/Z3yB6+/U/7g9XfKn7z+1uT1tyWvvy15/d1v5f7wzSknEXlE7BFVj6h5ROIRqUfUPSLziIZDpJ4VoZ4VoZ4VoZ4VoZ4VoZ4VoZ4Vsd9E++HrXE4i84iGQ7Tf0joTkUfEHlH1iJpH5DlO3XOcuuc4mec4mec4mec47bfDyVb/pO+Exn7LmNj2aothOyLyiHb3Sdt5n1R39mm/gWsmah6ReETqEXWPyDyisS6i/a6lmYg8orq+YE9nhB6ReET7B5fOs+jKuiPqHpF5RMMh2m9H0fIq6jsi8ojYI6oeUfOIxCNSj6ivJ0vav208Ew2HiItHRB4Re0TVI2oekXhE6hF5VgR7VgR7VkT1rIjqWRHVsyL2r+j1cn5KXyfZRC/P8DiJukdkHtFwiPav0rwRcd0RkUfEHtHuV/6t4Va2qx+nU7U/3l79uLxaUsf2FJc3L0Crbe86TC1tu2rD7zZ+BurRgCwa0AgGtH8h7JFAFA2IowHVaEAtGpBEA4qWqSVappZomVqiZWqNlqk1WqbWaJlao2VqjZapNVqm1miZWqNlao2WqTVapu7RMnWPlql7tEzdo2XqHi1T2/0XdXsFErkEuvshe72dzfa2qfkM1KIBSTQgjQbUowFZNKARDGiUaEAUDYijAd2/lr3pLrQdoLuHfaPtbUWN2yWQRQMasYC4lGhAFA2IowHVaEB3z0Ot8AZEcgkk0YA0GlCPBmTRgEYwICrRgCgaEEcDqtGAoiVGipYYKVpipGiJ8cqI7Tj/MmilvGp2x460bx2E9trxRJVePqCiP6ChP0DAH3BlTOyGH4A+yA19kBv6IF/pPWA9v12LeLR3sp2PKNu1WC3yOtx3usS4s/WHL+46fTDdAqhsPeyFp0B9bL2L9ub7/Lb1M5LcHcm2b1RM2g6S3h+Jx8dI/f5I21uexVR2kCwe0giHdOWG5EORKB4Sx0Oq8ZBaPCSJh6TxkOJl7x4ve/d42dviZW97QPYmeUXSydaD6vn8eVDfOZUxjrQDz0g1HlKLhyTxkPaH1sfrww/G3tn0/o3sucwx9s/7d2BnIvGI1CPqHpHjAQPVM9tci2OasJbuETnGyWtxjJNXKh4ReUTsEVWPqHlE4hGpR9Q9ouFYsFeGhyci8oj2D+6H0+51f3h4JmoekXhEjnHyuj88PBOZRzQcolo8IvKI2CNyjJPX/cvjM5F4RJ4CUD0FoJpH5Bgnr614ROQRsUfkWRHNsyKaZ0U0z4ponhXRPCviyiX2ut0poGpvbisQv8jYJ6s+2e53eLpn9Hpbjy9vH9T9q9Bzmblk1/rwbXvANZUx+b0h2s4fIm+L/JXfG9XOZwSnP9q7rZ+RJB6SxkPq8ZAsHtIIh3Rt0OSRSBQPieMh1XhI8bK3xcveFi97W7zsPe4fcY22HoG3HU6vSPdfS62WDanqDtJN1hJvh0L73qHo9/gQu8eHDPyHtFLu8SF0jw/he3yIRAv0Vu6foZtu31J78wLbV6T7Z+gm/DGSPSAdjlckm2w9Cp9JRpG9HRjR8nmjEg+J4iFxPKQaD6nFQwp3BtVI4yH1eEgWDyle9uZ42ZvjZW+Ol705XvbmeNn7yjP6aGuhIXpzUvYyGNSuPEiP2/lO97cRhUsVuVTsUlWXqrlUVxqq+ja2xWPnO1SP6kofutD2tiahS8IrreIzFbtU1aVqLtX+N69b6yKplkuVulTdpTKXanhUVy77z1TkUrFLVV2q5lK51oa51oa51oa51oa51sZwrY3hWhvDtTaGa21ceTCO2rlIUi98qRKXSl2q7lKZSzUcKrlycXOmIpdq/yifTiDPqtboUtVcKnGp1KXqLpW5VMOjunIZaqYil4pdKtfaINfaINfauHJhoUnfVL1cqrpLZS7V8Kiu/MidqcilYpequlTNpRKXyrU22LU22LU22LU2qmttVM8vDqnsUlWXqrlU+z1wHz++T/bbS6lvneHUx+Vn7feXTlXkUrFLtf/Nm51n3+h0l+ZS1VwqcanUpeoulblUw6O68tKZmYpcKnapXGtDXGtDXGtDXGtDXGtDXGtDXGtDXWtj/+ocl+2MiEvdUbFLVV2q5lLtD7lNhgRFXSOJ4nkPsXjeQyye9xBLF49IPSLHQKLsX1X6eIBKzDF9IKYekWP8TMw8IsdAooziEZFHxB5R9YiaRyQekXpE5liwwzGQqKV4RPsH98PhPS3sEVWPqHlEjvfbalGPqHtE5hE5BhLV88Zj9bzxWMkxfqZUPaLmEYlHpB5R94jMI3IMJKrnjcfqeeOxet54rJ43HqvnjcfqeeOxet54rJ43HuuVU9I29s6Nnk9j9doLiLaGTioqlyp2qapL1Vyq/Z9uHzcg6JVbuDNVd6nMpfI0VuiVW7gzFblU7FJVl6q5VK61Ya61Ya61Ya61Ya61MVxrY/9U/eNcc+VWbNla7KnUHZW6VN2lMpdqOFT92uzHROXJ172wS1VdquZSiUulLlV3qcylurI2dIuuYhe3s/u13v6JilwqdqmqS9VcKnGp5mtjT+VaG+RaG9fakj9WXescnqhceYNdeYNdeYNdeYNdeYNdeYNda4Nda4Nda6O61kZ1rY3qOsrVdZSr6yjX5aP8x+lv//f9L1+//9uPP/x60nz7x//89Pffvv7808tff/v/fz//y2nj/wI=","brillig_names":["public_dispatch"],"assert_messages":{"1024":"Array index out of bounds","1277":"Array index out of bounds","1347":"attempt to add with overflow","1329":"Array index out of bounds","430":"Storage slot 0 not allowed. Storage slots must start from 1.","1131":"attempt to add with overflow","1704":"Array index out of bounds","351":"rejecting all","863":"Function is_consumable can only be called statically","1113":"Array index out of bounds","1244":"Storage slot 0 not allowed. Storage slots must start from 1.","1235":"Storage slot 0 not allowed. Storage slots must start from 1.","1311":"attempt to add with overflow","1497":"attempt to add with overflow","1095":"attempt to add with overflow","1412":"Array index out of bounds","1604":"attempt to add with overflow","1336":"Array index out of bounds","1720":"Array index out of bounds","626":"Function _set_authorized can only be called internally","483":"Storage slot 0 not allowed. Storage slots must start from 1.","1120":"Array index out of bounds","1626":"attempt to add with overflow","1047":"Stack too deep","1041":"attempt to add with overflow","1608":"Array index out of bounds","1285":"attempt to add with overflow","1218":"attempt to add with overflow","1736":"attempt to add with overflow","1590":"attempt to add with overflow","883":"Storage slot 0 not allowed. Storage slots must start from 1.","1200":"Array index out of bounds","1325":"attempt to add with overflow","746":"Function is_reject_all can only be called statically","103":"Storage slot 0 not allowed. Storage slots must start from 1.","1712":"Array index out of bounds","472":"unauthorized","1109":"attempt to add with overflow","1423":"attempt to add with overflow","1615":"Array index out of bounds","1478":"Array index out of bounds","646":"Storage slot 0 not allowed. Storage slots must start from 1."}},{"name":"unconstrained_is_consumable","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7V3bbhs5DP0XP/dBlEhd+iuLxSK9IkCQFE26wKLIv6/jZsZONba6XNU58vClSFod+/QcmqSo8cz3zYeP7759/uv69tPd/ebtH983N3fvrx6u7263v31/fLN59/X65ub681+Hf71xT3+Q362//3J1+/Tr/cPV14fNW4rFvdl8vP2w/TE5t32FT9c3HzdvQ5THN9Xq7Ph5cfZ+XkuZF9aKl+e1IvvXJZcf/3yzodCBjExvkFNqkOFQntdyzBUZ/v9kivPPiwvFBpnoJuLRx4qMdCDD0+IioUUmT2sPX3ciE5fICFGarCXmFplZ+pLL/g18WVhLEp/XerePr0CyI5OQyGQkMgWIjHdIZAiJjEciE5DIMBIZQSKDlIE9Ugb2SBnYI2XggJSBA1IGDkgZOHTIwOTi1JETeWrQCSVMXXCzh5Q0t+/Fv3jdJ+o8LnUZl3ocl3oal3oel3q7KkU6V7pjh0SGkMh4JDIBiQwjkREkMhGJTEIik5HIIGVgQcrAgpSBBSkDC1IGFqQMLB0y8O9rxWKi57UxH5wxBNpRj+NST+NSz+NSb1eO3HoDEp4+TSSJXrxFvdrT/Dn1FA/OghbPjWh7zjW9dsncWJ1o2qakg/O3px1LtZTzpIocZIDt0q0o0a1VlPl4UXz5WRQyUWpRvIlSixJMlFoUNlFqUcREqUWJJkotSrooUdx8NUwsDVEoTWvZ0560d7vZa8ymy6Iul9XXdtMlXVZr20+Xy+pu++lyWQ1uP10uq8ftpwubLou6XFan20+Xy2p2++my2n7Xz6TZR650WW2/29Bltf3uaV3yavvdhi6r7Xcbuqy2323ostp+t6ELmy6Luqy2323ostp+t6HLevvdxLMuJb/QZYE00zQj9+yrXUNeb3fcU8X19tIdVSzr7bx7qrjePr2niuvt6nuquN49QE8V2VTsoOJ69xc9VbRO51dUJBeni0W3Px5cL+5+3BfDWXn5NRlTmmXMsZbR6ksXGa3AdJHRKkwXGV9h4OV5ljFJU5jppRPJz/Vx+58bmn0emn0Zhr0PFXtyQ7OnodlbI9GjrSVrJH5NxjyR3n7q5YWM9ersp8X58H4ey2tnpfPBDRZne6xBgbZnvSd9Q9hjB47Q9thJJrQ9NjhEtsfbQPJ17ZE03Z9BEtf2WOf2yvbMLywHLGZ7rHODtsc6t9e1J/KkdIwLtcc6N2h7rHNDtifYVXPQ9tjleND22L4H2h47l4G2h80eZHtsagBtj00NoO2xqQG0PTY1gLbHpgbI9rBNDX6DPUeP2BbkOP09C2KbG4AbZJMDcINsdnBOg3aSs0l+bsltj392yW3f3uN7Pmz76y4y2j64i4y2X+0ho9i+souMtvvrIqPt0brIaDupLjKyydhDRtvxdJHRdjFdZLRdTBcZbRfTRUbbxfSQ8cIe5/lqMtoupouMbDICfzfvwh5JeXH2WJ8LbY/1z698nRDND3v3C7XH+nJoe6zfR7Znvc9OHcMe25+8sj1ub0+q7bHTG2h77FQI2h42e5DtsakBtD02NYC2x6YG0PbY1AD5flgrfvTzCPas+AnUQ9hjUwNoe2xqAG2PTQ2g7WGzB9kemxpA22NTA2h7bGoAbY9NDaDtsakBsj3FpgbQ9tjUANoemxpA22NTA2B7/PLjzMk5lomOc+XgTip+6T1Cmc6UOBw8W3JJQR/c/OzP4BuLY5i8iSEdLt1RD+NS53Gpy7jU47jU07jU87jUy7DUlx9JPQZ1Gpf6uNWUxq2mNG41pXGrKY1bTQm7mqZpjxEP9joTdexqepI6djU9Rd1jV9OT1LGr6Unq2NX0JHWgarrjA1Qid3yA6t6OD1Ax2/EBqlA7PkBlZ8cHqJY88QlABWLHByjr7/gApfIdH7D8HMDycwDLzwEsPwew/BzA8nMAy88Mlp8ZLD8zWH5msPzMYPmZwfIzg+VnBsvPDJafGSw/C1h+FrD8LGD5WcDys4DlZwHLzwKWn+P5P1+85yNS8Tl7/Owv4fGZg3rxjrwgk6c030WQUqkmpTGOTD6NTD5Dk895f12eqz+wZWDyyY1MnkYm70cmH0YmD11hW+SxK2yDPHaFbZDHrrAN8iNX2DRyhc0jV9g8coXNI1fYPHKFzSNX2AxdYb3z8wPLXajJQ1fYFnnoCtsiD11hW+ShK2yDfIGusC3y0BW2RR66wrbIQ1fYFvnzT9HnCZ4PuRr8lrMnEJ6/LOvZ8098gnNgfAiMjwfjE8D4MBgfAeNz9vzDbs6HTFLxSWB8MhifgsXn/F8KbfAhMD4ejE8A48NgfASMD1g+JLB8SGD50IPlw+Wr4DLPN3uRUEGOpAjx8/8g1u/DGpBoQFEDWv4Ykd/fISflCpQ1oKIALT9iugUiDchrQEEDYg1INKCoAWkiImoiImoiImkiImkiImkiYvno/WRaOXbgTTx/bkMNyhpQUYCOHe+dBpEG5DUgTVLOmqScNUk5a5LysWOC06CsARUF6Ng4+jToSETE+dPksq9AXgMKGhBrQKIBRQ0oaUDtiFgAKSKCndOASAPyGlDQgFgDEg0oakBJA8oakCYiSBMRpIkI0kQEaSKCNOaSxlzSmEsac72iyeEjd9zwPF8C7SNVINaARAOKGlDSgJYl92ne0x7ejXQCFQXoyJfohaYbo2x/rOgd+aZ7AyQaUNSAkga0LHkMs0/x4D60E6goQEe+x9wAkQbkNaCgAbEGJBpQ1ICSBqSJCNZEhGgiQjQRIZqIEE1EiCYiRBMRoomII/OpmOeilpyvQFkDKgrQkflUA0QakNeAggbEGtCyuTxf40Hb1FiBkgaUNaCiAB0ZNTVApAF5DShoQKwBiQakiYikiYikiYgjs7BtwplBqcpGR2ZhDRBpQF4DChoQa0CiAUUNKGlAWQPSRETRRETRRETRRETRRETRbBuKZttQNNuG8p+3DY/b3/6++np99e7m4/0W8/SP327fP1zf3T7/+vDPlx//sl38Lw==","brillig_names":["unconstrained_is_consumable"]},{"name":"set_authorized","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"1Z3bbts4GITfxde5IP8DD32VxaJI27QwECRFky6wCPLuK6uRnEQHYgetMbwJ7JgjfZJ+z1AUJT8dvtx8+vnt4/Hu6/3D4cNfT4fb+8/Xj8f7u+Hd0/PV4dOP4+3t8dvH1/8+hNOfKGP7h+/Xd6e3D4/XPx4PH2KwenW4uftyepnysISvx9ubwwdN/ny1aG1By0trC5bm1rGstU5uU+vkSd+0/vvqEHUdSOIMZKUBVHWir6WeVyB1pW309NJWgpyXG3/BGBOMM8EkJpjMBFOYYCoRjAQmmMgEI0wwTA4sTA4sTA4sTA4sTA4sTA4sTA6sv8GBhw6hTa2jxAaOVp27hqGxZM/+0tarvFnuCT32iy79omu/6NYvuveL3k6lrBezu8wEU5hgKhGMBSaYyAQjTDDKBGNMMM4Ew+TAxuTAxuTAxuTAzuTAzuTA/hsc+M91xVKeMFI5dwijxhFd+0W3ftG9X/R2ctQmuqTp6s5Aa29WsYITbNrQFPzVF3X1ypH7tGjP550iYTzxSPHy8CHP8NKEz3WyJC+vjtPLZa/k5PhlPlJe3Bb4iR1f6h5+ZsefM8rLae3v8Evf+LVr/Bz6xmc3zga+9I2vfeNb3/j0qbuPT5+6+/h9p27uO3Vz36lb+k7dQp+60c/4rTl9Nep0DlpjXnSvC31Gb2/sCZ8+o/fx6TN6H58+o3fx68beD+Yz/5sNEF8d45m21vTVGKWtNBUN05m6qDQaJ51MKml+3fRE7t2Sp27Jc7fkpVvy2iv5wNUveuwXXfpF137Ruw3SGLpN0uFKVL/o3WZpDN2G6dAZp0bPYUJ/dQnxBT1yp+kuOnea7qJzp+kuOnea7qJzp+kuOlGajjxEETnyEOXeyEMUZiMPUUKdeIQodkYeoiwZeYgCYuQhcv2Rh8jKRx4yfxYyfxYyfxYyfxYyf1Yyf1Yyf1Yyf1Yyf1Yyf1Yyf1Yyf1Yyf1Yyf1YyfzYyfzYyfzYyfzYyfzYyfzYyfzYyfzYyfzYyf/bLf7/szOO+4Ll4/Zxv9pBiCjce4TMzfMx5mncXc12MlHrpGb52DJ8CNXwp0xW8WMPiC5tiz/DSM7z2DG89w3vP8NQJ24LnTtgGPHfCNuC5E3YfPvecsLnnhM09J2zuOWFzzwmbe07Y3HPCZuqElSAyNQ66hKdO2BY8dcI24At1wrbgqRO2BU+dsC146oRtwVMnbAueOmFb8JcfRZ9H8ETLYuC3XtxALM7PoTOxBY+Q8SgZj5HxOBlPIuPJZDwX9x8Lsx9aXPjh5e9K3eWRy99q2uCJZDxCxqNkPEbG42Q8iYwnk/GQ+WEk88NI5oeRzA/X72op8+8cFteFZMOyXOYtSMv1OCJKiCgjovVuTpxP5OIw4rYQVUC0MW2+IYqISBCRIiJDRI6IEiLKiAipCEUqwpCKMKQiDKkIQypifbLmrq1szaeM8zO/gy5FFRBtPdZ/XxQRkSAiRUSIKTtiyo6YsiOmvDVPb19UAdHWvLR9UUREGxWRzj8sXGQhUkRkiMgRUUJEGREVRNSuiKUoIxWRkYrYmjewL1JEhHhERjwiIx6REY/IiEdkxCMKUhEFqYiCVERBKqIgFVGQg1uQg1uQg1uQg1uRTs7G2PrQY5pEQ0YsRI6IEiLKiKggovVdLvMvIg778f3e042R04ZofZd7nB6MMryMC5EjooSIMiIqiGh9l6f5gcMxpfBetDE40xBFRCSISBGRISJHRAkRZURUEBFSEYJUhCAVIUhFCFIRglSEIBUhSEUIUhEb41OpzKGWgyxEFRBtjE81RBERCSJSRGSIyBHR+sG1eY5HNFt4+cZQU0NUAdHGUFNDFBGRICJFRIaIHBElRIRUhCEVYUhFbIyFmedZlBdutDEW1hAJIlJEZIjIEVFCRBkRFURUAVFCKiIhFZGQikhIRSSkIhJy2pCQ04aEnDak/33a8Dy8++f6x/H60+3Nw6A5ffjz7vPj8f7u5e3jv99/fTI0/g8=","brillig_names":["set_authorized"],"assert_messages":{"77":"Array index out of bounds","55":"Storage slot 0 not allowed. Storage slots must start from 1.","212":"attempt to add with overflow","257":"Array index out of bounds","273":"Array index out of bounds","91":"Stack too deep","289":"attempt to add with overflow","85":"attempt to add with overflow","194":"Array index out of bounds","312":"Array index out of bounds","331":"attempt to add with overflow","265":"Array index out of bounds","35":"Storage slot 0 not allowed. Storage slots must start from 1."}},{"name":"set_authorized_private","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"message_hash","type":{"kind":"field"},"visibility":"private"},{"name":"authorize","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7VrbbtswDP0XP+dBvEgi+yvDMKRXBAjSopcBQ9F/n5xFipMqMbjETdP6pbCac2jyiKYpya/N9c3ly92v2eL2/qm5+PHazO+vps+z+0UavTbAy/89PUwX7fDpefr43FxAUDdpbhbX6TI69zZpbmfzm+aCgn+bvENjlLhCozgtaAhQQRMHWaHJM/SgAVyA7Aq4yGtfsOYLMGKGc8c6cdU4arEdpQv+OWnAj9LskiaM0uySJn56aVSK+ymWPmlEQoar8wdJI6M0u6TRw6Uh5ZzzpDGug5XQ3gLd8LeA2i0INUdO5EPPLYDEFY/S/daTEKkGV++4TIKP0AN3AYt1F4g+rjAgjuLsFofOQBwf1+J04IMXB+RRnN3i+GOIo1wKPzvgnmg5+uI+i+sThyFQgYPwRtmc1HzHte99r7hTSh9G6U8lfRylP5X0cgbSaynejAQ90qdOrkgJ63AVluHq5w8XS1earnszDdJKoPQtPjjebmPJfb+Q4euFHLgTctB3IeP3C5lOHHJ3zViFK2bbSh331VWwqeqvsNGFDWwbKn+lUCNnt2NnL6uOPZsXKZ26cz/uFBXs9hS1oZ6iU1ZdFwMH2oW3Lp2gg/REa5dIaD8cnYM8WZiM06ddg5KMWh5NSx21PJaW7E6hpRSPUtfZ0+J4cVl5L6A9DQ6C+AxP1wLbDQ7Ddwu43sRSyClErNATcAQor65uNoNCPYAVOIDfWisyHcMbT8UblR5vkj5UWmTxLAcLyucfgv/wEDTt/5eatSxrXZfS6PJxNp/P7n5tfHvg2j/1ZRggld1qDLSVZ/V1zD5OGkALrZ+zBcpPsHQKbirWu8/N9lPATkE7hewUtlOq2STltSPdhF1Rgp0S7RSxU9RMqe8F7aeAnYJ2CtkpbKfUZ1/y0y6qG5TagX05r9fOgWJKtJ3rouOZj8Oal0PNp+Kba3L3G5WVeR3UfL05PJ55GNY8DmuehjXPw5r3w5oPRzQv7x4rjsOal2HNV59axVB2kuJ2kfXOTgE7Be0UslPYTvF2SjBTwn9Qop1STS7knDAY4nbCBDVTorNTwE5BO4XsFLZTvJ0S7JTq7O9tCKLYKWqmiLNTwE5BO4WMlDTC5aqsXvE5L0Gl+6mhi7u/Jd1PUTOlvvbbTwE7BY2UNKLl2rn+QW06xS97grh9nl/vKvdz6q1iDwesnDTgZTZUo/LlNCN2D7WWaZSGv6ePs+nl/KbdWGh/fVlc5X2GNHz+8/DvlwT+Cw==","brillig_names":["pack_arguments_array_oracle_wrapper","call_private_function_internal","unpack_returns","pack_arguments_oracle_wrapper","enqueue_public_function_call_internal"]},{"name":"set_reject_all","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"reject","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_reject_all"],"assert_messages":{"128":"Array index out of bounds","154":"Array index out of bounds","222":"Array index out of bounds","238":"Array index out of bounds","136":"attempt to add with overflow","254":"attempt to add with overflow","178":"Stack too deep","277":"Array index out of bounds","108":"Storage slot 0 not allowed. Storage slots must start from 1.","172":"attempt to add with overflow","230":"Array index out of bounds","296":"attempt to add with overflow"}},{"name":"consume","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["consume"],"assert_messages":{"454":"Array index out of bounds","622":"Array index out of bounds","171":"unauthorized","249":"Array index out of bounds","57":"rejecting all","182":"Storage slot 0 not allowed. Storage slots must start from 1.","272":"Stack too deep","473":"attempt to add with overflow","138":"Storage slot 0 not allowed. Storage slots must start from 1.","202":"Storage slot 0 not allowed. Storage slots must start from 1.","266":"attempt to add with overflow","388":"Array index out of bounds","158":"Storage slot 0 not allowed. Storage slots must start from 1.","222":"Array index out of bounds","347":"attempt to add with overflow","606":"Array index out of bounds","638":"attempt to add with overflow","399":"attempt to add with overflow","44":"Storage slot 0 not allowed. Storage slots must start from 1.","329":"Array index out of bounds","614":"Array index out of bounds","230":"attempt to add with overflow"}},{"name":"is_reject_all","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["is_reject_all"],"assert_messages":{"176":"Array index out of bounds","157":"attempt to add with overflow","320":"Array index out of bounds","244":"Array index out of bounds","260":"Array index out of bounds","276":"attempt to add with overflow","200":"Stack too deep","146":"Array index out of bounds","111":"Storage slot 0 not allowed. Storage slots must start from 1.","15":"Function is_reject_all can only be called statically","194":"attempt to add with overflow","252":"Array index out of bounds","339":"attempt to add with overflow"}}],"outputs":{"globals":{"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AuthRegistry"}},{"name":"fields","value":{"fields":[{"name":"reject_all","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"approved_actions","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_private_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::is_consumable_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::is_consumable_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"reject","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_parameters"}}],"kind":"struct","path":"AuthRegistry::set_reject_all_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"approver","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::_set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"message_hash","type":{"kind":"field"}},{"name":"authorize","type":{"kind":"boolean"}}],"kind":"struct","path":"AuthRegistry::set_authorized_parameters"}}],"kind":"struct","path":"AuthRegistry::set_authorized_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"on_behalf_of","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AuthRegistry::consume_abi"}]}},"file_map":{"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"107":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"108":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"129":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"131":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"184":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::storage_read,\n};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"185":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR,\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field,\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N],\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"190":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n    packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe { unpack_returns(self.packed_returns) };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"191":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs,\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context\n            .call_private_function_with_packed_args(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {}\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"},"209":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"315":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"365":{"path":"/usr/src/noir-projects/noir-contracts/contracts/auth_registry_contract/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract AuthRegistry {\n    use dep::aztec::{\n        state_vars::{PublicMutable, Map}, protocol_types::address::AztecAddress,\n        macros::{storage::storage, functions::{private, public, internal, view}},\n    };\n    use dep::authwit::auth::{\n        IS_VALID_SELECTOR, compute_authwit_message_hash, assert_current_call_valid_authwit,\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        reject_all: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // on_behalf_of => authwit hash => authorized\n        approved_actions: Map<AztecAddress, Map<Field, PublicMutable<bool, Context>, Context>, Context>,\n    }\n\n    /**\n     * Updates the `authorized` value for `msg_sender` for `message_hash`.\n     *\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[public]\n    fn set_authorized(message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(context.msg_sender()).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Updates the `reject_all` value for `msg_sender`.\n     *\n     * When `reject_all` is `true` any `consume` on `msg_sender` will revert.\n     *\n     * @param reject True if all actions should be rejected, false otherwise\n     */\n    #[public]\n    fn set_reject_all(reject: bool) {\n        storage.reject_all.at(context.msg_sender()).write(reject);\n    }\n\n    /**\n     * Consumes an `inner_hash` on behalf of `on_behalf_of` if the caller is authorized to do so.\n     *\n     * Will revert even if the caller is authorized if `reject_all` is set to true for `on_behalf_of`.\n     * This is to support \"mass-revoke\".\n     *\n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param inner_hash The inner_hash of the authwit\n     * @return `IS_VALID_SELECTOR` if the action was consumed, revert otherwise\n     */\n    #[public]\n    fn consume(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n        assert_eq(false, storage.reject_all.at(on_behalf_of).read(), \"rejecting all\");\n\n        let message_hash = compute_authwit_message_hash(\n            context.msg_sender(),\n            context.chain_id(),\n            context.version(),\n            inner_hash,\n        );\n\n        let authorized = storage.approved_actions.at(on_behalf_of).at(message_hash).read();\n\n        assert_eq(true, authorized, \"unauthorized\");\n        storage.approved_actions.at(on_behalf_of).at(message_hash).write(false);\n\n        IS_VALID_SELECTOR\n    }\n\n    /**\n     * Updates a public authwit using a private authwit\n     *\n     * Useful for the case where you want someone else to insert a public authwit for you.\n     * For example, if Alice wants Bob to insert an authwit in public, such that they can execute\n     * a trade, Alice can create a private authwit, and Bob can call this function with it.\n     *\n     * @param approver The address of the approver (Alice in the example)\n     * @param message_hash The message hash to authorize\n     * @param authorize True if the message hash should be authorized, false otherwise\n     */\n    #[private]\n    fn set_authorized_private(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        assert_current_call_valid_authwit(&mut context, approver);\n        AuthRegistry::at(context.this_address())\n            ._set_authorized(approver, message_hash, authorize)\n            .enqueue(&mut context);\n    }\n\n    /**\n     * Internal function to update the `authorized` value for `approver` for `messageHash`.\n     * Used along with `set_authorized_private` to update the public authwit.\n     *\n     * @param approver The address of the approver\n     * @param message_hash The message hash being authorized\n     * @param authorize True if the caller is authorized to perform the message hash, false otherwise\n     */\n    #[public]\n    #[internal]\n    fn _set_authorized(approver: AztecAddress, message_hash: Field, authorize: bool) {\n        storage.approved_actions.at(approver).at(message_hash).write(authorize);\n    }\n\n    /**\n     * Fetches the `reject_all` value for `on_behalf_of`.\n     *\n     * @param on_behalf_of The address to check\n     * @return True if all actions are rejected, false otherwise\n     */\n    #[public]\n    #[view]\n    fn is_reject_all(on_behalf_of: AztecAddress) -> bool {\n        storage.reject_all.at(on_behalf_of).read()\n    }\n\n    /**\n     * Fetches the `authorized` value for `on_behalf_of` for `message_hash`.\n     *\n     * @param on_behalf_of The address on whose behalf the action is being consumed\n     * @param message_hash The message hash to check\n     * @return True if the caller is authorized to perform the action, false otherwise\n     */\n    #[public]\n    #[view]\n    fn is_consumable(on_behalf_of: AztecAddress, message_hash: Field) -> bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n\n    unconstrained fn unconstrained_is_consumable(\n        on_behalf_of: AztecAddress,\n        message_hash: Field,\n    ) -> pub bool {\n        storage.approved_actions.at(on_behalf_of).at(message_hash).read()\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"73":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, CANONICAL_AUTH_REGISTRY_ADDRESS,\n    }, hash::poseidon2_hash_with_separator,\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let result: Field = context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n            [on_behalf_of.to_field(), inner_hash].as_slice(),\n            GasOpts::default(),\n        )\n        .deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n            [message_hash, authorize as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n            [context.this_address().to_field(), reject as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n"},"91":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_oracle_wrapper(args) };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_arguments_array_oracle_wrapper(args) };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"92":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: Field,\n    length: Field,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field,\n    )\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Deserialize<N>,\n{\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"}}}
{"transpiled":true,"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-x8664","name":"MultiCallEntrypoint","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/9VYzXLaMBAWYDB2AiEmKemNXtuLnRCgN8/0J733CRp+Lj2knckDuDNtn7uoaO2PZctQWB3YGY9krfztt7uS11bNrKW9umqu33Rty2wLzcldmx4nmSJW6pNn7UR41k+EZ+NEeAaKPGsCT9sGrm/3nd1zoVnvxy0lPmwT3QC92QFUY0at/IR+17Wfn7/Mvg6fn56G88XiWzn9t2sj19YBTjGPWWS2Y6OFP01Hs8hsijL/u8hhhn7w7wm/7Qc/Jd7vigoffSG7Ddc+FFUsH+AZKx3XxyVHuKSrg+490zVA94HpcMl/ZDrcJsSJ4tYCXxTX1dR3Xsi3EHyr/aM1poodjlGsY+N1jWaU84jx4fyJT4fmFBWfFtMFoIuYrgk6ir9thzCP5z6EeW9gnK/Jhtlew6SnnGOsfaypwAP+SkZS3HlOgmLTNuow7gHEc+j6/dX1yc0JIGZWwsKLT2V9bTv8JvAmm8i9zubzfpONvTYV77/+wFyy04Axsnnh7lugo2d3YQUCVk+Y32JYoYCFY+S33ROvXP/MrPP3g/DN9ntC7xt4/FZ6Z+rhT8paHPnhvyD82Av+qMQ/A3zNvUL4537iMyb8jh/88luo6wX/tozPBeAbvfhnVJdoP6MNsn3pJfdZts83A9qPGVdf3wyXjA+PD9Ynq0sErj1Bx/doIthJBDuUhz57Plfxe7yUuPYP5CphdRWxIkWsQ32kfFyx53N3nx4lk5HE9UrR744iVlsR69B1Qvm4Zs/n7j49SsZiPq4V/dbMx7kiVqiIpblvNeNFeZRqnZXctemRwrni/xTapDrfZPO/u5ZqzgtTCa/XAxhXrNe3+9brAeOKfIh3LOiOOeOcjZd3j/PlaP44WUwh3gPGlY/hGaK9boT5Uu2nWL80XmKdSv/FNxBXKwHoBkzXBB1xxP/iiGFq898n/mi/J+jwn+N/cpmYzbWWMJ/x/CdX8bc6G2sDNt+XkZdYp/f77kuyHzOuynx2nr1hfPh3dCxw7Qk6XpdiwU4s2DlFLH5+jTG0+4PiFBSVXiuXk2l1lkXvITzLQglAj/N/ufvEyGJ9+ANQAijv/B0AAA==","debug_symbols":"tdnBaoNAEIDhd9mzBzW7Mzu+SilBEw0LokFNoYjvXm1DCeT8X8TR2f/2nXZ117Z53M5p6MbZVR+r68dLvaRx2Kd1y1wzpb5Pt/PrZ5cfD+9/9+d7PRzjvNTT4qoy+My1w/V4s/18l/rWVT7Ilr3tavlcVf3f3A99Zs4HsC1gW8F2BNvGtUMOtguwXYLtE9gGXQbQZQBdBtBlAF0G0KWALgV0KaBLAV0K6FJAlwK6FNClgC4FdKmgSwVdKuhSQZcKulTQpYIuFXSpoEsFXUbQZQRdRtBlBF1G0GUEXUbQZQRdRtBlBF0a6NJAlwa6NNClgS4NdGmgSwNdGujSQJdFnpPxgoyXZPxExj0ZD2RcyLiS8UjGSaEFKbQghRaY0G2fvuop1U3fPu9AusdwebkSWb7vf3/25R8=","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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u+62q5Vdre1qY1dbu9rZlWJXe7s62NXRrk52dbari11d7epm1z12dberh1097brXrl529barj1197epnV3+7Bth1n10D7Rpk12C77rdriF1D7Rpm1wN2DbdrhF0j7XrQrofsGmXXaLsetmuMXWPtGmfXI3Y9atd4uybY9ZhdE+2aZNdkux63a4pdU+2aZtcTdj1p13S7Ztg1066n7Jpl12y7nrbrGbvm2DXXrmftmmfXfLsW2PWcXc/btdCuRXa9YNeLdi22a4ldL9n1sl1L7Vpm13K7XrFrhV0r7XrVrlV2rbZrjV2v2fW6XWvtWmfXG3att2uDXRvtetOut+zaZNdmu962a4tdW+3aZtc7dr1r13t2bbfrfbs+sGuHXTvt+tCuj+zaZdduuz626xO7PrVrj12f2fW5XV/YtdeuL+36yq6v7dpn1zd2fWvXfrsO2PWdXd/bddCuQ3b9YNePdv1k12G7jtj1s11H7Tpm1y92/WrXb3Ydt+t3u07YddKuU3b9Ydefdp22y100k82uaLti7MpuVw67ctqVy67cduWxK69d+ezKb1cBu86xq6Bdhew6167CdhWxq6hd59l1vl3F7Cpu1wV2XWhXCbtK2nWRXRfbVcquWLsusetSu0rbVcauy+y63K6ydpWzq7xdV9hVwa6Kdl1p11V2VbIrzi5jV7xdCXYl2pVkV2W7qtiVbFdVu662q5pd1e26xq5r7arhrtu26zq7atlV2646dl1v1w121bWrnl032nWTXfXtamDXzXbdYldDuxrZdatdt9nV2K4mdt1uV1O7mtnV3K477LrTrhZ2tbTrLrvutquVXa3tamNXW7va2ZViV3u7OtjV0a5OdnW2q4tdXe3qZtc9dnW3q4ddPe26165edvW2q49dfe3qZ1d/uwbYdZ9dA+0aZNdgu+63a4hdQ+0aZtcDdg23a4RdI+160K6H7Bpl12i7HrZrjF1j7Rpn1yN2PWrXeLsm2PWYXRPtmmTXZLset2uKXVPtmmbXE3a576B336Puvlfcfe+y++5g992qs+1y33novgPQfUea+54v971X7jul3Pc1ue9Cct8z5L7Dx30/jvvuGfe9Lu47U9z3kbjv+nDffeG+V8J9z4L7DgP3/QDu3vvuvvbunvHufuzuXufuPuLuHt3u/tfu3tLuvs3r7HL3G3b38nX3yXX3oHX3d3X3TnX3JXX3/HT303T3qnT3gXT3WHT3L3T3BnT33XP3tHP3i3P3YnP3OXP3EHP353L3vnL3lXL3bHL3Q3L3GnL38XH3yHH3n3H3dnH3Tdlrl7vfh7uXhrtPhbsHhLu/grt3gbsvgPvMvfs8u/usuPsctvuMs/v8sPtsrvvcq/tMqfu8pvsspPucofsMn6t37rNn7nNd7jNT7vNI7rM+7nM07jMq7vMf7rMV7nMLrkC66+3dtezuOnF3Dba7vtldO+yuy3XXvLrrSd21mu46SHeNobt+z10b564Vc9dOuWuJ3LU17loTd+2FuxbBvTfv3qt279269zLde3vuvS733o97L8S9N+Bm5W527GapbrboZm1u9uRmMW424Xp117u6Xs71Nk7rO+3rtKDTRk4rRP87hUW5Wu8e1aL+eqS696/v8nP/764Zc9dQuWuK3DU27poTdw2GuybBvUfv3rN27+G69zTde3zuPS/3HpB7T8S9R+Bm5m6G7GaqbsboZm5uBuVmMm5G4Xp218O6ni7WrkvsutQupwmdRnLf93K5XWXtKmdXebuusKuCXRXtutKuq+yqZJcTbMaueLsS7Eq0K8muynZVsSvZrqp2XR31z0ezmL9+rhLx7yVT/2zTp0/7e3r2ie3TI7ZNSkps/859OsX26Ne+V4duPZxk+Jc2OtM913vsuTFizyX/3HNP3259Ovfsdt8/Nzbw3djIw8rGvi/WzHfjnb4bW/pubOW7sY3vxna+G9tHnXkIO/u+WHffjT19N/bx3TjAd+NQjwN9MGJP4dQ/e/btbX+pb5/YHh1i2/bo2z3FtSP/6h+8zJriYdZTHnvmeux5wWPPco89r3vs2eix5+2IPf87nNsifvOMwvmJh1lfeez53mPPzx57TnjscT3Wme7J67GniMeeYhF7ziiwF/puvNjDyst9X6y878YrPaxM9Nhzja+BNX031vGw8kbfF2vgu7GRh5V3+L5Yiu/Gzr4be/luvN9343DfjWN9N07x3Tjdd+Ms343P+G6c5wHTRb4vtth341IPK1/12LPO18ANvhs3eVi53ffFPvbd+JXvxoO+G4/5bvzDd2POaM+NBX03FvfdeInvxit8Nyb4bqzuu/F63423+G5s5ruxte/Gzr4be/luHOS7caTvxkd8N07x3TjLd+MC340v+W5c5btxg+/Gbb4bP/TduNt34x7fjXsjNv6fW3bfF9vnu/FbDyt/9H2xw74bf/aw8lePPX/6GhgV47kxOubMrczu+2I5fTfm9rAyv++Lneu7sYjvxmK+G0v6brzYd+OlvhvL+m4s77uxgu/GK303VvKAaRXfF6vqu7Gah5U1PPbU8TXwBt+N9TysbOD7Yo18Nzbx3djcd2NL342tfTem+G7s5Luxm+/Gnr4b+/huHOC7cbDvxmG+G0f6bhztu3Gc78YJvhsn+26c5rtxhu/G2b4b5/puXOC7cZHvxiW+G5f5blzpu3GN78Z1vhvX+27c6LvxLY+a+o7Hnh0Re/73m9gf+rpSOvuZm1XBY4/x2HO1x55aHntu8tjTyGPP7RF7/nc4m0X85plN8TzMGuGxZ6zHnkkee6Z77JnjsWehx56lHntW+AZ2le/G1z2s3Oj7Ypt8N271sPJ9jz2f+Br4me/GLz2s/Nb3xb7z3fiDh5W/+r7Y774b//CwMnuOM99TIIengYV8Nxb1sPIC3xcr6bsx1sPK8r4vVtF3Y5yHlVU89tT0NbC278a6HlY28H2xhr4bG3tY2dL3xVr5bmznYWUXjz29fQ3s57txoIeVQ31fbLjvxoc8rHzY98XG+W6c4GHlFN8Xe8J340wPK+d47Fnga+BC342LPaxc7vtiK303rvGwcr3Hnk2+Bm7x3fiuh5U7fV9sl+/GTz2s/NJjzwFfAw/6bvzJw8rjvi920nfjaQ8rc+Y88z0FcnoaWMh3Y1EPKy/yfbFY341lPKys4LEn3tfAJN+NVT2srOX7Ytf7brzRw8pGHnua+Rp4p+/Guz2s7Oj7Yl18N3b3sLKvx57BvgYO9d04wsPKcb4vNt534yQPK5/02PO0r4FzfTcu8LDyJd8XW+a7caWHlWs99rzla+Dbvhvf8bDyI98X+9h342ceVu7z2HPQ18AffTf+7GHlSd8X+9N3Y3SuM7cyj8eeQrk8DSziu7GYh5Wxvi9W2ndjWQ8rr/LYk+RrYLLvxuoeVl7v+2L1fDc28LCysceeO30NvMt3YxsPK7v4vtg9vhvv9bBygMeeob4GDvfd+JCHleN9X2yi78YpHlbO9Ngz19fA+b4bF3pYucz3xVb4blztYeV6jz1v+xq4zXfjdg8rd/i+2Ee+Gz/xsHKP74t97rtxr4eVB3xf7HvfjYc8rDzssee4r4EnfDee8rDyT98X+9fd6Hw2Ruc+cyvz+r5Yft+N53hYWdhjz4W+Bpb03Xixh5Wxvi92qe/GMh5WVvR9sat8N8Z5WJnosae6r4HX+m6s6WFlLd8Xq+O78QYPK2/xfbFGvhtv87Cyqceeu30NbO27sa2HlSm+L9bBd2MnDyu7+L5YN9+N3T2s7Of7YgN8Nw70sHKIx54RvgY+6LtxlIeV431f7DHfjZM8rJzqsWeGr4FP+W6c7WHlAt8Xe9534yIPK5d47Fnua+AK342velj5hu+LbfDd+KaHlW977HnX18Dtvhs/8LDyE98X2+O78XMPK7/y2LPf18DvfDce9LDyqO+L/eK78TcPK0967PnXjeZ9DIz23Zg9z5lbmd/3xc7x3VjIw8qiHnsu8DWwhO/GizysvMz3xcr6bizvYeWVHnvifQ1M9N1Y2cPKa31frKbvxloeVt7gsae+r4E3+25s6GFlM98Xu8N3YwsPK1t57EnxNbCD78ZOHlb29H2xXr4b+3hYOcBjz/2+Bg713fiAh5UP+77YWN+Nj3hY+ZjHnim+Bk7z3fikh5XP+L7YXN+N8zysfN5jz2JfA1/y3bjUw8rVvi/2mu/GtR5WbvDYs9nXwC2+G7d5WLnT98U+8t2428PKPR57vvQ18Gvfjd94WPmD74v95LvxiIeVv3jsOeFr4CnfjX96WPmvr4LzebFo343Z8565lfk89pwbsed/30qniK8rizzMWuaxZ5XHng0ee7Z67NnlsWfP/zk0n/uGpli+MzerlMeesh57KnnsqeKxp4bHnroee27N5xmkJr4bm3tYebfvi7Xx3djew8quHnv6+BrY33fjIA8rh/m+2AjfjaM8rJzg+2KTfDdO9bDyKY89830NfN5344seVi71fbFXfDeu8rByg++LveW7cYuHle977PnE18DPfDd+6WHlt74v9p3vxh88rPzV98V+9934h4eV2fOf+Z4C+T0NLOS7saiHlRf4vlhJ342xHlZe7vti5X03XulhZYLHnmRfA6v5bqzhYeX1vi9Wz3djAw8rb/PY08zXwDt9N97tYWWK74t19N3Y1cPKez32DPA1cJDvxqEeVo72fbGxvhvHe1g5xWPPTF8DZ/tunOth5Qu+L7bEd+MyDytXe+xZ72vgm74b3/aw8gPfF/vQd+PHHlbu9diz39fA7303/uhh5W++L3bCd+OfHlbmKHDme/IX8DSwoO/GIh5WlvR9sVK+G0t7WHmFxx7ja2Ci78ZkDyuv832xOr4b63lY2dBjT1NfA+/w3XiXh5UdfF+ss+/Gezys7OOxZ5CvgUN8Nw73sHKs74s96rtxooeVT3jsme1r4BzfjfM9rFzi+2JLfTeu8LDydY89b/oauNl34zYPKz/0fbHdvhv3eFj5tcee730N/MF34xEPK0/4vtgfvhuznXPmVub22FPwHE8DC/tuPN/DylK+L3ap78bLPay80mNPoq+BVXw3VvOwso7vi9X13Vjfw8rbPPbc4WtgS9+NrT2sbOv7Yim+Gzt4WNnd98V6+m7s5WFlP489Q3wNHOa7cbiHlSN9X+wh342jPayc4PtiE303TvawcprHntm+Bj7ju3Guh5XzfF9sge/G5z2sfNn3xZb5bnzFw8pVHnvW+xq40XfjWx5WbvZ9sS2+G7d5WLnT98U+8t2428PKPR579vka+K3vxgMeVn7v+2KHfDf+6GHlr74vdtx34wkPK//02BNT0NPAHL4bcxU8cysL+r7Yub4bi3hYWcxjT0lfAy/23RjrYWU53xe7wndjRQ8r4zz2JPkaWMV3Y1UPK6/zfbHavhuv97DyRo89t/ga2Mh3420eVt7p+2ItfTfe7WFlW489HX0N7Oy7sauHlb19X6yv78b+HlYO8tgzzNfA4b4bR3pYOc73xR713TjBw8rJHnue8DVwuu/GmR5WPuv7YvN9Nz7nYeULHnte9jVwme/GVzysfN33xdb5blzvYeVbHnu2+hr4ju/G9zys3OX7Yh/7bvzUw8ovPPbs8zXwW9+NBzysPOz7Yj/7bjzmYeVxjz1/+Bp42ndjtkJnbmWeQp4vls93YwEPK8/12HO+r4HFfTde6GHlpb4vVsZ34+UeVl7hsaeSr4HGd2OCh5XVfF/sGt+NNTysrO2xp56vgTf5bmzgYWUT3xdr6ruxuYeVLT32tPE1sJ3vxvYeVt7j+2I9fDfe62FlX489A30NHOy7ccgZWpnN/n+N1N8r/tfWqLRhe+M+bdp1tTt7xKa0b9/T/XbN1P+pcUa/XTfity9I/fO6Xr3a3BfbuXtK+wF/v2tJ5MZbo87coWFn5NDaM3Jora9DazPh0LsxZ+JQ/exn4lDab5+xQ2kbfRzKn/dMHPog75k4lPbbZ+xQ2sYzdSgq9SCiLkz9M+0eUtGpf7ondxGsmfr3uMw9TJ6I50U/f3JcYtWIe2Ax7E/Ik/qcOTnPn5T2/Lk4zx+X9ry1h/31/JG+pP1/Kmuj6gz76yzrDPu7TWm/c0PE79zwX36nbsTv1I34HfcokPpztr9+5T/2pf1fdNQ/7SgQ8Tppj+vT/V/2qH/alvZ/OaL+aZO70/m5EXa5R71hf9mbZmORdP+etve81J/dZ8zSmNu++7192/dt36hv226d293Qt3u7Pp17dK/dplu3SIfTByLykSPd76XfF53u7zHp/p493d9zZPC8/21/+n/7b0GLtN/dhiKNiNmH/f05aqb+e1wmHlWS4+LSXjdm2F++pLc78vVzpPv9tOAUjsr44XxomvqzeFJsEybF//0Ik+L/PykWjrDLPTJKimn/d2PE/6XZGJkw0/7NPW/1qL+/fsQ3vP/necnxT8iW7vWiov6Z7yJfP28UFe8mW7rXS7Mn/fmknWP+1PN1j3a2rjTq1blfmz7t00pNpAuRTxudgYvpS0/a7wSxBBWM+u8lKFvUP+2MyeDf0uwu9F/2u0dGVMz2X/5Me52o/8/rZGRzRrT2fZ00ykT+DjJlFkpna+RrFczgtdOfa0w6P9L/2/+KS0w6H7NzfEzKKCWmPQpE/f/xEpmu0nMtKp3/kY9In1yKvC7iedP/Xnp7MjrzmHR+ZISLmKh/nmWOdDam35f+3PP8l9epmfr3uMw9KmdUItL7H3nm6eORO+L/zjQeaT6daTwizyhXuv+L5HRMuv+LtC/tORRkdc3Uv/8vWR1Z9jPKFenze+QZps9vpBIcn75Wpp1DentyRvx/5O/X+/+cQ7aof2L5f+XB9PZE/n7kGaTZlnZ2kVzMle7/Anbm/1P2ZHTmab+fxuuc/+X3I2MY+fu3pf7532KUUa2OSfd/0Rm8Tkb8TotDJIfT/iya7vlrpv49LnOP/7SV53GePy4yTlHpfIl83fTtcxTQhrTnS4tLRrU6vYZN+93c6ezLhrfPRKV7ZKTZ0h5FIn7O9l9szBvx/8h8l/b8+TjPnyFWIm7uHpUv3f+lxSx7Bvuy/Ze/R6f783/9brb/8bwFMvi/yDY2/b/9P7NAsXbJBBIA","debug_symbols":"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","brillig_names":["enqueue_public_function_call_internal","call_private_function_internal","directive_invert","directive_integer_quotient"]}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}}],"kind":"struct","path":"MultiCallEntrypoint::entrypoint_parameters"}}],"kind":"struct","path":"MultiCallEntrypoint::entrypoint_abi"}]}},"file_map":{"105":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"106":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"161":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"186":{"path":"/usr/src/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"},"305":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"312":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"325":{"path":"/usr/src/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"456":{"path":"/usr/src/noir-projects/noir-contracts/contracts/multi_call_entrypoint_contract/src/main.nr","source":"// An entrypoint contract that allows everything to go through. Only used for testing\n// Pair this with SignerlessWallet to perform multiple actions before any account contracts are deployed (and without authentication)\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract MultiCallEntrypoint {\n    use dep::authwit::entrypoint::app::AppPayload;\n    use dep::aztec::macros::functions::private;\n\n    #[private]\n    fn entrypoint(app_payload: AppPayload) {\n        app_payload.execute_calls(&mut context);\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"80":{"path":"/usr/src/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"}}}
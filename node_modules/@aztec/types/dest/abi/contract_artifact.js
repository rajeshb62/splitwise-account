import { FunctionType, NoteSelector, } from '@aztec/foundation/abi';
import { Fr } from '@aztec/foundation/fields';
import { AZTEC_INITIALIZER_ATTRIBUTE, AZTEC_INTERNAL_ATTRIBUTE, AZTEC_PRIVATE_ATTRIBUTE, AZTEC_PUBLIC_ATTRIBUTE, AZTEC_VIEW_ATTRIBUTE, } from '../noir/index.js';
import { mockVerificationKey } from './mocked_keys.js';
/**
 * Serializes a contract artifact to a buffer for storage.
 * @param artifact - Artifact to serialize.
 * @returns A buffer.
 */
export function contractArtifactToBuffer(artifact) {
    return Buffer.from(JSON.stringify(artifact, (key, value) => {
        if (key === 'bytecode' &&
            value !== null &&
            typeof value === 'object' &&
            value.type === 'Buffer' &&
            Array.isArray(value.data)) {
            return Buffer.from(value.data).toString('base64');
        }
        return value;
    }), 'utf-8');
}
/**
 * Deserializes a contract artifact from storage.
 * @param buffer - Buffer to deserialize.
 * @returns Deserialized artifact.
 */
export function contractArtifactFromBuffer(buffer) {
    return JSON.parse(buffer.toString('utf-8'), (key, value) => {
        if (key === 'bytecode' && typeof value === 'string') {
            return Buffer.from(value, 'base64');
        }
        if (typeof value === 'object' && value !== null && value.type === 'NoteSelector') {
            return new NoteSelector(Number(value.value));
        }
        if (typeof value === 'object' && value !== null && value.type === 'Fr') {
            return new Fr(BigInt(value.value));
        }
        return value;
    });
}
/**
 * Gets nargo build output and returns a valid contract artifact instance.
 * @param input - Input object as generated by nargo compile.
 * @returns A valid contract artifact instance.
 */
export function loadContractArtifact(input) {
    if (isContractArtifact(input)) {
        return input;
    }
    return generateContractArtifact(input);
}
/**
 * Checks if the given input looks like a valid ContractArtifact. The check is not exhaustive,
 * and it's just meant to differentiate between nargo raw build artifacts and the ones
 * produced by this compiler.
 * @param input - Input object.
 * @returns True if it looks like a ContractArtifact.
 */
function isContractArtifact(input) {
    if (typeof input !== 'object') {
        return false;
    }
    const maybeContractArtifact = input;
    if (typeof maybeContractArtifact.name !== 'string') {
        return false;
    }
    if (!Array.isArray(maybeContractArtifact.functions)) {
        return false;
    }
    for (const fn of maybeContractArtifact.functions) {
        if (typeof fn.name !== 'string') {
            return false;
        }
        if (typeof fn.functionType !== 'string') {
            return false;
        }
    }
    return true;
}
/**
 * Generates a function parameter out of one generated by a nargo build.
 * @param param - Noir parameter.
 * @returns A function parameter.
 */
function generateFunctionParameter(param) {
    const { visibility } = param;
    if (visibility === 'databus') {
        throw new Error(`Unsupported visibility ${param.visibility} for noir contract function parameter ${param.name}.`);
    }
    return { ...param, visibility: visibility };
}
/**
 * Generates a function build artifact. Replaces verification key with a mock value.
 * @param fn - Noir function entry.
 * @param contract - Parent contract.
 * @returns Function artifact.
 */
function generateFunctionArtifact(fn, contract) {
    if (fn.custom_attributes === undefined) {
        throw new Error(`No custom attributes found for contract function ${fn.name}. Try rebuilding the contract with the latest nargo version.`);
    }
    const functionType = getFunctionType(fn);
    const isInternal = fn.custom_attributes.includes(AZTEC_INTERNAL_ATTRIBUTE);
    const isStatic = fn.custom_attributes.includes(AZTEC_VIEW_ATTRIBUTE);
    // If the function is not unconstrained, the first item is inputs or CallContext which we should omit
    let parameters = fn.abi.parameters.map(generateFunctionParameter);
    if (hasKernelFunctionInputs(parameters)) {
        parameters = parameters.slice(1);
    }
    let returnTypes = [];
    if (functionType === FunctionType.UNCONSTRAINED && fn.abi.return_type) {
        returnTypes = [fn.abi.return_type.abi_type];
    }
    else {
        const pathToFind = `${contract.name}::${fn.name}_abi`;
        const abiStructs = contract.outputs.structs['functions'];
        const returnStruct = abiStructs.find(a => a.kind === 'struct' && a.path === pathToFind);
        if (returnStruct) {
            if (returnStruct.kind !== 'struct') {
                throw new Error('Could not generate contract function artifact');
            }
            const returnTypeField = returnStruct.fields.find(field => field.name === 'return_type');
            if (returnTypeField) {
                returnTypes = [returnTypeField.type];
            }
        }
    }
    return {
        name: fn.name,
        functionType,
        isInternal,
        isStatic,
        isInitializer: fn.custom_attributes.includes(AZTEC_INITIALIZER_ATTRIBUTE),
        parameters,
        returnTypes,
        bytecode: Buffer.from(fn.bytecode, 'base64'),
        verificationKey: mockVerificationKey,
        debugSymbols: fn.debug_symbols,
        assertMessages: fn.assert_messages,
    };
}
function getFunctionType(fn) {
    if (fn.custom_attributes.includes(AZTEC_PRIVATE_ATTRIBUTE)) {
        return FunctionType.PRIVATE;
    }
    else if (fn.custom_attributes.includes(AZTEC_PUBLIC_ATTRIBUTE)) {
        return FunctionType.PUBLIC;
    }
    else if (fn.is_unconstrained) {
        return FunctionType.UNCONSTRAINED;
    }
    else {
        // Default to a private function (see simple_macro_example_expanded for an example of this behavior)
        return FunctionType.PRIVATE;
    }
}
/**
 * Returns true if the first parameter is kernel function inputs.
 *
 * Noir macros #[aztec(private|public)] inject the following code
 * fn <name>(inputs: <Public|Private>ContextInputs, ...otherparams) {}
 *
 * Return true if this injected parameter is found
 */
function hasKernelFunctionInputs(params) {
    const firstParam = params[0];
    return firstParam?.type.kind === 'struct' && firstParam.type.path.includes('ContextInputs');
}
/**
 * Generates a storage layout for the contract artifact.
 * @param input - The compiled noir contract to get storage layout for
 * @returns A storage layout for the contract.
 */
function getStorageLayout(input) {
    // If another contract is imported by the main contract, its storage layout its going to also show up here.
    // The layout export includes the contract name, so here we can find the one that belongs to the current one and
    // ignore the rest.
    const storageExports = input.outputs.globals.storage ? input.outputs.globals.storage : [];
    const storageForContract = storageExports.find(storageExport => {
        const contractNameField = storageExport.fields.find(field => field.name === 'contract_name')?.value;
        return contractNameField.value === input.name;
    });
    const storageFields = storageForContract
        ? storageForContract.fields.find(field => field.name == 'fields').value
            .fields
        : [];
    if (storageFields.length === 0) {
        return {};
    }
    return storageFields.reduce((acc, field) => {
        const name = field.name;
        const slot = field.value.fields[0].value;
        acc[name] = {
            slot: Fr.fromString(slot.value),
        };
        return acc;
    }, {});
}
/**
 * Generates records of the notes with note type ids of the artifact.
 * @param input - The compiled noir contract to get note types for
 * @return A record of the note types and their ids
 */
function getNoteTypes(input) {
    // The type is useless here as it does not give us any guarantee (e.g. `AbiValue` can be one of many different
    // types) so we nuke it and later we manually check the values are as we expect.
    const notes = input.outputs.globals.notes;
    if (!notes) {
        return {};
    }
    return notes.reduce((acc, note) => {
        const noteFields = note.fields;
        // We find note type id by looking for respective kinds as each of them is unique
        const rawNoteTypeId = noteFields.find((field) => field.kind === 'integer');
        const rawName = noteFields.find((field) => field.kind === 'string');
        const rawNoteFields = noteFields.find((field) => field.kind === 'struct');
        if (!rawNoteTypeId || !rawName || !rawNoteFields) {
            throw new Error(`Could not find note type id, name or fields for note ${note}`);
        }
        const noteTypeId = NoteSelector.fromField(Fr.fromString(rawNoteTypeId.value));
        const name = rawName.value;
        // Note type id is encoded as a hex string
        const fields = rawNoteFields.fields.map((field) => {
            return {
                name: field.name,
                index: parseInt(field.value.fields[0].value.value, 16),
                nullable: field.value.fields[1].value.value,
            };
        });
        acc[name] = {
            id: noteTypeId,
            typ: name,
            fields,
        };
        return acc;
    }, {});
}
/**
 * Given a Nargo output generates an Aztec-compatible contract artifact.
 * @param compiled - Noir build output.
 * @returns Aztec contract build artifact.
 */
function generateContractArtifact(contract, aztecNrVersion) {
    try {
        return {
            name: contract.name,
            functions: contract.functions.map(f => generateFunctionArtifact(f, contract)),
            outputs: contract.outputs,
            storageLayout: getStorageLayout(contract),
            notes: getNoteTypes(contract),
            fileMap: contract.file_map,
            aztecNrVersion,
        };
    }
    catch (err) {
        throw new Error(`Could not generate contract artifact for ${contract.name}: ${err}`);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJhY3RfYXJ0aWZhY3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYWJpL2NvbnRyYWN0X2FydGlmYWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFTTCxZQUFZLEVBRVosWUFBWSxHQUdiLE1BQU0sdUJBQXVCLENBQUM7QUFDL0IsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRTlDLE9BQU8sRUFDTCwyQkFBMkIsRUFDM0Isd0JBQXdCLEVBQ3hCLHVCQUF1QixFQUN2QixzQkFBc0IsRUFDdEIsb0JBQW9CLEdBRXJCLE1BQU0sa0JBQWtCLENBQUM7QUFDMUIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFdkQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FBQyxRQUEwQjtJQUNqRSxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFO1FBQ3RDLElBQ0UsR0FBRyxLQUFLLFVBQVU7WUFDbEIsS0FBSyxLQUFLLElBQUk7WUFDZCxPQUFPLEtBQUssS0FBSyxRQUFRO1lBQ3pCLEtBQUssQ0FBQyxJQUFJLEtBQUssUUFBUTtZQUN2QixLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFDekIsQ0FBQztZQUNELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3BELENBQUM7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUMsQ0FBQyxFQUNGLE9BQU8sQ0FDUixDQUFDO0FBQ0osQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsMEJBQTBCLENBQUMsTUFBYztJQUN2RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMs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
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Buffer32 } from '@aztec/foundation/buffer';
import { BufferReader } from '@aztec/foundation/serialize';
/**Viem Signature
 *
 * A version of the Signature class that uses `0x${string}` values for r and s rather than
 * Buffer32s
 */
export type ViemSignature = {
    r: `0x${string}`;
    s: `0x${string}`;
    v: number;
    isEmpty: boolean;
};
/**
 * Signature
 *
 * Contains a signature split into it's primary components (r,s,v)
 */
export declare class Signature {
    /** The r value of the signature */
    readonly r: Buffer32;
    /** The s value of the signature */
    readonly s: Buffer32;
    /** The v value of the signature */
    readonly v: number;
    /** Does this struct store an empty signature */
    readonly isEmpty: boolean;
    private size;
    constructor(
    /** The r value of the signature */
    r: Buffer32, 
    /** The s value of the signature */
    s: Buffer32, 
    /** The v value of the signature */
    v: number, 
    /** Does this struct store an empty signature */
    isEmpty?: boolean);
    static fromBuffer(buf: Buffer | BufferReader): Signature;
    /**
     * A seperate method exists for this as when signing locally with viem, as when
     * parsing from viem, we can expect the v value to be a u8, rather than our
     * default serialization of u32
     */
    static from0xString(sig: `0x${string}`): Signature;
    static random(): Signature;
    static empty(): Signature;
    equals(other: Signature): boolean;
    toBuffer(): Buffer;
    getSize(): number;
    to0xString(): `0x${string}`;
    /**
     * Return the signature with `0x${string}` encodings for r and s
     */
    toViemSignature(): ViemSignature;
}
//# sourceMappingURL=eth_signature.d.ts.map
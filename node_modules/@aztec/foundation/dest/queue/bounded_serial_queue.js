import { createDebugLogger } from '../log/index.js';
import { Semaphore } from './semaphore.js';
import { SerialQueue } from './serial_queue.js';
/**
 * Leverages the unbounded SerialQueue and Semaphore to create a SerialQueue that will block when putting an item
 * if the queue size = maxQueueSize.
 */
export class BoundedSerialQueue {
    constructor(maxQueueSize, log = createDebugLogger('aztec:foundation:bounded_serial_queue')) {
        this.log = log;
        this.queue = new SerialQueue();
        this.semaphore = new Semaphore(maxQueueSize);
    }
    /**
     * Initializes the underlying SerialQueue instance, allowing items to be processed from the queue.
     * The start method should be called before using the BoundedSerialQueue to ensure proper functionality.
     */
    start() {
        this.queue.start();
    }
    /**
     * Returns the current number of items in the queue.
     * This is useful for monitoring the size of BoundedSerialQueue and understanding its utilization.
     *
     * @returns The length of the queue as an integer value.
     */
    length() {
        return this.queue.length();
    }
    /**
     * Cancels the current operation in the SerialQueue, if any, and clears the queue.
     * Any pending tasks in the queue will not be executed, and the queue will be emptied.
     * This method is useful for cleaning up resources and stopping ongoing processes when they are no longer needed.
     * @returns A promise, resolved once cancelled.
     */
    cancel() {
        return this.queue.cancel();
    }
    /**
     * Ends the queue processing gracefully, preventing new items from being added.
     * The currently executing item, if any, will complete and remaining queued items
     * will be processed in order. Once all items have been processed, the queue becomes
     * permanently unusable.
     *
     * @returns A promise that resolves when all items in the queue have been processed.
     */
    end() {
        return this.queue.end();
    }
    /**
     * The caller will block until fn is successfully enqueued.
     * The fn itself is execute asynchronously and its result discarded.
     * TODO(AD) do we need this if we have exec()?
     * @param fn - The function to call once unblocked.
     */
    async put(fn) {
        await this.semaphore.acquire();
        this.queue
            .put(async () => {
            try {
                await fn();
            }
            finally {
                this.semaphore.release();
            }
        })
            .catch(err => {
            this.log.error('BoundedSerialQueue handler exception:', err);
        });
    }
    /**
     * The caller will block until fn is successfully executed, and it's result returned.
     * @param fn - The function.
     * @returns A promise that resolves with the result once executed.
     */
    async exec(fn) {
        await this.semaphore.acquire();
        return this.queue.put(async () => {
            try {
                return await fn();
            }
            finally {
                this.semaphore.release();
            }
        });
    }
    /**
     * Awaiting this ensures the queue is empty before resuming.
     */
    async syncPoint() {
        await this.queue.syncPoint();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm91bmRlZF9zZXJpYWxfcXVldWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcXVldWUvYm91bmRlZF9zZXJpYWxfcXVldWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDcEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUVoRDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sa0JBQWtCO0lBSTdCLFlBQVksWUFBb0IsRUFBVSxNQUFNLGlCQUFpQixDQUFDLHVDQUF1QyxDQUFDO1FBQWhFLFFBQUcsR0FBSCxHQUFHLENBQTZEO1FBSHpGLFVBQUssR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDO1FBSXpDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7T0FHRztJQUNJLEtBQUs7UUFDVixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU07UUFDWCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTTtRQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLEdBQUc7UUFDUixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUF1QjtRQUN0QyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLEtBQUs7YUFDUCxHQUFHLENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDZCxJQUFJLENBQUM7Z0JBQ0gsTUFBTSxFQUFFLEVBQUUsQ0FBQztZQUNiLENBQUM7b0JBQVMsQ0FBQztnQkFDVCxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzNCLENBQUM7UUFDSCxDQUFDLENBQUM7YUFDRCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDWCxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyx1Q0FBdUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMvRCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLElBQUksQ0FBSSxFQUFvQjtRQUN2QyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDL0IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLElBQUksRUFBRTtZQUMvQixJQUFJLENBQUM7Z0JBQ0gsT0FBTyxNQUFNLEVBQUUsRUFBRSxDQUFDO1lBQ3BCLENBQUM7b0JBQVMsQ0FBQztnQkFDVCxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzNCLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxTQUFTO1FBQ3BCLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUMvQixDQUFDO0NBQ0YifQ==
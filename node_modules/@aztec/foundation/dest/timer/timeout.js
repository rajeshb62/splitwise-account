/**
 * TimeoutTask class creates an instance for managing and executing a given asynchronous function with a specified timeout duration.
 * The task will be automatically interrupted if it exceeds the given timeout duration, and will throw a custom error message.
 * Additional information such as execution time can be retrieved using getTime method after the task has been executed.
 *
 * @typeparam T - The return type of the asynchronous function to be executed.
 */
export class TimeoutTask {
    constructor(fn, timeout = 0, fnName = '', error = () => new Error(`Timeout${fnName ? ` running ${fnName}` : ''} after ${timeout}ms.`)) {
        this.fn = fn;
        this.timeout = timeout;
        this.interrupt = () => { };
        this.totalTime = 0;
        this.interruptPromise = new Promise((_, reject) => {
            this.interrupt = () => reject(error());
        });
    }
    /**
     * Executes the given function with a specified timeout.
     * If the function takes longer than the timeout, it will be interrupted and an error will be thrown.
     * The total execution time of the function will be stored in the totalTime property.
     *
     * @returns The result of the executed function if completed within the timeout.
     * @throws An error with a message indicating the function was interrupted due to exceeding the specified timeout.
     */
    async exec() {
        const interruptTimeout = !this.timeout ? 0 : setTimeout(this.interrupt, this.timeout);
        try {
            const start = Date.now();
            const result = await Promise.race([this.fn(), this.interruptPromise]);
            this.totalTime = Date.now() - start;
            return result;
        }
        finally {
            clearTimeout(interruptTimeout);
        }
    }
    /**
     * Returns the interrupt promise associated with the TimeoutTask instance.
     * The interrupt promise is used internally to reject the task when a timeout occurs.
     * This method can be helpful when debugging or tracking the state of the task.
     *
     * @returns The interrupt promise associated with the task.
     */
    getInterruptPromise() {
        return this.interruptPromise;
    }
    /**
     * Get the total time spent on the most recent execution of the wrapped function.
     * This method provides the duration from the start to the end of the function execution, whether it completed or timed out.
     *
     * @returns The total time in milliseconds spent on the most recent function execution.
     */
    getTime() {
        return this.totalTime;
    }
}
export const executeTimeout = async (fn, timeout = 0, fnName = '') => {
    const task = new TimeoutTask(fn, timeout, fnName);
    return await task.exec();
};
export const executeTimeoutWithCustomError = async (fn, timeout = 0, error = () => new Error('No custom error provided'), fnName = '') => {
    const task = new TimeoutTask(fn, timeout, fnName, error);
    return await task.exec();
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZW91dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90aW1lci90aW1lb3V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUNILE1BQU0sT0FBTyxXQUFXO0lBS3RCLFlBQ1UsRUFBb0IsRUFDcEIsVUFBVSxDQUFDLEVBQ25CLE1BQU0sR0FBRyxFQUFFLEVBQ1gsS0FBSyxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksS0FBSyxDQUFDLFVBQVUsTUFBTSxDQUFDLENBQUMsQ0FBQyxZQUFZLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsT0FBTyxLQUFLLENBQUM7UUFIbkYsT0FBRSxHQUFGLEVBQUUsQ0FBa0I7UUFDcEIsWUFBTyxHQUFQLE9BQU8sQ0FBSTtRQUxiLGNBQVMsR0FBRyxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUM7UUFDckIsY0FBUyxHQUFHLENBQUMsQ0FBQztRQVFwQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxPQUFPLENBQUksQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFDbkQsSUFBSSxDQUFDLFNBQVMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN6QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksS0FBSyxDQUFDLElBQUk7UUFDZixNQUFNLGdCQUFnQixHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEYsSUFBSSxDQUFDO1lBQ0gsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ3pCLE1BQU0sTUFBTSxHQUFHLE1BQU0sT0FBTyxDQUFDLElBQUksQ0FBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBQ3pFLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQztZQUNwQyxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO2dCQUFTLENBQUM7WUFDVCxZQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUNqQyxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLG1CQUFtQjtRQUN4QixPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztJQUMvQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxPQUFPO1FBQ1osT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3hCLENBQUM7Q0FDRjtBQUVELE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxLQUFLLEVBQUssRUFBb0IsRUFBRSxPQUFPLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxFQUFFLEVBQUUsRUFBRTtJQUN4RixNQUFNLElBQUksR0FBRyxJQUFJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xELE9BQU8sTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDM0IsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sNkJBQTZCLEdBQUcsS0FBSyxFQUNoRCxFQUFvQixFQUNwQixPQUFPLEdBQUcsQ0FBQyxFQUNYLEtBQUssR0FBRyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxFQUNuRCxNQUFNLEdBQUcsRUFBRSxFQUNYLEVBQUU7SUFDRixNQUFNLElBQUksR0FBRyxJQUFJLFdBQVcsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN6RCxPQUFPLE1BQU0sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQzNCLENBQUMsQ0FBQyJ9
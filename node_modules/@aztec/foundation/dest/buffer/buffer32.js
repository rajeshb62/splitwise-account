import { randomBytes } from '@aztec/foundation/crypto';
import { BufferReader, deserializeBigInt, serializeBigInt } from '@aztec/foundation/serialize';
/**
 * A class representing a 32 byte Buffer.
 */
export class Buffer32 {
    constructor(
    /**
     * The buffer containing the hash.
     */
    buffer) {
        this.buffer = buffer;
        if (buffer.length !== Buffer32.SIZE) {
            throw new Error(`Expected buffer to have length ${Buffer32.SIZE} but was ${buffer.length}`);
        }
    }
    /**
     * Returns the raw buffer of the hash.
     * @returns The buffer containing the hash.
     */
    toBuffer() {
        return this.buffer;
    }
    /**
     * Creates a Buffer32 from a buffer.
     * @param buffer - The buffer to create from.
     * @returns A new Buffer32 object.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new Buffer32(reader.readBytes(Buffer32.SIZE));
    }
    /**
     * Checks if this hash and another hash are equal.
     * @param hash - A hash to compare with.
     * @returns True if the hashes are equal, false otherwise.
     */
    equals(hash) {
        return this.buffer.equals(hash.buffer);
    }
    /**
     * Returns true if this hash is zero.
     * @returns True if this hash is zero.
     */
    isZero() {
        return this.buffer.equals(Buffer.alloc(32, 0));
    }
    /**
     * Convert this hash to a hex string.
     * @returns The hex string.
     */
    toString() {
        return this.buffer.toString('hex');
    }
    to0xString() {
        return `0x${this.buffer.toString('hex')}`;
    }
    /**
     * Convert this hash to a big int.
     * @returns The big int.
     */
    toBigInt() {
        return deserializeBigInt(this.buffer, 0, Buffer32.SIZE).elem;
    }
    /**
     * Creates a Buffer32 from a bigint.
     * @param hash - The tx hash as a big int.
     * @returns The Buffer32.
     */
    static fromBigInt(hash) {
        return new Buffer32(serializeBigInt(hash, Buffer32.SIZE));
    }
    static fromField(hash) {
        return new Buffer32(serializeBigInt(hash.toBigInt()));
    }
    /**
     * Converts this hash from a buffer of 28 bytes.
     * Verifies the input is 28 bytes.
     * @param buffer - The 28 byte buffer to construct from.
     * @returns A Buffer32 created from the input buffer with 4 bytes 0 padding at the front.
     */
    static fromBuffer28(buffer) {
        if (buffer.length != 28) {
            throw new Error(`Expected Buffer32 input buffer to be 28 bytes`);
        }
        const padded = Buffer.concat([Buffer.alloc(this.SIZE - 28), buffer]);
        return new Buffer32(padded);
    }
    /**
     * Converts a string into a Buffer32 object.
     * @param str - The TX hash in string format.
     * @returns A new Buffer32 object.
     */
    static fromStringUnchecked(str) {
        return new Buffer32(Buffer.from(str, 'hex'));
    }
    /**
     * Converts a string into a Buffer32 object.
     * NOTE: this method includes checks for the 0x prefix and the length of the string.
     *       if you dont need this checks, use fromStringUnchecked instead.
     *
     * @param str - The TX hash in string format.
     * @returns A new Buffer32 object.
     */
    static fromString(str) {
        if (str.startsWith('0x')) {
            str = str.slice(2);
        }
        if (str.length !== 64) {
            throw new Error(`Expected string to be 64 characters long, but was ${str.length}`);
        }
        return new Buffer32(Buffer.from(str, 'hex'));
    }
    /**
     * Converts a number into a Buffer32 object.
     * @param num - The number to convert.
     * @returns A new Buffer32 object.
     */
    static fromNumber(num) {
        return new Buffer32(serializeBigInt(BigInt(num), Buffer32.SIZE));
    }
    /**
     * Generates a random Buffer32.
     * @returns A new Buffer32 object.
     */
    static random() {
        return new Buffer32(Buffer.from(randomBytes(Buffer32.SIZE)));
    }
}
/**
 * The size of the hash in bytes.
 */
Buffer32.SIZE = 32;
/**
 * Buffer32 with value zero.
 */
Buffer32.ZERO = new Buffer32(Buffer.alloc(Buffer32.SIZE));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVmZmVyMzIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYnVmZmVyL2J1ZmZlcjMyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUV2RCxPQUFPLEVBQUUsWUFBWSxFQUFFLGlCQUFpQixFQUFFLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRS9GOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFFBQVE7SUFXbkI7SUFDRTs7T0FFRztJQUNJLE1BQWM7UUFBZCxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBRXJCLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsUUFBUSxDQUFDLElBQUksWUFBWSxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUM5RixDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNJLFFBQVE7UUFDYixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQTZCO1FBQ3BELE1BQU0sTUFBTSxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDN0MsT0FBTyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLElBQWM7UUFDMUIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU07UUFDWCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxL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
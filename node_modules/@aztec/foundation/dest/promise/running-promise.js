import { InterruptibleSleep } from '../sleep/index.js';
import { promiseWithResolvers } from './utils.js';
/**
 * RunningPromise is a utility class that helps manage the execution of an asynchronous function
 * at a specified polling interval. It allows starting, stopping, and checking the status of the
 * internally managed promise. The class also supports interrupting the polling process when stopped.
 */
export class RunningPromise {
    constructor(fn, pollingIntervalMS = 10000) {
        this.fn = fn;
        this.pollingIntervalMS = pollingIntervalMS;
        this.running = false;
        this.runningPromise = Promise.resolve();
        this.interruptibleSleep = new InterruptibleSleep();
        this.requested = undefined;
    }
    /**
     * Starts the running promise.
     */
    start() {
        this.running = true;
        const poll = async () => {
            while (this.running) {
                const hasRequested = this.requested !== undefined;
                await this.fn();
                // If an immediate run had been requested *before* the function started running, resolve the request.
                if (hasRequested) {
                    this.requested.resolve();
                    this.requested = undefined;
                }
                // If no immediate run was requested, sleep for the polling interval.
                if (this.requested === undefined) {
                    await this.interruptibleSleep.sleep(this.pollingIntervalMS);
                }
            }
        };
        this.runningPromise = poll();
    }
    /**
     * Stops the running promise, resolves any pending interruptible sleep,
     * and waits for the currently executing function to complete.
     */
    async stop() {
        this.running = false;
        this.interruptibleSleep.interrupt();
        await this.runningPromise;
    }
    /**
     * Checks if the running promise is currently active.
     * @returns True if the promise is running.
     */
    isRunning() {
        return this.running;
    }
    /**
     * Triggers an immediate run of the function, bypassing the polling interval.
     * If the function is currently running, it will be allowed to continue and then called again immediately.
     */
    async trigger() {
        if (!this.running) {
            return this.fn();
        }
        let requested = this.requested;
        if (!requested) {
            requested = promiseWithResolvers();
            this.requested = requested;
            this.interruptibleSleep.interrupt();
        }
        await requested.promise;
    }
    /**
     * Updates the polling interval. The new interval will take effect after the next poll.
     * @param pollingIntervalMS The polling interval in milliseconds.
     */
    setPollingIntervalMS(pollingIntervalMS) {
        this.pollingIntervalMS = pollingIntervalMS;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicnVubmluZy1wcm9taXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Byb21pc2UvcnVubmluZy1wcm9taXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3ZELE9BQU8sRUFBNkIsb0JBQW9CLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFFN0U7Ozs7R0FJRztBQUNILE1BQU0sT0FBTyxjQUFjO0lBTXpCLFlBQW9CLEVBQThCLEVBQVUsb0JBQW9CLEtBQUs7UUFBakUsT0FBRSxHQUFGLEVBQUUsQ0FBNEI7UUFBVSxzQkFBaUIsR0FBakIsaUJBQWlCLENBQVE7UUFMN0UsWUFBTyxHQUFHLEtBQUssQ0FBQztRQUNoQixtQkFBYyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNuQyx1QkFBa0IsR0FBRyxJQUFJLGtCQUFrQixFQUFFLENBQUM7UUFDOUMsY0FBUyxHQUEyQyxTQUFTLENBQUM7SUFFa0IsQ0FBQztJQUV6Rjs7T0FFRztJQUNJLEtBQUs7UUFDVixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUVwQixNQUFNLElBQUksR0FBRyxLQUFLLElBQUksRUFBRTtZQUN0QixPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDcEIsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLFNBQVMsS0FBSyxTQUFTLENBQUM7Z0JBQ2xELE1BQU0sSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUVoQixxR0FBcUc7Z0JBQ3JHLElBQUksWUFBWSxFQUFFLENBQUM7b0JBQ2pCLElBQUksQ0FBQyxTQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQzFCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO2dCQUM3QixDQUFDO2dCQUVELHFFQUFxRTtnQkFDckUsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRSxDQUFDO29CQUNqQyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7Z0JBQzlELENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQyxDQUFDO1FBQ0YsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLElBQUk7UUFDUixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNyQixJQUFJLENBQUMsa0JBQWtCLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDcEMsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQzVCLENBQUM7SUFFRDs7O09BR0c7SUFDSSxTQUFTO1FBQ2QsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFFRDs7O09BR0c7SUFDSSxLQUFLLENBQUMsT0FBTztRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2xCLE9BQU8sSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQ25CLENBQUM7UUFFRCxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQy9CLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNmLFNBQVMsR0FBRyxvQkFBb0IsRUFBUSxDQUFDO1lBQ3pDLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1lBQzNCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN0QyxDQUFDO1FBQ0QsTUFBTSxTQUFVLENBQUMsT0FBTyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxvQkFBb0IsQ0FBQyxpQkFBeUI7UUFDNUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDO0lBQzdDLENBQUM7Q0FDRiJ9
import { toBigIntBE } from '../bigint-buffer/index.js';
import { poseidon2Hash } from '../crypto/poseidon/index.js';
import { randomBoolean } from '../crypto/random/index.js';
import { BufferReader, FieldReader, serializeToBuffer } from '../serialize/index.js';
import { Fr } from './fields.js';
/**
 * Represents a Point on an elliptic curve with x and y coordinates.
 * The Point class provides methods for creating instances from different input types,
 * converting instances to various output formats, and checking the equality of points.
 */
export class Point {
    constructor(
    /**
     * The point's x coordinate
     */
    x, 
    /**
     * The point's y coordinate
     */
    y, 
    /**
     * Whether the point is at infinity
     */
    isInfinite) {
        this.x = x;
        this.y = y;
        this.isInfinite = isInfinite;
        /** Used to differentiate this class from AztecAddress */
        this.kind = 'point';
        // TODO(#7386): check if on curve
    }
    /**
     * Generate a random Point instance.
     *
     * @returns A randomly generated Point instance.
     */
    static random() {
        while (true) {
            try {
                return Point.fromXAndSign(Fr.random(), randomBoolean());
            }
            catch (e) {
                if (!(e instanceof NotOnCurveError)) {
                    throw e;
                }
                // The random point is not on the curve - we try again
                continue;
            }
        }
    }
    /**
     * Create a Point instance from a given buffer or BufferReader.
     * The input 'buffer' should have exactly 64 bytes representing the x and y coordinates.
     *
     * @param buffer - The buffer or BufferReader containing the x and y coordinates of the point.
     * @returns A Point instance.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new this(Fr.fromBuffer(reader), Fr.fromBuffer(reader), false);
    }
    /**
     * Create a Point instance from a compressed buffer.
     * The input 'buffer' should have exactly 33 bytes representing the x coordinate and the sign of the y coordinate.
     *
     * @param buffer - The buffer containing the x coordinate and the sign of the y coordinate.
     * @returns A Point instance.
     */
    static fromCompressedBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const value = toBigIntBE(reader.readBytes(Point.COMPRESSED_SIZE_IN_BYTES));
        const x = new Fr(value & ((1n << 255n) - 1n));
        const sign = (value & (1n << 255n)) !== 0n;
        return this.fromXAndSign(x, sign);
    }
    /**
     * Create a Point instance from a hex-encoded string.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 128 hex characters representing the x and y coordinates.
     * Throws an error if the input length is invalid or coordinate values are out of range.
     *
     * @param address - The hex-encoded string representing the Point coordinates.
     * @returns A Point instance.
     */
    static fromString(address) {
        return this.fromBuffer(Buffer.from(address.replace(/^0x/i, ''), 'hex'));
    }
    /**
     * Returns the contents of the point as an array of 2 fields.
     * @returns The point as an array of 2 fields
     */
    toFields() {
        return [this.x, this.y, new Fr(this.isInfinite)];
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new this(reader.readField(), reader.readField(), reader.readBoolean());
    }
    /**
     * Uses the x coordinate and isPositive flag (+/-) to reconstruct the point.
     * @dev The y coordinate can be derived from the x coordinate and the "sign" flag by solving the grumpkin curve
     * equation for y.
     * @param x - The x coordinate of the point
     * @param sign - The "sign" of the y coordinate - note that this is not a sign as is known in integer arithmetic.
     * Instead it is a boolean flag that determines whether the y coordinate is <= (Fr.MODULUS - 1) / 2
     * @returns The point as an array of 2 fields
     */
    static fromXAndSign(x, sign) {
        // Calculate y^2 = x^3 - 17
        const ySquared = x.square().mul(x).sub(new Fr(17));
        // Calculate the square root of ySquared
        const y = ySquared.sqrt();
        // If y is null, the x-coordinate is not on the curve
        if (y === null) {
            throw new NotOnCurveError(x);
        }
        const yPositiveBigInt = y.toBigInt() <= (Fr.MODULUS - 1n) / 2n ? y.toBigInt() : Fr.MODULUS - y.toBigInt();
        const yNegativeBigInt = Fr.MODULUS - yPositiveBigInt;
        // Choose the positive or negative root based on isPositive
        const finalY = sign ? new Fr(yPositiveBigInt) : new Fr(yNegativeBigInt);
        // Create and return the new Point
        return new this(x, finalY, false);
    }
    /**
     * Returns the x coordinate and the sign of the y coordinate.
     * @dev The y sign can be determined by checking if the y coordinate is greater than half of the modulus.
     * @returns The x coordinate and the sign of the y coordinate.
     */
    toXAndSign() {
        return [this.x, this.y.toBigInt() <= (Fr.MODULUS - 1n) / 2n];
    }
    /**
     * Returns the contents of the point as BigInts.
     * @returns The point as BigInts
     */
    toBigInts() {
        return {
            x: this.x.toBigInt(),
            y: this.y.toBigInt(),
            isInfinite: this.isInfinite ? 1n : 0n,
        };
    }
    /**
     * Converts the Point instance to a Buffer representation of the coordinates.
     * @returns A Buffer representation of the Point instance.
     * @dev Note that toBuffer does not include the isInfinite flag and other serialization methods do (e.g. toFields).
     * This is because currently when we work with point as bytes we don't want to populate the extra bytes for
     * isInfinite flag because:
     * 1. Our Grumpkin BB API currently does not handle point at infinity,
     * 2. we use toBuffer when serializing notes and events and there we only work with public keys and point at infinity
     *   is not considered a valid public key and the extra byte would raise DA cost.
     */
    toBuffer() {
        if (this.isInfinite) {
            throw new Error('Cannot serialize infinite point without isInfinite flag');
        }
        const buf = serializeToBuffer([this.x, this.y]);
        if (buf.length !== Point.SIZE_IN_BYTES) {
            throw new Error(`Invalid buffer length for Point: ${buf.length}`);
        }
        return buf;
    }
    /**
     * Converts the Point instance to a compressed Buffer representation of the coordinates.
     * @returns A Buffer representation of the Point instance
     */
    toCompressedBuffer() {
        const [x, sign] = this.toXAndSign();
        // Here we leverage that Fr fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32 bytes
        // and we use big-endian the 2 most significant bits are never populated. Hence we can use one of the bits as
        // a sign bit.
        const compressedValue = x.toBigInt() + (sign ? 2n ** 255n : 0n);
        const buf = serializeToBuffer(compressedValue);
        if (buf.length !== Point.COMPRESSED_SIZE_IN_BYTES) {
            throw new Error(`Invalid buffer length for compressed Point: ${buf.length}`);
        }
        return buf;
    }
    /**
     * Convert the Point instance to a hexadecimal string representation.
     * The output string is prefixed with '0x' and consists of exactly 128 hex characters,
     * representing the concatenated x and y coordinates of the point.
     *
     * @returns A hex-encoded string representing the Point instance.
     */
    toString() {
        return '0x' + this.toBuffer().toString('hex');
    }
    /**
     * Generate a short string representation of the Point instance.
     * The returned string includes the first 10 and last 4 characters of the full string representation,
     * with '...' in between to indicate truncation. This is useful for displaying or logging purposes
     * when the full string representation may be too long.
     *
     * @returns A truncated string representation of the Point instance.
     */
    toShortString() {
        const str = this.toString();
        return `${str.slice(0, 10)}...${str.slice(-4)}`;
    }
    toNoirStruct() {
        /* eslint-disable camelcase */
        return { x: this.x, y: this.y, is_infinite: this.isInfinite };
        /* eslint-enable camelcase */
    }
    // Used for IvpkM, OvpkM, NpkM and TpkM. TODO(#8124): Consider removing this method.
    toWrappedNoirStruct() {
        /* eslint-disable camelcase */
        return { inner: this.toNoirStruct() };
        /* eslint-enable camelcase */
    }
    /**
     * Check if two Point instances are equal by comparing their buffer values.
     * Returns true if the buffer values are the same, and false otherwise.
     *
     * @param rhs - The Point instance to compare with the current instance.
     * @returns A boolean indicating whether the two Point instances are equal.
     */
    equals(rhs) {
        return this.x.equals(rhs.x) && this.y.equals(rhs.y);
    }
    isZero() {
        return this.x.isZero() && this.y.isZero();
    }
    hash() {
        return poseidon2Hash(this.toFields());
    }
    /**
     * Check if this is point at infinity.
     * Check this is consistent with how bb is encoding the point at infinity
     */
    get inf() {
        return this.isInfinite;
    }
    isOnGrumpkin() {
        // TODO: Check this against how bb handles curve check and infinity point check
        if (this.inf) {
            return true;
        }
        // p.y * p.y == p.x * p.x * p.x - 17
        const A = new Fr(17);
        const lhs = this.y.square();
        const rhs = this.x.square().mul(this.x).sub(A);
        return lhs.equals(rhs);
    }
}
Point.ZERO = new Point(Fr.ZERO, Fr.ZERO, false);
Point.SIZE_IN_BYTES = Fr.SIZE_IN_BYTES * 2;
Point.COMPRESSED_SIZE_IN_BYTES = Fr.SIZE_IN_BYTES;
export class NotOnCurveError extends Error {
    constructor(x) {
        super('The given x-coordinate is not on the Grumpkin curve: ' + x.toString());
        this.name = 'NotOnCurveError';
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9pbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZmllbGRzL3BvaW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDNUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzFELE9BQU8sRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDckYsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUVqQzs7OztHQUlHO0FBQ0gsTUFBTSxPQUFPLEtBQUs7SUFRaEI7SUFDRTs7T0FFRztJQUNhLENBQUs7SUFDckI7O09BRUc7SUFDYSxDQUFLO0lBQ3JCOztPQUVHO0lBQ2EsVUFBbUI7UUFSbkIsTUFBQyxHQUFELENBQUMsQ0FBSTtRQUlMLE1BQUMsR0FBRCxDQUFDLENBQUk7UUFJTCxlQUFVLEdBQVYsVUFBVSxDQUFTO1FBZnJDLHlEQUF5RDtRQUN6QyxTQUFJLEdBQUcsT0FBTyxDQUFDO1FBZ0I3QixpQ0FBaUM7SUFDbkMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsTUFBTTtRQUNYLE9BQU8sSUFBSSxFQUFFLENBQUM7WUFDWixJQUFJLENBQUM7Z0JBQ0gsT0FBTyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDO1lBQzFELENBQUM7WUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO2dCQUNoQixJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksZUFBZSxDQUFDLEVBQUUsQ0FBQztvQkFDcEMsTUFBTSxDQUFDLENBQUM7Z0JBQ1YsQ0FBQztnQkFDRCxzREFBc0Q7Z0JBQ3RELFNBQVM7WUFDWCxDQUFDO1FBQ0gs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
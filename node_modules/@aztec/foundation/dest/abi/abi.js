import { inflate } from 'pako';
/**
 * Aztec.nr function types.
 */
export var FunctionType;
(function (FunctionType) {
    FunctionType["PRIVATE"] = "private";
    FunctionType["PUBLIC"] = "public";
    FunctionType["UNCONSTRAINED"] = "unconstrained";
})(FunctionType || (FunctionType = {}));
/**
 * Gets a function artifact including debug metadata given its name or selector.
 */
export function getFunctionArtifact(artifact, functionNameOrSelector) {
    const functionArtifact = artifact.functions.find(f => typeof functionNameOrSelector === 'string'
        ? f.name === functionNameOrSelector
        : functionNameOrSelector.equals(f.name, f.parameters));
    if (!functionArtifact) {
        throw new Error(`Unknown function ${functionNameOrSelector}`);
    }
    const debugMetadata = getFunctionDebugMetadata(artifact, functionArtifact);
    return { ...functionArtifact, debug: debugMetadata };
}
/**
 * Gets the debug metadata of a given function from the contract artifact
 * @param artifact - The contract build artifact
 * @param functionName - The name of the function
 * @returns The debug metadata of the function
 */
export function getFunctionDebugMetadata(contractArtifact, functionArtifact) {
    if (functionArtifact.debugSymbols && contractArtifact.fileMap) {
        const programDebugSymbols = JSON.parse(inflate(Buffer.from(functionArtifact.debugSymbols, 'base64'), { to: 'string', raw: true }));
        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/5813)
        // We only support handling debug info for the contract function entry point.
        // So for now we simply index into the first debug info.
        return {
            debugSymbols: programDebugSymbols.debug_infos[0],
            files: contractArtifact.fileMap,
            assertMessages: functionArtifact.assertMessages,
        };
    }
    return undefined;
}
/**
 * Returns an initializer from the contract, assuming there is at least one. If there are multiple initializers,
 * it returns the one named "constructor" or "initializer"; if there is none with that name, it returns the first
 * initializer it finds, prioritizing initializers with no arguments and then private ones.
 * @param contractArtifact - The contract artifact.
 * @returns An initializer function, or none if there are no functions flagged as initializers in the contract.
 */
export function getDefaultInitializer(contractArtifact) {
    const initializers = contractArtifact.functions.filter(f => f.isInitializer);
    return initializers.length > 1
        ? initializers.find(f => f.name === 'constructor') ??
            initializers.find(f => f.name === 'initializer') ??
            initializers.find(f => f.parameters?.length === 0) ??
            initializers.find(f => f.functionType === FunctionType.PRIVATE) ??
            initializers[0]
        : initializers[0];
}
/**
 * Returns an initializer from the contract.
 * @param initializerNameOrArtifact - The name of the constructor, or the artifact of the constructor, or undefined
 * to pick the default initializer.
 */
export function getInitializer(contract, initializerNameOrArtifact) {
    if (typeof initializerNameOrArtifact === 'string') {
        const found = contract.functions.find(f => f.name === initializerNameOrArtifact);
        if (!found) {
            throw new Error(`Constructor method ${initializerNameOrArtifact} not found in contract artifact`);
        }
        else if (!found.isInitializer) {
            throw new Error(`Method ${initializerNameOrArtifact} is not an initializer`);
        }
        return found;
    }
    else if (initializerNameOrArtifact === undefined) {
        return getDefaultInitializer(contract);
    }
    else {
        if (!initializerNameOrArtifact.isInitializer) {
            throw new Error(`Method ${initializerNameOrArtifact.name} is not an initializer`);
        }
        return initializerNameOrArtifact;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2FiaS9hYmkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQStKL0I7O0dBRUc7QUFDSCxNQUFNLENBQU4sSUFBWSxZQUlYO0FBSkQsV0FBWSxZQUFZO0lBQ3RCLG1DQUFtQixDQUFBO0lBQ25CLGlDQUFpQixDQUFBO0lBQ2pCLCtDQUErQixDQUFBO0FBQ2pDLENBQUMsRUFKVyxZQUFZLEtBQVosWUFBWSxRQUl2QjtBQXFPRDs7R0FFRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FDakMsUUFBMEIsRUFDMUIsc0JBQWlEO0lBRWpELE1BQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FDbkQsT0FBTyxzQkFBc0IsS0FBSyxRQUFRO1FBQ3hDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLHNCQUFzQjtRQUNuQyxDQUFDLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUN4RCxDQUFDO0lBQ0YsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0Isc0JBQXNCLEVBQUUsQ0FBQyxDQUFDO0lBQ2hFLENBQUM7SUFDRCxNQUFNLGFBQWEsR0FBRyx3QkFBd0IsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztJQUMzRSxPQUFPLEVBQUUsR0FBRyxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLENBQUM7QUFDdkQsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLHdCQUF3QixDQUN0QyxnQkFBa0MsRUFDbEMsZ0JBQWtDO0lBRWxDLElBQUksZ0JBQWdCLENBQUMsWUFBWSxJQUFJLGdCQUFn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
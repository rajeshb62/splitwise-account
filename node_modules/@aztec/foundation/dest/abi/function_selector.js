import { fromHex, toBigIntBE } from '../bigint-buffer/index.js';
import { poseidon2HashBytes, randomBytes } from '../crypto/index.js';
import { BufferReader } from '../serialize/buffer_reader.js';
import { FieldReader } from '../serialize/field_reader.js';
import { TypeRegistry } from '../serialize/type_registry.js';
import { decodeFunctionSignature } from './decoder.js';
import { Selector } from './selector.js';
/** A function selector is the first 4 bytes of the hash of a function signature. */
export class FunctionSelector extends Selector {
    equals(other, otherParams) {
        if (typeof other === 'string') {
            return this.equals(FunctionSelector.fromNameAndParameters(other, otherParams));
        }
        else if (typeof other === 'object' && 'name' in other) {
            return this.equals(FunctionSelector.fromNameAndParameters(other.name, other.parameters));
        }
        else {
            return this.value === other.value;
        }
    }
    /**
     * Deserializes from a buffer or reader, corresponding to a write in cpp.
     * @param buffer - Buffer  or BufferReader to read from.
     * @returns The Selector.
     */
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const value = Number(toBigIntBE(reader.readBytes(Selector.SIZE)));
        return new FunctionSelector(value);
    }
    /**
     * Converts a field to selector.
     * @param fr - The field to convert.
     * @returns The selector.
     */
    static fromField(fr) {
        return new FunctionSelector(Number(fr.toBigInt()));
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return FunctionSelector.fromField(reader.readField());
    }
    /**
     * Creates a selector from a signature.
     * @param signature - Signature to generate the selector for (e.g. "transfer(field,field)").
     * @returns selector.
     */
    static fromSignature(signature) {
        // throw if signature contains whitespace
        if (/\s/.test(signature)) {
            throw new Error('Signature cannot contain whitespace');
        }
        const hash = poseidon2HashBytes(Buffer.from(signature));
        // We take the last Selector.SIZE big endian bytes
        const bytes = hash.toBuffer().slice(-Selector.SIZE);
        return FunctionSelector.fromBuffer(bytes);
    }
    /**
     * Create a Selector instance from a hex-encoded string.
     * The input 'address' should be prefixed with '0x' or not, and have exactly 64 hex characters.
     * Throws an error if the input length is invalid or address value is out of range.
     *
     * @param selector - The hex-encoded string representing the Selector.
     * @returns An Selector instance.
     */
    static fromString(selector) {
        const buf = fromHex(selector);
        if (buf.length !== Selector.SIZE) {
            throw new Error(`Invalid Selector length ${buf.length} (expected ${Selector.SIZE}).`);
        }
        return FunctionSelector.fromBuffer(buf);
    }
    /**
     * Creates an empty selector.
     * @returns An empty selector.
     */
    static empty() {
        return new FunctionSelector(0);
    }
    static fromNameAndParameters(nameOrArgs, maybeParameters) {
        const { name, parameters } = typeof nameOrArgs === 'string' ? { name: nameOrArgs, parameters: maybeParameters } : nameOrArgs;
        const signature = decodeFunctionSignature(name, parameters);
        const selector = this.fromSignature(signature);
        // If using the debug logger here it kill the typing in the `server_world_state_synchronizer` and jest tests.
        // console.log(`selector for ${signature} is ${selector}`);
        return selector;
    }
    /**
     * Creates a random instance.
     */
    static random() {
        return FunctionSelector.fromBuffer(randomBytes(Selector.SIZE));
    }
    toJSON() {
        return {
            type: 'FunctionSelector',
            value: this.toString(),
        };
    }
}
// For deserializing JSON.
TypeRegistry.register('FunctionSelector', FunctionSelector);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25fc2VsZWN0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYWJpL2Z1bmN0aW9uX3NlbGVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXJFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUM3RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDM0QsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBRTdELE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN2RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBVXpDLG9GQUFvRjtBQUNwRixNQUFNLE9BQU8sZ0JBQWlCLFNBQVEsUUFBUTtJQVFuQyxNQUFNLENBQ2IsS0FBK0UsRUFDL0UsV0FBNEI7UUFFNUIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUM5QixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMscUJBQXFCLENBQUMsS0FBSyxFQUFFLFdBQVksQ0FBQyxDQUFDLENBQUM7UUFDbEYsQ0FBQzthQUFNLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLE1BQU0sSUFBSSxLQUFLLEVBQUUsQ0FBQztZQUN4RCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMscUJBQXFCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUMzRixDQUFDO2FBQU0sQ0FBQztZQUNOLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQ3BDLENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBNkI7UUFDN0MsTUFBTSxNQUFNLEdBQUcsWUFBWSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsRSxPQUFPLElBQUksZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQU07UUFDckIsT0FBTyxJQUFJLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRCxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQTBCO1FBQzFDLE1BQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUMsT0FBTyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxNQUFNLENBQUMsYUFBYSxDQUFDLFNBQWlCO1FBQ3BDLHlDQUF5QztRQUN6QyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQztZQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7UUFDekQsQ0FBQztRQUNELE1BQU0sSUFBSSxHQUFHLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUN4RCxrREFBa0Q7UUFDbEQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRCxPQUFPLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBZ0I7UUFDaEMsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzlCLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDakMsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsR0FBRyxDQUFDLE1BQU0sY0FBYyxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztRQUN4RixDQUFDO1FBQ0QsT0FBTyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxLQUFLO1FBQ1YsT0FBTyxJQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pDLENBQUM7SUFVRCxNQUFNLENBQUMscUJBQXFCLENBQzFCLFVBQWlFLEVBQ2pFLGVBQWdDO1FBRWhDLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEdBQ3hCLE9BQU8sVUFBVSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxlQUFnQixFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztRQUNuRyxNQUFNLFNBQVMsR0FBRyx1QkFBdUIsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDNUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvQyw2R0FBNkc7UUFDN0csMkRBQTJEO1FBQzNELE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7T0FFRztJQUNILE1BQU0sQ0FBQyxNQUFNO1FBQ1gsT0FBTyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRCxNQUFNO1FBQ0osT0FBTztZQUNMLElBQUksRUFBRSxrQkFBa0I7WUFDeEIsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUU7U0FDdkIsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQUVELDBCQUEwQjtBQUMxQixZQUFZLENBQUMsUUFBUSxDQUFDLGtCQUFrQixFQUFFLGdCQUFnQixDQUFDLENBQUMifQ==
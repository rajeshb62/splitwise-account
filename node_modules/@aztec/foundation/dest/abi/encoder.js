import { Fr } from '../fields/index.js';
import { isAddressStruct, isFunctionSelectorStruct, isWrappedFieldStruct } from './utils.js';
/**
 * Encodes arguments for a function call.
 * Missing support for integer and string.
 */
class ArgumentEncoder {
    constructor(abi, args) {
        this.abi = abi;
        this.args = args;
        this.flattened = [];
    }
    static typeSize(abiType) {
        switch (abiType.kind) {
            case 'field':
            case 'boolean':
            case 'integer':
                return 1;
            case 'string':
                return abiType.length;
            case 'array':
                return abiType.length * ArgumentEncoder.typeSize(abiType.type);
            case 'struct':
                return abiType.fields.reduce((acc, field) => acc + ArgumentEncoder.typeSize(field.type), 0);
            case 'tuple':
                return abiType.fields.reduce((acc, field) => acc + ArgumentEncoder.typeSize(field), 0);
            default: {
                const exhaustiveCheck = abiType;
                throw new Error(`Unhandled abi type: ${exhaustiveCheck}`);
            }
        }
    }
    /**
     * Encodes a single argument from the given type to field.
     * @param abiType - The abi type of the argument.
     * @param arg - The value to encode.
     * @param name - Name.
     */
    encodeArgument(abiType, arg, name) {
        if (arg === undefined || arg == null) {
            throw new Error(`Undefined argument ${name ?? 'unnamed'} of type ${abiType.kind}`);
        }
        switch (abiType.kind) {
            case 'field':
                if (typeof arg === 'number') {
                    this.flattened.push(new Fr(BigInt(arg)));
                }
                else if (typeof arg === 'bigint') {
                    this.flattened.push(new Fr(arg));
                }
                else if (typeof arg === 'string') {
                    this.flattened.push(Fr.fromString(arg));
                }
                else if (typeof arg === 'boolean') {
                    this.flattened.push(new Fr(arg ? 1n : 0n));
                }
                else if (typeof arg === 'object') {
                    if (Buffer.isBuffer(arg)) {
                        this.flattened.push(Fr.fromBuffer(arg));
                    }
                    else if (typeof arg.toField === 'function') {
                        this.flattened.push(arg.toField());
                    }
                    else {
                        throw new Error(`Argument for ${name} cannot be serialized to a field`);
                    }
                }
                else {
                    throw new Error(`Invalid argument "${arg}" of type ${abiType.kind}`);
                }
                break;
            case 'boolean':
                this.flattened.push(new Fr(arg ? 1n : 0n));
                break;
            case 'array':
                for (let i = 0; i < abiType.length; i += 1) {
                    this.encodeArgument(abiType.type, arg[i], `${name}[${i}]`);
                }
                break;
            case 'string':
                for (let i = 0; i < abiType.length; i += 1) {
                    // If the string is shorter than the defined length, pad it with 0s.
                    const toInsert = i < arg.length ? BigInt(arg.charCodeAt(i)) : 0n;
                    this.flattened.push(new Fr(toInsert));
                }
                break;
            case 'struct': {
                // If the type defines the encoding to noir, we use it
                if (arg.encodeToNoir !== undefined) {
                    this.flattened.push(...arg.encodeToNoir());
                    break;
                }
                // If the abi expects a struct like { address: Field } and the supplied arg does not have
                // an address field in it, we try to encode it as if it were a field directly.
                const isAddress = isAddressStruct(abiType);
                if (isAddress && typeof arg.address === 'undefined' && typeof arg.inner === 'undefined') {
                    this.encodeArgument({ kind: 'field' }, arg, `${name}.inner`);
                    break;
                }
                // Or if the supplied argument does have an address field in it, like a CompleteAddress,
                // we encode it directly as a field.
                if (isAddress && typeof arg.address !== 'undefined') {
                    this.encodeArgument({ kind: 'field' }, arg.address, `${name}.address`);
                    break;
                }
                if (isFunctionSelectorStruct(abiType)) {
                    this.encodeArgument({ kind: 'integer', sign: 'unsigned', width: 32 }, arg.value ?? arg, `${name}.inner`);
                    break;
                }
                if (isWrappedFieldStruct(abiType)) {
                    this.encodeArgument({ kind: 'field' }, arg.inner ?? arg, `${name}.inner`);
                    break;
                }
                for (const field of abiType.fields) {
                    this.encodeArgument(field.type, arg[field.name], `${name}.${field.name}`);
                }
                break;
            }
            case 'integer':
                if (typeof arg === 'string') {
                    const value = BigInt(arg);
                    this.flattened.push(new Fr(value));
                }
                else {
                    this.flattened.push(new Fr(arg));
                }
                break;
            default:
                throw new Error(`Unsupported type: ${abiType}`);
        }
    }
    /**
     * Encodes all the arguments for the given function ABI.
     * @returns The encoded arguments.
     */
    encode() {
        for (let i = 0; i < this.abi.parameters.length; i += 1) {
            const parameterAbi = this.abi.parameters[i];
            this.encodeArgument(parameterAbi.type, this.args[i], parameterAbi.name);
        }
        return this.flattened;
    }
}
/**
 * Encodes all the arguments for a function call.
 * @param abi - The function ABI entry.
 * @param args - The arguments to encode.
 * @returns The encoded arguments.
 */
export function encodeArguments(abi, args) {
    return new ArgumentEncoder(abi, args).encode();
}
/**
 * Returns the size of the arguments for a function ABI.
 * @param abi - The function ABI entry.
 * @returns The size of the arguments.
 */
export function countArgumentsSize(abi) {
    return abi.parameters.reduce((acc, parameter) => acc + ArgumentEncoder.typeSize(parameter.type), 0);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW5jb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hYmkvZW5jb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFeEMsT0FBTyxFQUFFLGVBQWUsRUFBRSx3QkFBd0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUU3Rjs7O0dBR0c7QUFDSCxNQUFNLGVBQWU7SUFHbkIsWUFBb0IsR0FBZ0IsRUFBVSxJQUFXO1FBQXJDLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFBVSxTQUFJLEdBQUosSUFBSSxDQUFPO1FBRmpELGNBQVMsR0FBUyxFQUFFLENBQUM7SUFFK0IsQ0FBQztJQUU3RCxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQWdCO1FBQzlCLFFBQVEsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JCLEtBQUssT0FBTyxDQUFDO1lBQ2IsS0FBSyxTQUFTLENBQUM7WUFDZixLQUFLLFNBQVM7Z0JBQ1osT0FBTyxDQUFDLENBQUM7WUFDWCxLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQ3hCLEtBQUssT0FBTztnQkFDVixPQUFPLE9BQU8sQ0FBQyxNQUFNLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDakUsS0FBSyxRQUFRO2dCQUNYLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDOUYsS0FBSyxPQUFPO2dCQUNWLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxH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
import { AztecAddress } from '../aztec-address/index.js';
import { isAztecAddressStruct } from './utils.js';
/**
 * Decodes values using a provided ABI.
 * Missing support for signed integer.
 */
class AbiDecoder {
    constructor(types, flattened) {
        this.types = types;
        this.flattened = flattened;
    }
    /**
     * Decodes a single return value from field to the given type.
     * @param abiType - The type of the return value.
     * @returns The decoded return value.
     */
    decodeNext(abiType) {
        switch (abiType.kind) {
            case 'field':
                return this.getNextField().toBigInt();
            case 'integer':
                if (abiType.sign === 'signed') {
                    throw new Error('Unsupported type: signed integer');
                }
                return this.getNextField().toBigInt();
            case 'boolean':
                return !this.getNextField().isZero();
            case 'array': {
                const array = [];
                for (let i = 0; i < abiType.length; i += 1) {
                    array.push(this.decodeNext(abiType.type));
                }
                return array;
            }
            case 'struct': {
                const struct = {};
                if (isAztecAddressStruct(abiType)) {
                    return new AztecAddress(this.getNextField().toBuffer());
                }
                for (const field of abiType.fields) {
                    struct[field.name] = this.decodeNext(field.type);
                }
                return struct;
            }
            case 'string': {
                const array = [];
                for (let i = 0; i < abiType.length; i += 1) {
                    array.push(this.getNextField().toBigInt());
                }
                return array;
            }
            case 'tuple': {
                const array = [];
                for (const tupleAbiType of abiType.fields) {
                    array.push(this.decodeNext(tupleAbiType));
                }
                return array;
            }
            default:
                throw new Error(`Unsupported type: ${abiType}`);
        }
    }
    /**
     * Gets the next field in the flattened buffer.
     * @returns The next field in the flattened buffer.
     */
    getNextField() {
        const field = this.flattened.shift();
        if (!field) {
            throw new Error('Not enough return values');
        }
        return field;
    }
    /**
     * Decodes all the values for the given ABI.
     * The decided value can be simple types, structs or arrays
     * @returns The decoded return values.
     */
    decode() {
        if (this.types.length > 1) {
            throw new Error('Multiple types not supported');
        }
        if (this.types.length === 0) {
            return [];
        }
        return this.decodeNext(this.types[0]);
    }
}
/**
 * Decodes values in a flattened Field array using a provided ABI.
 * @param abi - The ABI to use as reference.
 * @param buffer - The flattened Field array to decode.
 * @returns
 */
export function decodeFromAbi(typ, buffer) {
    return new AbiDecoder(typ, buffer.slice()).decode();
}
/**
 * Decodes the signature of a function from the name and parameters.
 */
export class FunctionSignatureDecoder {
    constructor(name, parameters, includeNames = false) {
        this.name = name;
        this.parameters = parameters;
        this.includeNames = includeNames;
        this.separator = includeNames ? ', ' : ',';
    }
    /**
     * Decodes a single function parameter type for the function signature.
     * @param param - The parameter type to decode.
     * @returns A string representing the parameter type.
     */
    getParameterType(param) {
        switch (param.kind) {
            case 'field':
                return 'Field';
            case 'integer':
                if (param.sign === 'signed') {
                    throw new Error('Unsupported type: signed integer');
                }
                return `u${param.width}`;
            case 'boolean':
                return 'bool';
            case 'array':
                return `[${this.getParameterType(param.type)};${param.length}]`;
            case 'string':
                return `str<${param.length}>`;
            case 'struct':
                return `(${param.fields.map(field => `${this.decodeParameter(field)}`).join(this.separator)})`;
            default:
                throw new Error(`Unsupported type: ${param}`);
        }
    }
    /**
     * Decodes a single function parameter for the function signature.
     * @param param - The parameter to decode.
     * @returns A string representing the parameter type and optionally its name.
     */
    decodeParameter(param) {
        const type = this.getParameterType(param.type);
        return this.includeNames ? `${param.name}: ${type}` : type;
    }
    /**
     * Decodes all the parameters and build the function signature
     * @returns The function signature.
     */
    decode() {
        return `${this.name}(${this.parameters.map(param => this.decodeParameter(param)).join(this.separator)})`;
    }
}
/**
 * Decodes a function signature from the name and parameters.
 * @param name - The name of the function.
 * @param parameters - The parameters of the function.
 * @returns - The function signature.
 */
export function decodeFunctionSignature(name, parameters) {
    return new FunctionSignatureDecoder(name, parameters).decode();
}
/**
 * Decodes a function signature from the name and parameters including parameter names.
 * @param name - The name of the function.
 * @param parameters - The parameters of the function.
 * @returns - The user-friendly function signature.
 */
export function decodeFunctionSignatureWithParameterNames(name, parameters) {
    return new FunctionSignatureDecoder(name, parameters, true).decode();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb2Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hYmkvZGVjb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFHekQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBT2xEOzs7R0FHRztBQUNILE1BQU0sVUFBVTtJQUNkLFlBQW9CLEtBQWdCLEVBQVUsU0FBZTtRQUF6QyxVQUFLLEdBQUwsS0FBSyxDQUFXO1FBQVUsY0FBUyxHQUFULFNBQVMsQ0FBTTtJQUFHLENBQUM7SUFFakU7Ozs7T0FJRztJQUNLLFVBQVUsQ0FBQyxPQUFnQjtRQUNqQyxRQUFRLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNyQixLQUFLLE9BQU87Z0JBQ1YsT0FBTyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDeEMsS0FBSyxTQUFTO2dCQUNaLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxRQUFRLEVBQUUsQ0FBQztvQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO2dCQUN0RCxDQUFDO2dCQUNELE9BQU8sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3hDLEtBQUssU0FBUztnQkFDWixPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3ZDLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFDYixNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7Z0JBQ2pCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztvQkFDM0MsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FB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
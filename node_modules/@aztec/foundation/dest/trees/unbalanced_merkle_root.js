import { padArrayEnd } from '@aztec/foundation/collection';
import { sha256Trunc } from '@aztec/foundation/crypto';
/**
 * Computes the merkle root for an unbalanced tree.
 *
 * @dev Adapted from proving-state.ts -> findMergeLevel and unbalanced_tree.ts.
 * Calculates the tree upwards layer by layer until we reach the root.
 * The L1 calculation instead computes the tree from right to left (slightly cheaper gas).
 * TODO: A more thorough investigation of which method is cheaper, then use that method everywhere.
 */
export function computeUnbalancedMerkleRoot(leaves, emptyLeaf, hasher = sha256Trunc) {
    // Pad leaves to 2
    if (leaves.length < 2) {
        if (emptyLeaf === undefined) {
            throw new Error('Cannot compute a Merkle root with less than 2 leaves');
        }
        else {
            leaves = padArrayEnd(leaves, emptyLeaf, 2);
        }
    }
    const depth = Math.ceil(Math.log2(leaves.length));
    let [layerWidth, nodeToShift] = leaves.length & 1 ? [leaves.length - 1, leaves[leaves.length - 1]] : [leaves.length, Buffer.alloc(0)];
    // Allocate this layer's leaves and init the next layer up
    let thisLayer = leaves.slice(0, layerWidth);
    let nextLayer = [];
    for (let i = 0; i < depth; i++) {
        for (let j = 0; j < layerWidth; j += 2) {
            // Store the hash of each pair one layer up
            nextLayer[j / 2] = hasher(Buffer.concat([thisLayer[j], thisLayer[j + 1]]));
        }
        layerWidth /= 2;
        if (layerWidth & 1) {
            if (nodeToShift.length) {
                // If the next layer has odd length, and we have a node that needs to be shifted up, add it here
                nextLayer.push(nodeToShift);
                layerWidth += 1;
                nodeToShift = Buffer.alloc(0);
            }
            else {
                // If we don't have a node waiting to be shifted, store the next layer's final node to be shifted
                layerWidth -= 1;
                nodeToShift = nextLayer[layerWidth];
            }
        }
        // reset the layers
        thisLayer = nextLayer;
        nextLayer = [];
    }
    // return the root
    return thisLayer[0];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5iYWxhbmNlZF9tZXJrbGVfcm9vdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90cmVlcy91bmJhbGFuY2VkX21lcmtsZV9yb290LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFFdkQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSwyQkFBMkIsQ0FBQyxNQUFnQixFQUFFLFNBQWtCLEVBQUUsTUFBTSxHQUFHLFdBQVc7SUFDcEcsa0JBQWtCO0lBQ2xCLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztRQUN0QixJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7UUFDMUUsQ0FBQzthQUFNLENBQUM7WUFDTixNQUFNLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDN0MsQ0FBQztJQUNILENBQUM7SUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDbEQsSUFBSSxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsR0FDM0IsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RywwREFBMEQ7SUFDMUQsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDNUMsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ25CLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUMvQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUN2QywyQ0FBMkM7WUFDM0MsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdFLENBQUM7UUFDRCxVQUFVLElBQUksQ0FBQyxDQUFDO1FBQ2hCLElBQUksVUFBVSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQ25CLElBQUksV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUN2QixnR0FBZ0c7Z0JBQ2hHLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQzVCLFVBQVUsSUFBSSxDQUFDLENBQUM7Z0JBQ2hCLFdBQVcsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2hDLENBQUM7aUJBQU0sQ0FBQztnQkFDTixpR0FBaUc7Z0JBQ2pHLFVBQVUsSUFBSSxDQUFDLENBQUM7Z0JBQ2hCLFdBQVcsR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEMsQ0FBQztRQUNILENBQUM7UUFDRCxtQkFBbUI7UUFDbkIsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUN0QixTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFDRCxrQkFBa0I7SUFDbEIsT0FBTyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEIsQ0FBQyJ9